"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/Float.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Float.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Float: function() { return /* binding */ Float; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var react_merge_refs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-merge-refs */ \"(app-pages-browser)/./node_modules/react-merge-refs/dist/react-merge-refs.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n\n\n\n\nconst Float = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({\n  children,\n  enabled = true,\n  speed = 1,\n  rotationIntensity = 1,\n  floatIntensity = 1,\n  floatingRange = [-0.1, 0.1],\n  ...props\n}, forwardRef) => {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const offset = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Math.random() * 10000);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => {\n    var _floatingRange$, _floatingRange$2;\n    if (!enabled || speed === 0) return;\n    const t = offset.current + state.clock.getElapsedTime();\n    ref.current.rotation.x = Math.cos(t / 4 * speed) / 8 * rotationIntensity;\n    ref.current.rotation.y = Math.sin(t / 4 * speed) / 8 * rotationIntensity;\n    ref.current.rotation.z = Math.sin(t / 4 * speed) / 20 * rotationIntensity;\n    let yPosition = Math.sin(t / 4 * speed) / 10;\n    yPosition = three__WEBPACK_IMPORTED_MODULE_3__.MathUtils.mapLinear(yPosition, -0.1, 0.1, (_floatingRange$ = floatingRange == null ? void 0 : floatingRange[0]) !== null && _floatingRange$ !== void 0 ? _floatingRange$ : -0.1, (_floatingRange$2 = floatingRange == null ? void 0 : floatingRange[1]) !== null && _floatingRange$2 !== void 0 ? _floatingRange$2 : 0.1);\n    ref.current.position.y = yPosition * floatIntensity;\n    ref.current.updateMatrix();\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"group\", props, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"group\", {\n    ref: (0,react_merge_refs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([ref, forwardRef]),\n    matrixAutoUpdate: false\n  }, children));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0Zsb2F0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErQjtBQUNlO0FBQ0w7QUFDVjs7QUFFL0IsNkJBQTZCLDZDQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjLHlDQUFZO0FBQzFCLGlCQUFpQix5Q0FBWTtBQUM3QixFQUFFLHFEQUFRO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQWU7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CLDhCQUE4QixnREFBbUI7QUFDMUYsU0FBUyw0REFBUztBQUNsQjtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVnQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9GbG9hdC5qcz8yODEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCBtZXJnZVJlZnMgZnJvbSAncmVhY3QtbWVyZ2UtcmVmcyc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IEZsb2F0ID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBjaGlsZHJlbixcbiAgZW5hYmxlZCA9IHRydWUsXG4gIHNwZWVkID0gMSxcbiAgcm90YXRpb25JbnRlbnNpdHkgPSAxLFxuICBmbG9hdEludGVuc2l0eSA9IDEsXG4gIGZsb2F0aW5nUmFuZ2UgPSBbLTAuMSwgMC4xXSxcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRSZWYpID0+IHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBvZmZzZXQgPSBSZWFjdC51c2VSZWYoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgdXNlRnJhbWUoc3RhdGUgPT4ge1xuICAgIHZhciBfZmxvYXRpbmdSYW5nZSQsIF9mbG9hdGluZ1JhbmdlJDI7XG4gICAgaWYgKCFlbmFibGVkIHx8IHNwZWVkID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgdCA9IG9mZnNldC5jdXJyZW50ICsgc3RhdGUuY2xvY2suZ2V0RWxhcHNlZFRpbWUoKTtcbiAgICByZWYuY3VycmVudC5yb3RhdGlvbi54ID0gTWF0aC5jb3ModCAvIDQgKiBzcGVlZCkgLyA4ICogcm90YXRpb25JbnRlbnNpdHk7XG4gICAgcmVmLmN1cnJlbnQucm90YXRpb24ueSA9IE1hdGguc2luKHQgLyA0ICogc3BlZWQpIC8gOCAqIHJvdGF0aW9uSW50ZW5zaXR5O1xuICAgIHJlZi5jdXJyZW50LnJvdGF0aW9uLnogPSBNYXRoLnNpbih0IC8gNCAqIHNwZWVkKSAvIDIwICogcm90YXRpb25JbnRlbnNpdHk7XG4gICAgbGV0IHlQb3NpdGlvbiA9IE1hdGguc2luKHQgLyA0ICogc3BlZWQpIC8gMTA7XG4gICAgeVBvc2l0aW9uID0gVEhSRUUuTWF0aFV0aWxzLm1hcExpbmVhcih5UG9zaXRpb24sIC0wLjEsIDAuMSwgKF9mbG9hdGluZ1JhbmdlJCA9IGZsb2F0aW5nUmFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGZsb2F0aW5nUmFuZ2VbMF0pICE9PSBudWxsICYmIF9mbG9hdGluZ1JhbmdlJCAhPT0gdm9pZCAwID8gX2Zsb2F0aW5nUmFuZ2UkIDogLTAuMSwgKF9mbG9hdGluZ1JhbmdlJDIgPSBmbG9hdGluZ1JhbmdlID09IG51bGwgPyB2b2lkIDAgOiBmbG9hdGluZ1JhbmdlWzFdKSAhPT0gbnVsbCAmJiBfZmxvYXRpbmdSYW5nZSQyICE9PSB2b2lkIDAgPyBfZmxvYXRpbmdSYW5nZSQyIDogMC4xKTtcbiAgICByZWYuY3VycmVudC5wb3NpdGlvbi55ID0geVBvc2l0aW9uICogZmxvYXRJbnRlbnNpdHk7XG4gICAgcmVmLmN1cnJlbnQudXBkYXRlTWF0cml4KCk7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCBwcm9wcywgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCB7XG4gICAgcmVmOiBtZXJnZVJlZnMoW3JlZiwgZm9yd2FyZFJlZl0pLFxuICAgIG1hdHJpeEF1dG9VcGRhdGU6IGZhbHNlXG4gIH0sIGNoaWxkcmVuKSk7XG59KTtcblxuZXhwb3J0IHsgRmxvYXQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/Float.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/MeshTransmissionMaterial.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/MeshTransmissionMaterial.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshTransmissionMaterial: function() { return /* binding */ MeshTransmissionMaterial; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var _useFBO_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./useFBO.js */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/useFBO.js\");\n/* harmony import */ var _materials_DiscardMaterial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../materials/DiscardMaterial.js */ \"(app-pages-browser)/./node_modules/@react-three/drei/materials/DiscardMaterial.js\");\n\n\n\n\n\n\n\nclass MeshTransmissionMaterialImpl extends three__WEBPACK_IMPORTED_MODULE_2__.MeshPhysicalMaterial {\n  constructor(samples = 6, transmissionSampler = false) {\n    super();\n    this.uniforms = {\n      chromaticAberration: {\n        value: 0.05\n      },\n      // Transmission must always be 0, unless transmissionSampler is being used\n      transmission: {\n        value: 0\n      },\n      // Instead a workaround is used, see below for reasons why\n      _transmission: {\n        value: 1\n      },\n      transmissionMap: {\n        value: null\n      },\n      // Roughness is 1 in THREE.MeshPhysicalMaterial but it makes little sense in a transmission material\n      roughness: {\n        value: 0\n      },\n      thickness: {\n        value: 0\n      },\n      thicknessMap: {\n        value: null\n      },\n      attenuationDistance: {\n        value: Infinity\n      },\n      attenuationColor: {\n        value: new three__WEBPACK_IMPORTED_MODULE_2__.Color('white')\n      },\n      anisotropicBlur: {\n        value: 0.1\n      },\n      time: {\n        value: 0\n      },\n      distortion: {\n        value: 0.0\n      },\n      distortionScale: {\n        value: 0.5\n      },\n      temporalDistortion: {\n        value: 0.0\n      },\n      buffer: {\n        value: null\n      }\n    };\n    this.onBeforeCompile = shader => {\n      shader.uniforms = {\n        ...shader.uniforms,\n        ...this.uniforms\n      };\n\n      // Fix for r153-r156 anisotropy chunks\n      // https://github.com/mrdoob/three.js/pull/26716\n      if (this.anisotropy > 0) shader.defines.USE_ANISOTROPY = '';\n\n      // If the transmission sampler is active inject a flag\n      if (transmissionSampler) shader.defines.USE_SAMPLER = '';\n      // Otherwise we do use use .transmission and must therefore force USE_TRANSMISSION\n      // because threejs won't inject it for us\n      else shader.defines.USE_TRANSMISSION = '';\n\n      // Head\n      shader.fragmentShader = /*glsl*/`\n      uniform float chromaticAberration;         \n      uniform float anisotropicBlur;      \n      uniform float time;\n      uniform float distortion;\n      uniform float distortionScale;\n      uniform float temporalDistortion;\n      uniform sampler2D buffer;\n\n      vec3 random3(vec3 c) {\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n        vec3 r;\n        r.z = fract(512.0*j);\n        j *= .125;\n        r.x = fract(512.0*j);\n        j *= .125;\n        r.y = fract(512.0*j);\n        return r-0.5;\n      }\n\n      float seed = 0.0;\n      uint hash( uint x ) {\n        x += ( x << 10u );\n        x ^= ( x >>  6u );\n        x += ( x <<  3u );\n        x ^= ( x >> 11u );\n        x += ( x << 15u );\n        return x;\n      }\n\n      // Compound versions of the hashing algorithm I whipped together.\n      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\n      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n      // Construct a float with half-open range [0:1] using low 23 bits.\n      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\n      float floatConstruct( uint m ) {\n        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n        m |= ieeeOne;                          // Add fractional part to 1.0\n        float  f = uintBitsToFloat( m );       // Range [1:2]\n        return f - 1.0;                        // Range [0:1]\n      }\n\n      // Pseudo-random value in half-open range [0:1].\n      float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\n      float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n      float rand() {\n        float result = random(vec3(gl_FragCoord.xy, seed));\n        seed += 1.0;\n        return result;\n      }\n\n      const float F3 =  0.3333333;\n      const float G3 =  0.1666667;\n\n      float snoise(vec3 p) {\n        vec3 s = floor(p + dot(p, vec3(F3)));\n        vec3 x = p - s + dot(s, vec3(G3));\n        vec3 e = step(vec3(0.0), x - x.yzx);\n        vec3 i1 = e*(1.0 - e.zxy);\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n        vec3 x1 = x - i1 + G3;\n        vec3 x2 = x - i2 + 2.0*G3;\n        vec3 x3 = x - 1.0 + 3.0*G3;\n        vec4 w, d;\n        w.x = dot(x, x);\n        w.y = dot(x1, x1);\n        w.z = dot(x2, x2);\n        w.w = dot(x3, x3);\n        w = max(0.6 - w, 0.0);\n        d.x = dot(random3(s), x);\n        d.y = dot(random3(s + i1), x1);\n        d.z = dot(random3(s + i2), x2);\n        d.w = dot(random3(s + 1.0), x3);\n        w *= w;\n        w *= w;\n        d *= w;\n        return dot(d, vec4(52.0));\n      }\n\n      float snoiseFractal(vec3 m) {\n        return 0.5333333* snoise(m)\n              +0.2666667* snoise(2.0*m)\n              +0.1333333* snoise(4.0*m)\n              +0.0666667* snoise(8.0*m);\n      }\\n` + shader.fragmentShader;\n\n      // Remove transmission\n      shader.fragmentShader = shader.fragmentShader.replace('#include <transmission_pars_fragment>', /*glsl*/`\n        #ifdef USE_TRANSMISSION\n          // Transmission code is based on glTF-Sampler-Viewer\n          // https://github.com/KhronosGroup/glTF-Sample-Viewer\n          uniform float _transmission;\n          uniform float thickness;\n          uniform float attenuationDistance;\n          uniform vec3 attenuationColor;\n          #ifdef USE_TRANSMISSIONMAP\n            uniform sampler2D transmissionMap;\n          #endif\n          #ifdef USE_THICKNESSMAP\n            uniform sampler2D thicknessMap;\n          #endif\n          uniform vec2 transmissionSamplerSize;\n          uniform sampler2D transmissionSamplerMap;\n          uniform mat4 modelMatrix;\n          uniform mat4 projectionMatrix;\n          varying vec3 vWorldPosition;\n          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n            // Direction of refracted light.\n            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n            // Compute rotation-independant scaling of the model matrix.\n            vec3 modelScale;\n            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n            // The thickness is specified in local space.\n            return normalize( refractionVector ) * thickness * modelScale;\n          }\n          float applyIorToRoughness( const in float roughness, const in float ior ) {\n            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n            // an IOR of 1.5 results in the default amount of microfacet refraction.\n            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n          }\n          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            \n            #ifdef USE_SAMPLER\n              #ifdef texture2DLodEXT\n                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #else\n                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #endif\n            #else\n              return texture2D(buffer, fragCoord.xy);\n            #endif\n          }\n          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n            if ( isinf( attenuationDistance ) ) {\n              // Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\n              return radiance;\n            } else {\n              // Compute light attenuation using Beer's law.\n              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n              return transmittance * radiance;\n            }\n          }\n          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n            const in vec3 attenuationColor, const in float attenuationDistance ) {\n            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n            vec3 refractedRayExit = position + transmissionRay;\n            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n            vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n            refractionCoords += 1.0;\n            refractionCoords /= 2.0;\n            // Sample framebuffer to get pixel the refracted ray hits.\n            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n            // Get the specular component.\n            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n          }\n        #endif\\n`);\n\n      // Add refraction\n      shader.fragmentShader = shader.fragmentShader.replace('#include <transmission_fragment>', /*glsl*/`  \n        // Improve the refraction to use the world pos\n        material.transmission = _transmission;\n        material.transmissionAlpha = 1.0;\n        material.thickness = thickness;\n        material.attenuationDistance = attenuationDistance;\n        material.attenuationColor = attenuationColor;\n        #ifdef USE_TRANSMISSIONMAP\n          material.transmission *= texture2D( transmissionMap, vUv ).r;\n        #endif\n        #ifdef USE_THICKNESSMAP\n          material.thickness *= texture2D( thicknessMap, vUv ).g;\n        #endif\n        \n        vec3 pos = vWorldPosition;\n        vec3 v = normalize( cameraPosition - pos );\n        vec3 n = inverseTransformDirection( normal, viewMatrix );\n        vec3 transmission = vec3(0.0);\n        float transmissionR, transmissionB, transmissionG;\n        float randomCoords = rand();\n        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);\n        vec3 distortionNormal = vec3(0.0);\n        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;\n        if (distortion > 0.0) {\n          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));\n        }\n        for (float i = 0.0; i < ${samples}.0; i ++) {\n          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand() - 0.5, rand() - 0.5, rand() - 0.5)) * pow(rand(), 0.33) + distortionNormal);\n          transmissionR = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${samples}),\n            material.attenuationColor, material.attenuationDistance\n          ).r;\n          transmissionG = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${samples})) , material.thickness + thickness_smear * (i + randomCoords) / float(${samples}),\n            material.attenuationColor, material.attenuationDistance\n          ).g;\n          transmissionB = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${samples})), material.thickness + thickness_smear * (i + randomCoords) / float(${samples}),\n            material.attenuationColor, material.attenuationDistance\n          ).b;\n          transmission.r += transmissionR;\n          transmission.g += transmissionG;\n          transmission.b += transmissionB;\n        }\n        transmission /= ${samples}.0;\n        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\\n`);\n    };\n    Object.keys(this.uniforms).forEach(name => Object.defineProperty(this, name, {\n      get: () => this.uniforms[name].value,\n      set: v => this.uniforms[name].value = v\n    }));\n  }\n}\nconst MeshTransmissionMaterial = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  buffer,\n  transmissionSampler = false,\n  backside = false,\n  side = three__WEBPACK_IMPORTED_MODULE_2__.FrontSide,\n  transmission = 1,\n  thickness = 0,\n  backsideThickness = 0,\n  samples = 10,\n  resolution,\n  backsideResolution,\n  background,\n  anisotropy,\n  anisotropicBlur,\n  ...props\n}, fref) => {\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.e)({\n    MeshTransmissionMaterial: MeshTransmissionMaterialImpl\n  });\n  const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const [discardMaterial] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => new _materials_DiscardMaterial_js__WEBPACK_IMPORTED_MODULE_4__.DiscardMaterial());\n  const fboBack = (0,_useFBO_js__WEBPACK_IMPORTED_MODULE_5__.useFBO)(backsideResolution || resolution);\n  const fboMain = (0,_useFBO_js__WEBPACK_IMPORTED_MODULE_5__.useFBO)(resolution);\n  let oldBg;\n  let oldTone;\n  let parent;\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.C)(state => {\n    ref.current.time = state.clock.getElapsedTime();\n    // Render only if the buffer matches the built-in and no transmission sampler is set\n    if (ref.current.buffer === fboMain.texture && !transmissionSampler) {\n      parent = ref.current.__r3f.parent;\n      if (parent) {\n        // Save defaults\n        oldTone = state.gl.toneMapping;\n        oldBg = state.scene.background;\n\n        // Switch off tonemapping lest it double tone maps\n        // Save the current background and set the HDR as the new BG\n        // Use discardmaterial, the parent will be invisible, but it's shadows will still be cast\n        state.gl.toneMapping = three__WEBPACK_IMPORTED_MODULE_2__.NoToneMapping;\n        if (background) state.scene.background = background;\n        parent.material = discardMaterial;\n        if (backside) {\n          // Render into the backside buffer\n          state.gl.setRenderTarget(fboBack);\n          state.gl.render(state.scene, state.camera);\n          // And now prepare the material for the main render using the backside buffer\n          parent.material = ref.current;\n          parent.material.buffer = fboBack.texture;\n          parent.material.thickness = backsideThickness;\n          parent.material.side = three__WEBPACK_IMPORTED_MODULE_2__.BackSide;\n        }\n\n        // Render into the main buffer\n        state.gl.setRenderTarget(fboMain);\n        state.gl.render(state.scene, state.camera);\n        parent.material = ref.current;\n        parent.material.thickness = thickness;\n        parent.material.side = side;\n        parent.material.buffer = fboMain.texture;\n\n        // Set old state back\n        state.scene.background = oldBg;\n        state.gl.setRenderTarget(null);\n        state.gl.toneMapping = oldTone;\n      }\n    }\n  });\n\n  // Forward ref\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshTransmissionMaterial\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    // Samples must re-compile the shader so we memoize it\n    args: [samples, transmissionSampler],\n    ref: ref\n  }, props, {\n    buffer: buffer || fboMain.texture\n    // @ts-ignore\n    ,\n    _transmission: transmission\n    // In order for this to not incur extra cost \"transmission\" must be set to 0 and treated as a reserved prop.\n    // This is because THREE.WebGLRenderer will check for transmission > 0 and execute extra renders.\n    // The exception is when transmissionSampler is set, in which case we are using three's built in sampler.\n    ,\n    anisotropicBlur: anisotropicBlur !== null && anisotropicBlur !== void 0 ? anisotropicBlur : anisotropy,\n    transmission: transmissionSampler ? transmission : 0,\n    thickness: thickness,\n    side: side\n  }));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL01lc2hUcmFuc21pc3Npb25NYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUNBO0FBQ3VCO0FBQ2pCO0FBQzZCOztBQUVsRSwyQ0FBMkMsdURBQTBCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG1CQUFtQix3Q0FBVztBQUM5QixPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU0sUUFBUSxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLCtJQUErSSxRQUFRO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJLFFBQVEseUVBQXlFLFFBQVE7QUFDL047QUFDQTtBQUNBO0FBQ0E7QUFDQSwySUFBMkksUUFBUSx3RUFBd0UsUUFBUTtBQUNuTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQyxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdEQUFnRCw2Q0FBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxFQUFFLHFEQUFNO0FBQ1I7QUFDQSxHQUFHO0FBQ0gsY0FBYyx5Q0FBWTtBQUMxQiw0QkFBNEIsMkNBQWMsV0FBVywwRUFBZTtBQUNwRSxrQkFBa0Isa0RBQU07QUFDeEIsa0JBQWtCLGtEQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEVBQUUscURBQVE7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnREFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkNBQWM7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUUsc0RBQXlCO0FBQzNCLHNCQUFzQixnREFBbUIsNkJBQTZCLDhFQUFRO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvTWVzaFRyYW5zbWlzc2lvbk1hdGVyaWFsLmpzP2FhOTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZXh0ZW5kLCB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyB1c2VGQk8gfSBmcm9tICcuL3VzZUZCTy5qcyc7XG5pbXBvcnQgeyBEaXNjYXJkTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvRGlzY2FyZE1hdGVyaWFsLmpzJztcblxuY2xhc3MgTWVzaFRyYW5zbWlzc2lvbk1hdGVyaWFsSW1wbCBleHRlbmRzIFRIUkVFLk1lc2hQaHlzaWNhbE1hdGVyaWFsIHtcbiAgY29uc3RydWN0b3Ioc2FtcGxlcyA9IDYsIHRyYW5zbWlzc2lvblNhbXBsZXIgPSBmYWxzZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgIGNocm9tYXRpY0FiZXJyYXRpb246IHtcbiAgICAgICAgdmFsdWU6IDAuMDVcbiAgICAgIH0sXG4gICAgICAvLyBUcmFuc21pc3Npb24gbXVzdCBhbHdheXMgYmUgMCwgdW5sZXNzIHRyYW5zbWlzc2lvblNhbXBsZXIgaXMgYmVpbmcgdXNlZFxuICAgICAgdHJhbnNtaXNzaW9uOiB7XG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9LFxuICAgICAgLy8gSW5zdGVhZCBhIHdvcmthcm91bmQgaXMgdXNlZCwgc2VlIGJlbG93IGZvciByZWFzb25zIHdoeVxuICAgICAgX3RyYW5zbWlzc2lvbjoge1xuICAgICAgICB2YWx1ZTogMVxuICAgICAgfSxcbiAgICAgIHRyYW5zbWlzc2lvbk1hcDoge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSxcbiAgICAgIC8vIFJvdWdobmVzcyBpcyAxIGluIFRIUkVFLk1lc2hQaHlzaWNhbE1hdGVyaWFsIGJ1dCBpdCBtYWtlcyBsaXR0bGUgc2Vuc2UgaW4gYSB0cmFuc21pc3Npb24gbWF0ZXJpYWxcbiAgICAgIHJvdWdobmVzczoge1xuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSxcbiAgICAgIHRoaWNrbmVzczoge1xuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSxcbiAgICAgIHRoaWNrbmVzc01hcDoge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSxcbiAgICAgIGF0dGVudWF0aW9uRGlzdGFuY2U6IHtcbiAgICAgICAgdmFsdWU6IEluZmluaXR5XG4gICAgICB9LFxuICAgICAgYXR0ZW51YXRpb25Db2xvcjoge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCd3aGl0ZScpXG4gICAgICB9LFxuICAgICAgYW5pc290cm9waWNCbHVyOiB7XG4gICAgICAgIHZhbHVlOiAwLjFcbiAgICAgIH0sXG4gICAgICB0aW1lOiB7XG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9LFxuICAgICAgZGlzdG9ydGlvbjoge1xuICAgICAgICB2YWx1ZTogMC4wXG4gICAgICB9LFxuICAgICAgZGlzdG9ydGlvblNjYWxlOiB7XG4gICAgICAgIHZhbHVlOiAwLjVcbiAgICAgIH0sXG4gICAgICB0ZW1wb3JhbERpc3RvcnRpb246IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIGJ1ZmZlcjoge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbkJlZm9yZUNvbXBpbGUgPSBzaGFkZXIgPT4ge1xuICAgICAgc2hhZGVyLnVuaWZvcm1zID0ge1xuICAgICAgICAuLi5zaGFkZXIudW5pZm9ybXMsXG4gICAgICAgIC4uLnRoaXMudW5pZm9ybXNcbiAgICAgIH07XG5cbiAgICAgIC8vIEZpeCBmb3IgcjE1My1yMTU2IGFuaXNvdHJvcHkgY2h1bmtzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjY3MTZcbiAgICAgIGlmICh0aGlzLmFuaXNvdHJvcHkgPiAwKSBzaGFkZXIuZGVmaW5lcy5VU0VfQU5JU09UUk9QWSA9ICcnO1xuXG4gICAgICAvLyBJZiB0aGUgdHJhbnNtaXNzaW9uIHNhbXBsZXIgaXMgYWN0aXZlIGluamVjdCBhIGZsYWdcbiAgICAgIGlmICh0cmFuc21pc3Npb25TYW1wbGVyKSBzaGFkZXIuZGVmaW5lcy5VU0VfU0FNUExFUiA9ICcnO1xuICAgICAgLy8gT3RoZXJ3aXNlIHdlIGRvIHVzZSB1c2UgLnRyYW5zbWlzc2lvbiBhbmQgbXVzdCB0aGVyZWZvcmUgZm9yY2UgVVNFX1RSQU5TTUlTU0lPTlxuICAgICAgLy8gYmVjYXVzZSB0aHJlZWpzIHdvbid0IGluamVjdCBpdCBmb3IgdXNcbiAgICAgIGVsc2Ugc2hhZGVyLmRlZmluZXMuVVNFX1RSQU5TTUlTU0lPTiA9ICcnO1xuXG4gICAgICAvLyBIZWFkXG4gICAgICBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSAvKmdsc2wqL2BcbiAgICAgIHVuaWZvcm0gZmxvYXQgY2hyb21hdGljQWJlcnJhdGlvbjsgICAgICAgICBcbiAgICAgIHVuaWZvcm0gZmxvYXQgYW5pc290cm9waWNCbHVyOyAgICAgIFxuICAgICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xuICAgICAgdW5pZm9ybSBmbG9hdCBkaXN0b3J0aW9uO1xuICAgICAgdW5pZm9ybSBmbG9hdCBkaXN0b3J0aW9uU2NhbGU7XG4gICAgICB1bmlmb3JtIGZsb2F0IHRlbXBvcmFsRGlzdG9ydGlvbjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIGJ1ZmZlcjtcblxuICAgICAgdmVjMyByYW5kb20zKHZlYzMgYykge1xuICAgICAgICBmbG9hdCBqID0gNDA5Ni4wKnNpbihkb3QoYyx2ZWMzKDE3LjAsIDU5LjQsIDE1LjApKSk7XG4gICAgICAgIHZlYzMgcjtcbiAgICAgICAgci56ID0gZnJhY3QoNTEyLjAqaik7XG4gICAgICAgIGogKj0gLjEyNTtcbiAgICAgICAgci54ID0gZnJhY3QoNTEyLjAqaik7XG4gICAgICAgIGogKj0gLjEyNTtcbiAgICAgICAgci55ID0gZnJhY3QoNTEyLjAqaik7XG4gICAgICAgIHJldHVybiByLTAuNTtcbiAgICAgIH1cblxuICAgICAgZmxvYXQgc2VlZCA9IDAuMDtcbiAgICAgIHVpbnQgaGFzaCggdWludCB4ICkge1xuICAgICAgICB4ICs9ICggeCA8PCAxMHUgKTtcbiAgICAgICAgeCBePSAoIHggPj4gIDZ1ICk7XG4gICAgICAgIHggKz0gKCB4IDw8ICAzdSApO1xuICAgICAgICB4IF49ICggeCA+PiAxMXUgKTtcbiAgICAgICAgeCArPSAoIHggPDwgMTV1ICk7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuXG4gICAgICAvLyBDb21wb3VuZCB2ZXJzaW9ucyBvZiB0aGUgaGFzaGluZyBhbGdvcml0aG0gSSB3aGlwcGVkIHRvZ2V0aGVyLlxuICAgICAgdWludCBoYXNoKCB1dmVjMiB2ICkgeyByZXR1cm4gaGFzaCggdi54IF4gaGFzaCh2LnkpICAgICAgICAgICAgICAgICAgICAgICAgICk7IH1cbiAgICAgIHVpbnQgaGFzaCggdXZlYzMgdiApIHsgcmV0dXJuIGhhc2goIHYueCBeIGhhc2godi55KSBeIGhhc2godi56KSAgICAgICAgICAgICApOyB9XG4gICAgICB1aW50IGhhc2goIHV2ZWM0IHYgKSB7IHJldHVybiBoYXNoKCB2LnggXiBoYXNoKHYueSkgXiBoYXNoKHYueikgXiBoYXNoKHYudykgKTsgfVxuXG4gICAgICAvLyBDb25zdHJ1Y3QgYSBmbG9hdCB3aXRoIGhhbGYtb3BlbiByYW5nZSBbMDoxXSB1c2luZyBsb3cgMjMgYml0cy5cbiAgICAgIC8vIEFsbCB6ZXJvZXMgeWllbGRzIDAuMCwgYWxsIG9uZXMgeWllbGRzIHRoZSBuZXh0IHNtYWxsZXN0IHJlcHJlc2VudGFibGUgdmFsdWUgYmVsb3cgMS4wLlxuICAgICAgZmxvYXQgZmxvYXRDb25zdHJ1Y3QoIHVpbnQgbSApIHtcbiAgICAgICAgY29uc3QgdWludCBpZWVlTWFudGlzc2EgPSAweDAwN0ZGRkZGdTsgLy8gYmluYXJ5MzIgbWFudGlzc2EgYml0bWFza1xuICAgICAgICBjb25zdCB1aW50IGllZWVPbmUgICAgICA9IDB4M0Y4MDAwMDB1OyAvLyAxLjAgaW4gSUVFRSBiaW5hcnkzMlxuICAgICAgICBtICY9IGllZWVNYW50aXNzYTsgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIG9ubHkgbWFudGlzc2EgYml0cyAoZnJhY3Rpb25hbCBwYXJ0KVxuICAgICAgICBtIHw9IGllZWVPbmU7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZnJhY3Rpb25hbCBwYXJ0IHRvIDEuMFxuICAgICAgICBmbG9hdCAgZiA9IHVpbnRCaXRzVG9GbG9hdCggbSApOyAgICAgICAvLyBSYW5nZSBbMToyXVxuICAgICAgICByZXR1cm4gZiAtIDEuMDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBSYW5nZSBbMDoxXVxuICAgICAgfVxuXG4gICAgICAvLyBQc2V1ZG8tcmFuZG9tIHZhbHVlIGluIGhhbGYtb3BlbiByYW5nZSBbMDoxXS5cbiAgICAgIGZsb2F0IHJhbmRvbSggZmxvYXQgeCApIHsgcmV0dXJuIGZsb2F0Q29uc3RydWN0KGhhc2goZmxvYXRCaXRzVG9VaW50KHgpKSk7IH1cbiAgICAgIGZsb2F0IHJhbmRvbSggdmVjMiAgdiApIHsgcmV0dXJuIGZsb2F0Q29uc3RydWN0KGhhc2goZmxvYXRCaXRzVG9VaW50KHYpKSk7IH1cbiAgICAgIGZsb2F0IHJhbmRvbSggdmVjMyAgdiApIHsgcmV0dXJuIGZsb2F0Q29uc3RydWN0KGhhc2goZmxvYXRCaXRzVG9VaW50KHYpKSk7IH1cbiAgICAgIGZsb2F0IHJhbmRvbSggdmVjNCAgdiApIHsgcmV0dXJuIGZsb2F0Q29uc3RydWN0KGhhc2goZmxvYXRCaXRzVG9VaW50KHYpKSk7IH1cblxuICAgICAgZmxvYXQgcmFuZCgpIHtcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gcmFuZG9tKHZlYzMoZ2xfRnJhZ0Nvb3JkLnh5LCBzZWVkKSk7XG4gICAgICAgIHNlZWQgKz0gMS4wO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmbG9hdCBGMyA9ICAwLjMzMzMzMzM7XG4gICAgICBjb25zdCBmbG9hdCBHMyA9ICAwLjE2NjY2Njc7XG5cbiAgICAgIGZsb2F0IHNub2lzZSh2ZWMzIHApIHtcbiAgICAgICAgdmVjMyBzID0gZmxvb3IocCArIGRvdChwLCB2ZWMzKEYzKSkpO1xuICAgICAgICB2ZWMzIHggPSBwIC0gcyArIGRvdChzLCB2ZWMzKEczKSk7XG4gICAgICAgIHZlYzMgZSA9IHN0ZXAodmVjMygwLjApLCB4IC0geC55engpO1xuICAgICAgICB2ZWMzIGkxID0gZSooMS4wIC0gZS56eHkpO1xuICAgICAgICB2ZWMzIGkyID0gMS4wIC0gZS56eHkqKDEuMCAtIGUpO1xuICAgICAgICB2ZWMzIHgxID0geCAtIGkxICsgRzM7XG4gICAgICAgIHZlYzMgeDIgPSB4IC0gaTIgKyAyLjAqRzM7XG4gICAgICAgIHZlYzMgeDMgPSB4IC0gMS4wICsgMy4wKkczO1xuICAgICAgICB2ZWM0IHcsIGQ7XG4gICAgICAgIHcueCA9IGRvdCh4LCB4KTtcbiAgICAgICAgdy55ID0gZG90KHgxLCB4MSk7XG4gICAgICAgIHcueiA9IGRvdCh4MiwgeDIpO1xuICAgICAgICB3LncgPSBkb3QoeDMsIHgzKTtcbiAgICAgICAgdyA9IG1heCgwLjYgLSB3LCAwLjApO1xuICAgICAgICBkLnggPSBkb3QocmFuZG9tMyhzKSwgeCk7XG4gICAgICAgIGQueSA9IGRvdChyYW5kb20zKHMgKyBpMSksIHgxKTtcbiAgICAgICAgZC56ID0gZG90KHJhbmRvbTMocyArIGkyKSwgeDIpO1xuICAgICAgICBkLncgPSBkb3QocmFuZG9tMyhzICsgMS4wKSwgeDMpO1xuICAgICAgICB3ICo9IHc7XG4gICAgICAgIHcgKj0gdztcbiAgICAgICAgZCAqPSB3O1xuICAgICAgICByZXR1cm4gZG90KGQsIHZlYzQoNTIuMCkpO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCBzbm9pc2VGcmFjdGFsKHZlYzMgbSkge1xuICAgICAgICByZXR1cm4gMC41MzMzMzMzKiBzbm9pc2UobSlcbiAgICAgICAgICAgICAgKzAuMjY2NjY2Nyogc25vaXNlKDIuMCptKVxuICAgICAgICAgICAgICArMC4xMzMzMzMzKiBzbm9pc2UoNC4wKm0pXG4gICAgICAgICAgICAgICswLjA2NjY2NjcqIHNub2lzZSg4LjAqbSk7XG4gICAgICB9XFxuYCArIHNoYWRlci5mcmFnbWVudFNoYWRlcjtcblxuICAgICAgLy8gUmVtb3ZlIHRyYW5zbWlzc2lvblxuICAgICAgc2hhZGVyLmZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoJyNpbmNsdWRlIDx0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudD4nLCAvKmdsc2wqL2BcbiAgICAgICAgI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cbiAgICAgICAgICAvLyBUcmFuc21pc3Npb24gY29kZSBpcyBiYXNlZCBvbiBnbFRGLVNhbXBsZXItVmlld2VyXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGLVNhbXBsZS1WaWV3ZXJcbiAgICAgICAgICB1bmlmb3JtIGZsb2F0IF90cmFuc21pc3Npb247XG4gICAgICAgICAgdW5pZm9ybSBmbG9hdCB0aGlja25lc3M7XG4gICAgICAgICAgdW5pZm9ybSBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlO1xuICAgICAgICAgIHVuaWZvcm0gdmVjMyBhdHRlbnVhdGlvbkNvbG9yO1xuICAgICAgICAgICNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25NYXA7XG4gICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgI2lmZGVmIFVTRV9USElDS05FU1NNQVBcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRoaWNrbmVzc01hcDtcbiAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICB1bmlmb3JtIHZlYzIgdHJhbnNtaXNzaW9uU2FtcGxlclNpemU7XG4gICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdHJhbnNtaXNzaW9uU2FtcGxlck1hcDtcbiAgICAgICAgICB1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XG4gICAgICAgICAgdW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuICAgICAgICAgIHZlYzMgZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBjb25zdCBpbiB2ZWMzIG4sIGNvbnN0IGluIHZlYzMgdiwgY29uc3QgaW4gZmxvYXQgdGhpY2tuZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IsIGNvbnN0IGluIG1hdDQgbW9kZWxNYXRyaXggKSB7XG4gICAgICAgICAgICAvLyBEaXJlY3Rpb24gb2YgcmVmcmFjdGVkIGxpZ2h0LlxuICAgICAgICAgICAgdmVjMyByZWZyYWN0aW9uVmVjdG9yID0gcmVmcmFjdCggLSB2LCBub3JtYWxpemUoIG4gKSwgMS4wIC8gaW9yICk7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHJvdGF0aW9uLWluZGVwZW5kYW50IHNjYWxpbmcgb2YgdGhlIG1vZGVsIG1hdHJpeC5cbiAgICAgICAgICAgIHZlYzMgbW9kZWxTY2FsZTtcbiAgICAgICAgICAgIG1vZGVsU2NhbGUueCA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDAgXS54eXogKSApO1xuICAgICAgICAgICAgbW9kZWxTY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLnh5eiApICk7XG4gICAgICAgICAgICBtb2RlbFNjYWxlLnogPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAyIF0ueHl6ICkgKTtcbiAgICAgICAgICAgIC8vIFRoZSB0aGlja25lc3MgaXMgc3BlY2lmaWVkIGluIGxvY2FsIHNwYWNlLlxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZSggcmVmcmFjdGlvblZlY3RvciApICogdGhpY2tuZXNzICogbW9kZWxTY2FsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmxvYXQgYXBwbHlJb3JUb1JvdWdobmVzcyggY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IgKSB7XG4gICAgICAgICAgICAvLyBTY2FsZSByb3VnaG5lc3Mgd2l0aCBJT1Igc28gdGhhdCBhbiBJT1Igb2YgMS4wIHJlc3VsdHMgaW4gbm8gbWljcm9mYWNldCByZWZyYWN0aW9uIGFuZFxuICAgICAgICAgICAgLy8gYW4gSU9SIG9mIDEuNSByZXN1bHRzIGluIHRoZSBkZWZhdWx0IGFtb3VudCBvZiBtaWNyb2ZhY2V0IHJlZnJhY3Rpb24uXG4gICAgICAgICAgICByZXR1cm4gcm91Z2huZXNzICogY2xhbXAoIGlvciAqIDIuMCAtIDIuMCwgMC4wLCAxLjAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmVjNCBnZXRUcmFuc21pc3Npb25TYW1wbGUoIGNvbnN0IGluIHZlYzIgZnJhZ0Nvb3JkLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHtcbiAgICAgICAgICAgIGZsb2F0IGZyYW1lYnVmZmVyTG9kID0gbG9nMiggdHJhbnNtaXNzaW9uU2FtcGxlclNpemUueCApICogYXBwbHlJb3JUb1JvdWdobmVzcyggcm91Z2huZXNzLCBpb3IgKTsgICAgICAgICAgICBcbiAgICAgICAgICAgICNpZmRlZiBVU0VfU0FNUExFUlxuICAgICAgICAgICAgICAjaWZkZWYgdGV4dHVyZTJETG9kRVhUXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHR1cmUyRExvZEVYVCh0cmFuc21pc3Npb25TYW1wbGVyTWFwLCBmcmFnQ29vcmQueHksIGZyYW1lYnVmZmVyTG9kKTtcbiAgICAgICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZTJEKHRyYW5zbWlzc2lvblNhbXBsZXJNYXAsIGZyYWdDb29yZC54eSwgZnJhbWVidWZmZXJMb2QpO1xuICAgICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgICNlbHNlXG4gICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlMkQoYnVmZmVyLCBmcmFnQ29vcmQueHkpO1xuICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIHZlYzMgYXBwbHlWb2x1bWVBdHRlbnVhdGlvbiggY29uc3QgaW4gdmVjMyByYWRpYW5jZSwgY29uc3QgaW4gZmxvYXQgdHJhbnNtaXNzaW9uRGlzdGFuY2UsIGNvbnN0IGluIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgY29uc3QgaW4gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHtcbiAgICAgICAgICAgIGlmICggaXNpbmYoIGF0dGVudWF0aW9uRGlzdGFuY2UgKSApIHtcbiAgICAgICAgICAgICAgLy8gQXR0ZW51YXRpb24gZGlzdGFuY2UgaXMgK+KIniwgaS5lLiB0aGUgdHJhbnNtaXR0ZWQgY29sb3IgaXMgbm90IGF0dGVudWF0ZWQgYXQgYWxsLlxuICAgICAgICAgICAgICByZXR1cm4gcmFkaWFuY2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBDb21wdXRlIGxpZ2h0IGF0dGVudWF0aW9uIHVzaW5nIEJlZXIncyBsYXcuXG4gICAgICAgICAgICAgIHZlYzMgYXR0ZW51YXRpb25Db2VmZmljaWVudCA9IC1sb2coIGF0dGVudWF0aW9uQ29sb3IgKSAvIGF0dGVudWF0aW9uRGlzdGFuY2U7XG4gICAgICAgICAgICAgIHZlYzMgdHJhbnNtaXR0YW5jZSA9IGV4cCggLSBhdHRlbnVhdGlvbkNvZWZmaWNpZW50ICogdHJhbnNtaXNzaW9uRGlzdGFuY2UgKTsgLy8gQmVlcidzIGxhd1xuICAgICAgICAgICAgICByZXR1cm4gdHJhbnNtaXR0YW5jZSAqIHJhZGlhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2ZWM0IGdldElCTFZvbHVtZVJlZnJhY3Rpb24oIGNvbnN0IGluIHZlYzMgbiwgY29uc3QgaW4gdmVjMyB2LCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yLFxuICAgICAgICAgICAgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gdmVjMyBwb3NpdGlvbiwgY29uc3QgaW4gbWF0NCBtb2RlbE1hdHJpeCxcbiAgICAgICAgICAgIGNvbnN0IGluIG1hdDQgdmlld01hdHJpeCwgY29uc3QgaW4gbWF0NCBwcm9qTWF0cml4LCBjb25zdCBpbiBmbG9hdCBpb3IsIGNvbnN0IGluIGZsb2F0IHRoaWNrbmVzcyxcbiAgICAgICAgICAgIGNvbnN0IGluIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgY29uc3QgaW4gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHtcbiAgICAgICAgICAgIHZlYzMgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBuLCB2LCB0aGlja25lc3MsIGlvciwgbW9kZWxNYXRyaXggKTtcbiAgICAgICAgICAgIHZlYzMgcmVmcmFjdGVkUmF5RXhpdCA9IHBvc2l0aW9uICsgdHJhbnNtaXNzaW9uUmF5O1xuICAgICAgICAgICAgLy8gUHJvamVjdCByZWZyYWN0ZWQgdmVjdG9yIG9uIHRoZSBmcmFtZWJ1ZmZlciwgd2hpbGUgbWFwcGluZyB0byBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlcy5cbiAgICAgICAgICAgIHZlYzQgbmRjUG9zID0gcHJvak1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZyYWN0ZWRSYXlFeGl0LCAxLjAgKTtcbiAgICAgICAgICAgIHZlYzIgcmVmcmFjdGlvbkNvb3JkcyA9IG5kY1Bvcy54eSAvIG5kY1Bvcy53O1xuICAgICAgICAgICAgcmVmcmFjdGlvbkNvb3JkcyArPSAxLjA7XG4gICAgICAgICAgICByZWZyYWN0aW9uQ29vcmRzIC89IDIuMDtcbiAgICAgICAgICAgIC8vIFNhbXBsZSBmcmFtZWJ1ZmZlciB0byBnZXQgcGl4ZWwgdGhlIHJlZnJhY3RlZCByYXkgaGl0cy5cbiAgICAgICAgICAgIHZlYzQgdHJhbnNtaXR0ZWRMaWdodCA9IGdldFRyYW5zbWlzc2lvblNhbXBsZSggcmVmcmFjdGlvbkNvb3Jkcywgcm91Z2huZXNzLCBpb3IgKTtcbiAgICAgICAgICAgIHZlYzMgYXR0ZW51YXRlZENvbG9yID0gYXBwbHlWb2x1bWVBdHRlbnVhdGlvbiggdHJhbnNtaXR0ZWRMaWdodC5yZ2IsIGxlbmd0aCggdHJhbnNtaXNzaW9uUmF5ICksIGF0dGVudWF0aW9uQ29sb3IsIGF0dGVudWF0aW9uRGlzdGFuY2UgKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgc3BlY3VsYXIgY29tcG9uZW50LlxuICAgICAgICAgICAgdmVjMyBGID0gRW52aXJvbm1lbnRCUkRGKCBuLCB2LCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgcm91Z2huZXNzICk7XG4gICAgICAgICAgICByZXR1cm4gdmVjNCggKCAxLjAgLSBGICkgKiBhdHRlbnVhdGVkQ29sb3IgKiBkaWZmdXNlQ29sb3IsIHRyYW5zbWl0dGVkTGlnaHQuYSApO1xuICAgICAgICAgIH1cbiAgICAgICAgI2VuZGlmXFxuYCk7XG5cbiAgICAgIC8vIEFkZCByZWZyYWN0aW9uXG4gICAgICBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXIuZnJhZ21lbnRTaGFkZXIucmVwbGFjZSgnI2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9mcmFnbWVudD4nLCAvKmdsc2wqL2AgIFxuICAgICAgICAvLyBJbXByb3ZlIHRoZSByZWZyYWN0aW9uIHRvIHVzZSB0aGUgd29ybGQgcG9zXG4gICAgICAgIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA9IF90cmFuc21pc3Npb247XG4gICAgICAgIG1hdGVyaWFsLnRyYW5zbWlzc2lvbkFscGhhID0gMS4wO1xuICAgICAgICBtYXRlcmlhbC50aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgICAgIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBhdHRlbnVhdGlvbkRpc3RhbmNlO1xuICAgICAgICBtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yID0gYXR0ZW51YXRpb25Db2xvcjtcbiAgICAgICAgI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcbiAgICAgICAgICBtYXRlcmlhbC50cmFuc21pc3Npb24gKj0gdGV4dHVyZTJEKCB0cmFuc21pc3Npb25NYXAsIHZVdiApLnI7XG4gICAgICAgICNlbmRpZlxuICAgICAgICAjaWZkZWYgVVNFX1RISUNLTkVTU01BUFxuICAgICAgICAgIG1hdGVyaWFsLnRoaWNrbmVzcyAqPSB0ZXh0dXJlMkQoIHRoaWNrbmVzc01hcCwgdlV2ICkuZztcbiAgICAgICAgI2VuZGlmXG4gICAgICAgIFxuICAgICAgICB2ZWMzIHBvcyA9IHZXb3JsZFBvc2l0aW9uO1xuICAgICAgICB2ZWMzIHYgPSBub3JtYWxpemUoIGNhbWVyYVBvc2l0aW9uIC0gcG9zICk7XG4gICAgICAgIHZlYzMgbiA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xuICAgICAgICB2ZWMzIHRyYW5zbWlzc2lvbiA9IHZlYzMoMC4wKTtcbiAgICAgICAgZmxvYXQgdHJhbnNtaXNzaW9uUiwgdHJhbnNtaXNzaW9uQiwgdHJhbnNtaXNzaW9uRztcbiAgICAgICAgZmxvYXQgcmFuZG9tQ29vcmRzID0gcmFuZCgpO1xuICAgICAgICBmbG9hdCB0aGlja25lc3Nfc21lYXIgPSB0aGlja25lc3MgKiBtYXgocG93KHJvdWdobmVzc0ZhY3RvciwgMC4zMyksIGFuaXNvdHJvcGljQmx1cik7XG4gICAgICAgIHZlYzMgZGlzdG9ydGlvbk5vcm1hbCA9IHZlYzMoMC4wKTtcbiAgICAgICAgdmVjMyB0ZW1wb3JhbE9mZnNldCA9IHZlYzModGltZSwgLXRpbWUsIC10aW1lKSAqIHRlbXBvcmFsRGlzdG9ydGlvbjtcbiAgICAgICAgaWYgKGRpc3RvcnRpb24gPiAwLjApIHtcbiAgICAgICAgICBkaXN0b3J0aW9uTm9ybWFsID0gZGlzdG9ydGlvbiAqIHZlYzMoc25vaXNlRnJhY3RhbCh2ZWMzKChwb3MgKiBkaXN0b3J0aW9uU2NhbGUgKyB0ZW1wb3JhbE9mZnNldCkpKSwgc25vaXNlRnJhY3RhbCh2ZWMzKHBvcy56eHkgKiBkaXN0b3J0aW9uU2NhbGUgLSB0ZW1wb3JhbE9mZnNldCkpLCBzbm9pc2VGcmFjdGFsKHZlYzMocG9zLnl4eiAqIGRpc3RvcnRpb25TY2FsZSArIHRlbXBvcmFsT2Zmc2V0KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoZmxvYXQgaSA9IDAuMDsgaSA8ICR7c2FtcGxlc30uMDsgaSArKykge1xuICAgICAgICAgIHZlYzMgc2FtcGxlTm9ybSA9IG5vcm1hbGl6ZShuICsgcm91Z2huZXNzRmFjdG9yICogcm91Z2huZXNzRmFjdG9yICogMi4wICogbm9ybWFsaXplKHZlYzMocmFuZCgpIC0gMC41LCByYW5kKCkgLSAwLjUsIHJhbmQoKSAtIDAuNSkpICogcG93KHJhbmQoKSwgMC4zMykgKyBkaXN0b3J0aW9uTm9ybWFsKTtcbiAgICAgICAgICB0cmFuc21pc3Npb25SID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcbiAgICAgICAgICAgIHNhbXBsZU5vcm0sIHYsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuZGlmZnVzZUNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCxcbiAgICAgICAgICAgIHBvcywgbW9kZWxNYXRyaXgsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXgsIG1hdGVyaWFsLmlvciwgbWF0ZXJpYWwudGhpY2tuZXNzICArIHRoaWNrbmVzc19zbWVhciAqIChpICsgcmFuZG9tQ29vcmRzKSAvIGZsb2F0KCR7c2FtcGxlc30pLFxuICAgICAgICAgICAgbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciwgbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZVxuICAgICAgICAgICkucjtcbiAgICAgICAgICB0cmFuc21pc3Npb25HID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcbiAgICAgICAgICAgIHNhbXBsZU5vcm0sIHYsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuZGlmZnVzZUNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCxcbiAgICAgICAgICAgIHBvcywgbW9kZWxNYXRyaXgsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXgsIG1hdGVyaWFsLmlvciAgKiAoMS4wICsgY2hyb21hdGljQWJlcnJhdGlvbiAqIChpICsgcmFuZG9tQ29vcmRzKSAvIGZsb2F0KCR7c2FtcGxlc30pKSAsIG1hdGVyaWFsLnRoaWNrbmVzcyArIHRoaWNrbmVzc19zbWVhciAqIChpICsgcmFuZG9tQ29vcmRzKSAvIGZsb2F0KCR7c2FtcGxlc30pLFxuICAgICAgICAgICAgbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciwgbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZVxuICAgICAgICAgICkuZztcbiAgICAgICAgICB0cmFuc21pc3Npb25CID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcbiAgICAgICAgICAgIHNhbXBsZU5vcm0sIHYsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuZGlmZnVzZUNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCxcbiAgICAgICAgICAgIHBvcywgbW9kZWxNYXRyaXgsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXgsIG1hdGVyaWFsLmlvciAqICgxLjAgKyAyLjAgKiBjaHJvbWF0aWNBYmVycmF0aW9uICogKGkgKyByYW5kb21Db29yZHMpIC8gZmxvYXQoJHtzYW1wbGVzfSkpLCBtYXRlcmlhbC50aGlja25lc3MgKyB0aGlja25lc3Nfc21lYXIgKiAoaSArIHJhbmRvbUNvb3JkcykgLyBmbG9hdCgke3NhbXBsZXN9KSxcbiAgICAgICAgICAgIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IsIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2VcbiAgICAgICAgICApLmI7XG4gICAgICAgICAgdHJhbnNtaXNzaW9uLnIgKz0gdHJhbnNtaXNzaW9uUjtcbiAgICAgICAgICB0cmFuc21pc3Npb24uZyArPSB0cmFuc21pc3Npb25HO1xuICAgICAgICAgIHRyYW5zbWlzc2lvbi5iICs9IHRyYW5zbWlzc2lvbkI7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNtaXNzaW9uIC89ICR7c2FtcGxlc30uMDtcbiAgICAgICAgdG90YWxEaWZmdXNlID0gbWl4KCB0b3RhbERpZmZ1c2UsIHRyYW5zbWlzc2lvbi5yZ2IsIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiApO1xcbmApO1xuICAgIH07XG4gICAgT2JqZWN0LmtleXModGhpcy51bmlmb3JtcykuZm9yRWFjaChuYW1lID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICBnZXQ6ICgpID0+IHRoaXMudW5pZm9ybXNbbmFtZV0udmFsdWUsXG4gICAgICBzZXQ6IHYgPT4gdGhpcy51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IHZcbiAgICB9KSk7XG4gIH1cbn1cbmNvbnN0IE1lc2hUcmFuc21pc3Npb25NYXRlcmlhbCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgYnVmZmVyLFxuICB0cmFuc21pc3Npb25TYW1wbGVyID0gZmFsc2UsXG4gIGJhY2tzaWRlID0gZmFsc2UsXG4gIHNpZGUgPSBUSFJFRS5Gcm9udFNpZGUsXG4gIHRyYW5zbWlzc2lvbiA9IDEsXG4gIHRoaWNrbmVzcyA9IDAsXG4gIGJhY2tzaWRlVGhpY2tuZXNzID0gMCxcbiAgc2FtcGxlcyA9IDEwLFxuICByZXNvbHV0aW9uLFxuICBiYWNrc2lkZVJlc29sdXRpb24sXG4gIGJhY2tncm91bmQsXG4gIGFuaXNvdHJvcHksXG4gIGFuaXNvdHJvcGljQmx1cixcbiAgLi4ucHJvcHNcbn0sIGZyZWYpID0+IHtcbiAgZXh0ZW5kKHtcbiAgICBNZXNoVHJhbnNtaXNzaW9uTWF0ZXJpYWw6IE1lc2hUcmFuc21pc3Npb25NYXRlcmlhbEltcGxcbiAgfSk7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgW2Rpc2NhcmRNYXRlcmlhbF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgRGlzY2FyZE1hdGVyaWFsKCkpO1xuICBjb25zdCBmYm9CYWNrID0gdXNlRkJPKGJhY2tzaWRlUmVzb2x1dGlvbiB8fCByZXNvbHV0aW9uKTtcbiAgY29uc3QgZmJvTWFpbiA9IHVzZUZCTyhyZXNvbHV0aW9uKTtcbiAgbGV0IG9sZEJnO1xuICBsZXQgb2xkVG9uZTtcbiAgbGV0IHBhcmVudDtcbiAgdXNlRnJhbWUoc3RhdGUgPT4ge1xuICAgIHJlZi5jdXJyZW50LnRpbWUgPSBzdGF0ZS5jbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgIC8vIFJlbmRlciBvbmx5IGlmIHRoZSBidWZmZXIgbWF0Y2hlcyB0aGUgYnVpbHQtaW4gYW5kIG5vIHRyYW5zbWlzc2lvbiBzYW1wbGVyIGlzIHNldFxuICAgIGlmIChyZWYuY3VycmVudC5idWZmZXIgPT09IGZib01haW4udGV4dHVyZSAmJiAhdHJhbnNtaXNzaW9uU2FtcGxlcikge1xuICAgICAgcGFyZW50ID0gcmVmLmN1cnJlbnQuX19yM2YucGFyZW50O1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBTYXZlIGRlZmF1bHRzXG4gICAgICAgIG9sZFRvbmUgPSBzdGF0ZS5nbC50b25lTWFwcGluZztcbiAgICAgICAgb2xkQmcgPSBzdGF0ZS5zY2VuZS5iYWNrZ3JvdW5kO1xuXG4gICAgICAgIC8vIFN3aXRjaCBvZmYgdG9uZW1hcHBpbmcgbGVzdCBpdCBkb3VibGUgdG9uZSBtYXBzXG4gICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgYmFja2dyb3VuZCBhbmQgc2V0IHRoZSBIRFIgYXMgdGhlIG5ldyBCR1xuICAgICAgICAvLyBVc2UgZGlzY2FyZG1hdGVyaWFsLCB0aGUgcGFyZW50IHdpbGwgYmUgaW52aXNpYmxlLCBidXQgaXQncyBzaGFkb3dzIHdpbGwgc3RpbGwgYmUgY2FzdFxuICAgICAgICBzdGF0ZS5nbC50b25lTWFwcGluZyA9IFRIUkVFLk5vVG9uZU1hcHBpbmc7XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kKSBzdGF0ZS5zY2VuZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICAgICAgcGFyZW50Lm1hdGVyaWFsID0gZGlzY2FyZE1hdGVyaWFsO1xuICAgICAgICBpZiAoYmFja3NpZGUpIHtcbiAgICAgICAgICAvLyBSZW5kZXIgaW50byB0aGUgYmFja3NpZGUgYnVmZmVyXG4gICAgICAgICAgc3RhdGUuZ2wuc2V0UmVuZGVyVGFyZ2V0KGZib0JhY2spO1xuICAgICAgICAgIHN0YXRlLmdsLnJlbmRlcihzdGF0ZS5zY2VuZSwgc3RhdGUuY2FtZXJhKTtcbiAgICAgICAgICAvLyBBbmQgbm93IHByZXBhcmUgdGhlIG1hdGVyaWFsIGZvciB0aGUgbWFpbiByZW5kZXIgdXNpbmcgdGhlIGJhY2tzaWRlIGJ1ZmZlclxuICAgICAgICAgIHBhcmVudC5tYXRlcmlhbCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgIHBhcmVudC5tYXRlcmlhbC5idWZmZXIgPSBmYm9CYWNrLnRleHR1cmU7XG4gICAgICAgICAgcGFyZW50Lm1hdGVyaWFsLnRoaWNrbmVzcyA9IGJhY2tzaWRlVGhpY2tuZXNzO1xuICAgICAgICAgIHBhcmVudC5tYXRlcmlhbC5zaWRlID0gVEhSRUUuQmFja1NpZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW5kZXIgaW50byB0aGUgbWFpbiBidWZmZXJcbiAgICAgICAgc3RhdGUuZ2wuc2V0UmVuZGVyVGFyZ2V0KGZib01haW4pO1xuICAgICAgICBzdGF0ZS5nbC5yZW5kZXIoc3RhdGUuc2NlbmUsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgIHBhcmVudC5tYXRlcmlhbCA9IHJlZi5jdXJyZW50O1xuICAgICAgICBwYXJlbnQubWF0ZXJpYWwudGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgICAgICBwYXJlbnQubWF0ZXJpYWwuc2lkZSA9IHNpZGU7XG4gICAgICAgIHBhcmVudC5tYXRlcmlhbC5idWZmZXIgPSBmYm9NYWluLnRleHR1cmU7XG5cbiAgICAgICAgLy8gU2V0IG9sZCBzdGF0ZSBiYWNrXG4gICAgICAgIHN0YXRlLnNjZW5lLmJhY2tncm91bmQgPSBvbGRCZztcbiAgICAgICAgc3RhdGUuZ2wuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICBzdGF0ZS5nbC50b25lTWFwcGluZyA9IG9sZFRvbmU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBGb3J3YXJkIHJlZlxuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGZyZWYsICgpID0+IHJlZi5jdXJyZW50LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1lc2hUcmFuc21pc3Npb25NYXRlcmlhbFwiLCBfZXh0ZW5kcyh7XG4gICAgLy8gU2FtcGxlcyBtdXN0IHJlLWNvbXBpbGUgdGhlIHNoYWRlciBzbyB3ZSBtZW1vaXplIGl0XG4gICAgYXJnczogW3NhbXBsZXMsIHRyYW5zbWlzc2lvblNhbXBsZXJdLFxuICAgIHJlZjogcmVmXG4gIH0sIHByb3BzLCB7XG4gICAgYnVmZmVyOiBidWZmZXIgfHwgZmJvTWFpbi50ZXh0dXJlXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgICxcbiAgICBfdHJhbnNtaXNzaW9uOiB0cmFuc21pc3Npb25cbiAgICAvLyBJbiBvcmRlciBmb3IgdGhpcyB0byBub3QgaW5jdXIgZXh0cmEgY29zdCBcInRyYW5zbWlzc2lvblwiIG11c3QgYmUgc2V0IHRvIDAgYW5kIHRyZWF0ZWQgYXMgYSByZXNlcnZlZCBwcm9wLlxuICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBUSFJFRS5XZWJHTFJlbmRlcmVyIHdpbGwgY2hlY2sgZm9yIHRyYW5zbWlzc2lvbiA+IDAgYW5kIGV4ZWN1dGUgZXh0cmEgcmVuZGVycy5cbiAgICAvLyBUaGUgZXhjZXB0aW9uIGlzIHdoZW4gdHJhbnNtaXNzaW9uU2FtcGxlciBpcyBzZXQsIGluIHdoaWNoIGNhc2Ugd2UgYXJlIHVzaW5nIHRocmVlJ3MgYnVpbHQgaW4gc2FtcGxlci5cbiAgICAsXG4gICAgYW5pc290cm9waWNCbHVyOiBhbmlzb3Ryb3BpY0JsdXIgIT09IG51bGwgJiYgYW5pc290cm9waWNCbHVyICE9PSB2b2lkIDAgPyBhbmlzb3Ryb3BpY0JsdXIgOiBhbmlzb3Ryb3B5LFxuICAgIHRyYW5zbWlzc2lvbjogdHJhbnNtaXNzaW9uU2FtcGxlciA/IHRyYW5zbWlzc2lvbiA6IDAsXG4gICAgdGhpY2tuZXNzOiB0aGlja25lc3MsXG4gICAgc2lkZTogc2lkZVxuICB9KSk7XG59KTtcblxuZXhwb3J0IHsgTWVzaFRyYW5zbWlzc2lvbk1hdGVyaWFsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/MeshTransmissionMaterial.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/Text.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Text.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: function() { return /* binding */ Text; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var troika_three_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! troika-three-text */ \"(app-pages-browser)/./node_modules/troika-three-text/dist/troika-three-text.esm.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! suspend-react */ \"(app-pages-browser)/./node_modules/suspend-react/index.js\");\n\n\n\n\n\n\n// eslint-disable-next-line prettier/prettier\nconst Text = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  sdfGlyphSize = 64,\n  anchorX = 'center',\n  anchorY = 'middle',\n  font,\n  fontSize = 1,\n  children,\n  characters,\n  onSync,\n  ...props\n}, ref) => {\n  const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(({\n    invalidate\n  }) => invalidate);\n  const [troikaMesh] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => new troika_three_text__WEBPACK_IMPORTED_MODULE_3__.Text());\n  const [nodes, text] = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    const n = [];\n    let t = '';\n    react__WEBPACK_IMPORTED_MODULE_1__.Children.forEach(children, child => {\n      if (typeof child === 'string' || typeof child === 'number') {\n        t += child;\n      } else {\n        n.push(child);\n      }\n    });\n    return [n, t];\n  }, [children]);\n  (0,suspend_react__WEBPACK_IMPORTED_MODULE_4__.suspend)(() => new Promise(res => (0,troika_three_text__WEBPACK_IMPORTED_MODULE_3__.preloadFont)({\n    font,\n    characters\n  }, res)), ['troika-text', font, characters]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => void troikaMesh.sync(() => {\n    invalidate();\n    if (onSync) onSync(troikaMesh);\n  }));\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => troikaMesh.dispose();\n  }, [troikaMesh]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    object: troikaMesh,\n    ref: ref,\n    font: font,\n    text: text,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    fontSize: fontSize,\n    sdfGlyphSize: sdfGlyphSize\n  }, props), nodes);\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL1RleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUNpQztBQUNsQjtBQUNOOztBQUV4QztBQUNBLDRCQUE0Qiw2Q0FBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQixxREFBUTtBQUM3QjtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsMkNBQWMsV0FBVyxtREFBTTtBQUN0RCx3QkFBd0IsMENBQWE7QUFDckM7QUFDQTtBQUNBLElBQUksMkNBQWM7QUFDbEI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUUsc0RBQU8sMEJBQTBCLDhEQUFXO0FBQzlDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxrREFBcUI7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0EsR0FBRztBQUNILHNCQUFzQixnREFBbUIsY0FBYyw4RUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvVGV4dC5qcz81ZTljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFRleHQgYXMgVGV4dCQxLCBwcmVsb2FkRm9udCB9IGZyb20gJ3Ryb2lrYS10aHJlZS10ZXh0JztcbmltcG9ydCB7IHVzZVRocmVlIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IHN1c3BlbmQgfSBmcm9tICdzdXNwZW5kLXJlYWN0JztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZXR0aWVyL3ByZXR0aWVyXG5jb25zdCBUZXh0ID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBzZGZHbHlwaFNpemUgPSA2NCxcbiAgYW5jaG9yWCA9ICdjZW50ZXInLFxuICBhbmNob3JZID0gJ21pZGRsZScsXG4gIGZvbnQsXG4gIGZvbnRTaXplID0gMSxcbiAgY2hpbGRyZW4sXG4gIGNoYXJhY3RlcnMsXG4gIG9uU3luYyxcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBpbnZhbGlkYXRlID0gdXNlVGhyZWUoKHtcbiAgICBpbnZhbGlkYXRlXG4gIH0pID0+IGludmFsaWRhdGUpO1xuICBjb25zdCBbdHJvaWthTWVzaF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVGV4dCQxKCkpO1xuICBjb25zdCBbbm9kZXMsIHRleHRdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgbiA9IFtdO1xuICAgIGxldCB0ID0gJyc7XG4gICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICB0ICs9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW24sIHRdO1xuICB9LCBbY2hpbGRyZW5dKTtcbiAgc3VzcGVuZCgoKSA9PiBuZXcgUHJvbWlzZShyZXMgPT4gcHJlbG9hZEZvbnQoe1xuICAgIGZvbnQsXG4gICAgY2hhcmFjdGVyc1xuICB9LCByZXMpKSwgWyd0cm9pa2EtdGV4dCcsIGZvbnQsIGNoYXJhY3RlcnNdKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgdHJvaWthTWVzaC5zeW5jKCgpID0+IHtcbiAgICBpbnZhbGlkYXRlKCk7XG4gICAgaWYgKG9uU3luYykgb25TeW5jKHRyb2lrYU1lc2gpO1xuICB9KSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHRyb2lrYU1lc2guZGlzcG9zZSgpO1xuICB9LCBbdHJvaWthTWVzaF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgX2V4dGVuZHMoe1xuICAgIG9iamVjdDogdHJvaWthTWVzaCxcbiAgICByZWY6IHJlZixcbiAgICBmb250OiBmb250LFxuICAgIHRleHQ6IHRleHQsXG4gICAgYW5jaG9yWDogYW5jaG9yWCxcbiAgICBhbmNob3JZOiBhbmNob3JZLFxuICAgIGZvbnRTaXplOiBmb250U2l6ZSxcbiAgICBzZGZHbHlwaFNpemU6IHNkZkdseXBoU2l6ZVxuICB9LCBwcm9wcyksIG5vZGVzKTtcbn0pO1xuXG5leHBvcnQgeyBUZXh0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/Text.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/shaderMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/shaderMaterial.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shaderMaterial: function() { return /* binding */ shaderMaterial; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n\nfunction shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {\n  const material = class material extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    constructor(parameters = {}) {\n      const entries = Object.entries(uniforms);\n      // Create unforms and shaders\n      super({\n        uniforms: entries.reduce((acc, [name, value]) => {\n          const uniform = three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone({\n            [name]: {\n              value\n            }\n          });\n          return {\n            ...acc,\n            ...uniform\n          };\n        }, {}),\n        vertexShader,\n        fragmentShader\n      });\n      // Create getter/setters\n      this.key = '';\n      entries.forEach(([name]) => Object.defineProperty(this, name, {\n        get: () => this.uniforms[name].value,\n        set: v => this.uniforms[name].value = v\n      }));\n\n      // Assign parameters, this might include uniforms\n      Object.assign(this, parameters);\n      // Call onInit\n      if (onInit) onInit(this);\n    }\n  };\n  material.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n  return material;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL3NoYWRlck1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCOztBQUUvQjtBQUNBLDBDQUEwQyxpREFBb0I7QUFDOUQsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBZTtBQUNoQztBQUNBOztBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9zaGFkZXJNYXRlcmlhbC5qcz8yZDk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuZnVuY3Rpb24gc2hhZGVyTWF0ZXJpYWwodW5pZm9ybXMsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIG9uSW5pdCkge1xuICBjb25zdCBtYXRlcmlhbCA9IGNsYXNzIG1hdGVyaWFsIGV4dGVuZHMgVEhSRUUuU2hhZGVyTWF0ZXJpYWwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHVuaWZvcm1zKTtcbiAgICAgIC8vIENyZWF0ZSB1bmZvcm1zIGFuZCBzaGFkZXJzXG4gICAgICBzdXBlcih7XG4gICAgICAgIHVuaWZvcm1zOiBlbnRyaWVzLnJlZHVjZSgoYWNjLCBbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgY29uc3QgdW5pZm9ybSA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoe1xuICAgICAgICAgICAgW25hbWVdOiB7XG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIC4uLnVuaWZvcm1cbiAgICAgICAgICB9O1xuICAgICAgICB9LCB7fSksXG4gICAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXJcbiAgICAgIH0pO1xuICAgICAgLy8gQ3JlYXRlIGdldHRlci9zZXR0ZXJzXG4gICAgICB0aGlzLmtleSA9ICcnO1xuICAgICAgZW50cmllcy5mb3JFYWNoKChbbmFtZV0pID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgIGdldDogKCkgPT4gdGhpcy51bmlmb3Jtc1tuYW1lXS52YWx1ZSxcbiAgICAgICAgc2V0OiB2ID0+IHRoaXMudW5pZm9ybXNbbmFtZV0udmFsdWUgPSB2XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIEFzc2lnbiBwYXJhbWV0ZXJzLCB0aGlzIG1pZ2h0IGluY2x1ZGUgdW5pZm9ybXNcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1ldGVycyk7XG4gICAgICAvLyBDYWxsIG9uSW5pdFxuICAgICAgaWYgKG9uSW5pdCkgb25Jbml0KHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgbWF0ZXJpYWwua2V5ID0gVEhSRUUuTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuICByZXR1cm4gbWF0ZXJpYWw7XG59XG5cbmV4cG9ydCB7IHNoYWRlck1hdGVyaWFsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/shaderMaterial.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/useFBO.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useFBO.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFBO: function() { return /* binding */ useFBO; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n\n\n\n\n// 👇 uncomment when TS version supports function overloads\n// export function useFBO(settings?: FBOSettings)\nfunction useFBO( /** Width in pixels, or settings (will render fullscreen by default) */\nwidth, /** Height in pixels */\nheight, /**Settings */\nsettings) {\n  const size = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.A)(state => state.size);\n  const viewport = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.A)(state => state.viewport);\n  const _width = typeof width === 'number' ? width : size.width * viewport.dpr;\n  const _height = typeof height === 'number' ? height : size.height * viewport.dpr;\n  const _settings = (typeof width === 'number' ? settings : width) || {};\n  const {\n    samples = 0,\n    depth,\n    ...targetSettings\n  } = _settings;\n  const target = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const target = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderTarget(_width, _height, {\n      minFilter: three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter,\n      magFilter: three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter,\n      type: three__WEBPACK_IMPORTED_MODULE_2__.HalfFloatType,\n      ...targetSettings\n    });\n    if (depth) {\n      target.depthTexture = new three__WEBPACK_IMPORTED_MODULE_2__.DepthTexture(_width, _height, three__WEBPACK_IMPORTED_MODULE_2__.FloatType);\n    }\n    target.samples = samples;\n    return target;\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n    target.setSize(_width, _height);\n    if (samples) target.samples = samples;\n  }, [samples, target, _width, _height]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => target.dispose();\n  }, []);\n  return target;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL3VzZUZCTy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErQjtBQUNBO0FBQ2U7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVE7QUFDdkIsbUJBQW1CLHFEQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQiwwQ0FBYTtBQUM5Qix1QkFBdUIsb0RBQXVCO0FBQzlDLGlCQUFpQiwrQ0FBa0I7QUFDbkMsaUJBQWlCLCtDQUFrQjtBQUNuQyxZQUFZLGdEQUFtQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQywrQ0FBa0Isa0JBQWtCLDRDQUFlO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGtEQUFxQjtBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvdXNlRkJPLmpzPzJmNjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgdXNlVGhyZWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuXG4vLyDwn5GHIHVuY29tbWVudCB3aGVuIFRTIHZlcnNpb24gc3VwcG9ydHMgZnVuY3Rpb24gb3ZlcmxvYWRzXG4vLyBleHBvcnQgZnVuY3Rpb24gdXNlRkJPKHNldHRpbmdzPzogRkJPU2V0dGluZ3MpXG5mdW5jdGlvbiB1c2VGQk8oIC8qKiBXaWR0aCBpbiBwaXhlbHMsIG9yIHNldHRpbmdzICh3aWxsIHJlbmRlciBmdWxsc2NyZWVuIGJ5IGRlZmF1bHQpICovXG53aWR0aCwgLyoqIEhlaWdodCBpbiBwaXhlbHMgKi9cbmhlaWdodCwgLyoqU2V0dGluZ3MgKi9cbnNldHRpbmdzKSB7XG4gIGNvbnN0IHNpemUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zaXplKTtcbiAgY29uc3Qgdmlld3BvcnQgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS52aWV3cG9ydCk7XG4gIGNvbnN0IF93aWR0aCA9IHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgPyB3aWR0aCA6IHNpemUud2lkdGggKiB2aWV3cG9ydC5kcHI7XG4gIGNvbnN0IF9oZWlnaHQgPSB0eXBlb2YgaGVpZ2h0ID09PSAnbnVtYmVyJyA/IGhlaWdodCA6IHNpemUuaGVpZ2h0ICogdmlld3BvcnQuZHByO1xuICBjb25zdCBfc2V0dGluZ3MgPSAodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyA/IHNldHRpbmdzIDogd2lkdGgpIHx8IHt9O1xuICBjb25zdCB7XG4gICAgc2FtcGxlcyA9IDAsXG4gICAgZGVwdGgsXG4gICAgLi4udGFyZ2V0U2V0dGluZ3NcbiAgfSA9IF9zZXR0aW5ncztcbiAgY29uc3QgdGFyZ2V0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KF93aWR0aCwgX2hlaWdodCwge1xuICAgICAgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsXG4gICAgICBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlcixcbiAgICAgIHR5cGU6IFRIUkVFLkhhbGZGbG9hdFR5cGUsXG4gICAgICAuLi50YXJnZXRTZXR0aW5nc1xuICAgIH0pO1xuICAgIGlmIChkZXB0aCkge1xuICAgICAgdGFyZ2V0LmRlcHRoVGV4dHVyZSA9IG5ldyBUSFJFRS5EZXB0aFRleHR1cmUoX3dpZHRoLCBfaGVpZ2h0LCBUSFJFRS5GbG9hdFR5cGUpO1xuICAgIH1cbiAgICB0YXJnZXQuc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSwgW10pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHRhcmdldC5zZXRTaXplKF93aWR0aCwgX2hlaWdodCk7XG4gICAgaWYgKHNhbXBsZXMpIHRhcmdldC5zYW1wbGVzID0gc2FtcGxlcztcbiAgfSwgW3NhbXBsZXMsIHRhcmdldCwgX3dpZHRoLCBfaGVpZ2h0XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHRhcmdldC5kaXNwb3NlKCk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IHsgdXNlRkJPIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/useFBO.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/useGLTF.js":
/*!********************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useGLTF.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGLTF: function() { return /* binding */ useGLTF; }\n/* harmony export */ });\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three-stdlib */ \"(app-pages-browser)/./node_modules/three-stdlib/loaders/DRACOLoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three-stdlib */ \"(app-pages-browser)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(app-pages-browser)/./node_modules/three-stdlib/loaders/GLTFLoader.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n\n\n\nlet dracoLoader = null;\nlet decoderPath = 'https://www.gstatic.com/draco/versioned/decoders/1.5.5/';\nfunction extensions(useDraco, useMeshopt, extendLoader) {\n  return loader => {\n    if (extendLoader) {\n      extendLoader(loader);\n    }\n    if (useDraco) {\n      if (!dracoLoader) {\n        dracoLoader = new three_stdlib__WEBPACK_IMPORTED_MODULE_0__.DRACOLoader();\n      }\n      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : decoderPath);\n      loader.setDRACOLoader(dracoLoader);\n    }\n    if (useMeshopt) {\n      loader.setMeshoptDecoder(typeof three_stdlib__WEBPACK_IMPORTED_MODULE_1__.MeshoptDecoder === 'function' ? (0,three_stdlib__WEBPACK_IMPORTED_MODULE_1__.MeshoptDecoder)() : three_stdlib__WEBPACK_IMPORTED_MODULE_1__.MeshoptDecoder);\n    }\n  };\n}\nfunction useGLTF(path, useDraco = true, useMeshOpt = true, extendLoader) {\n  return (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F)(three_stdlib__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\n}\nuseGLTF.preload = (path, useDraco = true, useMeshOpt = true, extendLoader) => _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F.preload(three_stdlib__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\nuseGLTF.clear = input => _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F.clear(three_stdlib__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader, input);\nuseGLTF.setDecoderPath = path => {\n  decoderPath = path;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL3VzZUdMVEYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUU7QUFDeEI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdEQUFjLGtCQUFrQiw0REFBYyxLQUFLLHdEQUFjO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxREFBUyxDQUFDLG9EQUFVO0FBQzdCO0FBQ0EsOEVBQThFLGlEQUFTLFNBQVMsb0RBQVU7QUFDMUcseUJBQXlCLGlEQUFTLE9BQU8sb0RBQVU7QUFDbkQ7QUFDQTtBQUNBOztBQUVtQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VHTFRGLmpzPzg4ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR0xURkxvYWRlciwgRFJBQ09Mb2FkZXIsIE1lc2hvcHREZWNvZGVyIH0gZnJvbSAndGhyZWUtc3RkbGliJztcbmltcG9ydCB7IHVzZUxvYWRlciB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5cbmxldCBkcmFjb0xvYWRlciA9IG51bGw7XG5sZXQgZGVjb2RlclBhdGggPSAnaHR0cHM6Ly93d3cuZ3N0YXRpYy5jb20vZHJhY28vdmVyc2lvbmVkL2RlY29kZXJzLzEuNS41Lyc7XG5mdW5jdGlvbiBleHRlbnNpb25zKHVzZURyYWNvLCB1c2VNZXNob3B0LCBleHRlbmRMb2FkZXIpIHtcbiAgcmV0dXJuIGxvYWRlciA9PiB7XG4gICAgaWYgKGV4dGVuZExvYWRlcikge1xuICAgICAgZXh0ZW5kTG9hZGVyKGxvYWRlcik7XG4gICAgfVxuICAgIGlmICh1c2VEcmFjbykge1xuICAgICAgaWYgKCFkcmFjb0xvYWRlcikge1xuICAgICAgICBkcmFjb0xvYWRlciA9IG5ldyBEUkFDT0xvYWRlcigpO1xuICAgICAgfVxuICAgICAgZHJhY29Mb2FkZXIuc2V0RGVjb2RlclBhdGgodHlwZW9mIHVzZURyYWNvID09PSAnc3RyaW5nJyA/IHVzZURyYWNvIDogZGVjb2RlclBhdGgpO1xuICAgICAgbG9hZGVyLnNldERSQUNPTG9hZGVyKGRyYWNvTG9hZGVyKTtcbiAgICB9XG4gICAgaWYgKHVzZU1lc2hvcHQpIHtcbiAgICAgIGxvYWRlci5zZXRNZXNob3B0RGVjb2Rlcih0eXBlb2YgTWVzaG9wdERlY29kZXIgPT09ICdmdW5jdGlvbicgPyBNZXNob3B0RGVjb2RlcigpIDogTWVzaG9wdERlY29kZXIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUdMVEYocGF0aCwgdXNlRHJhY28gPSB0cnVlLCB1c2VNZXNoT3B0ID0gdHJ1ZSwgZXh0ZW5kTG9hZGVyKSB7XG4gIHJldHVybiB1c2VMb2FkZXIoR0xURkxvYWRlciwgcGF0aCwgZXh0ZW5zaW9ucyh1c2VEcmFjbywgdXNlTWVzaE9wdCwgZXh0ZW5kTG9hZGVyKSk7XG59XG51c2VHTFRGLnByZWxvYWQgPSAocGF0aCwgdXNlRHJhY28gPSB0cnVlLCB1c2VNZXNoT3B0ID0gdHJ1ZSwgZXh0ZW5kTG9hZGVyKSA9PiB1c2VMb2FkZXIucHJlbG9hZChHTFRGTG9hZGVyLCBwYXRoLCBleHRlbnNpb25zKHVzZURyYWNvLCB1c2VNZXNoT3B0LCBleHRlbmRMb2FkZXIpKTtcbnVzZUdMVEYuY2xlYXIgPSBpbnB1dCA9PiB1c2VMb2FkZXIuY2xlYXIoR0xURkxvYWRlciwgaW5wdXQpO1xudXNlR0xURi5zZXREZWNvZGVyUGF0aCA9IHBhdGggPT4ge1xuICBkZWNvZGVyUGF0aCA9IHBhdGg7XG59O1xuXG5leHBvcnQgeyB1c2VHTFRGIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/useGLTF.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/materials/DiscardMaterial.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@react-three/drei/materials/DiscardMaterial.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiscardMaterial: function() { return /* binding */ DiscardMaterial; }\n/* harmony export */ });\n/* harmony import */ var _core_shaderMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/shaderMaterial.js */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/shaderMaterial.js\");\n\n\nconst DiscardMaterial = /* @__PURE__ */(0,_core_shaderMaterial_js__WEBPACK_IMPORTED_MODULE_0__.shaderMaterial)({}, 'void main() { }', 'void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9tYXRlcmlhbHMvRGlzY2FyZE1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEOztBQUUzRCx1Q0FBdUMsdUVBQWMsR0FBRyxrQkFBa0Isa0JBQWtCLHlDQUF5QyxXQUFXOztBQUVySCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbWF0ZXJpYWxzL0Rpc2NhcmRNYXRlcmlhbC5qcz8wMTJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNoYWRlck1hdGVyaWFsIH0gZnJvbSAnLi4vY29yZS9zaGFkZXJNYXRlcmlhbC5qcyc7XG5cbmNvbnN0IERpc2NhcmRNYXRlcmlhbCA9IC8qIEBfX1BVUkVfXyAqL3NoYWRlck1hdGVyaWFsKHt9LCAndm9pZCBtYWluKCkgeyB9JywgJ3ZvaWQgbWFpbigpIHsgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApOyBkaXNjYXJkOyAgfScpO1xuXG5leHBvcnQgeyBEaXNjYXJkTWF0ZXJpYWwgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/materials/DiscardMaterial.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Model.jsx":
/*!**********************************!*\
  !*** ./src/components/Model.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Model; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/useGLTF.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/Text.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/Float.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/MeshTransmissionMaterial.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/index-8afac004.esm.js\");\n/* harmony import */ var leva__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leva */ \"(app-pages-browser)/./node_modules/leva/dist/leva.esm.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nfunction Model() {\n    _s();\n    const { viewport } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.A)();\n    const { nodes } = (0,_react_three_drei__WEBPACK_IMPORTED_MODULE_4__.useGLTF)(\"/medias/shards.glb\");\n    const handleGoBack = ()=>{\n        // Replace 'https://example.com' with your desired URL\n        window.location.href = \"https://example.com\";\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n        scale: viewport.width / 1.5,\n        children: [\n            nodes.Scene.children.map((mesh, i)=>{\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Mesh, {\n                    data: mesh\n                }, i, false, {\n                    fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n                    lineNumber: 18,\n                    columnNumber: 24\n                }, this);\n            }),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Font, {}, void 0, false, {\n                fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n                lineNumber: 20,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"absolute\",\n                    top: 10,\n                    left: 10\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: handleGoBack,\n                    children: \"Go Back\"\n                }, void 0, false, {\n                    fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n                    lineNumber: 22,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n                lineNumber: 21,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n        lineNumber: 16,\n        columnNumber: 9\n    }, this);\n}\n_s(Model, \"4n5aGP+J1DlixBPGYHaoFuC2EaA=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.A,\n        _react_three_drei__WEBPACK_IMPORTED_MODULE_4__.useGLTF\n    ];\n});\n_c = Model;\nfunction Font() {\n    const src = \"/fonts/PPNeueMontreal-Bold.otf\";\n    const textOption = {\n        color: \"white\",\n        anchorX: \"center\",\n        anchorY: \"middle\"\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_5__.Text, {\n                font: src,\n                position: [\n                    0,\n                    0,\n                    -0.1\n                ],\n                fontSize: 0.4,\n                ...textOption,\n                children: \"404\"\n            }, void 0, false, {\n                fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n                lineNumber: 37,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_5__.Text, {\n                font: src,\n                position: [\n                    0,\n                    -0.15,\n                    -0.1\n                ],\n                fontSize: 0.03,\n                ...textOption,\n                children: \"The link is broken\"\n            }, void 0, false, {\n                fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n                lineNumber: 40,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n        lineNumber: 36,\n        columnNumber: 9\n    }, this);\n}\n_c1 = Font;\nfunction Mesh(param) {\n    let { data } = param;\n    _s1();\n    const materialProps = (0,leva__WEBPACK_IMPORTED_MODULE_2__.useControls)({\n        thickness: {\n            value: 0.275,\n            min: 0,\n            max: 1,\n            step: 0.01\n        },\n        ior: {\n            value: 1.8,\n            min: 0,\n            max: 3,\n            step: 0.1\n        },\n        chromaticAberration: {\n            value: 0.75,\n            min: 0,\n            max: 1\n        },\n        resolution: {\n            value: 300\n        }\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_6__.Float, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n            ...data,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_7__.MeshTransmissionMaterial, {\n                roughness: 0,\n                transmission: 0.99,\n                ...materialProps\n            }, void 0, false, {\n                fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n                lineNumber: 58,\n                columnNumber: 17\n            }, this)\n        }, void 0, false, {\n            fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n            lineNumber: 57,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"/home/vaibhav/Desktop/404-page-portfolio/src/components/Model.jsx\",\n        lineNumber: 56,\n        columnNumber: 9\n    }, this);\n}\n_s1(Mesh, \"D7ag7TRszUAk+HLPf6z1soC9Bz4=\", false, function() {\n    return [\n        leva__WEBPACK_IMPORTED_MODULE_2__.useControls\n    ];\n});\n_c2 = Mesh;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"Model\");\n$RefreshReg$(_c1, \"Font\");\n$RefreshReg$(_c2, \"Mesh\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL01vZGVsLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBbUY7QUFDekQ7QUFDb0I7QUFDWDtBQUVwQixTQUFTTzs7SUFDcEIsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0gscURBQVFBO0lBQzdCLE1BQU0sRUFBRUksS0FBSyxFQUFFLEdBQUdULDBEQUFPQSxDQUFDO0lBRTFCLE1BQU1VLGVBQWU7UUFDakIsc0RBQXNEO1FBQ3REQyxPQUFPQyxRQUFRLENBQUNDLElBQUksR0FBRztJQUMzQjtJQUVBLHFCQUNJLDhEQUFDQztRQUFNQyxPQUFPUCxTQUFTUSxLQUFLLEdBQUc7O1lBQzFCUCxNQUFNUSxLQUFLLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDLENBQUNDLE1BQU1DO2dCQUM3QixxQkFBTyw4REFBQ0M7b0JBQUtDLE1BQU1IO21CQUFXQzs7Ozs7WUFDbEM7MEJBQ0EsOERBQUNHOzs7OzswQkFDRCw4REFBQ0M7Z0JBQUlDLE9BQU87b0JBQUVDLFVBQVU7b0JBQVlDLEtBQUs7b0JBQUlDLE1BQU07Z0JBQUc7MEJBQ2xELDRFQUFDQztvQkFBT0MsU0FBU3JCOzhCQUFjOzs7Ozs7Ozs7Ozs7Ozs7OztBQUkvQztHQXBCd0JIOztRQUNDRixpREFBUUE7UUFDWEwsc0RBQU9BOzs7S0FGTE87QUFzQnhCLFNBQVNpQjtJQUNMLE1BQU1RLE1BQU07SUFDWixNQUFNQyxhQUFhO1FBQ2ZDLE9BQU87UUFDUEMsU0FBUztRQUNUQyxTQUFTO0lBQ2I7SUFDQSxxQkFDSSw4REFBQ3RCOzswQkFDRyw4REFBQ2IsbURBQUlBO2dCQUFDb0MsTUFBTUw7Z0JBQUtMLFVBQVU7b0JBQUM7b0JBQUc7b0JBQUcsQ0FBQztpQkFBSTtnQkFBRVcsVUFBVTtnQkFBTSxHQUFHTCxVQUFVOzBCQUFFOzs7Ozs7MEJBR3hFLDhEQUFDaEMsbURBQUlBO2dCQUFDb0MsTUFBTUw7Z0JBQUtMLFVBQVU7b0JBQUM7b0JBQUcsQ0FBQztvQkFBTSxDQUFDO2lCQUFJO2dCQUFFVyxVQUFVO2dCQUFPLEdBQUdMLFVBQVU7MEJBQUU7Ozs7Ozs7Ozs7OztBQUt6RjtNQWpCU1Q7QUFtQlQsU0FBU0YsS0FBSyxLQUFRO1FBQVIsRUFBRUMsSUFBSSxFQUFFLEdBQVI7O0lBQ1YsTUFBTWdCLGdCQUFnQmpDLGlEQUFXQSxDQUFDO1FBQzlCa0MsV0FBVztZQUFFQyxPQUFPO1lBQU9DLEtBQUs7WUFBR0MsS0FBSztZQUFHQyxNQUFNO1FBQUs7UUFDdERDLEtBQUs7WUFBRUosT0FBTztZQUFLQyxLQUFLO1lBQUdDLEtBQUs7WUFBR0MsTUFBTTtRQUFJO1FBQzdDRSxxQkFBcUI7WUFBRUwsT0FBTztZQUFNQyxLQUFLO1lBQUdDLEtBQUs7UUFBRTtRQUNuREksWUFBWTtZQUFFTixPQUFPO1FBQUk7SUFDN0I7SUFFQSxxQkFDSSw4REFBQ3ZDLG9EQUFLQTtrQkFDRiw0RUFBQ2tCO1lBQU0sR0FBR0csSUFBSTtzQkFDViw0RUFBQ3BCLHVFQUF3QkE7Z0JBQUM2QyxXQUFXO2dCQUFHQyxjQUFjO2dCQUFPLEdBQUdWLGFBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJN0Y7SUFmU2pCOztRQUNpQmhCLDZDQUFXQTs7O01BRDVCZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTW9kZWwuanN4P2MwZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlR0xURiwgVGV4dCwgRmxvYXQsIE1lc2hUcmFuc21pc3Npb25NYXRlcmlhbCB9IGZyb20gJ0ByZWFjdC10aHJlZS9kcmVpJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VUaHJlZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyB1c2VDb250cm9scyB9IGZyb20gJ2xldmEnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNb2RlbCgpIHtcbiAgICBjb25zdCB7IHZpZXdwb3J0IH0gPSB1c2VUaHJlZSgpO1xuICAgIGNvbnN0IHsgbm9kZXMgfSA9IHVzZUdMVEYoJy9tZWRpYXMvc2hhcmRzLmdsYicpO1xuXG4gICAgY29uc3QgaGFuZGxlR29CYWNrID0gKCkgPT4ge1xuICAgICAgICAvLyBSZXBsYWNlICdodHRwczovL2V4YW1wbGUuY29tJyB3aXRoIHlvdXIgZGVzaXJlZCBVUkxcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnaHR0cHM6Ly9leGFtcGxlLmNvbSc7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxncm91cCBzY2FsZT17dmlld3BvcnQud2lkdGggLyAxLjV9PlxuICAgICAgICAgICAge25vZGVzLlNjZW5lLmNoaWxkcmVuLm1hcCgobWVzaCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiA8TWVzaCBkYXRhPXttZXNofSBrZXk9e2l9IC8+O1xuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA8Rm9udCAvPlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAxMCwgbGVmdDogMTAgfX0+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVHb0JhY2t9PkdvIEJhY2s8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2dyb3VwPlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIEZvbnQoKSB7XG4gICAgY29uc3Qgc3JjID0gJy9mb250cy9QUE5ldWVNb250cmVhbC1Cb2xkLm90Zic7XG4gICAgY29uc3QgdGV4dE9wdGlvbiA9IHtcbiAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgIGFuY2hvclg6ICdjZW50ZXInLFxuICAgICAgICBhbmNob3JZOiAnbWlkZGxlJyxcbiAgICB9O1xuICAgIHJldHVybiAoXG4gICAgICAgIDxncm91cD5cbiAgICAgICAgICAgIDxUZXh0IGZvbnQ9e3NyY30gcG9zaXRpb249e1swLCAwLCAtMC4xXX0gZm9udFNpemU9ezAuNH0gey4uLnRleHRPcHRpb259PlxuICAgICAgICAgICAgICAgIDQwNFxuICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgPFRleHQgZm9udD17c3JjfSBwb3NpdGlvbj17WzAsIC0wLjE1LCAtMC4xXX0gZm9udFNpemU9ezAuMDN9IHsuLi50ZXh0T3B0aW9ufT5cbiAgICAgICAgICAgICAgICBUaGUgbGluayBpcyBicm9rZW5cbiAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgPC9ncm91cD5cbiAgICApO1xufVxuXG5mdW5jdGlvbiBNZXNoKHsgZGF0YSB9KSB7XG4gICAgY29uc3QgbWF0ZXJpYWxQcm9wcyA9IHVzZUNvbnRyb2xzKHtcbiAgICAgICAgdGhpY2tuZXNzOiB7IHZhbHVlOiAwLjI3NSwgbWluOiAwLCBtYXg6IDEsIHN0ZXA6IDAuMDEgfSxcbiAgICAgICAgaW9yOiB7IHZhbHVlOiAxLjgsIG1pbjogMCwgbWF4OiAzLCBzdGVwOiAwLjEgfSxcbiAgICAgICAgY2hyb21hdGljQWJlcnJhdGlvbjogeyB2YWx1ZTogMC43NSwgbWluOiAwLCBtYXg6IDEgfSxcbiAgICAgICAgcmVzb2x1dGlvbjogeyB2YWx1ZTogMzAwIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8RmxvYXQ+XG4gICAgICAgICAgICA8bWVzaCB7Li4uZGF0YX0+XG4gICAgICAgICAgICAgICAgPE1lc2hUcmFuc21pc3Npb25NYXRlcmlhbCByb3VnaG5lc3M9ezB9IHRyYW5zbWlzc2lvbj17MC45OX0gey4uLm1hdGVyaWFsUHJvcHN9IC8+XG4gICAgICAgICAgICA8L21lc2g+XG4gICAgICAgIDwvRmxvYXQ+XG4gICAgKTtcbn1cblxuIl0sIm5hbWVzIjpbInVzZUdMVEYiLCJUZXh0IiwiRmxvYXQiLCJNZXNoVHJhbnNtaXNzaW9uTWF0ZXJpYWwiLCJSZWFjdCIsInVzZVRocmVlIiwidXNlQ29udHJvbHMiLCJNb2RlbCIsInZpZXdwb3J0Iiwibm9kZXMiLCJoYW5kbGVHb0JhY2siLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJncm91cCIsInNjYWxlIiwid2lkdGgiLCJTY2VuZSIsImNoaWxkcmVuIiwibWFwIiwibWVzaCIsImkiLCJNZXNoIiwiZGF0YSIsIkZvbnQiLCJkaXYiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJzcmMiLCJ0ZXh0T3B0aW9uIiwiY29sb3IiLCJhbmNob3JYIiwiYW5jaG9yWSIsImZvbnQiLCJmb250U2l6ZSIsIm1hdGVyaWFsUHJvcHMiLCJ0aGlja25lc3MiLCJ2YWx1ZSIsIm1pbiIsIm1heCIsInN0ZXAiLCJpb3IiLCJjaHJvbWF0aWNBYmVycmF0aW9uIiwicmVzb2x1dGlvbiIsInJvdWdobmVzcyIsInRyYW5zbWlzc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Model.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-merge-refs/dist/react-merge-refs.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-merge-refs/dist/react-merge-refs.esm.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nfunction mergeRefs(refs) {\n  return function (value) {\n    refs.forEach(function (ref) {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (mergeRefs);\n//# sourceMappingURL=react-merge-refs.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1tZXJnZS1yZWZzL2Rpc3QvcmVhY3QtbWVyZ2UtcmVmcy5lc20uanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLCtEQUFlLFNBQVMsRUFBQztBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtbWVyZ2UtcmVmcy9kaXN0L3JlYWN0LW1lcmdlLXJlZnMuZXNtLmpzP2JiYjYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbWVyZ2VSZWZzKHJlZnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlZih2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lcmdlUmVmcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LW1lcmdlLXJlZnMuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-merge-refs/dist/react-merge-refs.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/troika-three-text/dist/troika-three-text.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.esm.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlyphsGeometry: function() { return /* binding */ GlyphsGeometry; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   configureTextBuilder: function() { return /* binding */ configureTextBuilder; },\n/* harmony export */   createTextDerivedMaterial: function() { return /* binding */ createTextDerivedMaterial; },\n/* harmony export */   dumpSDFTextures: function() { return /* binding */ dumpSDFTextures; },\n/* harmony export */   getCaretAtPoint: function() { return /* binding */ getCaretAtPoint; },\n/* harmony export */   getSelectionRects: function() { return /* binding */ getSelectionRects; },\n/* harmony export */   preloadFont: function() { return /* binding */ preloadFont; },\n/* harmony export */   typesetterWorkerModule: function() { return /* binding */ typesetterWorkerModule; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! troika-worker-utils */ \"(app-pages-browser)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\");\n/* harmony import */ var webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgl-sdf-generator */ \"(app-pages-browser)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\");\n/* harmony import */ var bidi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bidi-js */ \"(app-pages-browser)/./node_modules/bidi-js/dist/bidi.mjs\");\n/* harmony import */ var troika_three_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! troika-three-utils */ \"(app-pages-browser)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\");\n\n\n\n\n\n\n/**\n * Factory function that creates a self-contained environment for processing text typesetting requests.\n *\n * It is important that this function has no closure dependencies, so that it can be easily injected\n * into the source for a Worker without requiring a build step or complex dependency loading. All its\n * dependencies must be passed in at initialization.\n *\n * @param {function} fontParser - a function that accepts an ArrayBuffer of the font data and returns\n * a standardized structure giving access to the font and its glyphs:\n *   {\n *     unitsPerEm: number,\n *     ascender: number,\n *     descender: number,\n *     capHeight: number,\n *     xHeight: number,\n *     lineGap: number,\n *     forEachGlyph(string, fontSize, letterSpacing, callback) {\n *       //invokes callback for each glyph to render, passing it an object:\n *       callback({\n *         index: number,\n *         advanceWidth: number,\n *         xMin: number,\n *         yMin: number,\n *         xMax: number,\n *         yMax: number,\n *         path: string,\n *         pathCommandCount: number\n *       })\n *     }\n *   }\n * @param {object} bidi - the bidi.js implementation object\n * @param {Object} config\n * @return {Object}\n */\nfunction createTypesetter(fontParser, bidi, config) {\n\n  const {\n    defaultFontURL\n  } = config;\n\n  /**\n   * Holds parsed font objects by url\n   */\n  const fonts = Object.create(null);\n\n  const INF = Infinity;\n\n  // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs\n  // eslint-disable-next-line no-misleading-character-class\n  const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;\n\n  // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces\n  const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;\n\n  // Incomplete set of characters that allow line breaking after them\n  // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14\n  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);\n\n  /**\n   * Load a given font url\n   */\n  function doLoadFont(url, callback) {\n    function tryLoad() {\n      const onError = err => {\n        console.error(`Failure loading font ${url}${url === defaultFontURL ? '' : '; trying fallback'}`, err);\n        if (url !== defaultFontURL) {\n          url = defaultFontURL;\n          tryLoad();\n        }\n      };\n      try {\n        const request = new XMLHttpRequest();\n        request.open('get', url, true);\n        request.responseType = 'arraybuffer';\n        request.onload = function () {\n          if (request.status >= 400) {\n            onError(new Error(request.statusText));\n          }\n          else if (request.status > 0) {\n            try {\n              const fontObj = fontParser(request.response);\n              callback(fontObj);\n            } catch (e) {\n              onError(e);\n            }\n          }\n        };\n        request.onerror = onError;\n        request.send();\n      } catch(err) {\n        onError(err);\n      }\n    }\n    tryLoad();\n  }\n\n\n  /**\n   * Load a given font url if needed, invoking a callback when it's loaded. If already\n   * loaded, the callback will be called synchronously.\n   */\n  function loadFont(fontUrl, callback) {\n    if (!fontUrl) fontUrl = defaultFontURL;\n    let font = fonts[fontUrl];\n    if (font) {\n      // if currently loading font, add to callbacks, otherwise execute immediately\n      if (font.pending) {\n        font.pending.push(callback);\n      } else {\n        callback(font);\n      }\n    } else {\n      fonts[fontUrl] = {pending: [callback]};\n      doLoadFont(fontUrl, fontObj => {\n        let callbacks = fonts[fontUrl].pending;\n        fonts[fontUrl] = fontObj;\n        callbacks.forEach(cb => cb(fontObj));\n      });\n    }\n  }\n\n\n  /**\n   * Main entry point.\n   * Process a text string with given font and formatting parameters, and return all info\n   * necessary to render all its glyphs.\n   */\n  function typeset(\n    {\n      text='',\n      font=defaultFontURL,\n      sdfGlyphSize=64,\n      fontSize=1,\n      letterSpacing=0,\n      lineHeight='normal',\n      maxWidth=INF,\n      direction,\n      textAlign='left',\n      textIndent=0,\n      whiteSpace='normal',\n      overflowWrap='normal',\n      anchorX = 0,\n      anchorY = 0,\n      includeCaretPositions=false,\n      chunkedBoundsSize=8192,\n      colorRanges=null\n    },\n    callback,\n    metricsOnly=false\n  ) {\n    const mainStart = now();\n    const timings = {fontLoad: 0, typesetting: 0};\n\n    // Ensure newlines are normalized\n    if (text.indexOf('\\r') > -1) {\n      console.info('Typesetter: got text with \\\\r chars; normalizing to \\\\n');\n      text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n    }\n\n    // Ensure we've got numbers not strings\n    fontSize = +fontSize;\n    letterSpacing = +letterSpacing;\n    maxWidth = +maxWidth;\n    lineHeight = lineHeight || 'normal';\n    textIndent = +textIndent;\n\n    loadFont(font, fontObj => {\n      const hasMaxWidth = isFinite(maxWidth);\n      let glyphIds = null;\n      let glyphPositions = null;\n      let glyphData = null;\n      let glyphColors = null;\n      let caretPositions = null;\n      let visibleBounds = null;\n      let chunkedBounds = null;\n      let maxLineWidth = 0;\n      let renderableGlyphCount = 0;\n      let canWrap = whiteSpace !== 'nowrap';\n      const {ascender, descender, unitsPerEm, lineGap, capHeight, xHeight} = fontObj;\n      timings.fontLoad = now() - mainStart;\n      const typesetStart = now();\n\n      // Find conversion between native font units and fontSize units; this will already be done\n      // for the gx/gy values below but everything else we'll need to convert\n      const fontSizeMult = fontSize / unitsPerEm;\n\n      // Determine appropriate value for 'normal' line height based on the font's actual metrics\n      // TODO this does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n      if (lineHeight === 'normal') {\n        lineHeight = (ascender - descender + lineGap) / unitsPerEm;\n      }\n\n      // Determine line height and leading adjustments\n      lineHeight = lineHeight * fontSize;\n      const halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;\n      const topBaseline = -(ascender * fontSizeMult + halfLeading);\n      const caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);\n      const caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;\n\n      // Distribute glyphs into lines based on wrapping\n      let lineXOffset = textIndent;\n      let currentLine = new TextLine();\n      const lines = [currentLine];\n\n      fontObj.forEachGlyph(text, fontSize, letterSpacing, (glyphObj, glyphX, charIndex) => {\n        const char = text.charAt(charIndex);\n        const glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n        const curLineCount = currentLine.count;\n        let nextLine;\n\n        // Calc isWhitespace and isEmpty once per glyphObj\n        if (!('isEmpty' in glyphObj)) {\n          glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);\n          glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);\n          glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);\n        }\n        if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n          renderableGlyphCount++;\n        }\n\n        // If a non-whitespace character overflows the max width, we need to soft-wrap\n        if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n          // If it's the first char after a whitespace, start a new line\n          if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {\n            nextLine = new TextLine();\n            lineXOffset = -glyphX;\n          } else {\n            // Back up looking for a whitespace character to wrap at\n            for (let i = curLineCount; i--;) {\n              // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n              if (i === 0 && overflowWrap === 'break-word') {\n                nextLine = new TextLine();\n                lineXOffset = -glyphX;\n                break\n              }\n              // Found a soft break point; move all chars since it to a new line\n              else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {\n                nextLine = currentLine.splitAt(i + 1);\n                const adjustX = nextLine.glyphAt(0).x;\n                lineXOffset -= adjustX;\n                for (let j = nextLine.count; j--;) {\n                  nextLine.glyphAt(j).x -= adjustX;\n                }\n                break\n              }\n            }\n          }\n          if (nextLine) {\n            currentLine.isSoftWrapped = true;\n            currentLine = nextLine;\n            lines.push(currentLine);\n            maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n          }\n        }\n\n        let fly = currentLine.glyphAt(currentLine.count);\n        fly.glyphObj = glyphObj;\n        fly.x = glyphX + lineXOffset;\n        fly.width = glyphWidth;\n        fly.charIndex = charIndex;\n\n        // Handle hard line breaks\n        if (char === '\\n') {\n          currentLine = new TextLine();\n          lines.push(currentLine);\n          lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;\n        }\n      });\n\n      // Calculate width of each line (excluding trailing whitespace) and maximum block width\n      lines.forEach(line => {\n        for (let i = line.count; i--;) {\n          let {glyphObj, x, width} = line.glyphAt(i);\n          if (!glyphObj.isWhitespace) {\n            line.width = x + width;\n            if (line.width > maxLineWidth) {\n              maxLineWidth = line.width;\n            }\n            return\n          }\n        }\n      });\n\n      // Find overall position adjustments for anchoring\n      let anchorXOffset = 0;\n      let anchorYOffset = 0;\n      if (anchorX) {\n        if (typeof anchorX === 'number') {\n          anchorXOffset = -anchorX;\n        }\n        else if (typeof anchorX === 'string') {\n          anchorXOffset = -maxLineWidth * (\n            anchorX === 'left' ? 0 :\n            anchorX === 'center' ? 0.5 :\n            anchorX === 'right' ? 1 :\n            parsePercent(anchorX)\n          );\n        }\n      }\n      if (anchorY) {\n        if (typeof anchorY === 'number') {\n          anchorYOffset = -anchorY;\n        }\n        else if (typeof anchorY === 'string') {\n          let height = lines.length * lineHeight;\n          anchorYOffset = anchorY === 'top' ? 0 :\n            anchorY === 'top-baseline' ? -topBaseline :\n            anchorY === 'top-cap' ? -topBaseline - capHeight * fontSizeMult :\n            anchorY === 'top-ex' ? -topBaseline - xHeight * fontSizeMult :\n            anchorY === 'middle' ? height / 2 :\n            anchorY === 'bottom' ? height :\n            anchorY === 'bottom-baseline' ? height - halfLeading + descender * fontSizeMult :\n            parsePercent(anchorY) * height;\n        }\n      }\n\n      if (!metricsOnly) {\n        // Resolve bidi levels\n        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);\n\n        // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n        // collecting all renderable glyphs into a single collection.\n        glyphIds = new Uint16Array(renderableGlyphCount);\n        glyphPositions = new Float32Array(renderableGlyphCount * 2);\n        glyphData = {};\n        visibleBounds = [INF, INF, -INF, -INF];\n        chunkedBounds = [];\n        let lineYOffset = topBaseline;\n        if (includeCaretPositions) {\n          caretPositions = new Float32Array(text.length * 3);\n        }\n        if (colorRanges) {\n          glyphColors = new Uint8Array(renderableGlyphCount * 3);\n        }\n        let renderableGlyphIndex = 0;\n        let prevCharIndex = -1;\n        let colorCharIndex = -1;\n        let chunk;\n        let currentColor;\n        lines.forEach((line, lineIndex) => {\n          let {count:lineGlyphCount, width:lineWidth} = line;\n\n          // Ignore empty lines\n          if (lineGlyphCount > 0) {\n            // Count trailing whitespaces, we want to ignore these for certain things\n            let trailingWhitespaceCount = 0;\n            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {\n              trailingWhitespaceCount++;\n            }\n\n            // Apply horizontal alignment adjustments\n            let lineXOffset = 0;\n            let justifyAdjust = 0;\n            if (textAlign === 'center') {\n              lineXOffset = (maxLineWidth - lineWidth) / 2;\n            } else if (textAlign === 'right') {\n              lineXOffset = maxLineWidth - lineWidth;\n            } else if (textAlign === 'justify' && line.isSoftWrapped) {\n              // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop\n              let whitespaceCount = 0;\n              for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {\n                if (line.glyphAt(i).glyphObj.isWhitespace) {\n                  whitespaceCount++;\n                }\n              }\n              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n            }\n            if (justifyAdjust || lineXOffset) {\n              let justifyOffset = 0;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                let glyphInfo = line.glyphAt(i);\n                const glyphObj = glyphInfo.glyphObj;\n                glyphInfo.x += lineXOffset + justifyOffset;\n                // Expand non-trailing whitespaces for justify alignment\n                if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {\n                  justifyOffset += justifyAdjust;\n                  glyphInfo.width += justifyAdjust;\n                }\n              }\n            }\n\n            // Perform bidi range flipping\n            const flips = bidi.getReorderSegments(\n              text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex\n            );\n            for (let fi = 0; fi < flips.length; fi++) {\n              const [start, end] = flips[fi];\n              // Map start/end string indices to indices in the line\n              let left = Infinity, right = -Infinity;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                if (line.glyphAt(i).charIndex >= start) { // gte to handle removed characters\n                  let startInLine = i, endInLine = i;\n                  for (; endInLine < lineGlyphCount; endInLine++) {\n                    let info = line.glyphAt(endInLine);\n                    if (info.charIndex > end) {\n                      break\n                    }\n                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width\n                      left = Math.min(left, info.x);\n                      right = Math.max(right, info.x + info.width);\n                    }\n                  }\n                  for (let j = startInLine; j < endInLine; j++) {\n                    const glyphInfo = line.glyphAt(j);\n                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);\n                  }\n                  break\n                }\n              }\n            }\n\n            // Assemble final data arrays\n            let glyphObj;\n            const setGlyphObj = g => glyphObj = g;\n            for (let i = 0; i < lineGlyphCount; i++) {\n              let glyphInfo = line.glyphAt(i);\n              glyphObj = glyphInfo.glyphObj;\n              const glyphId = glyphObj.index;\n\n              // Replace mirrored characters in rtl\n              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl\n              if (rtl) {\n                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);\n                if (mirrored) {\n                  fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);\n                }\n              }\n\n              // Add caret positions\n              if (includeCaretPositions) {\n                const {charIndex} = glyphInfo;\n                const caretLeft = glyphInfo.x + anchorXOffset;\n                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;\n                caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft; //start edge x\n                caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight; //end edge x\n                caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset; //common bottom y\n\n                // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret\n                // positions for those missing char indices; currently this uses a best-guess by dividing\n                // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList\n                // table to get better interior caret positions.\n                const ligCount = charIndex - prevCharIndex;\n                if (ligCount > 1) {\n                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                }\n                prevCharIndex = charIndex;\n              }\n\n              // Track current color range\n              if (colorRanges) {\n                const {charIndex} = glyphInfo;\n                while(charIndex > colorCharIndex) {\n                  colorCharIndex++;\n                  if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                    currentColor = colorRanges[colorCharIndex];\n                  }\n                }\n              }\n\n              // Get atlas data for renderable glyphs\n              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                const idx = renderableGlyphIndex++;\n\n                // Add this glyph's path data\n                if (!glyphData[glyphId]) {\n                  glyphData[glyphId] = {\n                    path: glyphObj.path,\n                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]\n                  };\n                }\n\n                // Determine final glyph position and add to glyphPositions array\n                const glyphX = glyphInfo.x + anchorXOffset;\n                const glyphY = lineYOffset + anchorYOffset;\n                glyphPositions[idx * 2] = glyphX;\n                glyphPositions[idx * 2 + 1] = glyphY;\n\n                // Track total visible bounds\n                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;\n                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;\n                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;\n                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;\n                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;\n                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;\n                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;\n                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;\n\n                // Track bounding rects for each chunk of N glyphs\n                if (idx % chunkedBoundsSize === 0) {\n                  chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};\n                  chunkedBounds.push(chunk);\n                }\n                chunk.end++;\n                const chunkRect = chunk.rect;\n                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;\n                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;\n                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;\n                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;\n\n                // Add to glyph ids array\n                glyphIds[idx] = glyphId;\n\n                // Add colors\n                if (colorRanges) {\n                  const start = idx * 3;\n                  glyphColors[start] = currentColor >> 16 & 255;\n                  glyphColors[start + 1] = currentColor >> 8 & 255;\n                  glyphColors[start + 2] = currentColor & 255;\n                }\n              }\n            }\n          }\n\n          // Increment y offset for next line\n          lineYOffset -= lineHeight;\n        });\n\n        // Fill in remaining caret positions in case the final character was a ligature\n        if (caretPositions) {\n          const ligCount = text.length - prevCharIndex;\n          if (ligCount > 1) {\n            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n          }\n        }\n      }\n\n      // Timing stats\n      timings.typesetting = now() - typesetStart;\n\n      callback({\n        glyphIds, //font indices for each glyph\n        glyphPositions, //x,y of each glyph's origin in layout\n        glyphData, //dict holding data about each glyph appearing in the text\n        caretPositions, //startX,endX,bottomY caret positions for each char\n        caretHeight, //height of cursor from bottom to top\n        glyphColors, //color for each glyph, if color ranges supplied\n        chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n        fontSize, //calculated em height\n        unitsPerEm, //font units per em\n        ascender: ascender * fontSizeMult, //font ascender\n        descender: descender * fontSizeMult, //font descender\n        capHeight: capHeight * fontSizeMult, //font cap-height\n        xHeight: xHeight * fontSizeMult, //font x-height\n        lineHeight, //computed line height\n        topBaseline, //y coordinate of the top line's baseline\n        blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n          anchorXOffset,\n          anchorYOffset - lines.length * lineHeight,\n          anchorXOffset + maxLineWidth,\n          anchorYOffset\n        ],\n        visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n        timings\n      });\n    });\n  }\n\n\n  /**\n   * For a given text string and font parameters, determine the resulting block dimensions\n   * after wrapping for the given maxWidth.\n   * @param args\n   * @param callback\n   */\n  function measure(args, callback) {\n    typeset(args, (result) => {\n      const [x0, y0, x1, y1] = result.blockBounds;\n      callback({\n        width: x1 - x0,\n        height: y1 - y0\n      });\n    }, {metricsOnly: true});\n  }\n\n  function parsePercent(str) {\n    let match = str.match(/^([\\d.]+)%$/);\n    let pct = match ? parseFloat(match[1]) : NaN;\n    return isNaN(pct) ? 0 : pct / 100\n  }\n\n  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {\n    const ligStartX = caretPositions[ligStartIndex * 3];\n    const ligEndX = caretPositions[ligStartIndex * 3 + 1];\n    const ligY = caretPositions[ligStartIndex * 3 + 2];\n    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;\n    for (let i = 0; i < ligCount; i++) {\n      const startIndex = (ligStartIndex + i) * 3;\n      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;\n      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);\n      caretPositions[startIndex + 2] = ligY;\n    }\n  }\n\n  function now() {\n    return (self.performance || Date).now()\n  }\n\n  // Array-backed structure for a single line's glyphs data\n  function TextLine() {\n    this.data = [];\n  }\n  const textLineProps = ['glyphObj', 'x', 'width', 'charIndex'];\n  TextLine.prototype = {\n    width: 0,\n    isSoftWrapped: false,\n    get count() {\n      return Math.ceil(this.data.length / textLineProps.length)\n    },\n    glyphAt(i) {\n      let fly = TextLine.flyweight;\n      fly.data = this.data;\n      fly.index = i;\n      return fly\n    },\n    splitAt(i) {\n      let newLine = new TextLine();\n      newLine.data = this.data.splice(i * textLineProps.length);\n      return newLine\n    }\n  };\n  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {\n    Object.defineProperty(obj, prop, {\n      get() {\n        return this.data[this.index * textLineProps.length + i]\n      },\n      set(val) {\n        this.data[this.index * textLineProps.length + i] = val;\n      }\n    });\n    return obj\n  }, {data: null, index: 0});\n\n\n  return {\n    typeset,\n    measure,\n    loadFont\n  }\n}\n\nconst now = () => (self.performance || Date).now();\n\nconst mainThreadGenerator = /*#__PURE__*/ (0,webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\nlet warned;\n\n/**\n * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a\n * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF\n * generation when supported.\n */\nfunction generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {\n  // Allow opt-out\n  if (!useWebGL) {\n    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n  }\n\n  // Attempt GPU-accelerated generation first\n  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(\n    null,\n    err => {\n      // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers\n      if (!warned) {\n        console.warn(`WebGL SDF generation failed, falling back to JS`, err);\n        warned = true;\n      }\n      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n    }\n  )\n}\n\nconst queue = [];\nconst chunkTimeBudget = 5; // ms\nlet timer = 0;\n\nfunction nextChunk() {\n  const start = now();\n  while (queue.length && now() - start < chunkTimeBudget) {\n    queue.shift()();\n  }\n  timer = queue.length ? setTimeout(nextChunk, 0) : 0;\n}\n\n/**\n * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded\n * macrotask chunks to allow render frames to execute in between.\n */\nconst generateSDF_GL = (...args) => {\n  return new Promise((resolve, reject) => {\n    queue.push(() => {\n      const start = now();\n      try {\n        mainThreadGenerator.webgl.generateIntoCanvas(...args);\n        resolve({ timing: now() - start });\n      } catch (err) {\n        reject(err);\n      }\n    });\n    if (!timer) {\n      timer = setTimeout(nextChunk, 0);\n    }\n  })\n};\n\nconst threadCount = 4; // how many workers to spawn\nconst idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds\nconst threads = {};\nlet callNum = 0;\n\n/**\n * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism\n */\nfunction generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {\n  const workerId = 'TroikaTextSDFGenerator_JS_' + ((callNum++) % threadCount);\n  let thread = threads[workerId];\n  if (!thread) {\n    thread = threads[workerId] = {\n      workerModule: (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n        name: workerId,\n        workerId,\n        dependencies: [\n          webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n          now\n        ],\n        init(_createSDFGenerator, now) {\n          const generate = _createSDFGenerator().javascript.generate;\n          return function (...args) {\n            const start = now();\n            const textureData = generate(...args);\n            return {\n              textureData,\n              timing: now() - start\n            }\n          }\n        },\n        getTransferables(result) {\n          return [result.textureData.buffer]\n        }\n      }),\n      requests: 0,\n      idleTimer: null\n    };\n  }\n\n  thread.requests++;\n  clearTimeout(thread.idleTimer);\n  return thread.workerModule(width, height, path, viewBox, distance, exponent)\n    .then(({ textureData, timing }) => {\n      // copy result data into the canvas\n      const start = now();\n      // expand single-channel data into rgba\n      const imageData = new Uint8Array(textureData.length * 4);\n      for (let i = 0; i < textureData.length; i++) {\n        imageData[i * 4 + channel] = textureData[i];\n      }\n      mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << (3 - channel));\n      timing += now() - start;\n\n      // clean up workers after a while\n      if (--thread.requests === 0) {\n        thread.idleTimer = setTimeout(() => { (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.terminateWorker)(workerId); }, idleTimeout);\n      }\n      return { timing }\n    })\n}\n\nfunction warmUpSDFCanvas(canvas) {\n  if (!canvas._warm) {\n    mainThreadGenerator.webgl.isSupported(canvas);\n    canvas._warm = true;\n  }\n}\n\nconst resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;\n\n/*!\nCustom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.\nOriginal MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE\n*/\nfunction typrFactory(){return \"undefined\"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if(\"ttcf\"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=[\"cmap\",\"head\",\"hhea\",\"maxp\",\"hmtx\",\"name\",\"OS/2\",\"post\",\"loca\",\"glyf\",\"kern\",\"CFF \",\"GPOS\",\"GSUB\",\"SVG \"],i={_data:r,_offset:n},h={},f=0;f<o;f++){var d=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[d]={offset:u,length:l};}for(f=0;f<s.length;f++){var v=s[f];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var f=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t)return f}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){return e._bin._view(r).getInt32(t)},readInt8:function(r,t){return e._bin._view(r).getInt8(t)},readShort:function(r,t){return e._bin._view(r).getInt16(t)},readUshort:function(r,t){return e._bin._view(r).getUint16(t)},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++)n.push(e._bin.readUshort(r,t+2*o));return n},readUint:function(r,t){return e._bin._view(r).getUint32(t)},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a=\"\",n=0;n<t;n++)a+=String.fromCharCode(r[e+n]);return a},readUnicode:function(r,e,t){for(var a=\"\",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:\"undefined\"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(r[e+n]);return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(String.fromCharCode(r[e+n]));return a},_view:function(r){return r._dataView||(r._dataView=r.buffer?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(new Uint8Array(r).buffer))}},e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var f=s.readUshort(r,t);t+=2;var d=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+f),i.featureList=e._lctf.readFeatureList(r,h+d),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var f=n.readUshort(r,t);t+=2;var d=e._lctf.readLookupTable(r,o+f,a);s.push(d);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,f=0;f<i;f++){var d=n.readUshort(r,t);t+=2;var u=a(r,h,o+d,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++)0!=(r>>>t&1)&&e++;return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++)n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2;}if(2==o){var f=a.readUshort(r,t);t+=2;for(h=0;h<f;h++)n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2;}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n)return t}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt)return a.indexOf(t);if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n)return a[n+2]+(t-a[n])}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2;var d=e._lctf.readFeatureTable(r,n+f);d.tag=h.trim(),o.push(d);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++)o.tab.push(a.readUshort(r,t+2*h));return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+f);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,o.default=e._lctf.readLangSysTable(r,n+s);var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var f=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[f.trim()]=e._lctf.readLangSysTable(r,n+d);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++)s.push(n.readASCII(r,t+o[i],o[i+1]-o[i]));t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var f=[];for(i=0;i<h.length-1;i++)f.push(e.CFF.readDict(r,t+h[i],t+h[i+1]));t+=h[h.length-1];var d=f[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++)l.push(n.readASCII(r,t+u[i],u[i+1]-u[i]));if(t+=u[u.length-1],e.CFF.readSubrs(r,t,d),d.CharStrings){t=d.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++)v.push(n.readBytes(r,t+u[i],u[i+1]-u[i]));d.CharStrings=v;}if(d.ROS){t=d.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),d.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),d.FDArray.push(p);}t+=c[c.length-1],t=d.FDSelect,d.FDSelect=[];var U=r[t];if(t++,3!=U)throw U;var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++)d.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3;}return d.Encoding&&(d.Encoding=e.CFF.readEncoding(r,d.Encoding,d.CharStrings.length)),d.charset&&(d.charset=e.CFF.readCharset(r,d.charset,d.CharStrings.length)),e.CFF._readFDict(r,d,l),d},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t)-1!=[\"FamilyName\",\"FontName\",\"FullName\",\"Notice\",\"version\",\"Copyright\"].indexOf(o)&&(t[o]=a[t[o]-426+35]);},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++)a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h]));},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++)if(r.charset[t]==e)return t;return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[\".notdef\"],o=r[t];if(t++,0!=o)throw \"error: unknown encoding format: \"+o;var s=r[t];t++;for(var i=0;i<s;i++)n.push(r[t+i]);return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[\".notdef\"],s=r[t];if(t++,0==s)for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);}else {if(1!=s&&2!=s)throw \"error: format: \"+s;for(;o.length<a;){h=n.readUshort(r,t);t+=2;var f=0;1==s?(f=r[t],t++):(f=n.readUshort(r,t),t+=2);for(i=0;i<=f;i++)o.push(h),h++;}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s)for(var i=0;i<o;i++)a.push(r[t+i]);else if(2==s)for(i=0;i<o;i++)a.push(n.readUshort(r,t+2*i));else if(3==s)for(i=0;i<o;i++)a.push(16777215&n.readUint(r,t+3*i-1));else if(1!=o)throw \"unsupported offset size: \"+s+\", count: \"+o;return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,f=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(f=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(f=o-139,i=1),247<=o&&o<=250&&(f=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(f=256*-(o-251)-s-108,i=2),255==o&&(f=n.readInt(r,t+1)/65535,i=5),a.val=null!=f?f:\"o\"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var f=1,d=null,u=null;i<=20&&(d=i,f=1),12==i&&(d=100*i+h,f=2),19!=i&&20!=i||(d=i,f=2),21<=i&&i<=27&&(d=i,f=1),28==i&&(u=o.readShort(r,t+1),f=3),29<=i&&i<=31&&(d=i,f=1),32<=i&&i<=246&&(u=i-139,f=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,f=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,f=2),255==i&&(u=o.readInt(r,t+1)/65535,f=5),s.push(null!=u?u:\"o\"+d),t+=f;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var f=1,d=null,u=null;if(28==i&&(u=n.readShort(r,t+1),f=3),29==i&&(u=n.readInt(r,t+1),f=5),32<=i&&i<=246&&(u=i-139,f=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,f=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,f=2),255==i)throw u=n.readInt(r,t+1)/65535,f=5,\"unknown number\";if(30==i){var l=[];for(f=1;;){var v=r[t+f];f++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p)break}for(var U=\"\",g=[0,1,2,3,4,5,6,7,8,9,\".\",\"e\",\"e-\",\"reserved\",\"-\",\"endOfNumber\"],S=0;S<l.length;S++)U+=g[l[S]];u=parseFloat(U);}if(i<=21)if(d=[\"version\",\"Notice\",\"FullName\",\"FamilyName\",\"Weight\",\"FontBBox\",\"BlueValues\",\"OtherBlues\",\"FamilyBlues\",\"FamilyOtherBlues\",\"StdHW\",\"StdVW\",\"escape\",\"UniqueID\",\"XUID\",\"charset\",\"Encoding\",\"CharStrings\",\"Private\",\"Subrs\",\"defaultWidthX\",\"nominalWidthX\"][i],f=1,12==i)d=[\"Copyright\",\"isFixedPitch\",\"ItalicAngle\",\"UnderlinePosition\",\"UnderlineThickness\",\"PaintType\",\"CharstringType\",\"FontMatrix\",\"StrokeWidth\",\"BlueScale\",\"BlueShift\",\"BlueFuzz\",\"StemSnapH\",\"StemSnapV\",\"ForceBold\",0,0,\"LanguageGroup\",\"ExpansionFactor\",\"initialRandomSeed\",\"SyntheticBase\",\"PostScript\",\"BaseFontName\",\"BaseFontBlend\",0,0,0,0,0,0,\"ROS\",\"CIDFontVersion\",\"CIDFontRevision\",\"CIDFontType\",\"CIDCount\",\"UIDBase\",\"FDArray\",\"FDSelect\",\"FontName\"][h],f=2;null!=d?(o[d]=1==s.length?s[0]:s,s=[]):s.push(u),t+=f;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var f=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l=\"p\"+f+\"e\"+d,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):console.debug(\"unknown format: \"+p,f,d,u),o.tables.push(c);}if(null!=o[l])throw \"multiple tables for one platform+encoding\";o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++)n.map.push(r[t+s]);return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var f=0;f<h;f++)o.idDelta.push(a.readShort(r,t)),t+=2;for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;)o.glyphIdArray.push(a.readUshort(r,t)),t+=2;return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++)n.glyphIdArray.push(a.readUshort(r,t)),t+=2;return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),f=a.readUint(r,i+4),d=a.readUint(r,i+8);n.groups.push([h,f,d]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++)n.push(null);return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,\"glyf\",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1])return null;var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax)return null;if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++)s.endPts.push(a.readUshort(n,o)),o+=2;var h=a.readUshort(n,o);if(o+=2,n.length-o<h)return null;s.instructions=a.readBytes(n,o,h),o+=h;var f=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<f;i++){var d=n[o];if(o++,s.flags.push(d),0!=(8&d)){var u=n[o];o++;for(var l=0;l<u;l++)s.flags.push(d),i++;}}s.xs=[];for(i=0;i<f;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<f;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<f;i++)p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U;}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++)s.instr.push(n[o]),o++;}}return s},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var f=o.readUshort(r,a);a+=2;var d=e._lctf.numOfOnes(f);0!=f&&(i.pos=e.GPOS.readValueRecord(r,a,f));}else if(2==t&&i.fmt>=1&&i.fmt<=2){f=o.readUshort(r,a);a+=2;var u=o.readUshort(r,a);a+=2;d=e._lctf.numOfOnes(f);var l=e._lctf.numOfOnes(u);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*d),0!=u&&(P=e.GPOS.readValueRecord(r,p,u),p+=2*l),g.push({gid2:m,val1:x,val2:P});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var _=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var C=[];for(S=0;S<_;S++){var x=null,P=null;0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*d),0!=u&&(P=e.GPOS.readValueRecord(r,a,u),a+=2*l),C.push({val1:x,val2:P});}i.matrix.push(C);}}}else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=I;else if(n.ltype!=I)throw \"invalid extension substitution\";return e.GPOS.subt(r,n.ltype,s+w)}console.debug(\"unsupported GPOS table LookupType\",t,\"format\",i.fmt);}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&4!=t&&5!=t&&6!=t)return null;if(1==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt)i.delta=o.readShort(r,a),a+=2;else if(2==i.fmt){var f=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,f),a+=2*i.newg.length;}}else if(4==t){i.vals=[];f=o.readUshort(r,a);a+=2;for(var d=0;d<f;d++){var u=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+u));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var l=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+l),i.scset=[];var v=o.readUshort(r,a);a+=2;for(d=0;d<v;d++){var c=o.readUshort(r,a);a+=2,i.scset.push(0==c?null:e.GSUB.readSubClassSet(r,s+c));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(d=0;d<3;d++){f=o.readUshort(r,a);a+=2;for(var p=[],U=0;U<f;U++)p.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*U)));a+=2*f,0==d&&(i.backCvg=p),1==d&&(i.inptCvg=p),2==d&&(i.ahedCvg=p);}f=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,f);}}else {if(7==t&&1==i.fmt){var g=o.readUshort(r,a);a+=2;var S=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=g;else if(n.ltype!=g)throw \"invalid extension substitution\";return e.GSUB.subt(r,n.ltype,s+S)}console.debug(\"unsupported GSUB table LookupType\",t,\"format\",i.fmt);}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++)n.input.push(a(r,t)),t+=2;return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++)o.push(n(r,t),n(r,t+2)),t+=4;return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=[\"backtrack\",\"input\",\"lookahead\"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++)n.chain.push(a.readUshort(r,t)),t+=2;return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,f=0;f<n.maxp.numGlyphs;f++)f<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h);return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s)return e.kern.parseV1(r,t-2,a,n);var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},f=0;f<i;f++){t+=2;a=o.readUshort(r,t);t+=2;var d=o.readUshort(r,t);t+=2;var u=d>>>8;if(0!=(u&=15))throw \"unknown kern table format: \"+u;t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var f=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var d=f>>>8;if(0!=(d&=15))throw \"unknown kern table format: \"+d;t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var d=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(f),u.vals.push(d),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i)for(var f=0;f<h;f++)s.push(o.readUshort(r,t+(f<<1))<<1);if(1==i)for(f=0;f<h;f++)s.push(o.readUint(r,t+(f<<2)));return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=[\"copyright\",\"fontFamily\",\"fontSubfamily\",\"ID\",\"fullName\",\"version\",\"postScriptName\",\"trademark\",\"manufacturer\",\"designer\",\"description\",\"urlVendor\",\"urlDesigner\",\"licence\",\"licenceURL\",\"---\",\"typoFamilyName\",\"typoSubfamilyName\",\"compatibleFull\",\"sampleText\",\"postScriptCID\",\"wwsFamilyName\",\"wwsSubfamilyName\",\"lightPalette\",\"darkPalette\"],f=t+=2,d=0;d<s;d++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=f+12*s+U;if(0==u)g=n.readUnicode(r,m,p/2);else if(3==u&&0==l)g=n.readUnicode(r,m,p/2);else if(0==l)g=n.readASCII(r,m,p);else if(1==l)g=n.readUnicode(r,m,p/2);else if(3==l)g=n.readUnicode(r,m,p/2);else {if(1!=u)throw \"unknown encoding \"+l+\", platformID: \"+u;g=n.readASCII(r,m,p),console.debug(\"reading unknown MAC encoding \"+l+\" as ASCII\");}var b=\"p\"+u+\",\"+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o)if(null!=o[y].postScriptName&&1033==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&0==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&3084==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName)return o[y];for(var y in o){i=y;break}return console.debug(\"returning name table with languageID \"+o[i]._lang),o[i]},e[\"OS/2\"]={},e[\"OS/2\"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n)e[\"OS/2\"].version0(r,t,o);else if(1==n)e[\"OS/2\"].version1(r,t,o);else if(2==n||3==n||4==n)e[\"OS/2\"].version2(r,t,o);else {if(5!=n)throw \"unknown OS/2 table version: \"+n;e[\"OS/2\"].version5(r,t,o);}return o},e[\"OS/2\"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e[\"OS/2\"].version1=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e[\"OS/2\"].version2=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e[\"OS/2\"].version5=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a)throw \"no familiar platform and encoding!\";var n=t.tables[a];if(0==n.format)return e>=n.map.length?0:n.map[e];if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++)if(e<=n.endCount[s]){o=s;break}if(-1==o)return 0;if(n.startCount[o]>e)return 0;return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1])return 0;for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1])return i[2]+(e-i[0])}return 0}throw \"unknown cmap table format \"+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:(\"string\"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;)h+=2;i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else r.glyf&&e.U._drawGlyf(t,r,a);return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,f=1&r.flags[s],d=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n)if(f){if(!d){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else d?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2);f?d&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var f=o.crds[h],d=o.crds[h+1];a.crds.push(f*i.a+d*i.b+i.tx),a.crds.push(f*i.c+d*i.d+i.ty);}for(h=0;h<o.cmds.length;h++)a.cmds.push(o.cmds[h]);}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U.getPairAdjustment=function(r,t,a){var n=!1;if(r.GPOS)for(var o=r.GPOS,s=o.lookupList,i=o.featureList,h=[],f=0;f<i.length;f++){var d=i[f];if(\"kern\"==d.tag){n=!0;for(var u=0;u<d.tab.length;u++)if(!h[d.tab[u]]){h[d.tab[u]]=!0;for(var l=s[d.tab[u]],v=0;v<l.tabs.length;v++)if(null!=l.tabs[v]){var c,p=l.tabs[v];if(!p.coverage||-1!=(c=e._lctf.coverageIndex(p.coverage,t)))if(1==l.ltype);else if(2==l.ltype){var U=null;if(1==p.fmt){var g=p.pairsets[c];for(f=0;f<g.length;f++)g[f].gid2==a&&(U=g[f]);}else if(2==p.fmt){var S=e.U._getGlyphClass(t,p.classDef1),m=e.U._getGlyphClass(a,p.classDef2);U=p.matrix[S][m];}if(U){var b=0;return U.val1&&U.val1[2]&&(b+=U.val1[2]),U.val2&&U.val2[0]&&(b+=U.val2[0]),b}}}}}}if(r.kern&&!n){var y=r.kern.glyph1.indexOf(t);if(-1!=y){var F=r.kern.rval[y].glyph2.indexOf(a);if(-1!=F)return r.kern.rval[y].vals[F]}}return 0},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++)if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t])))if(1==a.ltype)r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i];else if(4==a.ltype)for(var f=h.vals[i],d=0;d<f.length;d++){var u=f[d],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];)c++;u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++)r[t+p+1]=-1;break}}}else if(5==a.ltype&&2==h.fmt)for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var _=b.substLookupRecords;for(d=0;d<_.length;d+=2)_[d],_[d+1];}}}else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length))continue;if(!e.U._glsCovered(r,h.inptCvg,t))continue;if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length))continue;var C=h.lookupRec;for(m=0;m<C.length;m+=2){U=C[m];var x=n[C[m+1]];e.U._applySubs(r,t+U,x,n);}}}},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n]))return !1}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,f=e.U.glyphToPath(r,i),d=0;d<f.crds.length;d+=2)n.crds.push(f.crds[d]+o),n.crds.push(f.crds[d+1]);a&&n.cmds.push(a);for(d=0;d<f.cmds.length;d++)n.cmds.push(f.cmds[d]);a&&n.cmds.push(\"X\"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push(\"M\"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push(\"L\"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push(\"C\"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push(\"Q\"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push(\"Z\");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,f=t.width,d=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,_=0,C={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,C);var x=C.val;if(u+=C.size,\"o1\"==x||\"o18\"==x)s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;else if(\"o3\"==x||\"o23\"==x){s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if(\"o4\"==x)s.length>1&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),d&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),d=!0;else if(\"o5\"==x)for(;s.length>0;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);else if(\"o6\"==x||\"o7\"==x)for(var P=s.length,I=\"o6\"==x,w=0;w<P;w++){var O=s.shift();I?l+=O:v+=O,I=!I,e.U.P.lineTo(o,l,v);}else if(\"o8\"==x||\"o24\"==x){P=s.length;for(var T=0;T+6<=P;)c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),T+=6;\"o24\"==x&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if(\"o11\"==x)break;if(\"o1234\"==x||\"o1235\"==x||\"o1236\"==x||\"o1237\"==x)\"o1234\"==x&&(p=v,U=(c=l+s.shift())+s.shift(),_=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1235\"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),_=g+s.shift(),S=F+s.shift(),m=_+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1236\"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),_=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1237\"==x&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),_=g+s.shift(),S=F+s.shift(),m=_+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,_),e.U.P.curveTo(o,S,m,b,y,l,v));else if(\"o14\"==x){if(s.length>0&&!h&&(f=s.shift()+a.nominalWidthX,h=!0),4==s.length){var k=s.shift(),G=s.shift(),D=s.shift(),B=s.shift(),L=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[L],t,a,n,o),t.x=k,t.y=G,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}d&&(e.U.P.closePath(o),d=!1);}else if(\"o19\"==x||\"o20\"==x){s.length%2!=0&&!h&&(f=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if(\"o21\"==x)s.length>2&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),d&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),d=!0;else if(\"o22\"==x)s.length>1&&!h&&(f=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),d&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),d=!0;else if(\"o25\"==x){for(;s.length>6;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if(\"o26\"==x)for(s.length%2&&(l+=s.shift());s.length>0;)c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o27\"==x)for(s.length%2&&(v+=s.shift());s.length>0;)p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o10\"==x||\"o29\"==x){var A=\"o10\"==x?n:a;if(0==s.length)console.debug(\"error: empty stack\");else {var W=s.pop(),M=A.Subrs[W+A.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=f,t.open=d,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,f=t.width,d=t.open;}}else if(\"o30\"==x||\"o31\"==x){var V=s.length,N=(T=0,\"o31\"==x);for(T+=V-(P=-3&V);T<P;)N?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),P-T==5?(l=U+s.shift(),T++):l=U,N=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),P-T==5?(v=g+s.shift(),T++):v=g,N=!0),e.U.P.curveTo(o,c,p,U,g,l,v),T+=4;}else {if(\"o\"==(x+\"\").charAt(0))throw console.debug(\"Unknown operation: \"+x,r),x;s.push(x);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=f,t.open=d;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).Typr}\n\n/*!\nCustom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate\n(https://github.com/101arrowz/fflate) for use in Troika text rendering. \nOriginal licenses apply: \n- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)\n- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n*/\nfunction woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),o=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(r,e){for(var a=new n(31),i=0;i<31;++i)a[i]=e+=1<<r[i-1];var o=new t(a[30]);for(i=1;i<30;++i)for(var f=a[i];f<a[i+1];++f)o[f]=f-a[i]<<5|i;return [a,o]},u=f(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=f(i,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,i=0,o=new n(e);i<a;++i)++o[r[i]-1];var f,u=new n(e);for(i=0;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(t){f=new n(1<<e);var v=15-e;for(i=0;i<a;++i)if(r[i])for(var s=i<<4|r[i],l=e-r[i],g=u[r[i]-1]++<<l,h=g|(1<<l)-1;g<=h;++g)f[c[g]>>>v]=s;}else for(f=new n(a),i=0;i<a;++i)r[i]&&(f[i]=c[u[r[i]-1]++]>>>15-r[i]);return f},d=new e(288);for(g=0;g<144;++g)d[g]=8;for(g=144;g<256;++g)d[g]=9;for(g=256;g<280;++g)d[g]=7;for(g=280;g<288;++g)d[g]=8;var m=new e(32);for(g=0;g<32;++g)m[g]=5;var b=w(d,9,1),p=w(m,5,1),y=function(r){for(var e=r[0],n=1;n<r.length;++n)r[n]>e&&(e=r[n]);return e},L=function(r,e,n){var t=e/8|0;return (r[t]|r[t+1]<<8)>>(7&e)&n},U=function(r,e){var n=e/8|0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>(7&e)},k=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],T=function(r,e,n){var t=new Error(e||k[r]);if(t.code=r,Error.captureStackTrace&&Error.captureStackTrace(t,T),!n)throw t;return t},O=function(r,f,u){var s=r.length;if(!s||u&&!u.l&&s<5)return f||new e(0);var c=!f||u,g=!u||u.i;u||(u={}),f||(f=new e(3*s));var h,d=function(r){var n=f.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(f),f=t;}},m=u.f||0,k=u.p||0,O=u.b||0,A=u.l,x=u.d,E=u.m,D=u.n,M=8*s;do{if(!A){u.f=m=L(r,k,1);var S=L(r,k+1,3);if(k+=3,!S){var V=r[(I=((h=k)/8|0)+(7&h&&1)+4)-4]|r[I-3]<<8,_=I+V;if(_>s){g&&T(0);break}c&&d(O+V),f.set(r.subarray(I,_),O),u.b=O+=V,u.p=k=8*_;continue}if(1==S)A=b,x=p,E=9,D=5;else if(2==S){var j=L(r,k,31)+257,z=L(r,k+10,15)+4,C=j+L(r,k+5,31)+1;k+=14;for(var F=new e(C),P=new e(19),q=0;q<z;++q)P[o[q]]=L(r,k+3*q,7);k+=3*z;var B=y(P),G=(1<<B)-1,H=w(P,B,1);for(q=0;q<C;){var I,J=H[L(r,k,G)];if(k+=15&J,(I=J>>>4)<16)F[q++]=I;else {var K=0,N=0;for(16==I?(N=3+L(r,k,3),k+=2,K=F[q-1]):17==I?(N=3+L(r,k,7),k+=3):18==I&&(N=11+L(r,k,127),k+=7);N--;)F[q++]=K;}}var Q=F.subarray(0,j),R=F.subarray(j);E=y(Q),D=y(R),A=w(Q,E,1),x=w(R,D,1);}else T(1);if(k>M){g&&T(0);break}}c&&d(O+131072);for(var W=(1<<E)-1,X=(1<<D)-1,Y=k;;Y=k){var Z=(K=A[U(r,k)&W])>>>4;if((k+=15&K)>M){g&&T(0);break}if(K||T(2),Z<256)f[O++]=Z;else {if(256==Z){Y=k,A=null;break}var $=Z-254;if(Z>264){var rr=a[q=Z-257];$=L(r,k,(1<<rr)-1)+v[q],k+=rr;}var er=x[U(r,k)&X],nr=er>>>4;er||T(3),k+=15&er;R=l[nr];if(nr>3){rr=i[nr];R+=U(r,k)&(1<<rr)-1,k+=rr;}if(k>M){g&&T(0);break}c&&d(O+131072);for(var tr=O+$;O<tr;O+=4)f[O]=f[O-R],f[O+1]=f[O+1-R],f[O+2]=f[O+2-R],f[O+3]=f[O+3-R];O=tr;}}u.l=A,u.p=Y,u.b=O,A&&(m=1,u.m=E,u.d=x,u.n=D);}while(!m);return O==f.length?f:function(r,a,i){(null==a||a<0)&&(a=0),(null==i||i>r.length)&&(i=r.length);var o=new(r instanceof n?n:r instanceof t?t:e)(i-a);return o.set(r.subarray(a,i)),o}(f,0,O)},A=new e(0);var x=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{x.decode(A,{stream:!0}),1;}catch(r){}return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function i(r){m.setUint16(b,r),b+=2;}function o(r){m.setUint32(b,r),b+=4;}for(var f={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=f.numTables;)u++;u--;for(var v=16*Math.pow(2,u),s=16*f.numTables-v,l=12,c=[],g=0;g<f.numTables;g++)c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16;var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),d=w.buffer,m=new DataView(d),b=0;return o(f.flavor),i(f.numTables),i(v),i(u),i(s),c.forEach((function(r){o(r.tag),o(r.origChecksum),o(l),o(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else a=new Uint8Array(t);w.set(a,e.outOffset);var i=0;(l=e.outOffset+e.origLength)%4!=0&&(i=4-l%4),w.set(new Uint8Array(i).buffer,e.outOffset+e.origLength),h=l+i;})),d.slice(0,h)},Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).convert_streams}\n\n/**\n * A factory wrapper parsing a font file using Typr.\n * Also adds support for WOFF files (not WOFF2).\n */\n\nfunction parserFactory(Typr, woff2otf) {\n  const cmdArgLengths = {\n    M: 2,\n    L: 2,\n    Q: 4,\n    C: 6,\n    Z: 0\n  };\n\n  // {joinType: \"skip+step,...\"}\n  const joiningTypeRawData = {\"C\":\"18g,ca,368,1kz\",\"D\":\"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\"R\":\"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\"L\":\"x9u,jff,a,fd,jv\",\"T\":\"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"};\n\n  const JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.\n    JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.\n    JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.\n    JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.\n    JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.\n    JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,\n\n  let joiningTypeMap;\n  function getCharJoiningType(ch) {\n    if (!joiningTypeMap) {\n      const m = {\n        R: JT_RIGHT,\n        L: JT_LEFT,\n        D: JT_DUAL,\n        C: JT_JOIN_CAUSING,\n        U: JT_NON_JOINING,\n        T: JT_TRANSPARENT\n      };\n      joiningTypeMap = new Map();\n      for (let type in joiningTypeRawData) {\n        let lastCode = 0;\n        joiningTypeRawData[type].split(',').forEach(range => {\n          let [skip, step] = range.split('+');\n          skip = parseInt(skip,36);\n          step = step ? parseInt(step, 36) : 0;\n          joiningTypeMap.set(lastCode += skip, m[type]);\n          for (let i = step; i--;) {\n            joiningTypeMap.set(++lastCode, m[type]);\n          }\n        });\n      }\n    }\n    return joiningTypeMap.get(ch) || JT_NON_JOINING\n  }\n\n  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;\n  const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];\n\n  function detectJoiningForms(str) {\n    // This implements the algorithm described here:\n    // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md\n    const joiningForms = new Uint8Array(str.length);\n    let prevJoiningType = JT_NON_JOINING;\n    let prevForm = ISOL;\n    let prevIndex = -1;\n    for (let i = 0; i < str.length; i++) {\n      const code = str.codePointAt(i);\n      let joiningType = getCharJoiningType(code) | 0;\n      let form = ISOL;\n      if (joiningType & JT_TRANSPARENT) {\n        continue\n      }\n      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {\n        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {\n          form = FINA;\n          // isol->init, fina->medi\n          if (prevForm === ISOL || prevForm === FINA) {\n            joiningForms[prevIndex]++;\n          }\n        }\n        else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {\n          // medi->fina, init->isol\n          if (prevForm === INIT || prevForm === MEDI) {\n            joiningForms[prevIndex]--;\n          }\n        }\n      }\n      else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {\n        // medi->fina, init->isol\n        if (prevForm === INIT || prevForm === MEDI) {\n          joiningForms[prevIndex]--;\n        }\n      }\n      prevForm = joiningForms[i] = form;\n      prevJoiningType = joiningType;\n      prevIndex = i;\n      if (code > 0xffff) i++;\n    }\n    // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))\n    // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))\n    // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))\n    return joiningForms\n  }\n\n  function stringToGlyphs (font, str) {\n    const glyphIds = [];\n    for (let i = 0; i < str.length; i++) {\n      const cc = str.codePointAt(i);\n      if (cc > 0xffff) i++;\n      glyphIds.push(Typr.U.codeToGlyph(font, cc));\n    }\n\n    const gsub = font['GSUB'];\n    if (gsub) {\n      const {lookupList, featureList} = gsub;\n      let joiningForms;\n      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;\n      const usedLookups = [];\n      featureList.forEach(feature => {\n        if (supportedFeatures.test(feature.tag)) {\n          for (let ti = 0; ti < feature.tab.length; ti++) {\n            if (usedLookups[feature.tab[ti]]) continue\n            usedLookups[feature.tab[ti]] = true;\n            const tab = lookupList[feature.tab[ti]];\n            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);\n            if (isJoiningFeature && !joiningForms) { //lazy\n              joiningForms = detectJoiningForms(str);\n            }\n            for (let ci = 0; ci < glyphIds.length; ci++) {\n              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {\n                Typr.U._applySubs(glyphIds, ci, tab, lookupList);\n              }\n            }\n          }\n        }\n      });\n    }\n\n    return glyphIds\n  }\n\n  function firstNum(...args) {\n    for (let i = 0; i < args.length; i++) {\n      if (typeof args[i] === 'number') {\n        return args[i]\n      }\n    }\n  }\n\n  function wrapFontObj(typrFont) {\n    const glyphMap = Object.create(null);\n\n    const os2 = typrFont['OS/2'];\n    const hhea = typrFont.hhea;\n    const unitsPerEm = typrFont.head.unitsPerEm;\n    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);\n\n    const fontObj = {\n      unitsPerEm,\n      ascender,\n      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),\n      capHeight: firstNum(os2 && os2.sCapHeight, ascender),\n      xHeight: firstNum(os2 && os2.sxHeight, ascender),\n      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),\n      forEachGlyph(text, fontSize, letterSpacing, callback) {\n        let glyphX = 0;\n        const fontScale = 1 / fontObj.unitsPerEm * fontSize;\n\n        const glyphIndices = stringToGlyphs(typrFont, text);\n        let charIndex = 0;\n        let prevGlyphIndex = -1;\n        glyphIndices.forEach((glyphIndex, i) => {\n          // Typr returns a glyph index per string codepoint, with -1s in place of those that\n          // were omitted due to ligature substitution. So we can track original index in the\n          // string via simple increment, and skip everything else when seeing a -1.\n          if (glyphIndex !== -1) {\n            let glyphObj = glyphMap[glyphIndex];\n            if (!glyphObj) {\n              const {cmds, crds} = Typr.U.glyphToPath(typrFont, glyphIndex);\n\n              // Build path string\n              let path = '';\n              let crdsIdx = 0;\n              for (let i = 0, len = cmds.length; i < len; i++) {\n                const numArgs = cmdArgLengths[cmds[i]];\n                path += cmds[i];\n                for (let j = 1; j <= numArgs; j++) {\n                  path += (j > 1 ? ',' : '') + crds[crdsIdx++];\n                }\n              }\n\n              // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't\n              // normalize the two, so it's simplest just to iterate ourselves.\n              let xMin, yMin, xMax, yMax;\n              if (crds.length) {\n                xMin = yMin = Infinity;\n                xMax = yMax = -Infinity;\n                for (let i = 0, len = crds.length; i < len; i += 2) {\n                  let x = crds[i];\n                  let y = crds[i + 1];\n                  if (x < xMin) xMin = x;\n                  if (y < yMin) yMin = y;\n                  if (x > xMax) xMax = x;\n                  if (y > yMax) yMax = y;\n                }\n              } else {\n                xMin = xMax = yMin = yMax = 0;\n              }\n\n              glyphObj = glyphMap[glyphIndex] = {\n                index: glyphIndex,\n                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],\n                xMin,\n                yMin,\n                xMax,\n                yMax,\n                path,\n                pathCommandCount: cmds.length,\n                // forEachPathCommand(callback) {\n                //   let argsIndex = 0\n                //   const argsArray = []\n                //   for (let i = 0, len = cmds.length; i < len; i++) {\n                //     const numArgs = cmdArgLengths[cmds[i]]\n                //     argsArray.length = 1 + numArgs\n                //     argsArray[0] = cmds[i]\n                //     for (let j = 1; j <= numArgs; j++) {\n                //       argsArray[j] = crds[argsIndex++]\n                //     }\n                //     callback.apply(null, argsArray)\n                //   }\n                // }\n              };\n            }\n\n            // Kerning\n            if (prevGlyphIndex !== -1) {\n              glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;\n            }\n\n            callback.call(null, glyphObj, glyphX, charIndex);\n\n            if (glyphObj.advanceWidth) {\n              glyphX += glyphObj.advanceWidth * fontScale;\n            }\n            if (letterSpacing) {\n              glyphX += letterSpacing * fontSize;\n            }\n\n            prevGlyphIndex = glyphIndex;\n          }\n          charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);\n        });\n        return glyphX\n      }\n    };\n\n    return fontObj\n  }\n\n  return function parse(buffer) {\n    // Look to see if we have a WOFF file and convert it if so:\n    const peek = new Uint8Array(buffer, 0, 4);\n    const tag = Typr._bin.readASCII(peek, 0, 4);\n    if (tag === 'wOFF') {\n      buffer = woff2otf(buffer);\n    } else if (tag === 'wOF2') {\n      throw new Error('woff2 fonts not supported')\n    }\n    return wrapFontObj(Typr.parse(buffer)[0])\n  }\n}\n\n\nconst workerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typr Font Parser',\n  dependencies: [typrFactory, woff2otfFactory, parserFactory],\n  init(typrFactory, woff2otfFactory, parserFactory) {\n    const Typr = typrFactory();\n    const woff2otf = woff2otfFactory();\n    return parserFactory(Typr, woff2otf)\n  }\n});\n\nconst CONFIG = {\n  defaultFontURL: 'https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff', //Roboto Regular\n  sdfGlyphSize: 64,\n  sdfMargin: 1 / 16,\n  sdfExponent: 9,\n  textureWidth: 2048\n};\nconst tempColor = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_3__.Color();\nlet hasRequested = false;\n\nfunction now$1() {\n  return (self.performance || Date).now()\n}\n\n/**\n * Customizes the text builder configuration. This must be called prior to the first font processing\n * request, and applies to all fonts.\n *\n * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n *                 requests, in case none is specified or the specifiede font fails to load or parse.\n *                 Defaults to \"Roboto Regular\" from Google Fonts.\n * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)\n *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n *                 to 64 which is generally a good balance of size and quality.\n * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent\n *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer\n *                 the glyph's path, with lower precision further away. Defaults to 9.\n * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's\n *                 path, as a percentage of the SDF width. A larger margin increases the quality of\n *                 extruded glyph outlines, but decreases the precision available for the glyph itself.\n *                 Defaults to 1/16th of the glyph size.\n * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n *                 2048 which is a safe maximum texture dimension according to the stats at\n *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of\n *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to\n *                 increase the glyph size and/or have an extraordinary number of glyphs.\n */\nfunction configureTextBuilder(config) {\n  if (hasRequested) {\n    console.warn('configureTextBuilder called after first font request; will be ignored.');\n  } else {\n    assign(CONFIG, config);\n  }\n}\n\n/**\n * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for\n * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.\n *\n *   {\n *     [sdfGlyphSize]: {\n *       glyphCount: number,\n *       sdfGlyphSize: number,\n *       sdfTexture: Texture,\n *       sdfCanvas: HTMLCanvasElement,\n *       contextLost: boolean,\n *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>\n *     }\n *   }\n */\nconst atlases = Object.create(null);\n\n/**\n * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n * @property {object} parameters - The normalized input arguments to the render call.\n * @property {Texture} sdfTexture - The SDF atlas texture.\n * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.\n * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.\n * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.\n * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.\n * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is\n *           three elements: the starting X, the ending X, and the bottom Y for the caret.\n * @property {number} [caretHeight] - An appropriate height for all selection carets.\n * @property {number} ascender - The font's ascender metric.\n * @property {number} descender - The font's descender metric.\n * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.\n * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.\n * @property {number} lineHeight - The final computed lineHeight measurement.\n * @property {number} topBaseline - The y position of the top line's baseline.\n * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is\n *           equivalent to the dimensions of a block-level text element in CSS.\n * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.\n * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n *           generation, typesetting, etc.\n * @frozen\n */\n\n/**\n * @callback getTextRenderInfo~callback\n * @param {TroikaTextRenderInfo} textRenderInfo\n */\n\n/**\n * Main entry point for requesting the data needed to render a text string with given font parameters.\n * This is an asynchronous call, performing most of the logic in a web worker thread.\n * @param {object} args\n * @param {getTextRenderInfo~callback} callback\n */\nfunction getTextRenderInfo(args, callback) {\n  hasRequested = true;\n  args = assign({}, args);\n  const totalStart = now$1();\n\n  // Apply default font here to avoid a 'null' atlas, and convert relative\n  // URLs to absolute so they can be resolved in the worker\n  args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);\n\n  // Normalize text to a string\n  args.text = '' + args.text;\n\n  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n\n  // Normalize colors\n  if (args.colorRanges != null) {\n    let colors = {};\n    for (let key in args.colorRanges) {\n      if (args.colorRanges.hasOwnProperty(key)) {\n        let val = args.colorRanges[key];\n        if (typeof val !== 'number') {\n          val = tempColor.set(val).getHex();\n        }\n        colors[key] = val;\n      }\n    }\n    args.colorRanges = colors;\n  }\n\n  Object.freeze(args);\n\n  // Init the atlas if needed\n  const {textureWidth, sdfExponent} = CONFIG;\n  const {sdfGlyphSize} = args;\n  const glyphsPerRow = (textureWidth / sdfGlyphSize * 4);\n  let atlas = atlases[sdfGlyphSize];\n  if (!atlas) {\n    const canvas = document.createElement('canvas');\n    canvas.width = textureWidth;\n    canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs\n    atlas = atlases[sdfGlyphSize] = {\n      glyphCount: 0,\n      sdfGlyphSize,\n      sdfCanvas: canvas,\n      sdfTexture: new three__WEBPACK_IMPORTED_MODULE_3__.Texture(\n        canvas,\n        undefined,\n        undefined,\n        undefined,\n        three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter,\n        three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter\n      ),\n      contextLost: false,\n      glyphsByFont: new Map()\n    };\n    atlas.sdfTexture.generateMipmaps = false;\n    initContextLossHandling(atlas);\n  }\n\n  const {sdfTexture, sdfCanvas} = atlas;\n  let fontGlyphs = atlas.glyphsByFont.get(args.font);\n  if (!fontGlyphs) {\n    atlas.glyphsByFont.set(args.font, fontGlyphs = new Map());\n  }\n\n  // Issue request to the typesetting engine in the worker\n  typesetInWorker(args).then(result => {\n    const {glyphIds, glyphPositions, fontSize, unitsPerEm, timings} = result;\n    const neededSDFs = [];\n    const glyphBounds = new Float32Array(glyphIds.length * 4);\n    const fontSizeMult = fontSize / unitsPerEm;\n    let boundsIdx = 0;\n    let positionsIdx = 0;\n    const quadsStart = now$1();\n    glyphIds.forEach((glyphId, i) => {\n      let glyphInfo = fontGlyphs.get(glyphId);\n\n      // If this is a glyphId not seen before, add it to the atlas\n      if (!glyphInfo) {\n        const {path, pathBounds} = result.glyphData[glyphId];\n\n        // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.\n        // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain\n        // useful interpolated values and will be ignored anyway.\n        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1])\n          / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);\n\n        const atlasIndex = atlas.glyphCount++;\n        const sdfViewBox = [\n          pathBounds[0] - fontUnitsMargin,\n          pathBounds[1] - fontUnitsMargin,\n          pathBounds[2] + fontUnitsMargin,\n          pathBounds[3] + fontUnitsMargin,\n        ];\n        fontGlyphs.set(glyphId, (glyphInfo = { path, atlasIndex, sdfViewBox }));\n\n        // Collect those that need SDF generation\n        neededSDFs.push(glyphInfo);\n      }\n\n      // Calculate bounds for renderable quads\n      // TODO can we get this back off the main thread?\n      const {sdfViewBox} = glyphInfo;\n      const posX = glyphPositions[positionsIdx++];\n      const posY = glyphPositions[positionsIdx++];\n      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;\n\n      // Convert glyphId to SDF index for the shader\n      glyphIds[i] = glyphInfo.atlasIndex;\n    });\n    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);\n\n    const sdfStart = now$1();\n    timings.sdf = {};\n\n    // Grow the texture height by power of 2 if needed\n    const currentHeight = sdfCanvas.height;\n    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);\n    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));\n    if (neededHeight > currentHeight) {\n      // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over\n      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);\n      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);\n      // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it\n      sdfTexture.dispose();\n    }\n\n    Promise.all(neededSDFs.map(glyphInfo =>\n      generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({timing}) => {\n        timings.sdf[glyphInfo.atlasIndex] = timing;\n      })\n    )).then(() => {\n      if (neededSDFs.length && !atlas.contextLost) {\n        safariPre15Workaround(atlas);\n        sdfTexture.needsUpdate = true;\n      }\n      timings.sdfTotal = now$1() - sdfStart;\n      timings.total = now$1() - totalStart;\n      // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)\n\n      // Invoke callback with the text layout arrays and updated texture\n      callback(Object.freeze({\n        parameters: args,\n        sdfTexture,\n        sdfGlyphSize,\n        sdfExponent,\n        glyphBounds,\n        glyphAtlasIndices: glyphIds,\n        glyphColors: result.glyphColors,\n        caretPositions: result.caretPositions,\n        caretHeight: result.caretHeight,\n        chunkedBounds: result.chunkedBounds,\n        ascender: result.ascender,\n        descender: result.descender,\n        lineHeight: result.lineHeight,\n        capHeight: result.capHeight,\n        xHeight: result.xHeight,\n        topBaseline: result.topBaseline,\n        blockBounds: result.blockBounds,\n        visibleBounds: result.visibleBounds,\n        timings: result.timings,\n      }));\n    });\n  });\n\n  // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is\n  // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets\n  // a head start on that process before SDFs actually start getting processed.\n  Promise.resolve().then(() => {\n    if (!atlas.contextLost) {\n      warmUpSDFCanvas(sdfCanvas);\n    }\n  });\n}\n\nfunction generateGlyphSDF({path, atlasIndex, sdfViewBox}, {sdfGlyphSize, sdfCanvas, contextLost}, useGPU) {\n  if (contextLost) {\n    // If the context is lost there's nothing we can do, just quit silently and let it\n    // get regenerated when the context is restored\n    return Promise.resolve({timing: -1})\n  }\n  const {textureWidth, sdfExponent} = CONFIG;\n  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);\n  const squareIndex = Math.floor(atlasIndex / 4);\n  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;\n  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;\n  const channel = atlasIndex % 4;\n  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU)\n}\n\nfunction initContextLossHandling(atlas) {\n  const canvas = atlas.sdfCanvas;\n\n  /*\n  // Begin context loss simulation\n  if (!window.WebGLDebugUtils) {\n    let script = document.getElementById('WebGLDebugUtilsScript')\n    if (!script) {\n      script = document.createElement('script')\n      script.id = 'WebGLDebugUtils'\n      document.head.appendChild(script)\n      script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'\n    }\n    script.addEventListener('load', () => {\n      initContextLossHandling(atlas)\n    })\n    return\n  }\n  window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)\n  canvas.loseContextInNCalls(500)\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    canvas.loseContextInNCalls(5000)\n  })\n  // End context loss simulation\n  */\n\n  canvas.addEventListener('webglcontextlost', (event) => {\n    console.log('Context Lost', event);\n    event.preventDefault();\n    atlas.contextLost = true;\n  });\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    console.log('Context Restored', event);\n    atlas.contextLost = false;\n    // Regenerate all glyphs into the restored canvas:\n    const promises = [];\n    atlas.glyphsByFont.forEach(glyphMap => {\n      glyphMap.forEach(glyph => {\n        promises.push(generateGlyphSDF(glyph, atlas, true));\n      });\n    });\n    Promise.all(promises).then(() => {\n      safariPre15Workaround(atlas);\n      atlas.sdfTexture.needsUpdate = true;\n    });\n  });\n}\n\n/**\n * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n * needed fonts and glyphs up front along with other assets.\n *\n * @param {object} options\n * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n *        be loaded.\n * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n *        to specify ligature sequences in addition to their individual characters to get all\n *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.\n * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n *        specified `characters`.\n * @param {function} callback - A function that will be called when the preloading is complete.\n */\nfunction preloadFont({font, characters, sdfGlyphSize}, callback) {\n  let text = Array.isArray(characters) ? characters.join('\\n') : '' + characters;\n  getTextRenderInfo({ font, sdfGlyphSize, text }, callback);\n}\n\n\n// Local assign impl so we don't have to import troika-core\nfunction assign(toObj, fromObj) {\n  for (let key in fromObj) {\n    if (fromObj.hasOwnProperty(key)) {\n      toObj[key] = fromObj[key];\n    }\n  }\n  return toObj\n}\n\n// Utility for making URLs absolute\nlet linkEl;\nfunction toAbsoluteURL(path) {\n  if (!linkEl) {\n    linkEl = typeof document === 'undefined' ? {} : document.createElement('a');\n  }\n  linkEl.href = path;\n  return linkEl.href\n}\n\n/**\n * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround\n * where it reads the pixels out of that canvas and uploads them as a data texture instead, at\n * a slight performance cost.\n */\nfunction safariPre15Workaround(atlas) {\n  // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers\n  // have supported it for a long while so any false positives should be minimal.\n  if (typeof createImageBitmap !== 'function') {\n    console.info('Safari<15: applying SDF canvas workaround');\n    const {sdfCanvas, sdfTexture} = atlas;\n    const {width, height} = sdfCanvas;\n    const gl = atlas.sdfCanvas.getContext('webgl');\n    let pixels = sdfTexture.image.data;\n    if (!pixels || pixels.length !== width * height * 4) {\n      pixels = new Uint8Array(width * height * 4);\n      sdfTexture.image = {width, height, data: pixels};\n      sdfTexture.flipY = false;\n      sdfTexture.isDataTexture = true;\n    }\n    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n  }\n}\n\n\nconst typesetterWorkerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typesetter',\n  dependencies: [\n    CONFIG,\n    workerModule,\n    createTypesetter,\n    bidi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n  ],\n  init(config, fontParser, createTypesetter, bidiFactory) {\n    const {defaultFontURL} = config;\n    return createTypesetter(fontParser, bidiFactory(), { defaultFontURL })\n  }\n});\n\nconst typesetInWorker = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typesetter',\n  dependencies: [\n    typesetterWorkerModule,\n  ],\n  init(typesetter) {\n    return function(args) {\n      return new Promise(resolve => {\n        typesetter.typeset(args, resolve);\n      })\n    }\n  },\n  getTransferables(result) {\n    // Mark array buffers as transferable to avoid cloning during postMessage\n    const transferables = [\n      result.glyphPositions.buffer,\n      result.glyphIds.buffer\n    ];\n    if (result.caretPositions) {\n      transferables.push(result.caretPositions.buffer);\n    }\n    if (result.glyphColors) {\n      transferables.push(result.glyphColors.buffer);\n    }\n    return transferables\n  }\n});\n\nfunction dumpSDFTextures() {\n  Object.keys(atlases).forEach(size => {\n    const canvas = atlases[size].sdfCanvas;\n    const {width, height} = canvas;\n    console.log(\"%c.\", `\n      background: url(${canvas.toDataURL()});\n      background-size: ${width}px ${height}px;\n      color: transparent;\n      font-size: 0;\n      line-height: ${height}px;\n      padding-left: ${width}px;\n    `);\n  });\n}\n\nconst templateGeometries = {};\n\nfunction getTemplateGeometry(detail) {\n  let geom = templateGeometries[detail];\n  if (!geom) {\n    // Geometry is two planes back-to-back, which will always be rendered FrontSide only but\n    // appear as DoubleSide by default. FrontSide/BackSide are emulated using drawRange.\n    // We do it this way to avoid the performance hit of two draw calls for DoubleSide materials\n    // introduced by Three.js in r130 - see https://github.com/mrdoob/three.js/pull/21967\n    const front = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, detail, detail);\n    const back = front.clone();\n    const frontAttrs = front.attributes;\n    const backAttrs = back.attributes;\n    const combined = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n    const vertCount = frontAttrs.uv.count;\n    for (let i = 0; i < vertCount; i++) {\n      backAttrs.position.array[i * 3] *= -1; // flip position x\n      backAttrs.normal.array[i * 3 + 2] *= -1; // flip normal z\n    }\n    ['position', 'normal', 'uv'].forEach(name => {\n      combined.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(\n        [...frontAttrs[name].array, ...backAttrs[name].array],\n        frontAttrs[name].itemSize)\n      );\n    });\n    combined.setIndex([...front.index.array, ...back.index.array.map(n => n + vertCount)]);\n    combined.translate(0.5, 0.5, 0);\n    geom = templateGeometries[detail] = combined;\n  }\n  return geom\n}\n\nconst glyphBoundsAttrName = 'aTroikaGlyphBounds';\nconst glyphIndexAttrName = 'aTroikaGlyphIndex';\nconst glyphColorAttrName = 'aTroikaGlyphColor';\n\n/**\n@class GlyphsGeometry\n\nA specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\nrender the glyphs using GPU instancing of a single quad, rather than constructing a whole\ngeometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n  Where N = number of glyphs...\n\n  Instanced:\n  - position: 4 * 3\n  - index: 2 * 3\n  - normal: 4 * 3\n  - uv: 4 * 2\n  - glyph x/y bounds: N * 4\n  - glyph indices: N * 1\n  = 5N + 38\n\n  Non-instanced:\n  - position: N * 4 * 3\n  - index: N * 2 * 3\n  - normal: N * 4 * 3\n  - uv: N * 4 * 2\n  - glyph indices: N * 1\n  = 39N\n\nA downside of this is the rare-but-possible lack of the instanced arrays extension,\nwhich we could potentially work around with a fallback non-instanced implementation.\n\n*/\nclass GlyphsGeometry extends three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferGeometry {\n  constructor() {\n    super();\n\n    this.detail = 1;\n    this.curveRadius = 0;\n\n    // Define groups for rendering text outline as a separate pass; these will only\n    // be used when the `material` getter returns an array, i.e. outlineWidth > 0.\n    this.groups = [\n      {start: 0, count: Infinity, materialIndex: 0},\n      {start: 0, count: Infinity, materialIndex: 1}\n    ];\n\n    // Preallocate empty bounding objects\n    this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_3__.Sphere();\n    this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_3__.Box3();\n  }\n\n  computeBoundingSphere () {\n    // No-op; we'll sync the boundingSphere proactively when needed.\n  }\n\n  computeBoundingBox() {\n    // No-op; we'll sync the boundingBox proactively when needed.\n  }\n\n  // Since our base geometry contains triangles for both front and back sides, we can emulate\n  // the \"side\" by restricting the draw range.\n  setSide(side) {\n    const verts = this.getIndex().count;\n    this.setDrawRange(side === three__WEBPACK_IMPORTED_MODULE_3__.BackSide ? verts / 2 : 0, side === three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide ? verts : verts / 2);\n  }\n\n  set detail(detail) {\n    if (detail !== this._detail) {\n      this._detail = detail;\n      if (typeof detail !== 'number' || detail < 1) {\n        detail = 1;\n      }\n      let tpl = getTemplateGeometry(detail)\n      ;['position', 'normal', 'uv'].forEach(attr => {\n        this.attributes[attr] = tpl.attributes[attr].clone();\n      });\n      this.setIndex(tpl.getIndex().clone());\n    }\n  }\n  get detail() {\n    return this._detail\n  }\n\n  set curveRadius(r) {\n    if (r !== this._curveRadius) {\n      this._curveRadius = r;\n      this._updateBounds();\n    }\n  }\n  get curveRadius() {\n    return this._curveRadius\n  }\n\n  /**\n   * Update the geometry for a new set of glyphs.\n   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n   *        the SDF atlas texture.\n   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n   *        used with `applyClipRect` to choose an optimized `instanceCount`.\n   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n   */\n  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {\n    // Update the instance attributes\n    updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);\n    updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);\n    updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);\n    this._blockBounds = blockBounds;\n    this._chunkedBounds = chunkedBounds;\n    this.instanceCount = glyphAtlasIndices.length;\n    this._updateBounds();\n  }\n\n  _updateBounds() {\n    const bounds = this._blockBounds;\n    if (bounds) {\n      const { curveRadius, boundingBox: bbox } = this;\n      if (curveRadius) {\n        const { PI, floor, min, max, sin, cos } = Math;\n        const halfPi = PI / 2;\n        const twoPi = PI * 2;\n        const absR = Math.abs(curveRadius);\n        const leftAngle = bounds[0] / absR;\n        const rightAngle = bounds[2] / absR;\n        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)\n          ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);\n        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)\n          ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);\n        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)\n          ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);\n        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);\n        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);\n      } else {\n        bbox.min.set(bounds[0], bounds[1], 0);\n        bbox.max.set(bounds[2], bounds[3], 0);\n      }\n      bbox.getBoundingSphere(this.boundingSphere);\n    }\n  }\n\n  /**\n   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n   * be clipped anyway.\n   *\n   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n   * but at the expense of much larger attribute buffers (see classdoc above.)\n   *\n   * @param {Vector4} clipRect\n   */\n  applyClipRect(clipRect) {\n    let count = this.getAttribute(glyphIndexAttrName).count;\n    let chunks = this._chunkedBounds;\n    if (chunks) {\n      for (let i = chunks.length; i--;) {\n        count = chunks[i].end;\n        let rect = chunks[i].rect;\n        // note: both rects are l-b-r-t\n        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n          break\n        }\n      }\n    }\n    this.instanceCount = count;\n  }\n}\n\n\nfunction updateBufferAttr(geom, attrName, newArray, itemSize) {\n  const attr = geom.getAttribute(attrName);\n  if (newArray) {\n    // If length isn't changing, just update the attribute's array data\n    if (attr && attr.array.length === newArray.length) {\n      attr.array.set(newArray);\n      attr.needsUpdate = true;\n    } else {\n      geom.setAttribute(attrName, new three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferAttribute(newArray, itemSize));\n      // If the new attribute has a different size, we also have to (as of r117) manually clear the\n      // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n      // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n      // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n      // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n      // implies it should be supported. It's possible we need to\n      delete geom._maxInstanceCount; //for r117+, could be fragile\n      geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like\n    }\n  } else if (attr) {\n    geom.deleteAttribute(attrName);\n  }\n}\n\n// language=GLSL\nconst VERTEX_DEFS = `\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n`;\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst VERTEX_TRANSFORM = `\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n${''/* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the\n  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts\n  on some glyphs (those in the leftmost texture column) on some systems. The exact reason\n  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n`;\n\n// language=GLSL\nconst FRAGMENT_DEFS = `\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  ${''/* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those\n    are linearly interpolated where the encoding is exponential. Look into improving this by rounding\n    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.\n  */}\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  ${''/*\n    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based\n    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes \n    readability and edge crispness at all sizes and screen resolutions.\n  */}\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  ${''/* \n  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...\n  // This has potential but currently gives very jagged extensions, maybe due to precision issues?\n  float uvStep = 1.0 / uTroikaSDFGlyphSize;\n  vec2 neighbor1UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  vec2 neighbor2UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);\n  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);\n  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);\n  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);\n  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);\n  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;\n  */}\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n`;\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst FRAGMENT_TRANSFORM = `\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n`;\n\n\n/**\n * Create a material for rendering text, derived from a baseMaterial\n */\nfunction createTextDerivedMaterial(baseMaterial) {\n  const textMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(baseMaterial, {\n    chained: true,\n    extensions: {\n      derivatives: true\n    },\n    uniforms: {\n      uTroikaSDFTexture: {value: null},\n      uTroikaSDFTextureSize: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()},\n      uTroikaSDFGlyphSize: {value: 0},\n      uTroikaSDFExponent: {value: 0},\n      uTroikaTotalBounds: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0,0,0,0)},\n      uTroikaClipRect: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0,0,0,0)},\n      uTroikaDistanceOffset: {value: 0},\n      uTroikaOutlineOpacity: {value: 0},\n      uTroikaFillOpacity: {value: 1},\n      uTroikaPositionOffset: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()},\n      uTroikaCurveRadius: {value: 0},\n      uTroikaBlurRadius: {value: 0},\n      uTroikaStrokeWidth: {value: 0},\n      uTroikaStrokeColor: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Color()},\n      uTroikaStrokeOpacity: {value: 1},\n      uTroikaOrient: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Matrix3()},\n      uTroikaUseGlyphColors: {value: true},\n      uTroikaSDFDebug: {value: false}\n    },\n    vertexDefs: VERTEX_DEFS,\n    vertexTransform: VERTEX_TRANSFORM,\n    fragmentDefs: FRAGMENT_DEFS,\n    fragmentColorTransform: FRAGMENT_TRANSFORM,\n    customRewriter({vertexShader, fragmentShader}) {\n      let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n      if (uDiffuseRE.test(fragmentShader)) {\n        // Replace all instances of `diffuse` with our varying\n        fragmentShader = fragmentShader\n          .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')\n          .replace(/\\bdiffuse\\b/g, 'vTroikaGlyphColor');\n        // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n        if (!uDiffuseRE.test(vertexShader)) {\n          vertexShader = vertexShader.replace(\n            troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.voidMainRegExp,\n            'uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n'\n          );\n        }\n      }\n      return { vertexShader, fragmentShader }\n    }\n  });\n\n  // Force transparency - TODO is this reasonable?\n  textMaterial.transparent = true;\n\n  Object.defineProperties(textMaterial, {\n    isTroikaTextMaterial: {value: true},\n\n    // WebGLShadowMap reverses the side of the shadow material by default, which fails\n    // for planes, so here we force the `shadowSide` to always match the main side.\n    shadowSide: {\n      get() {\n        return this.side\n      },\n      set() {\n        //no-op\n      }\n    }\n  });\n\n  return textMaterial\n}\n\nconst defaultMaterial = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n  color: 0xffffff,\n  side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide,\n  transparent: true\n});\nconst defaultStrokeColor = 0x808080;\n\nconst tempMat4 = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst tempVec3a = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempVec3b = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempArray = [];\nconst origin = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst defaultOrient = '+x+y';\n\nfunction first(o) {\n  return Array.isArray(o) ? o[0] : o\n}\n\nlet getFlatRaycastMesh = () => {\n  const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(\n    new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1),\n    defaultMaterial\n  );\n  getFlatRaycastMesh = () => mesh;\n  return mesh\n};\nlet getCurvedRaycastMesh = () => {\n  const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(\n    new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, 32, 1),\n    defaultMaterial\n  );\n  getCurvedRaycastMesh = () => mesh;\n  return mesh\n};\n\nconst syncStartEvent = { type: 'syncstart' };\nconst syncCompleteEvent = { type: 'synccomplete' };\n\nconst SYNCABLE_PROPS = [\n  'font',\n  'fontSize',\n  'letterSpacing',\n  'lineHeight',\n  'maxWidth',\n  'overflowWrap',\n  'text',\n  'direction',\n  'textAlign',\n  'textIndent',\n  'whiteSpace',\n  'anchorX',\n  'anchorY',\n  'colorRanges',\n  'sdfGlyphSize'\n];\n\nconst COPYABLE_PROPS = SYNCABLE_PROPS.concat(\n  'material',\n  'color',\n  'depthOffset',\n  'clipRect',\n  'curveRadius',\n  'orientation',\n  'glyphGeometryDetail'\n);\n\n/**\n * @class Text\n *\n * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n * fields (SDF).\n */\nclass Text extends three__WEBPACK_IMPORTED_MODULE_3__.Mesh {\n  constructor() {\n    const geometry = new GlyphsGeometry();\n    super(geometry, null);\n\n    // === Text layout properties: === //\n\n    /**\n     * @member {string} text\n     * The string of text to be rendered.\n     */\n    this.text = '';\n\n    /**\n     * @member {number|string} anchorX\n     * Defines the horizontal position in the text block that should line up with the local origin.\n     * Can be specified as a numeric x position in local units, a string percentage of the total\n     * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',\n     * or 'right'.\n     */\n    this.anchorX = 0;\n\n    /**\n     * @member {number|string} anchorX\n     * Defines the vertical position in the text block that should line up with the local origin.\n     * Can be specified as a numeric y position in local units (note: down is negative y), a string\n     * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:\n     * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.\n     */\n    this.anchorY = 0;\n\n    /**\n     * @member {number} curveRadius\n     * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put\n     * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave\n     * curvature, while negative numbers put it behind the text for a convex curvature. The centerline\n     * will be aligned with the text's local origin; you can use `anchorX` to offset it.\n     *\n     * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane\n     * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.\n     */\n    this.curveRadius = 0;\n\n    /**\n     * @member {string} direction\n     * Sets the base direction for the text. The default value of \"auto\" will choose a direction based\n     * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.\n     */\n    this.direction = 'auto';\n\n    /**\n     * @member {string} font\n     * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.\n     * Defaults to the Roboto font loaded from Google Fonts.\n     */\n    this.font = null; //will use default from TextBuilder\n\n    /**\n     * @member {number} fontSize\n     * The size at which to render the font in local units; corresponds to the em-box height\n     * of the chosen `font`.\n     */\n    this.fontSize = 0.1;\n\n    /**\n     * @member {number} letterSpacing\n     * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n     * numbers increase spacing and negative numbers decrease it.\n     */\n    this.letterSpacing = 0;\n\n    /**\n     * @member {number|string} lineHeight\n     * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n     * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n     */\n    this.lineHeight = 'normal';\n\n    /**\n     * @member {number} maxWidth\n     * The maximum width of the text block, above which text may start wrapping according to the\n     * `whiteSpace` and `overflowWrap` properties.\n     */\n    this.maxWidth = Infinity;\n\n    /**\n     * @member {string} overflowWrap\n     * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n     * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n     * Defaults to `'normal'`.\n     */\n    this.overflowWrap = 'normal';\n\n    /**\n     * @member {string} textAlign\n     * The horizontal alignment of each line of text within the overall text bounding box.\n     */\n    this.textAlign = 'left';\n\n    /**\n     * @member {number} textIndent\n     * Indentation for the first character of a line; see CSS `text-indent`.\n     */\n    this.textIndent = 0;\n\n    /**\n     * @member {string} whiteSpace\n     * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n     * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n     * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n     * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n     */\n    this.whiteSpace = 'normal';\n\n\n    // === Presentation properties: === //\n\n    /**\n     * @member {THREE.Material} material\n     * Defines a _base_ material to be used when rendering the text. This material will be\n     * automatically replaced with a material derived from it, that adds shader code to\n     * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n     * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n     * of the other mesh materials to gain other features like lighting, texture maps, etc.\n     *\n     * Also see the `color` shortcut property.\n     */\n    this.material = null;\n\n    /**\n     * @member {string|number|THREE.Color} color\n     * This is a shortcut for setting the `color` of the text's material. You can use this\n     * if you don't want to specify a whole custom `material`. Also, if you do use a custom\n     * `material`, this color will only be used for this particuar Text instance, even if\n     * that same material instance is shared across multiple Text objects.\n     */\n    this.color = null;\n\n    /**\n     * @member {object|null} colorRanges\n     * WARNING: This API is experimental and may change.\n     * This allows more fine-grained control of colors for individual or ranges of characters,\n     * taking precedence over the material's `color`. Its format is an Object whose keys each\n     * define a starting character index for a range, and whose values are the color for each\n     * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n     * any of the strings accepted by `THREE.Color`.\n     */\n    this.colorRanges = null;\n\n    /**\n     * @member {number|string} outlineWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means\n     * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.\n     */\n    this.outlineWidth = 0;\n\n    /**\n     * @member {string|number|THREE.Color} outlineColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to black.\n     */\n    this.outlineColor = 0x000000;\n\n    /**\n     * @member {number} outlineOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to `1`.\n     */\n    this.outlineOpacity = 1;\n\n    /**\n     * @member {number|string} outlineBlur\n     * WARNING: This API is experimental and may change.\n     * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is\n     * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineBlur = 0;\n\n    /**\n     * @member {number|string} outlineOffsetX\n     * WARNING: This API is experimental and may change.\n     * A horizontal offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineOffsetX = 0;\n\n    /**\n     * @member {number|string} outlineOffsetY\n     * WARNING: This API is experimental and may change.\n     * A vertical offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineOffsetY = 0;\n\n    /**\n     * @member {number|string} strokeWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.strokeWidth = 0;\n\n    /**\n     * @member {string|number|THREE.Color} strokeColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.\n     */\n    this.strokeColor = defaultStrokeColor;\n\n    /**\n     * @member {number} strokeOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.\n     */\n    this.strokeOpacity = 1;\n\n    /**\n     * @member {number} fillOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows\n     * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the\n     * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.\n     */\n    this.fillOpacity = 1;\n\n    /**\n     * @member {number} depthOffset\n     * This is a shortcut for setting the material's `polygonOffset` and related properties,\n     * which can be useful in preventing z-fighting when this text is laid on top of another\n     * plane in the scene. Positive numbers are further from the camera, negatives closer.\n     */\n    this.depthOffset = 0;\n\n    /**\n     * @member {Array<number>} clipRect\n     * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n     * pixels will be discarded. This can be used for example to clip overflowing text when\n     * `whiteSpace='nowrap'`.\n     */\n    this.clipRect = null;\n\n    /**\n     * @member {string} orientation\n     * Defines the axis plane on which the text should be laid out when the mesh has no extra\n     * rotation transform. It is specified as a string with two axes: the horizontal axis with\n     * positive pointing right, and the vertical axis with positive pointing up. By default this\n     * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y\n     * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's\n     * top toward negative z and facing positive y.\n     */\n    this.orientation = defaultOrient;\n\n    /**\n     * @member {number} glyphGeometryDetail\n     * Controls number of vertical/horizontal segments that make up each glyph's rectangular\n     * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n     * vertex shader effects, for example.\n     */\n    this.glyphGeometryDetail = 1;\n\n    /**\n     * @member {number|null} sdfGlyphSize\n     * The size of each glyph's SDF (signed distance field) used for rendering. This must be a\n     * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n     * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n     * the sharpness of corners and preventing loss of very thin lines, at the expense of\n     * increased memory footprint and longer SDF generation time.\n     */\n    this.sdfGlyphSize = null;\n\n    /**\n     * @member {boolean} gpuAccelerateSDF\n     * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,\n     * making it much faster especially for complex glyphs, and falling back to a JavaScript version\n     * executed in web workers when support isn't available. It should automatically detect support,\n     * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS\n     * version if you encounter issues with it.\n     */\n    this.gpuAccelerateSDF = true;\n\n    this.debugSDF = false;\n  }\n\n  /**\n   * Updates the text rendering according to the current text-related configuration properties.\n   * This is an async process, so you can pass in a callback function to be executed when it\n   * finishes.\n   * @param {function} [callback]\n   */\n  sync(callback) {\n    if (this._needsSync) {\n      this._needsSync = false;\n\n      // If there's another sync still in progress, queue\n      if (this._isSyncing) {\n        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n      } else {\n        this._isSyncing = true;\n        this.dispatchEvent(syncStartEvent);\n\n        getTextRenderInfo({\n          text: this.text,\n          font: this.font,\n          fontSize: this.fontSize || 0.1,\n          letterSpacing: this.letterSpacing || 0,\n          lineHeight: this.lineHeight || 'normal',\n          maxWidth: this.maxWidth,\n          direction: this.direction || 'auto',\n          textAlign: this.textAlign,\n          textIndent: this.textIndent,\n          whiteSpace: this.whiteSpace,\n          overflowWrap: this.overflowWrap,\n          anchorX: this.anchorX,\n          anchorY: this.anchorY,\n          colorRanges: this.colorRanges,\n          includeCaretPositions: true, //TODO parameterize\n          sdfGlyphSize: this.sdfGlyphSize,\n          gpuAccelerateSDF: this.gpuAccelerateSDF,\n        }, textRenderInfo => {\n          this._isSyncing = false;\n\n          // Save result for later use in onBeforeRender\n          this._textRenderInfo = textRenderInfo;\n\n          // Update the geometry attributes\n          this.geometry.updateGlyphs(\n            textRenderInfo.glyphBounds,\n            textRenderInfo.glyphAtlasIndices,\n            textRenderInfo.blockBounds,\n            textRenderInfo.chunkedBounds,\n            textRenderInfo.glyphColors\n          );\n\n          // If we had extra sync requests queued up, kick it off\n          const queued = this._queuedSyncs;\n          if (queued) {\n            this._queuedSyncs = null;\n            this._needsSync = true;\n            this.sync(() => {\n              queued.forEach(fn => fn && fn());\n            });\n          }\n\n          this.dispatchEvent(syncCompleteEvent);\n          if (callback) {\n            callback();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Initiate a sync if needed - note it won't complete until next frame at the\n   * earliest so if possible it's a good idea to call sync() manually as soon as\n   * all the properties have been set.\n   * @override\n   */\n  onBeforeRender(renderer, scene, camera, geometry, material, group) {\n    this.sync();\n\n    // This may not always be a text material, e.g. if there's a scene.overrideMaterial present\n    if (material.isTroikaTextMaterial) {\n      this._prepareForRender(material);\n    }\n\n    // We need to force the material to FrontSide to avoid the double-draw-call performance hit\n    // introduced in Three.js r130: https://github.com/mrdoob/three.js/pull/21967 - The sidedness\n    // is instead applied via drawRange in the GlyphsGeometry.\n    material._hadOwnSide = material.hasOwnProperty('side');\n    this.geometry.setSide(material._actualSide = material.side);\n    material.side = three__WEBPACK_IMPORTED_MODULE_3__.FrontSide;\n  }\n\n  onAfterRender(renderer, scene, camera, geometry, material, group) {\n    // Restore original material side\n    if (material._hadOwnSide) {\n      material.side = material._actualSide;\n    } else {\n      delete material.side; // back to inheriting from base material\n    }\n  }\n\n  /**\n   * Shortcut to dispose the geometry specific to this instance.\n   * Note: we don't also dispose the derived material here because if anything else is\n   * sharing the same base material it will result in a pause next frame as the program\n   * is recompiled. Instead users can dispose the base material manually, like normal,\n   * and we'll also dispose the derived material at that time.\n   */\n  dispose() {\n    this.geometry.dispose();\n  }\n\n  /**\n   * @property {TroikaTextRenderInfo|null} textRenderInfo\n   * @readonly\n   * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n   * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n   * the asynchrous `sync()` process completes.\n   */\n  get textRenderInfo() {\n    return this._textRenderInfo || null\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    // If text outline is configured, render it as a preliminary draw using Three's multi-material\n    // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi\n    // materials ensures the layers are always rendered consecutively in a consistent order.\n    // Each layer will trigger onBeforeRender with the appropriate material.\n    if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {\n      let outlineMaterial = derivedMaterial._outlineMtl;\n      if (!outlineMaterial) {\n        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {\n          id: {value: derivedMaterial.id + 0.1}\n        });\n        outlineMaterial.isTextOutlineMaterial = true;\n        outlineMaterial.depthWrite = false;\n        outlineMaterial.map = null; //???\n        derivedMaterial.addEventListener('dispose', function onDispose() {\n          derivedMaterial.removeEventListener('dispose', onDispose);\n          outlineMaterial.dispose();\n        });\n      }\n      return [\n        outlineMaterial,\n        derivedMaterial\n      ]\n    } else {\n      return derivedMaterial\n    }\n  }\n  set material(baseMaterial) {\n    if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation\n      this._derivedMaterial = baseMaterial;\n      this._baseMaterial = baseMaterial.baseMaterial;\n    } else {\n      this._baseMaterial = baseMaterial;\n    }\n  }\n\n  get glyphGeometryDetail() {\n    return this.geometry.detail\n  }\n  set glyphGeometryDetail(detail) {\n    this.geometry.detail = detail;\n  }\n\n  get curveRadius() {\n    return this.geometry.curveRadius\n  }\n  set curveRadius(r) {\n    this.geometry.curveRadius = r;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return first(this.material).getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return first(this.material).getDistanceMaterial()\n  }\n\n  _prepareForRender(material) {\n    const isOutline = material.isTextOutlineMaterial;\n    const uniforms = material.uniforms;\n    const textInfo = this.textRenderInfo;\n    if (textInfo) {\n      const {sdfTexture, blockBounds} = textInfo;\n      uniforms.uTroikaSDFTexture.value = sdfTexture;\n      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;\n      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);\n      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;\n\n      let distanceOffset = 0;\n      let blurRadius = 0;\n      let strokeWidth = 0;\n      let fillOpacity;\n      let strokeOpacity;\n      let strokeColor;\n      let offsetX = 0;\n      let offsetY = 0;\n\n      if (isOutline) {\n        let {outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity} = this;\n        distanceOffset = this._parsePercent(outlineWidth) || 0;\n        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);\n        fillOpacity = outlineOpacity;\n        offsetX = this._parsePercent(outlineOffsetX) || 0;\n        offsetY = this._parsePercent(outlineOffsetY) || 0;\n      } else {\n        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);\n        if (strokeWidth) {\n          strokeColor = this.strokeColor;\n          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);\n          strokeOpacity = this.strokeOpacity;\n          if (strokeOpacity == null) strokeOpacity = 1;\n        }\n        fillOpacity = this.fillOpacity;\n      }\n\n      uniforms.uTroikaDistanceOffset.value = distanceOffset;\n      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);\n      uniforms.uTroikaBlurRadius.value = blurRadius;\n      uniforms.uTroikaStrokeWidth.value = strokeWidth;\n      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;\n      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;\n      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;\n\n      let clipRect = this.clipRect;\n      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {\n        uniforms.uTroikaClipRect.value.fromArray(clipRect);\n      } else {\n        // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines\n        const pad = (this.fontSize || 0.1) * 100;\n        uniforms.uTroikaClipRect.value.set(\n          blockBounds[0] - pad,\n          blockBounds[1] - pad,\n          blockBounds[2] + pad,\n          blockBounds[3] + pad\n        );\n      }\n      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n    }\n    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n    material.polygonOffset = !!this.depthOffset;\n    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n\n    // Shortcut for setting material color via `color` prop on the mesh; this is\n    // applied only to the derived material to avoid mutating a shared base material.\n    const color = isOutline ? (this.outlineColor || 0) : this.color;\n\n    if (color == null) {\n      delete material.color; //inherit from base\n    } else {\n      const colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new three__WEBPACK_IMPORTED_MODULE_3__.Color());\n      if (color !== colorObj._input || typeof color === 'object') {\n        colorObj.set(colorObj._input = color);\n      }\n    }\n\n    // base orientation\n    let orient = this.orientation || defaultOrient;\n    if (orient !== material._orientation) {\n      let rotMat = uniforms.uTroikaOrient.value;\n      orient = orient.replace(/[^-+xyz]/g, '');\n      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n      if (match) {\n        let [, hSign, hAxis, vSign, vAxis] = match;\n        tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;\n        tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;\n        tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n        rotMat.setFromMatrix4(tempMat4);\n      } else {\n        rotMat.identity();\n      }\n      material._orientation = orient;\n    }\n  }\n\n  _parsePercent(value) {\n    if (typeof value === 'string') {\n      let match = value.match(/^(-?[\\d.]+)%$/);\n      let pct = match ? parseFloat(match[1]) : NaN;\n      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;\n    }\n    return value\n  }\n\n  /**\n   * Translate a point in local space to an x/y in the text plane.\n   */\n  localPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n    target.copy(position); //simple non-curved case is 1:1\n    const r = this.curveRadius;\n    if (r) { //flatten the curve\n      target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);\n    }\n    return target\n  }\n\n  /**\n   * Translate a point in world space to an x/y in the text plane.\n   */\n  worldPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n    tempVec3a.copy(position);\n    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)\n  }\n\n  /**\n   * @override Custom raycasting to test against the whole text block's max rectangular bounds\n   * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n   */\n  raycast(raycaster, intersects) {\n    const {textRenderInfo, curveRadius} = this;\n    if (textRenderInfo) {\n      const bounds = textRenderInfo.blockBounds;\n      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();\n      const geom = raycastMesh.geometry;\n      const {position, uv} = geom.attributes;\n      for (let i = 0; i < uv.count; i++) {\n        let x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));\n        const y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));\n        let z = 0;\n        if (curveRadius) {\n          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;\n          x = Math.sin(x / curveRadius) * curveRadius;\n        }\n        position.setXYZ(i, x, y, z);\n      }\n      geom.boundingSphere = this.geometry.boundingSphere;\n      geom.boundingBox = this.geometry.boundingBox;\n      raycastMesh.matrixWorld = this.matrixWorld;\n      raycastMesh.material.side = this.material.side;\n      tempArray.length = 0;\n      raycastMesh.raycast(raycaster, tempArray);\n      for (let i = 0; i < tempArray.length; i++) {\n        tempArray[i].object = this;\n        intersects.push(tempArray[i]);\n      }\n    }\n  }\n\n  copy(source) {\n    // Prevent copying the geometry reference so we don't end up sharing attributes between instances\n    const geom = this.geometry;\n    super.copy(source);\n    this.geometry = geom;\n\n    COPYABLE_PROPS.forEach(prop => {\n      this[prop] = source[prop];\n    });\n    return this\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n}\n\n\n// Create setters for properties that affect text layout:\nSYNCABLE_PROPS.forEach(prop => {\n  const privateKey = '_private_' + prop;\n  Object.defineProperty(Text.prototype, prop, {\n    get() {\n      return this[privateKey]\n    },\n    set(value) {\n      if (value !== this[privateKey]) {\n        this[privateKey] = value;\n        this._needsSync = true;\n      }\n    }\n  });\n});\n\n//=== Utility functions for dealing with carets and selection ranges ===//\n\n/**\n * @typedef {object} TextCaret\n * @property {number} x - x position of the caret\n * @property {number} y - y position of the caret's bottom\n * @property {number} height - height of the caret\n * @property {number} charIndex - the index in the original input string of this caret's target\n *   character; the caret will be for the position _before_ that character.\n */\n\n/**\n * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n * @param {number} x\n * @param {number} y\n * @return {TextCaret | null}\n */\nfunction getCaretAtPoint(textRenderInfo, x, y) {\n  let closestCaret = null;\n  const {caretHeight} = textRenderInfo;\n  const caretsByRow = groupCaretsByRow(textRenderInfo);\n\n  // Find nearest row by y first\n  let closestRowY = Infinity;\n  caretsByRow.forEach((carets, rowY) => {\n    if (Math.abs(y - (rowY + caretHeight / 2)) < Math.abs(y - (closestRowY + caretHeight / 2))) {\n      closestRowY = rowY;\n    }\n  });\n\n  // Then find closest caret by x within that row\n  caretsByRow.get(closestRowY).forEach(caret => {\n    if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n      closestCaret = caret;\n    }\n  });\n  return closestCaret\n}\n\n\nconst _rectsCache = new WeakMap();\n\n/**\n * Given start and end character indexes, return a list of rectangles covering all the\n * characters within that selection.\n * @param {TroikaTextRenderInfo} textRenderInfo\n * @param {number} start - index of the first char in the selection\n * @param {number} end - index of the first char after the selection\n * @return {Array<{left, top, right, bottom}> | null}\n */\nfunction getSelectionRects(textRenderInfo, start, end) {\n  let rects;\n  if (textRenderInfo) {\n    // Check cache - textRenderInfo is frozen so it's safe to cache based on it\n    let prevResult = _rectsCache.get(textRenderInfo);\n    if (prevResult && prevResult.start === start && prevResult.end === end) {\n      return prevResult.rects\n    }\n\n    const {caretPositions, caretHeight} = textRenderInfo;\n\n    // Normalize\n    if (end < start) {\n      const s = start;\n      start = end;\n      end = s;\n    }\n    start = Math.max(start, 0);\n    end = Math.min(end, caretPositions.length + 1);\n\n    // Build list of rects, expanding the current rect for all characters in a run and starting\n    // a new rect whenever reaching a new line or a new bidi direction\n    rects = [];\n    let currentRect = null;\n    for (let i = start; i < end; i++) {\n      const x1 = caretPositions[i * 3];\n      const x2 = caretPositions[i * 3 + 1];\n      const left = Math.min(x1, x2);\n      const right = Math.max(x1, x2);\n      const bottom = caretPositions[i * 3 + 2];\n      if (!currentRect || bottom !== currentRect.bottom || left > currentRect.right || right < currentRect.left) {\n        currentRect = {\n          left: Infinity,\n          right: -Infinity,\n          bottom: bottom,\n          top: bottom + caretHeight\n        };\n        rects.push(currentRect);\n      }\n      currentRect.left = Math.min(left, currentRect.left);\n      currentRect.right = Math.max(right, currentRect.right);\n    }\n\n    // Merge any overlapping rects, e.g. those formed by adjacent bidi runs\n    rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);\n    for (let i = rects.length - 1; i-- > 0;) {\n      const rectA = rects[i];\n      const rectB = rects[i + 1];\n      if (rectA.bottom === rectB.bottom && rectA.left <= rectB.right && rectA.right >= rectB.left) {\n        rectB.left = Math.min(rectB.left, rectA.left);\n        rectB.right = Math.max(rectB.right, rectA.right);\n        rects.splice(i, 1);\n      }\n    }\n\n    _rectsCache.set(textRenderInfo, {start, end, rects});\n  }\n  return rects\n}\n\nconst _caretsByRowCache = new WeakMap();\n\nfunction groupCaretsByRow(textRenderInfo) {\n  // textRenderInfo is frozen so it's safe to cache based on it\n  let caretsByRow = _caretsByRowCache.get(textRenderInfo);\n  if (!caretsByRow) {\n    const {caretPositions, caretHeight} = textRenderInfo;\n    caretsByRow = new Map();\n    for (let i = 0; i < caretPositions.length; i += 3) {\n      const rowY = caretPositions[i + 2];\n      let rowCarets = caretsByRow.get(rowY);\n      if (!rowCarets) {\n        caretsByRow.set(rowY, rowCarets = []);\n      }\n      rowCarets.push({\n        x: caretPositions[i],\n        y: rowY,\n        height: caretHeight,\n        charIndex: i / 3\n      });\n      // Add one more caret after the final char\n      if (i + 3 >= caretPositions.length) {\n        rowCarets.push({\n          x: caretPositions[i + 1],\n          y: rowY,\n          height: caretHeight,\n          charIndex: i / 3 + 1\n        });\n      }\n    }\n  }\n  _caretsByRowCache.set(textRenderInfo, caretsByRow);\n  return caretsByRow\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdGV4dC9kaXN0L3Ryb2lrYS10aHJlZS10ZXh0LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFvUjtBQUMxTTtBQUNyQjtBQUNuQjtBQUN5Qzs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyx1QkFBdUI7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxJQUFJLEVBQUUsaUNBQWlDLGlCQUFpQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssR0FBRyxrQkFBa0I7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFD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Z0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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Q1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUySyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC5lc20uanM/MjQ1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0dXJlLCBMaW5lYXJGaWx0ZXIsIENvbG9yLCBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSwgU3BoZXJlLCBCb3gzLCBCYWNrU2lkZSwgRG91YmxlU2lkZSwgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLCBQbGFuZUdlb21ldHJ5LCBCdWZmZXJHZW9tZXRyeSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgVmVjdG9yMiwgVmVjdG9yNCwgTWF0cml4MywgTWVzaCwgRnJvbnRTaWRlLCBNZXNoQmFzaWNNYXRlcmlhbCwgTWF0cml4NCwgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHRlcm1pbmF0ZVdvcmtlciwgZGVmaW5lV29ya2VyTW9kdWxlIH0gZnJvbSAndHJvaWthLXdvcmtlci11dGlscyc7XG5pbXBvcnQgY3JlYXRlU0RGR2VuZXJhdG9yIGZyb20gJ3dlYmdsLXNkZi1nZW5lcmF0b3InO1xuaW1wb3J0IGJpZGlGYWN0b3J5IGZyb20gJ2JpZGktanMnO1xuaW1wb3J0IHsgY3JlYXRlRGVyaXZlZE1hdGVyaWFsLCB2b2lkTWFpblJlZ0V4cCB9IGZyb20gJ3Ryb2lrYS10aHJlZS11dGlscyc7XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzZWxmLWNvbnRhaW5lZCBlbnZpcm9ubWVudCBmb3IgcHJvY2Vzc2luZyB0ZXh0IHR5cGVzZXR0aW5nIHJlcXVlc3RzLlxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0aGF0IHRoaXMgZnVuY3Rpb24gaGFzIG5vIGNsb3N1cmUgZGVwZW5kZW5jaWVzLCBzbyB0aGF0IGl0IGNhbiBiZSBlYXNpbHkgaW5qZWN0ZWRcbiAqIGludG8gdGhlIHNvdXJjZSBmb3IgYSBXb3JrZXIgd2l0aG91dCByZXF1aXJpbmcgYSBidWlsZCBzdGVwIG9yIGNvbXBsZXggZGVwZW5kZW5jeSBsb2FkaW5nLiBBbGwgaXRzXG4gKiBkZXBlbmRlbmNpZXMgbXVzdCBiZSBwYXNzZWQgaW4gYXQgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm9udFBhcnNlciAtIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFuIEFycmF5QnVmZmVyIG9mIHRoZSBmb250IGRhdGEgYW5kIHJldHVybnNcbiAqIGEgc3RhbmRhcmRpemVkIHN0cnVjdHVyZSBnaXZpbmcgYWNjZXNzIHRvIHRoZSBmb250IGFuZCBpdHMgZ2x5cGhzOlxuICogICB7XG4gKiAgICAgdW5pdHNQZXJFbTogbnVtYmVyLFxuICogICAgIGFzY2VuZGVyOiBudW1iZXIsXG4gKiAgICAgZGVzY2VuZGVyOiBudW1iZXIsXG4gKiAgICAgY2FwSGVpZ2h0OiBudW1iZXIsXG4gKiAgICAgeEhlaWdodDogbnVtYmVyLFxuICogICAgIGxpbmVHYXA6IG51bWJlcixcbiAqICAgICBmb3JFYWNoR2x5cGgoc3RyaW5nLCBmb250U2l6ZSwgbGV0dGVyU3BhY2luZywgY2FsbGJhY2spIHtcbiAqICAgICAgIC8vaW52b2tlcyBjYWxsYmFjayBmb3IgZWFjaCBnbHlwaCB0byByZW5kZXIsIHBhc3NpbmcgaXQgYW4gb2JqZWN0OlxuICogICAgICAgY2FsbGJhY2soe1xuICogICAgICAgICBpbmRleDogbnVtYmVyLFxuICogICAgICAgICBhZHZhbmNlV2lkdGg6IG51bWJlcixcbiAqICAgICAgICAgeE1pbjogbnVtYmVyLFxuICogICAgICAgICB5TWluOiBudW1iZXIsXG4gKiAgICAgICAgIHhNYXg6IG51bWJlcixcbiAqICAgICAgICAgeU1heDogbnVtYmVyLFxuICogICAgICAgICBwYXRoOiBzdHJpbmcsXG4gKiAgICAgICAgIHBhdGhDb21tYW5kQ291bnQ6IG51bWJlclxuICogICAgICAgfSlcbiAqICAgICB9XG4gKiAgIH1cbiAqIEBwYXJhbSB7b2JqZWN0fSBiaWRpIC0gdGhlIGJpZGkuanMgaW1wbGVtZW50YXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVzZXR0ZXIoZm9udFBhcnNlciwgYmlkaSwgY29uZmlnKSB7XG5cbiAgY29uc3Qge1xuICAgIGRlZmF1bHRGb250VVJMXG4gIH0gPSBjb25maWc7XG5cbiAgLyoqXG4gICAqIEhvbGRzIHBhcnNlZCBmb250IG9iamVjdHMgYnkgdXJsXG4gICAqL1xuICBjb25zdCBmb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgY29uc3QgSU5GID0gSW5maW5pdHk7XG5cbiAgLy8gU2V0IG9mIFVuaWNvZGUgRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBjaGFyYWN0ZXJzLCB0aGVzZSB3aWxsIG5vdCBwcm9kdWNlIHZpc2libGUgZ2x5cGhzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzc1xuICBjb25zdCBERUZBVUxUX0lHTk9SQUJMRV9DSEFSUyA9IC9bXFx1MDBBRFxcdTAzNEZcXHUwNjFDXFx1MTE1Ri1cXHUxMTYwXFx1MTdCNC1cXHUxN0I1XFx1MTgwQi1cXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDZGXFx1MzE2NFxcdUZFMDAtXFx1RkUwRlxcdUZFRkZcXHVGRkEwXFx1RkZGMC1cXHVGRkY4XS87XG5cbiAgLy8gVGhpcyByZWdleCAoaW5zdGVhZCBvZiAvXFxzLykgYWxsb3dzIHVzIHRvIHNlbGVjdCBhbGwgd2hpdGVzcGFjZSBFWENFUFQgZm9yIG5vbi1icmVha2luZyB3aGl0ZSBzcGFjZXNcbiAgY29uc3QgbGluZUJyZWFraW5nV2hpdGVTcGFjZSA9IGBbXlxcXFxTXFxcXHUwMEEwXWA7XG5cbiAgLy8gSW5jb21wbGV0ZSBzZXQgb2YgY2hhcmFjdGVycyB0aGF0IGFsbG93IGxpbmUgYnJlYWtpbmcgYWZ0ZXIgdGhlbVxuICAvLyBJbiB0aGUgZnV0dXJlIHdlIG1heSBjb25zaWRlciBhIGZ1bGwgVW5pY29kZSBsaW5lIGJyZWFraW5nIGFsZ29yaXRobSBpbXBsOiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMTRcbiAgY29uc3QgQlJFQUtfQUZURVJfQ0hBUlMgPSBuZXcgUmVnRXhwKGAke2xpbmVCcmVha2luZ1doaXRlU3BhY2V9fFtcXFxcLVxcXFx1MDA3Q1xcXFx1MDBBRFxcXFx1MjAxMFxcXFx1MjAxMi1cXFxcdTIwMTRcXFxcdTIwMjdcXFxcdTIwNTZcXFxcdTJFMTdcXFxcdTJFNDBdYCk7XG5cbiAgLyoqXG4gICAqIExvYWQgYSBnaXZlbiBmb250IHVybFxuICAgKi9cbiAgZnVuY3Rpb24gZG9Mb2FkRm9udCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gdHJ5TG9hZCgpIHtcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsdXJlIGxvYWRpbmcgZm9udCAke3VybH0ke3VybCA9PT0gZGVmYXVsdEZvbnRVUkwgPyAnJyA6ICc7IHRyeWluZyBmYWxsYmFjayd9YCwgZXJyKTtcbiAgICAgICAgaWYgKHVybCAhPT0gZGVmYXVsdEZvbnRVUkwpIHtcbiAgICAgICAgICB1cmwgPSBkZWZhdWx0Rm9udFVSTDtcbiAgICAgICAgICB0cnlMb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3Qub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBmb250T2JqID0gZm9udFBhcnNlcihyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZm9udE9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBvbkVycm9yO1xuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5TG9hZCgpO1xuICB9XG5cblxuICAvKipcbiAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsIGlmIG5lZWRlZCwgaW52b2tpbmcgYSBjYWxsYmFjayB3aGVuIGl0J3MgbG9hZGVkLiBJZiBhbHJlYWR5XG4gICAqIGxvYWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gICAqL1xuICBmdW5jdGlvbiBsb2FkRm9udChmb250VXJsLCBjYWxsYmFjaykge1xuICAgIGlmICghZm9udFVybCkgZm9udFVybCA9IGRlZmF1bHRGb250VVJMO1xuICAgIGxldCBmb250ID0gZm9udHNbZm9udFVybF07XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIC8vIGlmIGN1cnJlbnRseSBsb2FkaW5nIGZvbnQsIGFkZCB0byBjYWxsYmFja3MsIG90aGVyd2lzZSBleGVjdXRlIGltbWVkaWF0ZWx5XG4gICAgICBpZiAoZm9udC5wZW5kaW5nKSB7XG4gICAgICAgIGZvbnQucGVuZGluZy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGZvbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb250c1tmb250VXJsXSA9IHtwZW5kaW5nOiBbY2FsbGJhY2tdfTtcbiAgICAgIGRvTG9hZEZvbnQoZm9udFVybCwgZm9udE9iaiA9PiB7XG4gICAgICAgIGxldCBjYWxsYmFja3MgPSBmb250c1tmb250VXJsXS5wZW5kaW5nO1xuICAgICAgICBmb250c1tmb250VXJsXSA9IGZvbnRPYmo7XG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IGNiKGZvbnRPYmopKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIE1haW4gZW50cnkgcG9pbnQuXG4gICAqIFByb2Nlc3MgYSB0ZXh0IHN0cmluZyB3aXRoIGdpdmVuIGZvbnQgYW5kIGZvcm1hdHRpbmcgcGFyYW1ldGVycywgYW5kIHJldHVybiBhbGwgaW5mb1xuICAgKiBuZWNlc3NhcnkgdG8gcmVuZGVyIGFsbCBpdHMgZ2x5cGhzLlxuICAgKi9cbiAgZnVuY3Rpb24gdHlwZXNldChcbiAgICB7XG4gICAgICB0ZXh0PScnLFxuICAgICAgZm9udD1kZWZhdWx0Rm9udFVSTCxcbiAgICAgIHNkZkdseXBoU2l6ZT02NCxcbiAgICAgIGZvbnRTaXplPTEsXG4gICAgICBsZXR0ZXJTcGFjaW5nPTAsXG4gICAgICBsaW5lSGVpZ2h0PSdub3JtYWwnLFxuICAgICAgbWF4V2lkdGg9SU5GLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGV4dEFsaWduPSdsZWZ0JyxcbiAgICAgIHRleHRJbmRlbnQ9MCxcbiAgICAgIHdoaXRlU3BhY2U9J25vcm1hbCcsXG4gICAgICBvdmVyZmxvd1dyYXA9J25vcm1hbCcsXG4gICAgICBhbmNob3JYID0gMCxcbiAgICAgIGFuY2hvclkgPSAwLFxuICAgICAgaW5jbHVkZUNhcmV0UG9zaXRpb25zPWZhbHNlLFxuICAgICAgY2h1bmtlZEJvdW5kc1NpemU9ODE5MixcbiAgICAgIGNvbG9yUmFuZ2VzPW51bGxcbiAgICB9LFxuICAgIGNhbGxiYWNrLFxuICAgIG1ldHJpY3NPbmx5PWZhbHNlXG4gICkge1xuICAgIGNvbnN0IG1haW5TdGFydCA9IG5vdygpO1xuICAgIGNvbnN0IHRpbWluZ3MgPSB7Zm9udExvYWQ6IDAsIHR5cGVzZXR0aW5nOiAwfTtcblxuICAgIC8vIEVuc3VyZSBuZXdsaW5lcyBhcmUgbm9ybWFsaXplZFxuICAgIGlmICh0ZXh0LmluZGV4T2YoJ1xccicpID4gLTEpIHtcbiAgICAgIGNvbnNvbGUuaW5mbygnVHlwZXNldHRlcjogZ290IHRleHQgd2l0aCBcXFxcciBjaGFyczsgbm9ybWFsaXppbmcgdG8gXFxcXG4nKTtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgd2UndmUgZ290IG51bWJlcnMgbm90IHN0cmluZ3NcbiAgICBmb250U2l6ZSA9ICtmb250U2l6ZTtcbiAgICBsZXR0ZXJTcGFjaW5nID0gK2xldHRlclNwYWNpbmc7XG4gICAgbWF4V2lkdGggPSArbWF4V2lkdGg7XG4gICAgbGluZUhlaWdodCA9IGxpbmVIZWlnaHQgfHwgJ25vcm1hbCc7XG4gICAgdGV4dEluZGVudCA9ICt0ZXh0SW5kZW50O1xuXG4gICAgbG9hZEZvbnQoZm9udCwgZm9udE9iaiA9PiB7XG4gICAgICBjb25zdCBoYXNNYXhXaWR0aCA9IGlzRmluaXRlKG1heFdpZHRoKTtcbiAgICAgIGxldCBnbHlwaElkcyA9IG51bGw7XG4gICAgICBsZXQgZ2x5cGhQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgbGV0IGdseXBoRGF0YSA9IG51bGw7XG4gICAgICBsZXQgZ2x5cGhDb2xvcnMgPSBudWxsO1xuICAgICAgbGV0IGNhcmV0UG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGxldCB2aXNpYmxlQm91bmRzID0gbnVsbDtcbiAgICAgIGxldCBjaHVua2VkQm91bmRzID0gbnVsbDtcbiAgICAgIGxldCBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgbGV0IHJlbmRlcmFibGVHbHlwaENvdW50ID0gMDtcbiAgICAgIGxldCBjYW5XcmFwID0gd2hpdGVTcGFjZSAhPT0gJ25vd3JhcCc7XG4gICAgICBjb25zdCB7YXNjZW5kZXIsIGRlc2NlbmRlciwgdW5pdHNQZXJFbSwgbGluZUdhcCwgY2FwSGVpZ2h0LCB4SGVpZ2h0fSA9IGZvbnRPYmo7XG4gICAgICB0aW1pbmdzLmZvbnRMb2FkID0gbm93KCkgLSBtYWluU3RhcnQ7XG4gICAgICBjb25zdCB0eXBlc2V0U3RhcnQgPSBub3coKTtcblxuICAgICAgLy8gRmluZCBjb252ZXJzaW9uIGJldHdlZW4gbmF0aXZlIGZvbnQgdW5pdHMgYW5kIGZvbnRTaXplIHVuaXRzOyB0aGlzIHdpbGwgYWxyZWFkeSBiZSBkb25lXG4gICAgICAvLyBmb3IgdGhlIGd4L2d5IHZhbHVlcyBiZWxvdyBidXQgZXZlcnl0aGluZyBlbHNlIHdlJ2xsIG5lZWQgdG8gY29udmVydFxuICAgICAgY29uc3QgZm9udFNpemVNdWx0ID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgYXBwcm9wcmlhdGUgdmFsdWUgZm9yICdub3JtYWwnIGxpbmUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBmb250J3MgYWN0dWFsIG1ldHJpY3NcbiAgICAgIC8vIFRPRE8gdGhpcyBkb2VzIG5vdCBndWFyYW50ZWUgaW5kaXZpZHVhbCBnbHlwaHMgd29uJ3QgZXhjZWVkIHRoZSBsaW5lIGhlaWdodCwgZS5nLiBSb2JvdG87IHNob3VsZCB3ZSB1c2UgeU1pbi9NYXggaW5zdGVhZD9cbiAgICAgIGlmIChsaW5lSGVpZ2h0ID09PSAnbm9ybWFsJykge1xuICAgICAgICBsaW5lSGVpZ2h0ID0gKGFzY2VuZGVyIC0gZGVzY2VuZGVyICsgbGluZUdhcCkgLyB1bml0c1BlckVtO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgbGluZSBoZWlnaHQgYW5kIGxlYWRpbmcgYWRqdXN0bWVudHNcbiAgICAgIGxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ICogZm9udFNpemU7XG4gICAgICBjb25zdCBoYWxmTGVhZGluZyA9IChsaW5lSGVpZ2h0IC0gKGFzY2VuZGVyIC0gZGVzY2VuZGVyKSAqIGZvbnRTaXplTXVsdCkgLyAyO1xuICAgICAgY29uc3QgdG9wQmFzZWxpbmUgPSAtKGFzY2VuZGVyICogZm9udFNpemVNdWx0ICsgaGFsZkxlYWRpbmcpO1xuICAgICAgY29uc3QgY2FyZXRIZWlnaHQgPSBNYXRoLm1pbihsaW5lSGVpZ2h0LCAoYXNjZW5kZXIgLSBkZXNjZW5kZXIpICogZm9udFNpemVNdWx0KTtcbiAgICAgIGNvbnN0IGNhcmV0Qm90dG9tT2Zmc2V0ID0gKGFzY2VuZGVyICsgZGVzY2VuZGVyKSAvIDIgKiBmb250U2l6ZU11bHQgLSBjYXJldEhlaWdodCAvIDI7XG5cbiAgICAgIC8vIERpc3RyaWJ1dGUgZ2x5cGhzIGludG8gbGluZXMgYmFzZWQgb24gd3JhcHBpbmdcbiAgICAgIGxldCBsaW5lWE9mZnNldCA9IHRleHRJbmRlbnQ7XG4gICAgICBsZXQgY3VycmVudExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gW2N1cnJlbnRMaW5lXTtcblxuICAgICAgZm9udE9iai5mb3JFYWNoR2x5cGgodGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIChnbHlwaE9iaiwgZ2x5cGhYLCBjaGFySW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgY2hhciA9IHRleHQuY2hhckF0KGNoYXJJbmRleCk7XG4gICAgICAgIGNvbnN0IGdseXBoV2lkdGggPSBnbHlwaE9iai5hZHZhbmNlV2lkdGggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgIGNvbnN0IGN1ckxpbmVDb3VudCA9IGN1cnJlbnRMaW5lLmNvdW50O1xuICAgICAgICBsZXQgbmV4dExpbmU7XG5cbiAgICAgICAgLy8gQ2FsYyBpc1doaXRlc3BhY2UgYW5kIGlzRW1wdHkgb25jZSBwZXIgZ2x5cGhPYmpcbiAgICAgICAgaWYgKCEoJ2lzRW1wdHknIGluIGdseXBoT2JqKSkge1xuICAgICAgICAgIGdseXBoT2JqLmlzV2hpdGVzcGFjZSA9ICEhY2hhciAmJiBuZXcgUmVnRXhwKGxpbmVCcmVha2luZ1doaXRlU3BhY2UpLnRlc3QoY2hhcik7XG4gICAgICAgICAgZ2x5cGhPYmouY2FuQnJlYWtBZnRlciA9ICEhY2hhciAmJiBCUkVBS19BRlRFUl9DSEFSUy50ZXN0KGNoYXIpO1xuICAgICAgICAgIGdseXBoT2JqLmlzRW1wdHkgPSBnbHlwaE9iai54TWluID09PSBnbHlwaE9iai54TWF4IHx8IGdseXBoT2JqLnlNaW4gPT09IGdseXBoT2JqLnlNYXggfHwgREVGQVVMVF9JR05PUkFCTEVfQ0hBUlMudGVzdChjaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiAhZ2x5cGhPYmouaXNFbXB0eSkge1xuICAgICAgICAgIHJlbmRlcmFibGVHbHlwaENvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBvdmVyZmxvd3MgdGhlIG1heCB3aWR0aCwgd2UgbmVlZCB0byBzb2Z0LXdyYXBcbiAgICAgICAgaWYgKGNhbldyYXAgJiYgaGFzTWF4V2lkdGggJiYgIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiBnbHlwaFggKyBnbHlwaFdpZHRoICsgbGluZVhPZmZzZXQgPiBtYXhXaWR0aCAmJiBjdXJMaW5lQ291bnQpIHtcbiAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBmaXJzdCBjaGFyIGFmdGVyIGEgd2hpdGVzcGFjZSwgc3RhcnQgYSBuZXcgbGluZVxuICAgICAgICAgIGlmIChjdXJyZW50TGluZS5nbHlwaEF0KGN1ckxpbmVDb3VudCAtIDEpLmdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgIG5leHRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICBsaW5lWE9mZnNldCA9IC1nbHlwaFg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEJhY2sgdXAgbG9va2luZyBmb3IgYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciB0byB3cmFwIGF0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY3VyTGluZUNvdW50OyBpLS07KSB7XG4gICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdGhlcmUncyBubyBzb2Z0IGJyZWFrIHBvaW50OyBtYWtlIGhhcmQgYnJlYWsgaWYgb3ZlcmZsb3dXcmFwPSdicmVhay13b3JkJ1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBvdmVyZmxvd1dyYXAgPT09ICdicmVhay13b3JkJykge1xuICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtZ2x5cGhYO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRm91bmQgYSBzb2Z0IGJyZWFrIHBvaW50OyBtb3ZlIGFsbCBjaGFycyBzaW5jZSBpdCB0byBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRMaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouY2FuQnJlYWtBZnRlcikge1xuICAgICAgICAgICAgICAgIG5leHRMaW5lID0gY3VycmVudExpbmUuc3BsaXRBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0WCA9IG5leHRMaW5lLmdseXBoQXQoMCkueDtcbiAgICAgICAgICAgICAgICBsaW5lWE9mZnNldCAtPSBhZGp1c3RYO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBuZXh0TGluZS5jb3VudDsgai0tOykge1xuICAgICAgICAgICAgICAgICAgbmV4dExpbmUuZ2x5cGhBdChqKS54IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHRMaW5lKSB7XG4gICAgICAgICAgICBjdXJyZW50TGluZS5pc1NvZnRXcmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gbmV4dExpbmU7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IG1heFdpZHRoOyAvL2FmdGVyIHNvZnQgd3JhcHBpbmcgdXNlIG1heFdpZHRoIGFzIGNhbGN1bGF0ZWQgd2lkdGhcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmx5ID0gY3VycmVudExpbmUuZ2x5cGhBdChjdXJyZW50TGluZS5jb3VudCk7XG4gICAgICAgIGZseS5nbHlwaE9iaiA9IGdseXBoT2JqO1xuICAgICAgICBmbHkueCA9IGdseXBoWCArIGxpbmVYT2Zmc2V0O1xuICAgICAgICBmbHkud2lkdGggPSBnbHlwaFdpZHRoO1xuICAgICAgICBmbHkuY2hhckluZGV4ID0gY2hhckluZGV4O1xuXG4gICAgICAgIC8vIEhhbmRsZSBoYXJkIGxpbmUgYnJlYWtzXG4gICAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICAgIGN1cnJlbnRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICAgICAgbGluZVhPZmZzZXQgPSAtKGdseXBoWCArIGdseXBoV2lkdGggKyAobGV0dGVyU3BhY2luZyAqIGZvbnRTaXplKSkgKyB0ZXh0SW5kZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHdpZHRoIG9mIGVhY2ggbGluZSAoZXhjbHVkaW5nIHRyYWlsaW5nIHdoaXRlc3BhY2UpIGFuZCBtYXhpbXVtIGJsb2NrIHdpZHRoXG4gICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gbGluZS5jb3VudDsgaS0tOykge1xuICAgICAgICAgIGxldCB7Z2x5cGhPYmosIHgsIHdpZHRofSA9IGxpbmUuZ2x5cGhBdChpKTtcbiAgICAgICAgICBpZiAoIWdseXBoT2JqLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgbGluZS53aWR0aCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgIGlmIChsaW5lLndpZHRoID4gbWF4TGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBGaW5kIG92ZXJhbGwgcG9zaXRpb24gYWRqdXN0bWVudHMgZm9yIGFuY2hvcmluZ1xuICAgICAgbGV0IGFuY2hvclhPZmZzZXQgPSAwO1xuICAgICAgbGV0IGFuY2hvcllPZmZzZXQgPSAwO1xuICAgICAgaWYgKGFuY2hvclgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhbmNob3JYID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGFuY2hvclhPZmZzZXQgPSAtYW5jaG9yWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYW5jaG9yWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBhbmNob3JYT2Zmc2V0ID0gLW1heExpbmVXaWR0aCAqIChcbiAgICAgICAgICAgIGFuY2hvclggPT09ICdsZWZ0JyA/IDAgOlxuICAgICAgICAgICAgYW5jaG9yWCA9PT0gJ2NlbnRlcicgPyAwLjUgOlxuICAgICAgICAgICAgYW5jaG9yWCA9PT0gJ3JpZ2h0JyA/IDEgOlxuICAgICAgICAgICAgcGFyc2VQZXJjZW50KGFuY2hvclgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFuY2hvclkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhbmNob3JZID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGFuY2hvcllPZmZzZXQgPSAtYW5jaG9yWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYW5jaG9yWSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBsZXQgaGVpZ2h0ID0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodDtcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0ID0gYW5jaG9yWSA9PT0gJ3RvcCcgPyAwIDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICd0b3AtYmFzZWxpbmUnID8gLXRvcEJhc2VsaW5lIDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICd0b3AtY2FwJyA/IC10b3BCYXNlbGluZSAtIGNhcEhlaWdodCAqIGZvbnRTaXplTXVsdCA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWV4JyA/IC10b3BCYXNlbGluZSAtIHhIZWlnaHQgKiBmb250U2l6ZU11bHQgOlxuICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ21pZGRsZScgPyBoZWlnaHQgLyAyIDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdib3R0b20nID8gaGVpZ2h0IDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdib3R0b20tYmFzZWxpbmUnID8gaGVpZ2h0IC0gaGFsZkxlYWRpbmcgKyBkZXNjZW5kZXIgKiBmb250U2l6ZU11bHQgOlxuICAgICAgICAgICAgcGFyc2VQZXJjZW50KGFuY2hvclkpICogaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0cmljc09ubHkpIHtcbiAgICAgICAgLy8gUmVzb2x2ZSBiaWRpIGxldmVsc1xuICAgICAgICBjb25zdCBiaWRpTGV2ZWxzUmVzdWx0ID0gYmlkaS5nZXRFbWJlZGRpbmdMZXZlbHModGV4dCwgZGlyZWN0aW9uKTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggbGluZSwgYXBwbHlpbmcgYWxpZ25tZW50IG9mZnNldHMsIGFkZGluZyBlYWNoIGdseXBoIHRvIHRoZSBhdGxhcywgYW5kXG4gICAgICAgIC8vIGNvbGxlY3RpbmcgYWxsIHJlbmRlcmFibGUgZ2x5cGhzIGludG8gYSBzaW5nbGUgY29sbGVjdGlvbi5cbiAgICAgICAgZ2x5cGhJZHMgPSBuZXcgVWludDE2QXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQpO1xuICAgICAgICBnbHlwaFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQgKiAyKTtcbiAgICAgICAgZ2x5cGhEYXRhID0ge307XG4gICAgICAgIHZpc2libGVCb3VuZHMgPSBbSU5GLCBJTkYsIC1JTkYsIC1JTkZdO1xuICAgICAgICBjaHVua2VkQm91bmRzID0gW107XG4gICAgICAgIGxldCBsaW5lWU9mZnNldCA9IHRvcEJhc2VsaW5lO1xuICAgICAgICBpZiAoaW5jbHVkZUNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgY2FyZXRQb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHRleHQubGVuZ3RoICogMyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgZ2x5cGhDb2xvcnMgPSBuZXcgVWludDhBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCAqIDMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZW5kZXJhYmxlR2x5cGhJbmRleCA9IDA7XG4gICAgICAgIGxldCBwcmV2Q2hhckluZGV4ID0gLTE7XG4gICAgICAgIGxldCBjb2xvckNoYXJJbmRleCA9IC0xO1xuICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgIGxldCBjdXJyZW50Q29sb3I7XG4gICAgICAgIGxpbmVzLmZvckVhY2goKGxpbmUsIGxpbmVJbmRleCkgPT4ge1xuICAgICAgICAgIGxldCB7Y291bnQ6bGluZUdseXBoQ291bnQsIHdpZHRoOmxpbmVXaWR0aH0gPSBsaW5lO1xuXG4gICAgICAgICAgLy8gSWdub3JlIGVtcHR5IGxpbmVzXG4gICAgICAgICAgaWYgKGxpbmVHbHlwaENvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gQ291bnQgdHJhaWxpbmcgd2hpdGVzcGFjZXMsIHdlIHdhbnQgdG8gaWdub3JlIHRoZXNlIGZvciBjZXJ0YWluIHRoaW5nc1xuICAgICAgICAgICAgbGV0IHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsaW5lR2x5cGhDb3VudDsgaS0tICYmIGxpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5pc1doaXRlc3BhY2U7KSB7XG4gICAgICAgICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGhvcml6b250YWwgYWxpZ25tZW50IGFkanVzdG1lbnRzXG4gICAgICAgICAgICBsZXQgbGluZVhPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGp1c3RpZnlBZGp1c3QgPSAwO1xuICAgICAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeScgJiYgbGluZS5pc1NvZnRXcmFwcGVkKSB7XG4gICAgICAgICAgICAgIC8vIGNvdW50IG5vbi10cmFpbGluZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMsIGFuZCB3ZSdsbCBhZGp1c3QgdGhlIG9mZnNldHMgcGVyIGNoYXJhY3RlciBpbiB0aGUgbmV4dCBsb29wXG4gICAgICAgICAgICAgIGxldCB3aGl0ZXNwYWNlQ291bnQgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudDsgaS0tOykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAganVzdGlmeUFkanVzdCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGgpIC8gd2hpdGVzcGFjZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGp1c3RpZnlBZGp1c3QgfHwgbGluZVhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgbGV0IGp1c3RpZnlPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoT2JqID0gZ2x5cGhJbmZvLmdseXBoT2JqO1xuICAgICAgICAgICAgICAgIGdseXBoSW5mby54ICs9IGxpbmVYT2Zmc2V0ICsganVzdGlmeU9mZnNldDtcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgbm9uLXRyYWlsaW5nIHdoaXRlc3BhY2VzIGZvciBqdXN0aWZ5IGFsaWdubWVudFxuICAgICAgICAgICAgICAgIGlmIChqdXN0aWZ5QWRqdXN0ICE9PSAwICYmIGdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiBpIDwgbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAganVzdGlmeU9mZnNldCArPSBqdXN0aWZ5QWRqdXN0O1xuICAgICAgICAgICAgICAgICAgZ2x5cGhJbmZvLndpZHRoICs9IGp1c3RpZnlBZGp1c3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBlcmZvcm0gYmlkaSByYW5nZSBmbGlwcGluZ1xuICAgICAgICAgICAgY29uc3QgZmxpcHMgPSBiaWRpLmdldFJlb3JkZXJTZWdtZW50cyhcbiAgICAgICAgICAgICAgdGV4dCwgYmlkaUxldmVsc1Jlc3VsdCwgbGluZS5nbHlwaEF0KDApLmNoYXJJbmRleCwgbGluZS5nbHlwaEF0KGxpbmUuY291bnQgLSAxKS5jaGFySW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb3IgKGxldCBmaSA9IDA7IGZpIDwgZmxpcHMubGVuZ3RoOyBmaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IGZsaXBzW2ZpXTtcbiAgICAgICAgICAgICAgLy8gTWFwIHN0YXJ0L2VuZCBzdHJpbmcgaW5kaWNlcyB0byBpbmRpY2VzIGluIHRoZSBsaW5lXG4gICAgICAgICAgICAgIGxldCBsZWZ0ID0gSW5maW5pdHksIHJpZ2h0ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5nbHlwaEF0KGkpLmNoYXJJbmRleCA+PSBzdGFydCkgeyAvLyBndGUgdG8gaGFuZGxlIHJlbW92ZWQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5MaW5lID0gaSwgZW5kSW5MaW5lID0gaTtcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBlbmRJbkxpbmUgPCBsaW5lR2x5cGhDb3VudDsgZW5kSW5MaW5lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZm8gPSBsaW5lLmdseXBoQXQoZW5kSW5MaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uY2hhckluZGV4ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5MaW5lIDwgbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCkgeyAvL2Rvbid0IGluY2x1ZGUgdHJhaWxpbmcgd3MgaW4gZmxpcCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCBpbmZvLngpO1xuICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIGluZm8ueCArIGluZm8ud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gc3RhcnRJbkxpbmU7IGogPCBlbmRJbkxpbmU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaik7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoSW5mby54ID0gcmlnaHQgLSAoZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGggLSBsZWZ0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFzc2VtYmxlIGZpbmFsIGRhdGEgYXJyYXlzXG4gICAgICAgICAgICBsZXQgZ2x5cGhPYmo7XG4gICAgICAgICAgICBjb25zdCBzZXRHbHlwaE9iaiA9IGcgPT4gZ2x5cGhPYmogPSBnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaSk7XG4gICAgICAgICAgICAgIGdseXBoT2JqID0gZ2x5cGhJbmZvLmdseXBoT2JqO1xuICAgICAgICAgICAgICBjb25zdCBnbHlwaElkID0gZ2x5cGhPYmouaW5kZXg7XG5cbiAgICAgICAgICAgICAgLy8gUmVwbGFjZSBtaXJyb3JlZCBjaGFyYWN0ZXJzIGluIHJ0bFxuICAgICAgICAgICAgICBjb25zdCBydGwgPSBiaWRpTGV2ZWxzUmVzdWx0LmxldmVsc1tnbHlwaEluZm8uY2hhckluZGV4XSAmIDE7IC8vb2RkIGxldmVsIG1lYW5zIHJ0bFxuICAgICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlycm9yZWQgPSBiaWRpLmdldE1pcnJvcmVkQ2hhcmFjdGVyKHRleHRbZ2x5cGhJbmZvLmNoYXJJbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmIChtaXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgZm9udE9iai5mb3JFYWNoR2x5cGgobWlycm9yZWQsIDAsIDAsIHNldEdseXBoT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBZGQgY2FyZXQgcG9zaXRpb25zXG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlQ2FyZXRQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7Y2hhckluZGV4fSA9IGdseXBoSW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBjYXJldExlZnQgPSBnbHlwaEluZm8ueCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FyZXRSaWdodCA9IGdseXBoSW5mby54ICsgZ2x5cGhJbmZvLndpZHRoICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiAzXSA9IHJ0bCA/IGNhcmV0UmlnaHQgOiBjYXJldExlZnQ7IC8vc3RhcnQgZWRnZSB4XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogMyArIDFdID0gcnRsID8gY2FyZXRMZWZ0IDogY2FyZXRSaWdodDsgLy9lbmQgZWRnZSB4XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogMyArIDJdID0gbGluZVlPZmZzZXQgKyBjYXJldEJvdHRvbU9mZnNldCArIGFuY2hvcllPZmZzZXQ7IC8vY29tbW9uIGJvdHRvbSB5XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBza2lwcGVkIGFueSBjaGFycyBmcm9tIHRoZSBwcmV2aW91cyBnbHlwaCAoZHVlIHRvIGxpZ2F0dXJlIHN1YnMpLCBmaWxsIGluIGNhcmV0XG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGZvciB0aG9zZSBtaXNzaW5nIGNoYXIgaW5kaWNlczsgY3VycmVudGx5IHRoaXMgdXNlcyBhIGJlc3QtZ3Vlc3MgYnkgZGl2aWRpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGlnYXR1cmUncyB3aWR0aCBldmVubHkuIEluIHRoZSBmdXR1cmUgd2UgbWF5IHRyeSB0byB1c2UgdGhlIGZvbnQncyBMaWdhdHVyZUNhcmV0TGlzdFxuICAgICAgICAgICAgICAgIC8vIHRhYmxlIHRvIGdldCBiZXR0ZXIgaW50ZXJpb3IgY2FyZXQgcG9zaXRpb25zLlxuICAgICAgICAgICAgICAgIGNvbnN0IGxpZ0NvdW50ID0gY2hhckluZGV4IC0gcHJldkNoYXJJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAobGlnQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICBmaWxsTGlnYXR1cmVDYXJldFBvc2l0aW9ucyhjYXJldFBvc2l0aW9ucywgcHJldkNoYXJJbmRleCwgbGlnQ291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2Q2hhckluZGV4ID0gY2hhckluZGV4O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVHJhY2sgY3VycmVudCBjb2xvciByYW5nZVxuICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7Y2hhckluZGV4fSA9IGdseXBoSW5mbztcbiAgICAgICAgICAgICAgICB3aGlsZShjaGFySW5kZXggPiBjb2xvckNoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgY29sb3JDaGFySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcy5oYXNPd25Qcm9wZXJ0eShjb2xvckNoYXJJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbG9yID0gY29sb3JSYW5nZXNbY29sb3JDaGFySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEdldCBhdGxhcyBkYXRhIGZvciByZW5kZXJhYmxlIGdseXBoc1xuICAgICAgICAgICAgICBpZiAoIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiAhZ2x5cGhPYmouaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHJlbmRlcmFibGVHbHlwaEluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBnbHlwaCdzIHBhdGggZGF0YVxuICAgICAgICAgICAgICAgIGlmICghZ2x5cGhEYXRhW2dseXBoSWRdKSB7XG4gICAgICAgICAgICAgICAgICBnbHlwaERhdGFbZ2x5cGhJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGdseXBoT2JqLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhdGhCb3VuZHM6IFtnbHlwaE9iai54TWluLCBnbHlwaE9iai55TWluLCBnbHlwaE9iai54TWF4LCBnbHlwaE9iai55TWF4XVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZmluYWwgZ2x5cGggcG9zaXRpb24gYW5kIGFkZCB0byBnbHlwaFBvc2l0aW9ucyBhcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoWCA9IGdseXBoSW5mby54ICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaFkgPSBsaW5lWU9mZnNldCArIGFuY2hvcllPZmZzZXQ7XG4gICAgICAgICAgICAgICAgZ2x5cGhQb3NpdGlvbnNbaWR4ICogMl0gPSBnbHlwaFg7XG4gICAgICAgICAgICAgICAgZ2x5cGhQb3NpdGlvbnNbaWR4ICogMiArIDFdID0gZ2x5cGhZO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgdG90YWwgdmlzaWJsZSBib3VuZHNcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNYMCA9IGdseXBoWCArIGdseXBoT2JqLnhNaW4gKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzWTAgPSBnbHlwaFkgKyBnbHlwaE9iai55TWluICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc1gxID0gZ2x5cGhYICsgZ2x5cGhPYmoueE1heCAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNZMSA9IGdseXBoWSArIGdseXBoT2JqLnlNYXggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1gwIDwgdmlzaWJsZUJvdW5kc1swXSkgdmlzaWJsZUJvdW5kc1swXSA9IHZpc1gwO1xuICAgICAgICAgICAgICAgIGlmICh2aXNZMCA8IHZpc2libGVCb3VuZHNbMV0pIHZpc2libGVCb3VuZHNbMV0gPSB2aXNZMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWDEgPiB2aXNpYmxlQm91bmRzWzJdKSB2aXNpYmxlQm91bmRzWzJdID0gdmlzWDE7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1kxID4gdmlzaWJsZUJvdW5kc1szXSkgdmlzaWJsZUJvdW5kc1szXSA9IHZpc1kxO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgYm91bmRpbmcgcmVjdHMgZm9yIGVhY2ggY2h1bmsgb2YgTiBnbHlwaHNcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICUgY2h1bmtlZEJvdW5kc1NpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNodW5rID0ge3N0YXJ0OiBpZHgsIGVuZDogaWR4LCByZWN0OiBbSU5GLCBJTkYsIC1JTkYsIC1JTkZdfTtcbiAgICAgICAgICAgICAgICAgIGNodW5rZWRCb3VuZHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rLmVuZCsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUmVjdCA9IGNodW5rLnJlY3Q7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1gwIDwgY2h1bmtSZWN0WzBdKSBjaHVua1JlY3RbMF0gPSB2aXNYMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWTAgPCBjaHVua1JlY3RbMV0pIGNodW5rUmVjdFsxXSA9IHZpc1kwO1xuICAgICAgICAgICAgICAgIGlmICh2aXNYMSA+IGNodW5rUmVjdFsyXSkgY2h1bmtSZWN0WzJdID0gdmlzWDE7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1kxID4gY2h1bmtSZWN0WzNdKSBjaHVua1JlY3RbM10gPSB2aXNZMTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBnbHlwaCBpZHMgYXJyYXlcbiAgICAgICAgICAgICAgICBnbHlwaElkc1tpZHhdID0gZ2x5cGhJZDtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBjb2xvcnNcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaWR4ICogMztcbiAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0XSA9IGN1cnJlbnRDb2xvciA+PiAxNiAmIDI1NTtcbiAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0ICsgMV0gPSBjdXJyZW50Q29sb3IgPj4gOCAmIDI1NTtcbiAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0ICsgMl0gPSBjdXJyZW50Q29sb3IgJiAyNTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSW5jcmVtZW50IHkgb2Zmc2V0IGZvciBuZXh0IGxpbmVcbiAgICAgICAgICBsaW5lWU9mZnNldCAtPSBsaW5lSGVpZ2h0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaWxsIGluIHJlbWFpbmluZyBjYXJldCBwb3NpdGlvbnMgaW4gY2FzZSB0aGUgZmluYWwgY2hhcmFjdGVyIHdhcyBhIGxpZ2F0dXJlXG4gICAgICAgIGlmIChjYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgIGNvbnN0IGxpZ0NvdW50ID0gdGV4dC5sZW5ndGggLSBwcmV2Q2hhckluZGV4O1xuICAgICAgICAgIGlmIChsaWdDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIGZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zKGNhcmV0UG9zaXRpb25zLCBwcmV2Q2hhckluZGV4LCBsaWdDb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRpbWluZyBzdGF0c1xuICAgICAgdGltaW5ncy50eXBlc2V0dGluZyA9IG5vdygpIC0gdHlwZXNldFN0YXJ0O1xuXG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIGdseXBoSWRzLCAvL2ZvbnQgaW5kaWNlcyBmb3IgZWFjaCBnbHlwaFxuICAgICAgICBnbHlwaFBvc2l0aW9ucywgLy94LHkgb2YgZWFjaCBnbHlwaCdzIG9yaWdpbiBpbiBsYXlvdXRcbiAgICAgICAgZ2x5cGhEYXRhLCAvL2RpY3QgaG9sZGluZyBkYXRhIGFib3V0IGVhY2ggZ2x5cGggYXBwZWFyaW5nIGluIHRoZSB0ZXh0XG4gICAgICAgIGNhcmV0UG9zaXRpb25zLCAvL3N0YXJ0WCxlbmRYLGJvdHRvbVkgY2FyZXQgcG9zaXRpb25zIGZvciBlYWNoIGNoYXJcbiAgICAgICAgY2FyZXRIZWlnaHQsIC8vaGVpZ2h0IG9mIGN1cnNvciBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICAgICAgZ2x5cGhDb2xvcnMsIC8vY29sb3IgZm9yIGVhY2ggZ2x5cGgsIGlmIGNvbG9yIHJhbmdlcyBzdXBwbGllZFxuICAgICAgICBjaHVua2VkQm91bmRzLCAvL3RvdGFsIHJlY3RzIHBlciAobj1jaHVua2VkQm91bmRzU2l6ZSkgY29uc2VjdXRpdmUgZ2x5cGhzXG4gICAgICAgIGZvbnRTaXplLCAvL2NhbGN1bGF0ZWQgZW0gaGVpZ2h0XG4gICAgICAgIHVuaXRzUGVyRW0sIC8vZm9udCB1bml0cyBwZXIgZW1cbiAgICAgICAgYXNjZW5kZXI6IGFzY2VuZGVyICogZm9udFNpemVNdWx0LCAvL2ZvbnQgYXNjZW5kZXJcbiAgICAgICAgZGVzY2VuZGVyOiBkZXNjZW5kZXIgKiBmb250U2l6ZU11bHQsIC8vZm9udCBkZXNjZW5kZXJcbiAgICAgICAgY2FwSGVpZ2h0OiBjYXBIZWlnaHQgKiBmb250U2l6ZU11bHQsIC8vZm9udCBjYXAtaGVpZ2h0XG4gICAgICAgIHhIZWlnaHQ6IHhIZWlnaHQgKiBmb250U2l6ZU11bHQsIC8vZm9udCB4LWhlaWdodFxuICAgICAgICBsaW5lSGVpZ2h0LCAvL2NvbXB1dGVkIGxpbmUgaGVpZ2h0XG4gICAgICAgIHRvcEJhc2VsaW5lLCAvL3kgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxpbmUncyBiYXNlbGluZVxuICAgICAgICBibG9ja0JvdW5kczogWyAvL2JvdW5kcyBmb3IgdGhlIHdob2xlIGJsb2NrIG9mIHRleHQsIGluY2x1ZGluZyB2ZXJ0aWNhbCBwYWRkaW5nIGZvciBsaW5lSGVpZ2h0XG4gICAgICAgICAgYW5jaG9yWE9mZnNldCxcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0IC0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodCxcbiAgICAgICAgICBhbmNob3JYT2Zmc2V0ICsgbWF4TGluZVdpZHRoLFxuICAgICAgICAgIGFuY2hvcllPZmZzZXRcbiAgICAgICAgXSxcbiAgICAgICAgdmlzaWJsZUJvdW5kcywgLy90b3RhbCBib3VuZHMgb2YgdmlzaWJsZSB0ZXh0IHBhdGhzLCBtYXkgYmUgbGFyZ2VyIG9yIHNtYWxsZXIgdGhhbiBibG9ja0JvdW5kc1xuICAgICAgICB0aW1pbmdzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEZvciBhIGdpdmVuIHRleHQgc3RyaW5nIGFuZCBmb250IHBhcmFtZXRlcnMsIGRldGVybWluZSB0aGUgcmVzdWx0aW5nIGJsb2NrIGRpbWVuc2lvbnNcbiAgICogYWZ0ZXIgd3JhcHBpbmcgZm9yIHRoZSBnaXZlbiBtYXhXaWR0aC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBtZWFzdXJlKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgdHlwZXNldChhcmdzLCAocmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gcmVzdWx0LmJsb2NrQm91bmRzO1xuICAgICAgY2FsbGJhY2soe1xuICAgICAgICB3aWR0aDogeDEgLSB4MCxcbiAgICAgICAgaGVpZ2h0OiB5MSAtIHkwXG4gICAgICB9KTtcbiAgICB9LCB7bWV0cmljc09ubHk6IHRydWV9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGVyY2VudChzdHIpIHtcbiAgICBsZXQgbWF0Y2ggPSBzdHIubWF0Y2goL14oW1xcZC5dKyklJC8pO1xuICAgIGxldCBwY3QgPSBtYXRjaCA/IHBhcnNlRmxvYXQobWF0Y2hbMV0pIDogTmFOO1xuICAgIHJldHVybiBpc05hTihwY3QpID8gMCA6IHBjdCAvIDEwMFxuICB9XG5cbiAgZnVuY3Rpb24gZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIGxpZ1N0YXJ0SW5kZXgsIGxpZ0NvdW50KSB7XG4gICAgY29uc3QgbGlnU3RhcnRYID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDNdO1xuICAgIGNvbnN0IGxpZ0VuZFggPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogMyArIDFdO1xuICAgIGNvbnN0IGxpZ1kgPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogMyArIDJdO1xuICAgIGNvbnN0IGd1ZXNzZWRBZHZhbmNlWCA9IChsaWdFbmRYIC0gbGlnU3RhcnRYKSAvIGxpZ0NvdW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlnQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IChsaWdTdGFydEluZGV4ICsgaSkgKiAzO1xuICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleF0gPSBsaWdTdGFydFggKyBndWVzc2VkQWR2YW5jZVggKiBpO1xuICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleCArIDFdID0gbGlnU3RhcnRYICsgZ3Vlc3NlZEFkdmFuY2VYICogKGkgKyAxKTtcbiAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXggKyAyXSA9IGxpZ1k7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiAoc2VsZi5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKVxuICB9XG5cbiAgLy8gQXJyYXktYmFja2VkIHN0cnVjdHVyZSBmb3IgYSBzaW5nbGUgbGluZSdzIGdseXBocyBkYXRhXG4gIGZ1bmN0aW9uIFRleHRMaW5lKCkge1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG4gIGNvbnN0IHRleHRMaW5lUHJvcHMgPSBbJ2dseXBoT2JqJywgJ3gnLCAnd2lkdGgnLCAnY2hhckluZGV4J107XG4gIFRleHRMaW5lLnByb3RvdHlwZSA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBpc1NvZnRXcmFwcGVkOiBmYWxzZSxcbiAgICBnZXQgY291bnQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGF0YS5sZW5ndGggLyB0ZXh0TGluZVByb3BzLmxlbmd0aClcbiAgICB9LFxuICAgIGdseXBoQXQoaSkge1xuICAgICAgbGV0IGZseSA9IFRleHRMaW5lLmZseXdlaWdodDtcbiAgICAgIGZseS5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgZmx5LmluZGV4ID0gaTtcbiAgICAgIHJldHVybiBmbHlcbiAgICB9LFxuICAgIHNwbGl0QXQoaSkge1xuICAgICAgbGV0IG5ld0xpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgIG5ld0xpbmUuZGF0YSA9IHRoaXMuZGF0YS5zcGxpY2UoaSAqIHRleHRMaW5lUHJvcHMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXdMaW5lXG4gICAgfVxuICB9O1xuICBUZXh0TGluZS5mbHl3ZWlnaHQgPSB0ZXh0TGluZVByb3BzLnJlZHVjZSgob2JqLCBwcm9wLCBpLCBhbGwpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5pbmRleCAqIHRleHRMaW5lUHJvcHMubGVuZ3RoICsgaV1cbiAgICAgIH0sXG4gICAgICBzZXQodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLmluZGV4ICogdGV4dExpbmVQcm9wcy5sZW5ndGggKyBpXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqXG4gIH0sIHtkYXRhOiBudWxsLCBpbmRleDogMH0pO1xuXG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlc2V0LFxuICAgIG1lYXN1cmUsXG4gICAgbG9hZEZvbnRcbiAgfVxufVxuXG5jb25zdCBub3cgPSAoKSA9PiAoc2VsZi5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKTtcblxuY29uc3QgbWFpblRocmVhZEdlbmVyYXRvciA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU0RGR2VuZXJhdG9yKCk7XG5cbmxldCB3YXJuZWQ7XG5cbi8qKlxuICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgc2luZ2xlIGdseXBoIHBhdGgsIHBsYWNpbmcgdGhlIHJlc3VsdCBpbnRvIGEgd2ViZ2wgY2FudmFzIGF0IGFcbiAqIGdpdmVuIGxvY2F0aW9uIGFuZCBjaGFubmVsLiBVdGlsaXplcyB0aGUgd2ViZ2wtc2RmLWdlbmVyYXRvciBleHRlcm5hbCBwYWNrYWdlIGZvciBHUFUtYWNjZWxlcmF0ZWQgU0RGXG4gKiBnZW5lcmF0aW9uIHdoZW4gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNERih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCwgdXNlV2ViR0wgPSB0cnVlKSB7XG4gIC8vIEFsbG93IG9wdC1vdXRcbiAgaWYgKCF1c2VXZWJHTCkge1xuICAgIHJldHVybiBnZW5lcmF0ZVNERl9KU19Xb3JrZXIod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpXG4gIH1cblxuICAvLyBBdHRlbXB0IEdQVS1hY2NlbGVyYXRlZCBnZW5lcmF0aW9uIGZpcnN0XG4gIHJldHVybiBnZW5lcmF0ZVNERl9HTCh3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkudGhlbihcbiAgICBudWxsLFxuICAgIGVyciA9PiB7XG4gICAgICAvLyBXZWJHTCBmYWlsZWQgZWl0aGVyIGR1ZSB0byBhIGhhcmQgZXJyb3Igb3IgdW5leHBlY3RlZCByZXN1bHRzOyBmYWxsIGJhY2sgdG8gSlMgaW4gd29ya2Vyc1xuICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKU2AsIGVycik7XG4gICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2VuZXJhdGVTREZfSlNfV29ya2VyKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKVxuICAgIH1cbiAgKVxufVxuXG5jb25zdCBxdWV1ZSA9IFtdO1xuY29uc3QgY2h1bmtUaW1lQnVkZ2V0ID0gNTsgLy8gbXNcbmxldCB0aW1lciA9IDA7XG5cbmZ1bmN0aW9uIG5leHRDaHVuaygpIHtcbiAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAmJiBub3coKSAtIHN0YXJ0IDwgY2h1bmtUaW1lQnVkZ2V0KSB7XG4gICAgcXVldWUuc2hpZnQoKSgpO1xuICB9XG4gIHRpbWVyID0gcXVldWUubGVuZ3RoID8gc2V0VGltZW91dChuZXh0Q2h1bmssIDApIDogMDtcbn1cblxuLyoqXG4gKiBXZWJHTC1iYXNlZCBpbXBsZW1lbnRhdGlvbiBleGVjdXRlZCBvbiB0aGUgbWFpbiB0aHJlYWQuIFJlcXVlc3RzIGFyZSBleGVjdXRlZCBpbiB0aW1lLWJvdW5kZWRcbiAqIG1hY3JvdGFzayBjaHVua3MgdG8gYWxsb3cgcmVuZGVyIGZyYW1lcyB0byBleGVjdXRlIGluIGJldHdlZW4uXG4gKi9cbmNvbnN0IGdlbmVyYXRlU0RGX0dMID0gKC4uLmFyZ3MpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBxdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsLmdlbmVyYXRlSW50b0NhbnZhcyguLi5hcmdzKTtcbiAgICAgICAgcmVzb2x2ZSh7IHRpbWluZzogbm93KCkgLSBzdGFydCB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXRpbWVyKSB7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQobmV4dENodW5rLCAwKTtcbiAgICB9XG4gIH0pXG59O1xuXG5jb25zdCB0aHJlYWRDb3VudCA9IDQ7IC8vIGhvdyBtYW55IHdvcmtlcnMgdG8gc3Bhd25cbmNvbnN0IGlkbGVUaW1lb3V0ID0gMjAwMDsgLy8gd29ya2VycyB3aWxsIGJlIHRlcm1pbmF0ZWQgYWZ0ZXIgYmVpbmcgaWRsZSB0aGlzIG1hbnkgbWlsbGlzZWNvbmRzXG5jb25zdCB0aHJlYWRzID0ge307XG5sZXQgY2FsbE51bSA9IDA7XG5cbi8qKlxuICogRmFsbGJhY2sgSlMtYmFzZWQgaW1wbGVtZW50YXRpb24sIGZhbm5lZCBvdXQgdG8gYSBudW1iZXIgb2Ygd29ya2VyIHRocmVhZHMgZm9yIHBhcmFsbGVsaXNtXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU0RGX0pTX1dvcmtlcih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkge1xuICBjb25zdCB3b3JrZXJJZCA9ICdUcm9pa2FUZXh0U0RGR2VuZXJhdG9yX0pTXycgKyAoKGNhbGxOdW0rKykgJSB0aHJlYWRDb3VudCk7XG4gIGxldCB0aHJlYWQgPSB0aHJlYWRzW3dvcmtlcklkXTtcbiAgaWYgKCF0aHJlYWQpIHtcbiAgICB0aHJlYWQgPSB0aHJlYWRzW3dvcmtlcklkXSA9IHtcbiAgICAgIHdvcmtlck1vZHVsZTogZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICAgICAgbmFtZTogd29ya2VySWQsXG4gICAgICAgIHdvcmtlcklkLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgICAgICBjcmVhdGVTREZHZW5lcmF0b3IsXG4gICAgICAgICAgbm93XG4gICAgICAgIF0sXG4gICAgICAgIGluaXQoX2NyZWF0ZVNERkdlbmVyYXRvciwgbm93KSB7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGUgPSBfY3JlYXRlU0RGR2VuZXJhdG9yKCkuamF2YXNjcmlwdC5nZW5lcmF0ZTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlRGF0YSA9IGdlbmVyYXRlKC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdGV4dHVyZURhdGEsXG4gICAgICAgICAgICAgIHRpbWluZzogbm93KCkgLSBzdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gW3Jlc3VsdC50ZXh0dXJlRGF0YS5idWZmZXJdXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgcmVxdWVzdHM6IDAsXG4gICAgICBpZGxlVGltZXI6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgdGhyZWFkLnJlcXVlc3RzKys7XG4gIGNsZWFyVGltZW91dCh0aHJlYWQuaWRsZVRpbWVyKTtcbiAgcmV0dXJuIHRocmVhZC53b3JrZXJNb2R1bGUod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50KVxuICAgIC50aGVuKCh7IHRleHR1cmVEYXRhLCB0aW1pbmcgfSkgPT4ge1xuICAgICAgLy8gY29weSByZXN1bHQgZGF0YSBpbnRvIHRoZSBjYW52YXNcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAvLyBleHBhbmQgc2luZ2xlLWNoYW5uZWwgZGF0YSBpbnRvIHJnYmFcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVEYXRhLmxlbmd0aCAqIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbWFnZURhdGFbaSAqIDQgKyBjaGFubmVsXSA9IHRleHR1cmVEYXRhW2ldO1xuICAgICAgfVxuICAgICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbFV0aWxzLnJlbmRlckltYWdlRGF0YShjYW52YXMsIGltYWdlRGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSA8PCAoMyAtIGNoYW5uZWwpKTtcbiAgICAgIHRpbWluZyArPSBub3coKSAtIHN0YXJ0O1xuXG4gICAgICAvLyBjbGVhbiB1cCB3b3JrZXJzIGFmdGVyIGEgd2hpbGVcbiAgICAgIGlmICgtLXRocmVhZC5yZXF1ZXN0cyA9PT0gMCkge1xuICAgICAgICB0aHJlYWQuaWRsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IHRlcm1pbmF0ZVdvcmtlcih3b3JrZXJJZCk7IH0sIGlkbGVUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHRpbWluZyB9XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gd2FybVVwU0RGQ2FudmFzKGNhbnZhcykge1xuICBpZiAoIWNhbnZhcy5fd2FybSkge1xuICAgIG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2wuaXNTdXBwb3J0ZWQoY2FudmFzKTtcbiAgICBjYW52YXMuX3dhcm0gPSB0cnVlO1xuICB9XG59XG5cbmNvbnN0IHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nID0gbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbFV0aWxzLnJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nO1xuXG4vKiFcbkN1c3RvbSBidWlsZCBvZiBUeXByLnRzIChodHRwczovL2dpdGh1Yi5jb20vZnJlZGxpNzQvVHlwci50cykgZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuXG5PcmlnaW5hbCBNSVQgbGljZW5zZSBhcHBsaWVzOiBodHRwczovL2dpdGh1Yi5jb20vZnJlZGxpNzQvVHlwci50cy9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuZnVuY3Rpb24gdHlwckZhY3RvcnkoKXtyZXR1cm4gXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyYmKHNlbGYud2luZG93PXNlbGYpLGZ1bmN0aW9uKHIpe3ZhciBlPXtwYXJzZTpmdW5jdGlvbihyKXt2YXIgdD1lLl9iaW4sYT1uZXcgVWludDhBcnJheShyKTtpZihcInR0Y2ZcIj09dC5yZWFkQVNDSUkoYSwwLDQpKXt2YXIgbj00O3QucmVhZFVzaG9ydChhLG4pLG4rPTIsdC5yZWFkVXNob3J0KGEsbiksbis9Mjt2YXIgbz10LnJlYWRVaW50KGEsbik7bis9NDtmb3IodmFyIHM9W10saT0wO2k8bztpKyspe3ZhciBoPXQucmVhZFVpbnQoYSxuKTtuKz00LHMucHVzaChlLl9yZWFkRm9udChhLGgpKTt9cmV0dXJuIHN9cmV0dXJuIFtlLl9yZWFkRm9udChhLDApXX0sX3JlYWRGb250OmZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dDthLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9Mjtmb3IodmFyIHM9W1wiY21hcFwiLFwiaGVhZFwiLFwiaGhlYVwiLFwibWF4cFwiLFwiaG10eFwiLFwibmFtZVwiLFwiT1MvMlwiLFwicG9zdFwiLFwibG9jYVwiLFwiZ2x5ZlwiLFwia2VyblwiLFwiQ0ZGIFwiLFwiR1BPU1wiLFwiR1NVQlwiLFwiU1ZHIFwiXSxpPXtfZGF0YTpyLF9vZmZzZXQ6bn0saD17fSxmPTA7ZjxvO2YrKyl7dmFyIGQ9YS5yZWFkQVNDSUkocix0LDQpO3QrPTQsYS5yZWFkVWludChyLHQpLHQrPTQ7dmFyIHU9YS5yZWFkVWludChyLHQpO3QrPTQ7dmFyIGw9YS5yZWFkVWludChyLHQpO3QrPTQsaFtkXT17b2Zmc2V0OnUsbGVuZ3RoOmx9O31mb3IoZj0wO2Y8cy5sZW5ndGg7ZisrKXt2YXIgdj1zW2ZdO2hbdl0mJihpW3YudHJpbSgpXT1lW3YudHJpbSgpXS5wYXJzZShyLGhbdl0ub2Zmc2V0LGhbdl0ubGVuZ3RoLGkpKTt9cmV0dXJuIGl9LF90YWJPZmZzZXQ6ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4sbz1uLnJlYWRVc2hvcnQocixhKzQpLHM9YSsxMixpPTA7aTxvO2krKyl7dmFyIGg9bi5yZWFkQVNDSUkocixzLDQpO3MrPTQsbi5yZWFkVWludChyLHMpLHMrPTQ7dmFyIGY9bi5yZWFkVWludChyLHMpO2lmKHMrPTQsbi5yZWFkVWludChyLHMpLHMrPTQsaD09dClyZXR1cm4gZn1yZXR1cm4gMH19O2UuX2Jpbj17cmVhZEZpeGVkOmZ1bmN0aW9uKHIsZSl7cmV0dXJuIChyW2VdPDw4fHJbZSsxXSkrKHJbZSsyXTw8OHxyW2UrM10pLzY1NTQwfSxyZWFkRjJkb3QxNDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4ucmVhZFNob3J0KHIsdCkvMTYzODR9LHJlYWRJbnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldEludDMyKHQpfSxyZWFkSW50ODpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0SW50OCh0KX0scmVhZFNob3J0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRJbnQxNih0KX0scmVhZFVzaG9ydDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0VWludDE2KHQpfSxyZWFkVXNob3J0czpmdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPVtdLG89MDtvPGE7bysrKW4ucHVzaChlLl9iaW4ucmVhZFVzaG9ydChyLHQrMipvKSk7cmV0dXJuIG59LHJlYWRVaW50OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRVaW50MzIodCl9LHJlYWRVaW50NjQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gNDI5NDk2NzI5NiplLl9iaW4ucmVhZFVpbnQocix0KStlLl9iaW4ucmVhZFVpbnQocix0KzQpfSxyZWFkQVNDSUk6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1cIlwiLG49MDtuPHQ7bisrKWErPVN0cmluZy5mcm9tQ2hhckNvZGUocltlK25dKTtyZXR1cm4gYX0scmVhZFVuaWNvZGU6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1cIlwiLG49MDtuPHQ7bisrKXt2YXIgbz1yW2UrK108PDh8cltlKytdO2ErPVN0cmluZy5mcm9tQ2hhckNvZGUobyk7fXJldHVybiBhfSxfdGRlYzpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuVGV4dERlY29kZXI/bmV3IHdpbmRvdy5UZXh0RGVjb2RlcjpudWxsLHJlYWRVVEY4OmZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4uX3RkZWM7cmV0dXJuIG4mJjA9PXQmJmE9PXIubGVuZ3RoP24uZGVjb2RlKHIpOmUuX2Jpbi5yZWFkQVNDSUkocix0LGEpfSxyZWFkQnl0ZXM6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1bXSxuPTA7bjx0O24rKylhLnB1c2gocltlK25dKTtyZXR1cm4gYX0scmVhZEFTQ0lJQXJyYXk6ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1bXSxuPTA7bjx0O24rKylhLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShyW2Urbl0pKTtyZXR1cm4gYX0sX3ZpZXc6ZnVuY3Rpb24ocil7cmV0dXJuIHIuX2RhdGFWaWV3fHwoci5fZGF0YVZpZXc9ci5idWZmZXI/bmV3IERhdGFWaWV3KHIuYnVmZmVyLHIuYnl0ZU9mZnNldCxyLmJ5dGVMZW5ndGgpOm5ldyBEYXRhVmlldyhuZXcgVWludDhBcnJheShyKS5idWZmZXIpKX19LGUuX2xjdGY9e30sZS5fbGN0Zi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuLG8pe3ZhciBzPWUuX2JpbixpPXt9LGg9dDtzLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIGY9cy5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1zLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PXMucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLGkuc2NyaXB0TGlzdD1lLl9sY3RmLnJlYWRTY3JpcHRMaXN0KHIsaCtmKSxpLmZlYXR1cmVMaXN0PWUuX2xjdGYucmVhZEZlYXR1cmVMaXN0KHIsaCtkKSxpLmxvb2t1cExpc3Q9ZS5fbGN0Zi5yZWFkTG9va3VwTGlzdChyLGgrdSxvKSxpfSxlLl9sY3RmLnJlYWRMb29rdXBMaXN0PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz10LHM9W10saT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspe3ZhciBmPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9ZS5fbGN0Zi5yZWFkTG9va3VwVGFibGUocixvK2YsYSk7cy5wdXNoKGQpO31yZXR1cm4gc30sZS5fbGN0Zi5yZWFkTG9va3VwVGFibGU9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXQscz17dGFiczpbXX07cy5sdHlwZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLHMuZmxhZz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBpPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPXMubHR5cGUsZj0wO2Y8aTtmKyspe3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9YShyLGgsbytkLHMpO3MudGFicy5wdXNoKHUpO31yZXR1cm4gc30sZS5fbGN0Zi5udW1PZk9uZXM9ZnVuY3Rpb24ocil7Zm9yKHZhciBlPTAsdD0wO3Q8MzI7dCsrKTAhPShyPj4+dCYxKSYmZSsrO3JldHVybiBlfSxlLl9sY3RmLnJlYWRDbGFzc0RlZj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPVtdLG89YS5yZWFkVXNob3J0KHIsdCk7aWYodCs9MiwxPT1vKXt2YXIgcz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPTA7aDxpO2grKyluLnB1c2gocytoKSxuLnB1c2gocytoKSxuLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7fWlmKDI9PW8pe3ZhciBmPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKGg9MDtoPGY7aCsrKW4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MixuLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTIsbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO31yZXR1cm4gbn0sZS5fbGN0Zi5nZXRJbnRlcnZhbD1mdW5jdGlvbihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5sZW5ndGg7dCs9Myl7dmFyIGE9clt0XSxuPXJbdCsxXTtpZihyW3QrMl0sYTw9ZSYmZTw9bilyZXR1cm4gdH1yZXR1cm4gLTF9LGUuX2xjdGYucmVhZENvdmVyYWdlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mbXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MiwxPT1uLmZtdCYmKG4udGFiPWEucmVhZFVzaG9ydHMocix0LG8pKSwyPT1uLmZtdCYmKG4udGFiPWEucmVhZFVzaG9ydHMocix0LDMqbykpLG59LGUuX2xjdGYuY292ZXJhZ2VJbmRleD1mdW5jdGlvbihyLHQpe3ZhciBhPXIudGFiO2lmKDE9PXIuZm10KXJldHVybiBhLmluZGV4T2YodCk7aWYoMj09ci5mbXQpe3ZhciBuPWUuX2xjdGYuZ2V0SW50ZXJ2YWwoYSx0KTtpZigtMSE9bilyZXR1cm4gYVtuKzJdKyh0LWFbbl0pfXJldHVybiAtMX0sZS5fbGN0Zi5yZWFkRmVhdHVyZUxpc3Q9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBmPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9ZS5fbGN0Zi5yZWFkRmVhdHVyZVRhYmxlKHIsbitmKTtkLnRhZz1oLnRyaW0oKSxvLnB1c2goZCk7fXJldHVybiBvfSxlLl9sY3RmLnJlYWRGZWF0dXJlVGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLHM+MCYmKG8uZmVhdHVyZVBhcmFtcz1uK3MpO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby50YWI9W107Zm9yKHZhciBoPTA7aDxpO2grKylvLnRhYi5wdXNoKGEucmVhZFVzaG9ydChyLHQrMipoKSk7cmV0dXJuIG99LGUuX2xjdGYucmVhZFNjcmlwdExpc3Q9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBmPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsb1toLnRyaW0oKV09ZS5fbGN0Zi5yZWFkU2NyaXB0VGFibGUocixuK2YpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkU2NyaXB0VGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e30scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8uZGVmYXVsdD1lLl9sY3RmLnJlYWRMYW5nU3lzVGFibGUocixuK3MpO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPTA7aDxpO2grKyl7dmFyIGY9YS5yZWFkQVNDSUkocix0LDQpO3QrPTQ7dmFyIGQ9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvW2YudHJpbSgpXT1lLl9sY3RmLnJlYWRMYW5nU3lzVGFibGUocixuK2QpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307YS5yZWFkVXNob3J0KHIsdCksdCs9MixuLnJlcUZlYXR1cmU9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixuLmZlYXR1cmVzPWEucmVhZFVzaG9ydHMocix0LG8pLG59LGUuQ0ZGPXt9LGUuQ0ZGLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47KHI9bmV3IFVpbnQ4QXJyYXkoci5idWZmZXIsdCxhKSlbdD0wXSxyWysrdF0sclsrK3RdLHJbKyt0XSx0Kys7dmFyIG89W107dD1lLkNGRi5yZWFkSW5kZXgocix0LG8pO2Zvcih2YXIgcz1bXSxpPTA7aTxvLmxlbmd0aC0xO2krKylzLnB1c2gobi5yZWFkQVNDSUkocix0K29baV0sb1tpKzFdLW9baV0pKTt0Kz1vW28ubGVuZ3RoLTFdO3ZhciBoPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxoKTt2YXIgZj1bXTtmb3IoaT0wO2k8aC5sZW5ndGgtMTtpKyspZi5wdXNoKGUuQ0ZGLnJlYWREaWN0KHIsdCtoW2ldLHQraFtpKzFdKSk7dCs9aFtoLmxlbmd0aC0xXTt2YXIgZD1mWzBdLHU9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LHUpO3ZhciBsPVtdO2ZvcihpPTA7aTx1Lmxlbmd0aC0xO2krKylsLnB1c2gobi5yZWFkQVNDSUkocix0K3VbaV0sdVtpKzFdLXVbaV0pKTtpZih0Kz11W3UubGVuZ3RoLTFdLGUuQ0ZGLnJlYWRTdWJycyhyLHQsZCksZC5DaGFyU3RyaW5ncyl7dD1kLkNoYXJTdHJpbmdzO3U9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LHUpO3ZhciB2PVtdO2ZvcihpPTA7aTx1Lmxlbmd0aC0xO2krKyl2LnB1c2gobi5yZWFkQnl0ZXMocix0K3VbaV0sdVtpKzFdLXVbaV0pKTtkLkNoYXJTdHJpbmdzPXY7fWlmKGQuUk9TKXt0PWQuRkRBcnJheTt2YXIgYz1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsYyksZC5GREFycmF5PVtdO2ZvcihpPTA7aTxjLmxlbmd0aC0xO2krKyl7dmFyIHA9ZS5DRkYucmVhZERpY3Qocix0K2NbaV0sdCtjW2krMV0pO2UuQ0ZGLl9yZWFkRkRpY3QocixwLGwpLGQuRkRBcnJheS5wdXNoKHApO310Kz1jW2MubGVuZ3RoLTFdLHQ9ZC5GRFNlbGVjdCxkLkZEU2VsZWN0PVtdO3ZhciBVPXJbdF07aWYodCsrLDMhPVUpdGhyb3cgVTt2YXIgZz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2ZvcihpPTA7aTxnKzE7aSsrKWQuRkRTZWxlY3QucHVzaChuLnJlYWRVc2hvcnQocix0KSxyW3QrMl0pLHQrPTM7fXJldHVybiBkLkVuY29kaW5nJiYoZC5FbmNvZGluZz1lLkNGRi5yZWFkRW5jb2RpbmcocixkLkVuY29kaW5nLGQuQ2hhclN0cmluZ3MubGVuZ3RoKSksZC5jaGFyc2V0JiYoZC5jaGFyc2V0PWUuQ0ZGLnJlYWRDaGFyc2V0KHIsZC5jaGFyc2V0LGQuQ2hhclN0cmluZ3MubGVuZ3RoKSksZS5DRkYuX3JlYWRGRGljdChyLGQsbCksZH0sZS5DRkYuX3JlYWRGRGljdD1mdW5jdGlvbihyLHQsYSl7dmFyIG47Zm9yKHZhciBvIGluIHQuUHJpdmF0ZSYmKG49dC5Qcml2YXRlWzFdLHQuUHJpdmF0ZT1lLkNGRi5yZWFkRGljdChyLG4sbit0LlByaXZhdGVbMF0pLHQuUHJpdmF0ZS5TdWJycyYmZS5DRkYucmVhZFN1YnJzKHIsbit0LlByaXZhdGUuU3VicnMsdC5Qcml2YXRlKSksdCktMSE9W1wiRmFtaWx5TmFtZVwiLFwiRm9udE5hbWVcIixcIkZ1bGxOYW1lXCIsXCJOb3RpY2VcIixcInZlcnNpb25cIixcIkNvcHlyaWdodFwiXS5pbmRleE9mKG8pJiYodFtvXT1hW3Rbb10tNDI2KzM1XSk7fSxlLkNGRi5yZWFkU3VicnM9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxvKTt2YXIgcyxpPW8ubGVuZ3RoO3M9aTwxMjQwPzEwNzppPDMzOTAwPzExMzE6MzI3NjgsYS5CaWFzPXMsYS5TdWJycz1bXTtmb3IodmFyIGg9MDtoPG8ubGVuZ3RoLTE7aCsrKWEuU3VicnMucHVzaChuLnJlYWRCeXRlcyhyLHQrb1toXSxvW2grMV0tb1toXSkpO30sZS5DRkYudGFibGVTRT1bMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsOTYsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwwLDExMSwxMTIsMTEzLDExNCwwLDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsMCwxMjMsMCwxMjQsMTI1LDEyNiwxMjcsMTI4LDEyOSwxMzAsMTMxLDAsMTMyLDEzMywwLDEzNCwxMzUsMTM2LDEzNywwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEzOCwwLDEzOSwwLDAsMCwwLDE0MCwxNDEsMTQyLDE0MywwLDAsMCwwLDAsMTQ0LDAsMCwwLDE0NSwwLDAsMTQ2LDE0NywxNDgsMTQ5LDAsMCwwLDBdLGUuQ0ZGLmdseXBoQnlVbmljb2RlPWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciB0PTA7dDxyLmNoYXJzZXQubGVuZ3RoO3QrKylpZihyLmNoYXJzZXRbdF09PWUpcmV0dXJuIHQ7cmV0dXJuIC0xfSxlLkNGRi5nbHlwaEJ5U0U9ZnVuY3Rpb24ocix0KXtyZXR1cm4gdDwwfHx0PjI1NT8tMTplLkNGRi5nbHlwaEJ5VW5pY29kZShyLGUuQ0ZGLnRhYmxlU0VbdF0pfSxlLkNGRi5yZWFkRW5jb2Rpbmc9ZnVuY3Rpb24ocix0LGEpe2UuX2Jpbjt2YXIgbj1bXCIubm90ZGVmXCJdLG89clt0XTtpZih0KyssMCE9byl0aHJvdyBcImVycm9yOiB1bmtub3duIGVuY29kaW5nIGZvcm1hdDogXCIrbzt2YXIgcz1yW3RdO3QrKztmb3IodmFyIGk9MDtpPHM7aSsrKW4ucHVzaChyW3QraV0pO3JldHVybiBufSxlLkNGRi5yZWFkQ2hhcnNldD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W1wiLm5vdGRlZlwiXSxzPXJbdF07aWYodCsrLDA9PXMpZm9yKHZhciBpPTA7aTxhO2krKyl7dmFyIGg9bi5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnB1c2goaCk7fWVsc2Uge2lmKDEhPXMmJjIhPXMpdGhyb3cgXCJlcnJvcjogZm9ybWF0OiBcIitzO2Zvcig7by5sZW5ndGg8YTspe2g9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZj0wOzE9PXM/KGY9clt0XSx0KyspOihmPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIpO2ZvcihpPTA7aTw9ZjtpKyspby5wdXNoKGgpLGgrKzt9fXJldHVybiBvfSxlLkNGRi5yZWFkSW5kZXg9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPW4ucmVhZFVzaG9ydChyLHQpKzEscz1yW3QrPTJdO2lmKHQrKywxPT1zKWZvcih2YXIgaT0wO2k8bztpKyspYS5wdXNoKHJbdCtpXSk7ZWxzZSBpZigyPT1zKWZvcihpPTA7aTxvO2krKylhLnB1c2gobi5yZWFkVXNob3J0KHIsdCsyKmkpKTtlbHNlIGlmKDM9PXMpZm9yKGk9MDtpPG87aSsrKWEucHVzaCgxNjc3NzIxNSZuLnJlYWRVaW50KHIsdCszKmktMSkpO2Vsc2UgaWYoMSE9byl0aHJvdyBcInVuc3VwcG9ydGVkIG9mZnNldCBzaXplOiBcIitzK1wiLCBjb3VudDogXCIrbztyZXR1cm4gKHQrPW8qcyktMX0sZS5DRkYuZ2V0Q2hhclN0cmluZz1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89clt0XSxzPXJbdCsxXTtyW3QrMl0sclt0KzNdLHJbdCs0XTt2YXIgaT0xLGg9bnVsbCxmPW51bGw7bzw9MjAmJihoPW8saT0xKSwxMj09byYmKGg9MTAwKm8rcyxpPTIpLDIxPD1vJiZvPD0yNyYmKGg9byxpPTEpLDI4PT1vJiYoZj1uLnJlYWRTaG9ydChyLHQrMSksaT0zKSwyOTw9byYmbzw9MzEmJihoPW8saT0xKSwzMjw9byYmbzw9MjQ2JiYoZj1vLTEzOSxpPTEpLDI0Nzw9byYmbzw9MjUwJiYoZj0yNTYqKG8tMjQ3KStzKzEwOCxpPTIpLDI1MTw9byYmbzw9MjU0JiYoZj0yNTYqLShvLTI1MSktcy0xMDgsaT0yKSwyNTU9PW8mJihmPW4ucmVhZEludChyLHQrMSkvNjU1MzUsaT01KSxhLnZhbD1udWxsIT1mP2Y6XCJvXCIraCxhLnNpemU9aTt9LGUuQ0ZGLnJlYWRDaGFyU3RyaW5nPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49dCthLG89ZS5fYmluLHM9W107dDxuOyl7dmFyIGk9clt0XSxoPXJbdCsxXTtyW3QrMl0sclt0KzNdLHJbdCs0XTt2YXIgZj0xLGQ9bnVsbCx1PW51bGw7aTw9MjAmJihkPWksZj0xKSwxMj09aSYmKGQ9MTAwKmkraCxmPTIpLDE5IT1pJiYyMCE9aXx8KGQ9aSxmPTIpLDIxPD1pJiZpPD0yNyYmKGQ9aSxmPTEpLDI4PT1pJiYodT1vLnJlYWRTaG9ydChyLHQrMSksZj0zKSwyOTw9aSYmaTw9MzEmJihkPWksZj0xKSwzMjw9aSYmaTw9MjQ2JiYodT1pLTEzOSxmPTEpLDI0Nzw9aSYmaTw9MjUwJiYodT0yNTYqKGktMjQ3KStoKzEwOCxmPTIpLDI1MTw9aSYmaTw9MjU0JiYodT0yNTYqLShpLTI1MSktaC0xMDgsZj0yKSwyNTU9PWkmJih1PW8ucmVhZEludChyLHQrMSkvNjU1MzUsZj01KSxzLnB1c2gobnVsbCE9dT91Olwib1wiK2QpLHQrPWY7fXJldHVybiBzfSxlLkNGRi5yZWFkRGljdD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPWUuX2JpbixvPXt9LHM9W107dDxhOyl7dmFyIGk9clt0XSxoPXJbdCsxXTtyW3QrMl0sclt0KzNdLHJbdCs0XTt2YXIgZj0xLGQ9bnVsbCx1PW51bGw7aWYoMjg9PWkmJih1PW4ucmVhZFNob3J0KHIsdCsxKSxmPTMpLDI5PT1pJiYodT1uLnJlYWRJbnQocix0KzEpLGY9NSksMzI8PWkmJmk8PTI0NiYmKHU9aS0xMzksZj0xKSwyNDc8PWkmJmk8PTI1MCYmKHU9MjU2KihpLTI0NykraCsxMDgsZj0yKSwyNTE8PWkmJmk8PTI1NCYmKHU9MjU2Ki0oaS0yNTEpLWgtMTA4LGY9MiksMjU1PT1pKXRocm93IHU9bi5yZWFkSW50KHIsdCsxKS82NTUzNSxmPTUsXCJ1bmtub3duIG51bWJlclwiO2lmKDMwPT1pKXt2YXIgbD1bXTtmb3IoZj0xOzspe3ZhciB2PXJbdCtmXTtmKys7dmFyIGM9dj4+NCxwPTE1JnY7aWYoMTUhPWMmJmwucHVzaChjKSwxNSE9cCYmbC5wdXNoKHApLDE1PT1wKWJyZWFrfWZvcih2YXIgVT1cIlwiLGc9WzAsMSwyLDMsNCw1LDYsNyw4LDksXCIuXCIsXCJlXCIsXCJlLVwiLFwicmVzZXJ2ZWRcIixcIi1cIixcImVuZE9mTnVtYmVyXCJdLFM9MDtTPGwubGVuZ3RoO1MrKylVKz1nW2xbU11dO3U9cGFyc2VGbG9hdChVKTt9aWYoaTw9MjEpaWYoZD1bXCJ2ZXJzaW9uXCIsXCJOb3RpY2VcIixcIkZ1bGxOYW1lXCIsXCJGYW1pbHlOYW1lXCIsXCJXZWlnaHRcIixcIkZvbnRCQm94XCIsXCJCbHVlVmFsdWVzXCIsXCJPdGhlckJsdWVzXCIsXCJGYW1pbHlCbHVlc1wiLFwiRmFtaWx5T3RoZXJCbHVlc1wiLFwiU3RkSFdcIixcIlN0ZFZXXCIsXCJlc2NhcGVcIixcIlVuaXF1ZUlEXCIsXCJYVUlEXCIsXCJjaGFyc2V0XCIsXCJFbmNvZGluZ1wiLFwiQ2hhclN0cmluZ3NcIixcIlByaXZhdGVcIixcIlN1YnJzXCIsXCJkZWZhdWx0V2lkdGhYXCIsXCJub21pbmFsV2lkdGhYXCJdW2ldLGY9MSwxMj09aSlkPVtcIkNvcHlyaWdodFwiLFwiaXNGaXhlZFBpdGNoXCIsXCJJdGFsaWNBbmdsZVwiLFwiVW5kZXJsaW5lUG9zaXRpb25cIixcIlVuZGVybGluZVRoaWNrbmVzc1wiLFwiUGFpbnRUeXBlXCIsXCJDaGFyc3RyaW5nVHlwZVwiLFwiRm9udE1hdHJpeFwiLFwiU3Ryb2tlV2lkdGhcIixcIkJsdWVTY2FsZVwiLFwiQmx1ZVNoaWZ0XCIsXCJCbHVlRnV6elwiLFwiU3RlbVNuYXBIXCIsXCJTdGVtU25hcFZcIixcIkZvcmNlQm9sZFwiLDAsMCxcIkxhbmd1YWdlR3JvdXBcIixcIkV4cGFuc2lvbkZhY3RvclwiLFwiaW5pdGlhbFJhbmRvbVNlZWRcIixcIlN5bnRoZXRpY0Jhc2VcIixcIlBvc3RTY3JpcHRcIixcIkJhc2VGb250TmFtZVwiLFwiQmFzZUZvbnRCbGVuZFwiLDAsMCwwLDAsMCwwLFwiUk9TXCIsXCJDSURGb250VmVyc2lvblwiLFwiQ0lERm9udFJldmlzaW9uXCIsXCJDSURGb250VHlwZVwiLFwiQ0lEQ291bnRcIixcIlVJREJhc2VcIixcIkZEQXJyYXlcIixcIkZEU2VsZWN0XCIsXCJGb250TmFtZVwiXVtoXSxmPTI7bnVsbCE9ZD8ob1tkXT0xPT1zLmxlbmd0aD9zWzBdOnMscz1bXSk6cy5wdXNoKHUpLHQrPWY7fXJldHVybiBvfSxlLmNtYXA9e30sZS5jbWFwLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXtyPW5ldyBVaW50OEFycmF5KHIuYnVmZmVyLHQsYSksdD0wO3ZhciBuPWUuX2JpbixvPXt9O24ucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIHM9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaT1bXTtvLnRhYmxlcz1bXTtmb3IodmFyIGg9MDtoPHM7aCsrKXt2YXIgZj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9bi5yZWFkVWludChyLHQpO3QrPTQ7dmFyIGw9XCJwXCIrZitcImVcIitkLHY9aS5pbmRleE9mKHUpO2lmKC0xPT12KXt2YXIgYzt2PW8udGFibGVzLmxlbmd0aCxpLnB1c2godSk7dmFyIHA9bi5yZWFkVXNob3J0KHIsdSk7MD09cD9jPWUuY21hcC5wYXJzZTAocix1KTo0PT1wP2M9ZS5jbWFwLnBhcnNlNChyLHUpOjY9PXA/Yz1lLmNtYXAucGFyc2U2KHIsdSk6MTI9PXA/Yz1lLmNtYXAucGFyc2UxMihyLHUpOmNvbnNvbGUuZGVidWcoXCJ1bmtub3duIGZvcm1hdDogXCIrcCxmLGQsdSksby50YWJsZXMucHVzaChjKTt9aWYobnVsbCE9b1tsXSl0aHJvdyBcIm11bHRpcGxlIHRhYmxlcyBmb3Igb25lIHBsYXRmb3JtK2VuY29kaW5nXCI7b1tsXT12O31yZXR1cm4gb30sZS5jbWFwLnBhcnNlMD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ubWFwPVtdO2Zvcih2YXIgcz0wO3M8by02O3MrKyluLm1hcC5wdXNoKHJbdCtzXSk7cmV0dXJuIG59LGUuY21hcC5wYXJzZTQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89e307by5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgcz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaD1pLzI7by5zZWFyY2hSYW5nZT1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uZW50cnlTZWxlY3Rvcj1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ucmFuZ2VTaGlmdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uZW5kQ291bnQ9YS5yZWFkVXNob3J0cyhyLHQsaCksdCs9MipoLHQrPTIsby5zdGFydENvdW50PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCxvLmlkRGVsdGE9W107Zm9yKHZhciBmPTA7ZjxoO2YrKylvLmlkRGVsdGEucHVzaChhLnJlYWRTaG9ydChyLHQpKSx0Kz0yO2ZvcihvLmlkUmFuZ2VPZmZzZXQ9YS5yZWFkVXNob3J0cyhyLHQsaCksdCs9MipoLG8uZ2x5cGhJZEFycmF5PVtdO3Q8bitzOylvLmdseXBoSWRBcnJheS5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO3JldHVybiBvfSxlLmNtYXAucGFyc2U2PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5maXJzdENvZGU9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG4uZ2x5cGhJZEFycmF5PVtdO2Zvcih2YXIgcz0wO3M8bztzKyspbi5nbHlwaElkQXJyYXkucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MjtyZXR1cm4gbn0sZS5jbWFwLnBhcnNlMTI9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLHQrPTIsYS5yZWFkVWludChyLHQpLHQrPTQsYS5yZWFkVWludChyLHQpLHQrPTQ7dmFyIG89YS5yZWFkVWludChyLHQpO3QrPTQsbi5ncm91cHM9W107Zm9yKHZhciBzPTA7czxvO3MrKyl7dmFyIGk9dCsxMipzLGg9YS5yZWFkVWludChyLGkrMCksZj1hLnJlYWRVaW50KHIsaSs0KSxkPWEucmVhZFVpbnQocixpKzgpO24uZ3JvdXBzLnB1c2goW2gsZixkXSk7fXJldHVybiBufSxlLmdseWY9e30sZS5nbHlmLnBhcnNlPWZ1bmN0aW9uKHIsZSx0LGEpe2Zvcih2YXIgbj1bXSxvPTA7bzxhLm1heHAubnVtR2x5cGhzO28rKyluLnB1c2gobnVsbCk7cmV0dXJuIG59LGUuZ2x5Zi5fcGFyc2VHbHlmPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49ci5fZGF0YSxvPWUuX3RhYk9mZnNldChuLFwiZ2x5ZlwiLHIuX29mZnNldCkrci5sb2NhW3RdO2lmKHIubG9jYVt0XT09ci5sb2NhW3QrMV0pcmV0dXJuIG51bGw7dmFyIHM9e307aWYocy5ub2M9YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueE1pbj1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy55TWluPWEucmVhZFNob3J0KG4sbyksbys9MixzLnhNYXg9YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueU1heD1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy54TWluPj1zLnhNYXh8fHMueU1pbj49cy55TWF4KXJldHVybiBudWxsO2lmKHMubm9jPjApe3MuZW5kUHRzPVtdO2Zvcih2YXIgaT0wO2k8cy5ub2M7aSsrKXMuZW5kUHRzLnB1c2goYS5yZWFkVXNob3J0KG4sbykpLG8rPTI7dmFyIGg9YS5yZWFkVXNob3J0KG4sbyk7aWYobys9MixuLmxlbmd0aC1vPGgpcmV0dXJuIG51bGw7cy5pbnN0cnVjdGlvbnM9YS5yZWFkQnl0ZXMobixvLGgpLG8rPWg7dmFyIGY9cy5lbmRQdHNbcy5ub2MtMV0rMTtzLmZsYWdzPVtdO2ZvcihpPTA7aTxmO2krKyl7dmFyIGQ9bltvXTtpZihvKysscy5mbGFncy5wdXNoKGQpLDAhPSg4JmQpKXt2YXIgdT1uW29dO28rKztmb3IodmFyIGw9MDtsPHU7bCsrKXMuZmxhZ3MucHVzaChkKSxpKys7fX1zLnhzPVtdO2ZvcihpPTA7aTxmO2krKyl7dmFyIHY9MCE9KDImcy5mbGFnc1tpXSksYz0wIT0oMTYmcy5mbGFnc1tpXSk7dj8ocy54cy5wdXNoKGM/bltvXTotbltvXSksbysrKTpjP3MueHMucHVzaCgwKToocy54cy5wdXNoKGEucmVhZFNob3J0KG4sbykpLG8rPTIpO31zLnlzPVtdO2ZvcihpPTA7aTxmO2krKyl7dj0wIT0oNCZzLmZsYWdzW2ldKSxjPTAhPSgzMiZzLmZsYWdzW2ldKTt2PyhzLnlzLnB1c2goYz9uW29dOi1uW29dKSxvKyspOmM/cy55cy5wdXNoKDApOihzLnlzLnB1c2goYS5yZWFkU2hvcnQobixvKSksbys9Mik7fXZhciBwPTAsVT0wO2ZvcihpPTA7aTxmO2krKylwKz1zLnhzW2ldLFUrPXMueXNbaV0scy54c1tpXT1wLHMueXNbaV09VTt9ZWxzZSB7dmFyIGc7cy5wYXJ0cz1bXTtkb3tnPWEucmVhZFVzaG9ydChuLG8pLG8rPTI7dmFyIFM9e206e2E6MSxiOjAsYzowLGQ6MSx0eDowLHR5OjB9LHAxOi0xLHAyOi0xfTtpZihzLnBhcnRzLnB1c2goUyksUy5nbHlwaEluZGV4PWEucmVhZFVzaG9ydChuLG8pLG8rPTIsMSZnKXt2YXIgbT1hLnJlYWRTaG9ydChuLG8pO28rPTI7dmFyIGI9YS5yZWFkU2hvcnQobixvKTtvKz0yO31lbHNlIHttPWEucmVhZEludDgobixvKTtvKys7Yj1hLnJlYWRJbnQ4KG4sbyk7bysrO30yJmc/KFMubS50eD1tLFMubS50eT1iKTooUy5wMT1tLFMucDI9YiksOCZnPyhTLm0uYT1TLm0uZD1hLnJlYWRGMmRvdDE0KG4sbyksbys9Mik6NjQmZz8oUy5tLmE9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmQ9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIpOjEyOCZnJiYoUy5tLmE9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmI9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmM9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIsUy5tLmQ9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIpO313aGlsZSgzMiZnKTtpZigyNTYmZyl7dmFyIHk9YS5yZWFkVXNob3J0KG4sbyk7bys9MixzLmluc3RyPVtdO2ZvcihpPTA7aTx5O2krKylzLmluc3RyLnB1c2gobltvXSksbysrO319cmV0dXJuIHN9LGUuR1BPUz17fSxlLkdQT1MucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7cmV0dXJuIGUuX2xjdGYucGFyc2Uocix0LGEsbixlLkdQT1Muc3VidCl9LGUuR1BPUy5zdWJ0PWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPWEsaT17fTtpZihpLmZtdD1vLnJlYWRVc2hvcnQocixhKSxhKz0yLDE9PXR8fDI9PXR8fDM9PXR8fDc9PXR8fDg9PXQmJmkuZm10PD0yKXt2YXIgaD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixoK3MpO31pZigxPT10JiYxPT1pLmZtdCl7dmFyIGY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgZD1lLl9sY3RmLm51bU9mT25lcyhmKTswIT1mJiYoaS5wb3M9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLGEsZikpO31lbHNlIGlmKDI9PXQmJmkuZm10Pj0xJiZpLmZtdDw9Mil7Zj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB1PW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7ZD1lLl9sY3RmLm51bU9mT25lcyhmKTt2YXIgbD1lLl9sY3RmLm51bU9mT25lcyh1KTtpZigxPT1pLmZtdCl7aS5wYWlyc2V0cz1bXTt2YXIgdj1vLnJlYWRVc2hvcnQocixhKTthKz0yO2Zvcih2YXIgYz0wO2M8djtjKyspe3ZhciBwPXMrby5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgVT1vLnJlYWRVc2hvcnQocixwKTtwKz0yO2Zvcih2YXIgZz1bXSxTPTA7UzxVO1MrKyl7dmFyIG09by5yZWFkVXNob3J0KHIscCk7cCs9MiwwIT1mJiYoeD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIscCxmKSxwKz0yKmQpLDAhPXUmJihQPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixwLHUpLHArPTIqbCksZy5wdXNoKHtnaWQyOm0sdmFsMTp4LHZhbDI6UH0pO31pLnBhaXJzZXRzLnB1c2goZyk7fX1pZigyPT1pLmZtdCl7dmFyIGI9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgeT1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBGPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIF89by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNsYXNzRGVmMT1lLl9sY3RmLnJlYWRDbGFzc0RlZihyLHMrYiksaS5jbGFzc0RlZjI9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK3kpLGkubWF0cml4PVtdO2ZvcihjPTA7YzxGO2MrKyl7dmFyIEM9W107Zm9yKFM9MDtTPF87UysrKXt2YXIgeD1udWxsLFA9bnVsbDswIT1mJiYoeD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIsYSxmKSxhKz0yKmQpLDAhPXUmJihQPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixhLHUpLGErPTIqbCksQy5wdXNoKHt2YWwxOngsdmFsMjpQfSk7fWkubWF0cml4LnB1c2goQyk7fX19ZWxzZSB7aWYoOT09dCYmMT09aS5mbXQpe3ZhciBJPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHc9by5yZWFkVWludChyLGEpO2lmKGErPTQsOT09bi5sdHlwZSluLmx0eXBlPUk7ZWxzZSBpZihuLmx0eXBlIT1JKXRocm93IFwiaW52YWxpZCBleHRlbnNpb24gc3Vic3RpdHV0aW9uXCI7cmV0dXJuIGUuR1BPUy5zdWJ0KHIsbi5sdHlwZSxzK3cpfWNvbnNvbGUuZGVidWcoXCJ1bnN1cHBvcnRlZCBHUE9TIHRhYmxlIExvb2t1cFR5cGVcIix0LFwiZm9ybWF0XCIsaS5mbXQpO31yZXR1cm4gaX0sZS5HUE9TLnJlYWRWYWx1ZVJlY29yZD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W107cmV0dXJuIG8ucHVzaCgxJmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz0xJmE/MjowLG8ucHVzaCgyJmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz0yJmE/MjowLG8ucHVzaCg0JmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz00JmE/MjowLG8ucHVzaCg4JmE/bi5yZWFkU2hvcnQocix0KTowKSx0Kz04JmE/MjowLG99LGUuR1NVQj17fSxlLkdTVUIucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7cmV0dXJuIGUuX2xjdGYucGFyc2Uocix0LGEsbixlLkdTVUIuc3VidCl9LGUuR1NVQi5zdWJ0PWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPWEsaT17fTtpZihpLmZtdD1vLnJlYWRVc2hvcnQocixhKSxhKz0yLDEhPXQmJjQhPXQmJjUhPXQmJjYhPXQpcmV0dXJuIG51bGw7aWYoMT09dHx8ND09dHx8NT09dCYmaS5mbXQ8PTJ8fDY9PXQmJmkuZm10PD0yKXt2YXIgaD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixzK2gpO31pZigxPT10JiZpLmZtdD49MSYmaS5mbXQ8PTIpe2lmKDE9PWkuZm10KWkuZGVsdGE9by5yZWFkU2hvcnQocixhKSxhKz0yO2Vsc2UgaWYoMj09aS5mbXQpe3ZhciBmPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5uZXdnPW8ucmVhZFVzaG9ydHMocixhLGYpLGErPTIqaS5uZXdnLmxlbmd0aDt9fWVsc2UgaWYoND09dCl7aS52YWxzPVtdO2Y9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IodmFyIGQ9MDtkPGY7ZCsrKXt2YXIgdT1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkudmFscy5wdXNoKGUuR1NVQi5yZWFkTGlnYXR1cmVTZXQocixzK3UpKTt9fWVsc2UgaWYoNT09dCYmMj09aS5mbXQpe2lmKDI9PWkuZm10KXt2YXIgbD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuY0RlZj1lLl9sY3RmLnJlYWRDbGFzc0RlZihyLHMrbCksaS5zY3NldD1bXTt2YXIgdj1vLnJlYWRVc2hvcnQocixhKTthKz0yO2ZvcihkPTA7ZDx2O2QrKyl7dmFyIGM9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLnNjc2V0LnB1c2goMD09Yz9udWxsOmUuR1NVQi5yZWFkU3ViQ2xhc3NTZXQocixzK2MpKTt9fX1lbHNlIGlmKDY9PXQmJjM9PWkuZm10KXtpZigzPT1pLmZtdCl7Zm9yKGQ9MDtkPDM7ZCsrKXtmPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7Zm9yKHZhciBwPVtdLFU9MDtVPGY7VSsrKXAucHVzaChlLl9sY3RmLnJlYWRDb3ZlcmFnZShyLHMrby5yZWFkVXNob3J0KHIsYSsyKlUpKSk7YSs9MipmLDA9PWQmJihpLmJhY2tDdmc9cCksMT09ZCYmKGkuaW5wdEN2Zz1wKSwyPT1kJiYoaS5haGVkQ3ZnPXApO31mPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5sb29rdXBSZWM9ZS5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHMocixhLGYpO319ZWxzZSB7aWYoNz09dCYmMT09aS5mbXQpe3ZhciBnPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIFM9by5yZWFkVWludChyLGEpO2lmKGErPTQsOT09bi5sdHlwZSluLmx0eXBlPWc7ZWxzZSBpZihuLmx0eXBlIT1nKXRocm93IFwiaW52YWxpZCBleHRlbnNpb24gc3Vic3RpdHV0aW9uXCI7cmV0dXJuIGUuR1NVQi5zdWJ0KHIsbi5sdHlwZSxzK1MpfWNvbnNvbGUuZGVidWcoXCJ1bnN1cHBvcnRlZCBHU1VCIHRhYmxlIExvb2t1cFR5cGVcIix0LFwiZm9ybWF0XCIsaS5mbXQpO31yZXR1cm4gaX0sZS5HU1VCLnJlYWRTdWJDbGFzc1NldD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2Jpbi5yZWFkVXNob3J0LG49dCxvPVtdLHM9YShyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YShyLHQpO3QrPTIsby5wdXNoKGUuR1NVQi5yZWFkU3ViQ2xhc3NSdWxlKHIsbitoKSk7fXJldHVybiBvfSxlLkdTVUIucmVhZFN1YkNsYXNzUnVsZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2Jpbi5yZWFkVXNob3J0LG49e30sbz1hKHIsdCkscz1hKHIsdCs9Mik7dCs9MixuLmlucHV0PVtdO2Zvcih2YXIgaT0wO2k8by0xO2krKyluLmlucHV0LnB1c2goYShyLHQpKSx0Kz0yO3JldHVybiBuLnN1YnN0TG9va3VwUmVjb3Jkcz1lLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3JkcyhyLHQscyksbn0sZS5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHM9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4ucmVhZFVzaG9ydCxvPVtdLHM9MDtzPGE7cysrKW8ucHVzaChuKHIsdCksbihyLHQrMikpLHQrPTQ7cmV0dXJuIG99LGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1NldD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz1bXSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnB1c2goZS5HU1VCLnJlYWRDaGFpblN1YkNsYXNzUnVsZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRDaGFpblN1YkNsYXNzUnVsZT1mdW5jdGlvbihyLHQpe2Zvcih2YXIgYT1lLl9iaW4sbj17fSxvPVtcImJhY2t0cmFja1wiLFwiaW5wdXRcIixcImxvb2thaGVhZFwiXSxzPTA7czxvLmxlbmd0aDtzKyspe3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsMT09cyYmaS0tLG5bb1tzXV09YS5yZWFkVXNob3J0cyhyLHQsaSksdCs9MipuW29bc11dLmxlbmd0aDt9aT1hLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixuLnN1YnN0PWEucmVhZFVzaG9ydHMocix0LDIqaSksdCs9MipuLnN1YnN0Lmxlbmd0aCxufSxlLkdTVUIucmVhZExpZ2F0dXJlU2V0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucHVzaChlLkdTVUIucmVhZExpZ2F0dXJlKHIsbitoKSk7fXJldHVybiBvfSxlLkdTVUIucmVhZExpZ2F0dXJlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e2NoYWluOltdfTtuLm5nbHlwaD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBzPTA7czxvLTE7cysrKW4uY2hhaW4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MjtyZXR1cm4gbn0sZS5oZWFkPXt9LGUuaGVhZC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307cmV0dXJuIG4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLmZvbnRSZXZpc2lvbj1uLnJlYWRGaXhlZChyLHQpLHQrPTQsbi5yZWFkVWludChyLHQpLHQrPTQsbi5yZWFkVWludChyLHQpLHQrPTQsby5mbGFncz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8udW5pdHNQZXJFbT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uY3JlYXRlZD1uLnJlYWRVaW50NjQocix0KSx0Kz04LG8ubW9kaWZpZWQ9bi5yZWFkVWludDY0KHIsdCksdCs9OCxvLnhNaW49bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueU1pbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby54TWF4PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnlNYXg9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubWFjU3R5bGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLmxvd2VzdFJlY1BQRU09bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLmZvbnREaXJlY3Rpb25IaW50PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmluZGV4VG9Mb2NGb3JtYXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uZ2x5cGhEYXRhRm9ybWF0PW4ucmVhZFNob3J0KHIsdCksdCs9MixvfSxlLmhoZWE9e30sZS5oaGVhLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtyZXR1cm4gbi5yZWFkRml4ZWQocix0KSx0Kz00LG8uYXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uZGVzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmxpbmVHYXA9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uYWR2YW5jZVdpZHRoTWF4PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5taW5MZWZ0U2lkZUJlYXJpbmc9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubWluUmlnaHRTaWRlQmVhcmluZz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby54TWF4RXh0ZW50PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmNhcmV0U2xvcGVSaXNlPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmNhcmV0U2xvcGVSdW49bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uY2FyZXRPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLHQrPTgsby5tZXRyaWNEYXRhRm9ybWF0PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm51bWJlck9mSE1ldHJpY3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvfSxlLmhtdHg9e30sZS5obXR4LnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe2Zvcih2YXIgbz1lLl9iaW4scz17YVdpZHRoOltdLGxzQmVhcmluZzpbXX0saT0wLGg9MCxmPTA7ZjxuLm1heHAubnVtR2x5cGhzO2YrKylmPG4uaGhlYS5udW1iZXJPZkhNZXRyaWNzJiYoaT1vLnJlYWRVc2hvcnQocix0KSx0Kz0yLGg9by5yZWFkU2hvcnQocix0KSx0Kz0yKSxzLmFXaWR0aC5wdXNoKGkpLHMubHNCZWFyaW5nLnB1c2goaCk7cmV0dXJuIHN9LGUua2Vybj17fSxlLmtlcm4ucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluLHM9by5yZWFkVXNob3J0KHIsdCk7aWYodCs9MiwxPT1zKXJldHVybiBlLmtlcm4ucGFyc2VWMShyLHQtMixhLG4pO3ZhciBpPW8ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBoPXtnbHlwaDE6W10scnZhbDpbXX0sZj0wO2Y8aTtmKyspe3QrPTI7YT1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPW8ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHU9ZD4+Pjg7aWYoMCE9KHUmPTE1KSl0aHJvdyBcInVua25vd24ga2VybiB0YWJsZSBmb3JtYXQ6IFwiK3U7dD1lLmtlcm4ucmVhZEZvcm1hdDAocix0LGgpO31yZXR1cm4gaH0sZS5rZXJuLnBhcnNlVjE9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluO28ucmVhZEZpeGVkKHIsdCksdCs9NDt2YXIgcz1vLnJlYWRVaW50KHIsdCk7dCs9NDtmb3IodmFyIGk9e2dseXBoMTpbXSxydmFsOltdfSxoPTA7aDxzO2grKyl7by5yZWFkVWludChyLHQpLHQrPTQ7dmFyIGY9by5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBkPWY+Pj44O2lmKDAhPShkJj0xNSkpdGhyb3cgXCJ1bmtub3duIGtlcm4gdGFibGUgZm9ybWF0OiBcIitkO3Q9ZS5rZXJuLnJlYWRGb3JtYXQwKHIsdCxpKTt9cmV0dXJuIGl9LGUua2Vybi5yZWFkRm9ybWF0MD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89LTEscz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yLG4ucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZWFkVXNob3J0KHIsdCksdCs9MixuLnJlYWRVc2hvcnQocix0KSx0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1uLnJlYWRTaG9ydChyLHQpO3QrPTIsaCE9byYmKGEuZ2x5cGgxLnB1c2goaCksYS5ydmFsLnB1c2goe2dseXBoMjpbXSx2YWxzOltdfSkpO3ZhciB1PWEucnZhbFthLnJ2YWwubGVuZ3RoLTFdO3UuZ2x5cGgyLnB1c2goZiksdS52YWxzLnB1c2goZCksbz1oO31yZXR1cm4gdH0sZS5sb2NhPXt9LGUubG9jYS5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1bXSxpPW4uaGVhZC5pbmRleFRvTG9jRm9ybWF0LGg9bi5tYXhwLm51bUdseXBocysxO2lmKDA9PWkpZm9yKHZhciBmPTA7ZjxoO2YrKylzLnB1c2goby5yZWFkVXNob3J0KHIsdCsoZjw8MSkpPDwxKTtpZigxPT1pKWZvcihmPTA7ZjxoO2YrKylzLnB1c2goby5yZWFkVWludChyLHQrKGY8PDIpKSk7cmV0dXJuIHN9LGUubWF4cD17fSxlLm1heHAucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9LHM9bi5yZWFkVWludChyLHQpO3JldHVybiB0Kz00LG8ubnVtR2x5cGhzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsNjU1MzY9PXMmJihvLm1heFBvaW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29udG91cnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvc2l0ZVBvaW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9zaXRlQ29udG91cnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFpvbmVzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhUd2lsaWdodFBvaW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4U3RvcmFnZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4RnVuY3Rpb25EZWZzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhJbnN0cnVjdGlvbkRlZnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFN0YWNrRWxlbWVudHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFNpemVPZkluc3RydWN0aW9ucz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9uZW50RWxlbWVudHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvbmVudERlcHRoPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIpLG99LGUubmFtZT17fSxlLm5hbWUucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O24ucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIHM9bi5yZWFkVXNob3J0KHIsdCk7dCs9MixuLnJlYWRVc2hvcnQocix0KTtmb3IodmFyIGksaD1bXCJjb3B5cmlnaHRcIixcImZvbnRGYW1pbHlcIixcImZvbnRTdWJmYW1pbHlcIixcIklEXCIsXCJmdWxsTmFtZVwiLFwidmVyc2lvblwiLFwicG9zdFNjcmlwdE5hbWVcIixcInRyYWRlbWFya1wiLFwibWFudWZhY3R1cmVyXCIsXCJkZXNpZ25lclwiLFwiZGVzY3JpcHRpb25cIixcInVybFZlbmRvclwiLFwidXJsRGVzaWduZXJcIixcImxpY2VuY2VcIixcImxpY2VuY2VVUkxcIixcIi0tLVwiLFwidHlwb0ZhbWlseU5hbWVcIixcInR5cG9TdWJmYW1pbHlOYW1lXCIsXCJjb21wYXRpYmxlRnVsbFwiLFwic2FtcGxlVGV4dFwiLFwicG9zdFNjcmlwdENJRFwiLFwid3dzRmFtaWx5TmFtZVwiLFwid3dzU3ViZmFtaWx5TmFtZVwiLFwibGlnaHRQYWxldHRlXCIsXCJkYXJrUGFsZXR0ZVwiXSxmPXQrPTIsZD0wO2Q8cztkKyspe3ZhciB1PW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGw9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBjPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHA9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgVT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBnLFM9aFtjXSxtPWYrMTIqcytVO2lmKDA9PXUpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMz09dSYmMD09bClnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSBpZigwPT1sKWc9bi5yZWFkQVNDSUkocixtLHApO2Vsc2UgaWYoMT09bClnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSBpZigzPT1sKWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIHtpZigxIT11KXRocm93IFwidW5rbm93biBlbmNvZGluZyBcIitsK1wiLCBwbGF0Zm9ybUlEOiBcIit1O2c9bi5yZWFkQVNDSUkocixtLHApLGNvbnNvbGUuZGVidWcoXCJyZWFkaW5nIHVua25vd24gTUFDIGVuY29kaW5nIFwiK2wrXCIgYXMgQVNDSUlcIik7fXZhciBiPVwicFwiK3UrXCIsXCIrdi50b1N0cmluZygxNik7bnVsbD09b1tiXSYmKG9bYl09e30pLG9bYl1bdm9pZCAwIT09Uz9TOmNdPWcsb1tiXS5fbGFuZz12O31mb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lJiYxMDMzPT1vW3ldLl9sYW5nKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUmJjA9PW9beV0uX2xhbmcpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSYmMzA4ND09b1t5XS5fbGFuZylyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKXtpPXk7YnJlYWt9cmV0dXJuIGNvbnNvbGUuZGVidWcoXCJyZXR1cm5pbmcgbmFtZSB0YWJsZSB3aXRoIGxhbmd1YWdlSUQgXCIrb1tpXS5fbGFuZyksb1tpXX0sZVtcIk9TLzJcIl09e30sZVtcIk9TLzJcIl0ucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2Jpbi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgbz17fTtpZigwPT1uKWVbXCJPUy8yXCJdLnZlcnNpb24wKHIsdCxvKTtlbHNlIGlmKDE9PW4pZVtcIk9TLzJcIl0udmVyc2lvbjEocix0LG8pO2Vsc2UgaWYoMj09bnx8Mz09bnx8ND09billW1wiT1MvMlwiXS52ZXJzaW9uMihyLHQsbyk7ZWxzZSB7aWYoNSE9bil0aHJvdyBcInVua25vd24gT1MvMiB0YWJsZSB2ZXJzaW9uOiBcIituO2VbXCJPUy8yXCJdLnZlcnNpb241KHIsdCxvKTt9cmV0dXJuIG99LGVbXCJPUy8yXCJdLnZlcnNpb24wPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIGEueEF2Z0NoYXJXaWR0aD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS51c1dlaWdodENsYXNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c1dpZHRoQ2xhc3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLmZzVHlwZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFhTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRZU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WE9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WU9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRYU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRZU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRYT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFlPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN0cmlrZW91dFNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN0cmlrZW91dFBvc2l0aW9uPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNGYW1pbHlDbGFzcz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5wYW5vc2U9bi5yZWFkQnl0ZXMocix0LDEwKSx0Kz0xMCxhLnVsVW5pY29kZVJhbmdlMT1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsVW5pY29kZVJhbmdlMj1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsVW5pY29kZVJhbmdlMz1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsVW5pY29kZVJhbmdlND1uLnJlYWRVaW50KHIsdCksdCs9NCxhLmFjaFZlbmRJRD1bbi5yZWFkSW50OChyLHQpLG4ucmVhZEludDgocix0KzEpLG4ucmVhZEludDgocix0KzIpLG4ucmVhZEludDgocix0KzMpXSx0Kz00LGEuZnNTZWxlY3Rpb249bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzRmlyc3RDaGFySW5kZXg9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzTGFzdENoYXJJbmRleD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEuc1R5cG9Bc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zVHlwb0Rlc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zVHlwb0xpbmVHYXA9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEudXNXaW5Bc2NlbnQ9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzV2luRGVzY2VudD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yfSxlW1wiT1MvMlwiXS52ZXJzaW9uMT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiB0PWVbXCJPUy8yXCJdLnZlcnNpb24wKHIsdCxhKSxhLnVsQ29kZVBhZ2VSYW5nZTE9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bENvZGVQYWdlUmFuZ2UyPW4ucmVhZFVpbnQocix0KSx0Kz00fSxlW1wiT1MvMlwiXS52ZXJzaW9uMj1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiB0PWVbXCJPUy8yXCJdLnZlcnNpb24xKHIsdCxhKSxhLnN4SGVpZ2h0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNDYXBIZWlnaHQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEudXNEZWZhdWx0PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0JyZWFrPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c01heENvbnRleHQ9bi5yZWFkVXNob3J0KHIsdCksdCs9Mn0sZVtcIk9TLzJcIl0udmVyc2lvbjU9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMihyLHQsYSksYS51c0xvd2VyT3B0aWNhbFBvaW50U2l6ZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNVcHBlck9wdGljYWxQb2ludFNpemU9bi5yZWFkVXNob3J0KHIsdCksdCs9Mn0sZS5wb3N0PXt9LGUucG9zdC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307cmV0dXJuIG8udmVyc2lvbj1uLnJlYWRGaXhlZChyLHQpLHQrPTQsby5pdGFsaWNBbmdsZT1uLnJlYWRGaXhlZChyLHQpLHQrPTQsby51bmRlcmxpbmVQb3NpdGlvbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby51bmRlcmxpbmVUaGlja25lc3M9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG99LG51bGw9PWUmJihlPXt9KSxudWxsPT1lLlUmJihlLlU9e30pLGUuVS5jb2RlVG9HbHlwaD1mdW5jdGlvbihyLGUpe3ZhciB0PXIuY21hcCxhPS0xO2lmKG51bGwhPXQucDBlND9hPXQucDBlNDpudWxsIT10LnAzZTE/YT10LnAzZTE6bnVsbCE9dC5wMWUwP2E9dC5wMWUwOm51bGwhPXQucDBlMyYmKGE9dC5wMGUzKSwtMT09YSl0aHJvdyBcIm5vIGZhbWlsaWFyIHBsYXRmb3JtIGFuZCBlbmNvZGluZyFcIjt2YXIgbj10LnRhYmxlc1thXTtpZigwPT1uLmZvcm1hdClyZXR1cm4gZT49bi5tYXAubGVuZ3RoPzA6bi5tYXBbZV07aWYoND09bi5mb3JtYXQpe2Zvcih2YXIgbz0tMSxzPTA7czxuLmVuZENvdW50Lmxlbmd0aDtzKyspaWYoZTw9bi5lbmRDb3VudFtzXSl7bz1zO2JyZWFrfWlmKC0xPT1vKXJldHVybiAwO2lmKG4uc3RhcnRDb3VudFtvXT5lKXJldHVybiAwO3JldHVybiA2NTUzNSYoMCE9bi5pZFJhbmdlT2Zmc2V0W29dP24uZ2x5cGhJZEFycmF5W2Utbi5zdGFydENvdW50W29dKyhuLmlkUmFuZ2VPZmZzZXRbb10+PjEpLShuLmlkUmFuZ2VPZmZzZXQubGVuZ3RoLW8pXTplK24uaWREZWx0YVtvXSl9aWYoMTI9PW4uZm9ybWF0KXtpZihlPm4uZ3JvdXBzW24uZ3JvdXBzLmxlbmd0aC0xXVsxXSlyZXR1cm4gMDtmb3Iocz0wO3M8bi5ncm91cHMubGVuZ3RoO3MrKyl7dmFyIGk9bi5ncm91cHNbc107aWYoaVswXTw9ZSYmZTw9aVsxXSlyZXR1cm4gaVsyXSsoZS1pWzBdKX1yZXR1cm4gMH10aHJvdyBcInVua25vd24gY21hcCB0YWJsZSBmb3JtYXQgXCIrbi5mb3JtYXR9LGUuVS5nbHlwaFRvUGF0aD1mdW5jdGlvbihyLHQpe3ZhciBhPXtjbWRzOltdLGNyZHM6W119O2lmKHIuU1ZHJiZyLlNWRy5lbnRyaWVzW3RdKXt2YXIgbj1yLlNWRy5lbnRyaWVzW3RdO3JldHVybiBudWxsPT1uP2E6KFwic3RyaW5nXCI9PXR5cGVvZiBuJiYobj1lLlNWRy50b1BhdGgobiksci5TVkcuZW50cmllc1t0XT1uKSxuKX1pZihyLkNGRil7dmFyIG89e3g6MCx5OjAsc3RhY2s6W10sblN0ZW1zOjAsaGF2ZVdpZHRoOiExLHdpZHRoOnIuQ0ZGLlByaXZhdGU/ci5DRkYuUHJpdmF0ZS5kZWZhdWx0V2lkdGhYOjAsb3BlbjohMX0scz1yLkNGRixpPXIuQ0ZGLlByaXZhdGU7aWYocy5ST1Mpe2Zvcih2YXIgaD0wO3MuRkRTZWxlY3RbaCsyXTw9dDspaCs9MjtpPXMuRkRBcnJheVtzLkZEU2VsZWN0W2grMV1dLlByaXZhdGU7fWUuVS5fZHJhd0NGRihyLkNGRi5DaGFyU3RyaW5nc1t0XSxvLHMsaSxhKTt9ZWxzZSByLmdseWYmJmUuVS5fZHJhd0dseWYodCxyLGEpO3JldHVybiBhfSxlLlUuX2RyYXdHbHlmPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj10LmdseWZbcl07bnVsbD09biYmKG49dC5nbHlmW3JdPWUuZ2x5Zi5fcGFyc2VHbHlmKHQscikpLG51bGwhPW4mJihuLm5vYz4tMT9lLlUuX3NpbXBsZUdseXBoKG4sYSk6ZS5VLl9jb21wb0dseXBoKG4sdCxhKSk7fSxlLlUuX3NpbXBsZUdseXBoPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBhPTA7YTxyLm5vYzthKyspe2Zvcih2YXIgbj0wPT1hPzA6ci5lbmRQdHNbYS0xXSsxLG89ci5lbmRQdHNbYV0scz1uO3M8PW87cysrKXt2YXIgaT1zPT1uP286cy0xLGg9cz09bz9uOnMrMSxmPTEmci5mbGFnc1tzXSxkPTEmci5mbGFnc1tpXSx1PTEmci5mbGFnc1toXSxsPXIueHNbc10sdj1yLnlzW3NdO2lmKHM9PW4paWYoZil7aWYoIWQpe2UuVS5QLm1vdmVUbyh0LGwsdik7Y29udGludWV9ZS5VLlAubW92ZVRvKHQsci54c1tpXSxyLnlzW2ldKTt9ZWxzZSBkP2UuVS5QLm1vdmVUbyh0LHIueHNbaV0sci55c1tpXSk6ZS5VLlAubW92ZVRvKHQsKHIueHNbaV0rbCkvMiwoci55c1tpXSt2KS8yKTtmP2QmJmUuVS5QLmxpbmVUbyh0LGwsdik6dT9lLlUuUC5xY3VydmVUbyh0LGwsdixyLnhzW2hdLHIueXNbaF0pOmUuVS5QLnFjdXJ2ZVRvKHQsbCx2LChsK3IueHNbaF0pLzIsKHYrci55c1toXSkvMik7fWUuVS5QLmNsb3NlUGF0aCh0KTt9fSxlLlUuX2NvbXBvR2x5cGg9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj0wO248ci5wYXJ0cy5sZW5ndGg7bisrKXt2YXIgbz17Y21kczpbXSxjcmRzOltdfSxzPXIucGFydHNbbl07ZS5VLl9kcmF3R2x5ZihzLmdseXBoSW5kZXgsdCxvKTtmb3IodmFyIGk9cy5tLGg9MDtoPG8uY3Jkcy5sZW5ndGg7aCs9Mil7dmFyIGY9by5jcmRzW2hdLGQ9by5jcmRzW2grMV07YS5jcmRzLnB1c2goZippLmErZCppLmIraS50eCksYS5jcmRzLnB1c2goZippLmMrZCppLmQraS50eSk7fWZvcihoPTA7aDxvLmNtZHMubGVuZ3RoO2grKylhLmNtZHMucHVzaChvLmNtZHNbaF0pO319LGUuVS5fZ2V0R2x5cGhDbGFzcz1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2xjdGYuZ2V0SW50ZXJ2YWwodCxyKTtyZXR1cm4gLTE9PWE/MDp0W2ErMl19LGUuVS5nZXRQYWlyQWRqdXN0bWVudD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ITE7aWYoci5HUE9TKWZvcih2YXIgbz1yLkdQT1Mscz1vLmxvb2t1cExpc3QsaT1vLmZlYXR1cmVMaXN0LGg9W10sZj0wO2Y8aS5sZW5ndGg7ZisrKXt2YXIgZD1pW2ZdO2lmKFwia2VyblwiPT1kLnRhZyl7bj0hMDtmb3IodmFyIHU9MDt1PGQudGFiLmxlbmd0aDt1KyspaWYoIWhbZC50YWJbdV1dKXtoW2QudGFiW3VdXT0hMDtmb3IodmFyIGw9c1tkLnRhYlt1XV0sdj0wO3Y8bC50YWJzLmxlbmd0aDt2KyspaWYobnVsbCE9bC50YWJzW3ZdKXt2YXIgYyxwPWwudGFic1t2XTtpZighcC5jb3ZlcmFnZXx8LTEhPShjPWUuX2xjdGYuY292ZXJhZ2VJbmRleChwLmNvdmVyYWdlLHQpKSlpZigxPT1sLmx0eXBlKTtlbHNlIGlmKDI9PWwubHR5cGUpe3ZhciBVPW51bGw7aWYoMT09cC5mbXQpe3ZhciBnPXAucGFpcnNldHNbY107Zm9yKGY9MDtmPGcubGVuZ3RoO2YrKylnW2ZdLmdpZDI9PWEmJihVPWdbZl0pO31lbHNlIGlmKDI9PXAuZm10KXt2YXIgUz1lLlUuX2dldEdseXBoQ2xhc3ModCxwLmNsYXNzRGVmMSksbT1lLlUuX2dldEdseXBoQ2xhc3MoYSxwLmNsYXNzRGVmMik7VT1wLm1hdHJpeFtTXVttXTt9aWYoVSl7dmFyIGI9MDtyZXR1cm4gVS52YWwxJiZVLnZhbDFbMl0mJihiKz1VLnZhbDFbMl0pLFUudmFsMiYmVS52YWwyWzBdJiYoYis9VS52YWwyWzBdKSxifX19fX19aWYoci5rZXJuJiYhbil7dmFyIHk9ci5rZXJuLmdseXBoMS5pbmRleE9mKHQpO2lmKC0xIT15KXt2YXIgRj1yLmtlcm4ucnZhbFt5XS5nbHlwaDIuaW5kZXhPZihhKTtpZigtMSE9RilyZXR1cm4gci5rZXJuLnJ2YWxbeV0udmFsc1tGXX19cmV0dXJuIDB9LGUuVS5fYXBwbHlTdWJzPWZ1bmN0aW9uKHIsdCxhLG4pe2Zvcih2YXIgbz1yLmxlbmd0aC10LTEscz0wO3M8YS50YWJzLmxlbmd0aDtzKyspaWYobnVsbCE9YS50YWJzW3NdKXt2YXIgaSxoPWEudGFic1tzXTtpZighaC5jb3ZlcmFnZXx8LTEhPShpPWUuX2xjdGYuY292ZXJhZ2VJbmRleChoLmNvdmVyYWdlLHJbdF0pKSlpZigxPT1hLmx0eXBlKXJbdF0sMT09aC5mbXQ/clt0XT1yW3RdK2guZGVsdGE6clt0XT1oLm5ld2dbaV07ZWxzZSBpZig0PT1hLmx0eXBlKWZvcih2YXIgZj1oLnZhbHNbaV0sZD0wO2Q8Zi5sZW5ndGg7ZCsrKXt2YXIgdT1mW2RdLGw9dS5jaGFpbi5sZW5ndGg7aWYoIShsPm8pKXtmb3IodmFyIHY9ITAsYz0wLHA9MDtwPGw7cCsrKXtmb3IoOy0xPT1yW3QrYysoMStwKV07KWMrKzt1LmNoYWluW3BdIT1yW3QrYysoMStwKV0mJih2PSExKTt9aWYodil7clt0XT11Lm5nbHlwaDtmb3IocD0wO3A8bCtjO3ArKylyW3QrcCsxXT0tMTticmVha319fWVsc2UgaWYoNT09YS5sdHlwZSYmMj09aC5mbXQpZm9yKHZhciBVPWUuX2xjdGYuZ2V0SW50ZXJ2YWwoaC5jRGVmLHJbdF0pLGc9aC5jRGVmW1UrMl0sUz1oLnNjc2V0W2ddLG09MDttPFMubGVuZ3RoO20rKyl7dmFyIGI9U1ttXSx5PWIuaW5wdXQ7aWYoISh5Lmxlbmd0aD5vKSl7Zm9yKHY9ITAscD0wO3A8eS5sZW5ndGg7cCsrKXt2YXIgRj1lLl9sY3RmLmdldEludGVydmFsKGguY0RlZixyW3QrMStwXSk7aWYoLTE9PVUmJmguY0RlZltGKzJdIT15W3BdKXt2PSExO2JyZWFrfX1pZih2KXt2YXIgXz1iLnN1YnN0TG9va3VwUmVjb3Jkcztmb3IoZD0wO2Q8Xy5sZW5ndGg7ZCs9MilfW2RdLF9bZCsxXTt9fX1lbHNlIGlmKDY9PWEubHR5cGUmJjM9PWguZm10KXtpZighZS5VLl9nbHNDb3ZlcmVkKHIsaC5iYWNrQ3ZnLHQtaC5iYWNrQ3ZnLmxlbmd0aCkpY29udGludWU7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguaW5wdEN2Zyx0KSljb250aW51ZTtpZighZS5VLl9nbHNDb3ZlcmVkKHIsaC5haGVkQ3ZnLHQraC5pbnB0Q3ZnLmxlbmd0aCkpY29udGludWU7dmFyIEM9aC5sb29rdXBSZWM7Zm9yKG09MDttPEMubGVuZ3RoO20rPTIpe1U9Q1ttXTt2YXIgeD1uW0NbbSsxXV07ZS5VLl9hcHBseVN1YnMocix0K1UseCxuKTt9fX19LGUuVS5fZ2xzQ292ZXJlZD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe2lmKC0xPT1lLl9sY3RmLmNvdmVyYWdlSW5kZXgodFtuXSxyW2Erbl0pKXJldHVybiAhMX1yZXR1cm4gITB9LGUuVS5nbHlwaHNUb1BhdGg9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj17Y21kczpbXSxjcmRzOltdfSxvPTAscz0wO3M8dC5sZW5ndGg7cysrKXt2YXIgaT10W3NdO2lmKC0xIT1pKXtmb3IodmFyIGg9czx0Lmxlbmd0aC0xJiYtMSE9dFtzKzFdP3RbcysxXTowLGY9ZS5VLmdseXBoVG9QYXRoKHIsaSksZD0wO2Q8Zi5jcmRzLmxlbmd0aDtkKz0yKW4uY3Jkcy5wdXNoKGYuY3Jkc1tkXStvKSxuLmNyZHMucHVzaChmLmNyZHNbZCsxXSk7YSYmbi5jbWRzLnB1c2goYSk7Zm9yKGQ9MDtkPGYuY21kcy5sZW5ndGg7ZCsrKW4uY21kcy5wdXNoKGYuY21kc1tkXSk7YSYmbi5jbWRzLnB1c2goXCJYXCIpLG8rPXIuaG10eC5hV2lkdGhbaV0sczx0Lmxlbmd0aC0xJiYobys9ZS5VLmdldFBhaXJBZGp1c3RtZW50KHIsaSxoKSk7fX1yZXR1cm4gbn0sZS5VLlA9e30sZS5VLlAubW92ZVRvPWZ1bmN0aW9uKHIsZSx0KXtyLmNtZHMucHVzaChcIk1cIiksci5jcmRzLnB1c2goZSx0KTt9LGUuVS5QLmxpbmVUbz1mdW5jdGlvbihyLGUsdCl7ci5jbWRzLnB1c2goXCJMXCIpLHIuY3Jkcy5wdXNoKGUsdCk7fSxlLlUuUC5jdXJ2ZVRvPWZ1bmN0aW9uKHIsZSx0LGEsbixvLHMpe3IuY21kcy5wdXNoKFwiQ1wiKSxyLmNyZHMucHVzaChlLHQsYSxuLG8scyk7fSxlLlUuUC5xY3VydmVUbz1mdW5jdGlvbihyLGUsdCxhLG4pe3IuY21kcy5wdXNoKFwiUVwiKSxyLmNyZHMucHVzaChlLHQsYSxuKTt9LGUuVS5QLmNsb3NlUGF0aD1mdW5jdGlvbihyKXtyLmNtZHMucHVzaChcIlpcIik7fSxlLlUuX2RyYXdDRkY9ZnVuY3Rpb24ocix0LGEsbixvKXtmb3IodmFyIHM9dC5zdGFjayxpPXQublN0ZW1zLGg9dC5oYXZlV2lkdGgsZj10LndpZHRoLGQ9dC5vcGVuLHU9MCxsPXQueCx2PXQueSxjPTAscD0wLFU9MCxnPTAsUz0wLG09MCxiPTAseT0wLEY9MCxfPTAsQz17dmFsOjAsc2l6ZTowfTt1PHIubGVuZ3RoOyl7ZS5DRkYuZ2V0Q2hhclN0cmluZyhyLHUsQyk7dmFyIHg9Qy52YWw7aWYodSs9Qy5zaXplLFwibzFcIj09eHx8XCJvMThcIj09eClzLmxlbmd0aCUyIT0wJiYhaCYmKGY9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCksaSs9cy5sZW5ndGg+PjEscy5sZW5ndGg9MCxoPSEwO2Vsc2UgaWYoXCJvM1wiPT14fHxcIm8yM1wiPT14KXtzLmxlbmd0aCUyIT0wJiYhaCYmKGY9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCksaSs9cy5sZW5ndGg+PjEscy5sZW5ndGg9MCxoPSEwO31lbHNlIGlmKFwibzRcIj09eClzLmxlbmd0aD4xJiYhaCYmKGY9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCxoPSEwKSxkJiZlLlUuUC5jbG9zZVBhdGgobyksdis9cy5wb3AoKSxlLlUuUC5tb3ZlVG8obyxsLHYpLGQ9ITA7ZWxzZSBpZihcIm81XCI9PXgpZm9yKDtzLmxlbmd0aD4wOylsKz1zLnNoaWZ0KCksdis9cy5zaGlmdCgpLGUuVS5QLmxpbmVUbyhvLGwsdik7ZWxzZSBpZihcIm82XCI9PXh8fFwibzdcIj09eClmb3IodmFyIFA9cy5sZW5ndGgsST1cIm82XCI9PXgsdz0wO3c8UDt3Kyspe3ZhciBPPXMuc2hpZnQoKTtJP2wrPU86dis9TyxJPSFJLGUuVS5QLmxpbmVUbyhvLGwsdik7fWVsc2UgaWYoXCJvOFwiPT14fHxcIm8yNFwiPT14KXtQPXMubGVuZ3RoO2Zvcih2YXIgVD0wO1QrNjw9UDspYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHY9ZytzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KSxUKz02O1wibzI0XCI9PXgmJihsKz1zLnNoaWZ0KCksdis9cy5zaGlmdCgpLGUuVS5QLmxpbmVUbyhvLGwsdikpO31lbHNlIHtpZihcIm8xMVwiPT14KWJyZWFrO2lmKFwibzEyMzRcIj09eHx8XCJvMTIzNVwiPT14fHxcIm8xMjM2XCI9PXh8fFwibzEyMzdcIj09eClcIm8xMjM0XCI9PXgmJihwPXYsVT0oYz1sK3Muc2hpZnQoKSkrcy5zaGlmdCgpLF89Zz1wK3Muc2hpZnQoKSxtPWcseT12LGw9KGI9KFM9KEY9VStzLnNoaWZ0KCkpK3Muc2hpZnQoKSkrcy5zaGlmdCgpKStzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixfKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKSxcIm8xMjM1XCI9PXgmJihjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLEY9VStzLnNoaWZ0KCksXz1nK3Muc2hpZnQoKSxTPUYrcy5zaGlmdCgpLG09XytzLnNoaWZ0KCksYj1TK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLGw9YitzLnNoaWZ0KCksdj15K3Muc2hpZnQoKSxzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixfKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKSxcIm8xMjM2XCI9PXgmJihjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxfPWc9cCtzLnNoaWZ0KCksbT1nLGI9KFM9KEY9VStzLnNoaWZ0KCkpK3Muc2hpZnQoKSkrcy5zaGlmdCgpLHk9bStzLnNoaWZ0KCksbD1iK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLF8pLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpLFwibzEyMzdcIj09eCYmKGM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksRj1VK3Muc2hpZnQoKSxfPWcrcy5zaGlmdCgpLFM9RitzLnNoaWZ0KCksbT1fK3Muc2hpZnQoKSxiPVMrcy5zaGlmdCgpLHk9bStzLnNoaWZ0KCksTWF0aC5hYnMoYi1sKT5NYXRoLmFicyh5LXYpP2w9YitzLnNoaWZ0KCk6dj15K3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLF8pLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpO2Vsc2UgaWYoXCJvMTRcIj09eCl7aWYocy5sZW5ndGg+MCYmIWgmJihmPXMuc2hpZnQoKSthLm5vbWluYWxXaWR0aFgsaD0hMCksND09cy5sZW5ndGgpe3ZhciBrPXMuc2hpZnQoKSxHPXMuc2hpZnQoKSxEPXMuc2hpZnQoKSxCPXMuc2hpZnQoKSxMPWUuQ0ZGLmdseXBoQnlTRShhLEQpLFI9ZS5DRkYuZ2x5cGhCeVNFKGEsQik7ZS5VLl9kcmF3Q0ZGKGEuQ2hhclN0cmluZ3NbTF0sdCxhLG4sbyksdC54PWssdC55PUcsZS5VLl9kcmF3Q0ZGKGEuQ2hhclN0cmluZ3NbUl0sdCxhLG4sbyk7fWQmJihlLlUuUC5jbG9zZVBhdGgobyksZD0hMSk7fWVsc2UgaWYoXCJvMTlcIj09eHx8XCJvMjBcIj09eCl7cy5sZW5ndGglMiE9MCYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMCx1Kz1pKzc+PjM7fWVsc2UgaWYoXCJvMjFcIj09eClzLmxlbmd0aD4yJiYhaCYmKGY9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCxoPSEwKSx2Kz1zLnBvcCgpLGwrPXMucG9wKCksZCYmZS5VLlAuY2xvc2VQYXRoKG8pLGUuVS5QLm1vdmVUbyhvLGwsdiksZD0hMDtlbHNlIGlmKFwibzIyXCI9PXgpcy5sZW5ndGg+MSYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksbCs9cy5wb3AoKSxkJiZlLlUuUC5jbG9zZVBhdGgobyksZS5VLlAubW92ZVRvKG8sbCx2KSxkPSEwO2Vsc2UgaWYoXCJvMjVcIj09eCl7Zm9yKDtzLmxlbmd0aD42OylsKz1zLnNoaWZ0KCksdis9cy5zaGlmdCgpLGUuVS5QLmxpbmVUbyhvLGwsdik7Yz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHY9ZytzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KTt9ZWxzZSBpZihcIm8yNlwiPT14KWZvcihzLmxlbmd0aCUyJiYobCs9cy5zaGlmdCgpKTtzLmxlbmd0aD4wOyljPWwscD12K3Muc2hpZnQoKSxsPVU9YytzLnNoaWZ0KCksdj0oZz1wK3Muc2hpZnQoKSkrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7ZWxzZSBpZihcIm8yN1wiPT14KWZvcihzLmxlbmd0aCUyJiYodis9cy5zaGlmdCgpKTtzLmxlbmd0aD4wOylwPXYsVT0oYz1sK3Muc2hpZnQoKSkrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcsZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KTtlbHNlIGlmKFwibzEwXCI9PXh8fFwibzI5XCI9PXgpe3ZhciBBPVwibzEwXCI9PXg/bjphO2lmKDA9PXMubGVuZ3RoKWNvbnNvbGUuZGVidWcoXCJlcnJvcjogZW1wdHkgc3RhY2tcIik7ZWxzZSB7dmFyIFc9cy5wb3AoKSxNPUEuU3VicnNbVytBLkJpYXNdO3QueD1sLHQueT12LHQublN0ZW1zPWksdC5oYXZlV2lkdGg9aCx0LndpZHRoPWYsdC5vcGVuPWQsZS5VLl9kcmF3Q0ZGKE0sdCxhLG4sbyksbD10Lngsdj10LnksaT10Lm5TdGVtcyxoPXQuaGF2ZVdpZHRoLGY9dC53aWR0aCxkPXQub3Blbjt9fWVsc2UgaWYoXCJvMzBcIj09eHx8XCJvMzFcIj09eCl7dmFyIFY9cy5sZW5ndGgsTj0oVD0wLFwibzMxXCI9PXgpO2ZvcihUKz1WLShQPS0zJlYpO1Q8UDspTj8ocD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSx2PShnPXArcy5zaGlmdCgpKStzLnNoaWZ0KCksUC1UPT01PyhsPVUrcy5zaGlmdCgpLFQrKyk6bD1VLE49ITEpOihjPWwscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSxQLVQ9PTU/KHY9ZytzLnNoaWZ0KCksVCsrKTp2PWcsTj0hMCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KSxUKz00O31lbHNlIHtpZihcIm9cIj09KHgrXCJcIikuY2hhckF0KDApKXRocm93IGNvbnNvbGUuZGVidWcoXCJVbmtub3duIG9wZXJhdGlvbjogXCIreCxyKSx4O3MucHVzaCh4KTt9fX10Lng9bCx0Lnk9dix0Lm5TdGVtcz1pLHQuaGF2ZVdpZHRoPWgsdC53aWR0aD1mLHQub3Blbj1kO307dmFyIHQ9ZSxhPXtUeXByOnR9O3JldHVybiByLlR5cHI9dCxyLmRlZmF1bHQ9YSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyfSh7fSkuVHlwcn1cblxuLyohXG5DdXN0b20gYnVuZGxlIG9mIHdvZmYyb3RmIChodHRwczovL2dpdGh1Yi5jb20vYXJ0eS1uYW1lL3dvZmYyb3RmKSB3aXRoIGZmbGF0ZVxuKGh0dHBzOi8vZ2l0aHViLmNvbS8xMDFhcnJvd3ovZmZsYXRlKSBmb3IgdXNlIGluIFRyb2lrYSB0ZXh0IHJlbmRlcmluZy4gXG5PcmlnaW5hbCBsaWNlbnNlcyBhcHBseTogXG4tIGZmbGF0ZTogaHR0cHM6Ly9naXRodWIuY29tLzEwMWFycm93ei9mZmxhdGUvYmxvYi9tYXN0ZXIvTElDRU5TRSAoTUlUKVxuLSB3b2ZmMm90Zi5qczogaHR0cHM6Ly9naXRodWIuY29tL2FydHktbmFtZS93b2ZmMm90Zi9ibG9iL21hc3Rlci93b2ZmMm90Zi5qcyAoQXBhY2hlMilcbiovXG5mdW5jdGlvbiB3b2ZmMm90ZkZhY3RvcnkoKXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIGU9VWludDhBcnJheSxuPVVpbnQxNkFycmF5LHQ9VWludDMyQXJyYXksYT1uZXcgZShbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwLDAsMCwwXSksaT1uZXcgZShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdKSxvPW5ldyBlKFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksZj1mdW5jdGlvbihyLGUpe2Zvcih2YXIgYT1uZXcgbigzMSksaT0wO2k8MzE7KytpKWFbaV09ZSs9MTw8cltpLTFdO3ZhciBvPW5ldyB0KGFbMzBdKTtmb3IoaT0xO2k8MzA7KytpKWZvcih2YXIgZj1hW2ldO2Y8YVtpKzFdOysrZilvW2ZdPWYtYVtpXTw8NXxpO3JldHVybiBbYSxvXX0sdT1mKGEsMiksdj11WzBdLHM9dVsxXTt2WzI4XT0yNTgsc1syNThdPTI4O2Zvcih2YXIgbD1mKGksMClbMF0sYz1uZXcgbigzMjc2OCksZz0wO2c8MzI3Njg7KytnKXt2YXIgaD0oNDM2OTAmZyk+Pj4xfCgyMTg0NSZnKTw8MTtoPSg2MTY4MCYoaD0oNTI0MjgmaCk+Pj4yfCgxMzEwNyZoKTw8MikpPj4+NHwoMzg1NSZoKTw8NCxjW2ddPSgoNjUyODAmaCk+Pj44fCgyNTUmaCk8PDgpPj4+MTt9dmFyIHc9ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1yLmxlbmd0aCxpPTAsbz1uZXcgbihlKTtpPGE7KytpKSsrb1tyW2ldLTFdO3ZhciBmLHU9bmV3IG4oZSk7Zm9yKGk9MDtpPGU7KytpKXVbaV09dVtpLTFdK29baS0xXTw8MTtpZih0KXtmPW5ldyBuKDE8PGUpO3ZhciB2PTE1LWU7Zm9yKGk9MDtpPGE7KytpKWlmKHJbaV0pZm9yKHZhciBzPWk8PDR8cltpXSxsPWUtcltpXSxnPXVbcltpXS0xXSsrPDxsLGg9Z3woMTw8bCktMTtnPD1oOysrZylmW2NbZ10+Pj52XT1zO31lbHNlIGZvcihmPW5ldyBuKGEpLGk9MDtpPGE7KytpKXJbaV0mJihmW2ldPWNbdVtyW2ldLTFdKytdPj4+MTUtcltpXSk7cmV0dXJuIGZ9LGQ9bmV3IGUoMjg4KTtmb3IoZz0wO2c8MTQ0OysrZylkW2ddPTg7Zm9yKGc9MTQ0O2c8MjU2OysrZylkW2ddPTk7Zm9yKGc9MjU2O2c8MjgwOysrZylkW2ddPTc7Zm9yKGc9MjgwO2c8Mjg4OysrZylkW2ddPTg7dmFyIG09bmV3IGUoMzIpO2ZvcihnPTA7ZzwzMjsrK2cpbVtnXT01O3ZhciBiPXcoZCw5LDEpLHA9dyhtLDUsMSkseT1mdW5jdGlvbihyKXtmb3IodmFyIGU9clswXSxuPTE7bjxyLmxlbmd0aDsrK24pcltuXT5lJiYoZT1yW25dKTtyZXR1cm4gZX0sTD1mdW5jdGlvbihyLGUsbil7dmFyIHQ9ZS84fDA7cmV0dXJuIChyW3RdfHJbdCsxXTw8OCk+Pig3JmUpJm59LFU9ZnVuY3Rpb24ocixlKXt2YXIgbj1lLzh8MDtyZXR1cm4gKHJbbl18cltuKzFdPDw4fHJbbisyXTw8MTYpPj4oNyZlKX0saz1bXCJ1bmV4cGVjdGVkIEVPRlwiLFwiaW52YWxpZCBibG9jayB0eXBlXCIsXCJpbnZhbGlkIGxlbmd0aC9saXRlcmFsXCIsXCJpbnZhbGlkIGRpc3RhbmNlXCIsXCJzdHJlYW0gZmluaXNoZWRcIixcIm5vIHN0cmVhbSBoYW5kbGVyXCIsLFwibm8gY2FsbGJhY2tcIixcImludmFsaWQgVVRGLTggZGF0YVwiLFwiZXh0cmEgZmllbGQgdG9vIGxvbmdcIixcImRhdGUgbm90IGluIHJhbmdlIDE5ODAtMjA5OVwiLFwiZmlsZW5hbWUgdG9vIGxvbmdcIixcInN0cmVhbSBmaW5pc2hpbmdcIixcImludmFsaWQgemlwIGRhdGFcIl0sVD1mdW5jdGlvbihyLGUsbil7dmFyIHQ9bmV3IEVycm9yKGV8fGtbcl0pO2lmKHQuY29kZT1yLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0LFQpLCFuKXRocm93IHQ7cmV0dXJuIHR9LE89ZnVuY3Rpb24ocixmLHUpe3ZhciBzPXIubGVuZ3RoO2lmKCFzfHx1JiYhdS5sJiZzPDUpcmV0dXJuIGZ8fG5ldyBlKDApO3ZhciBjPSFmfHx1LGc9IXV8fHUuaTt1fHwodT17fSksZnx8KGY9bmV3IGUoMypzKSk7dmFyIGgsZD1mdW5jdGlvbihyKXt2YXIgbj1mLmxlbmd0aDtpZihyPm4pe3ZhciB0PW5ldyBlKE1hdGgubWF4KDIqbixyKSk7dC5zZXQoZiksZj10O319LG09dS5mfHwwLGs9dS5wfHwwLE89dS5ifHwwLEE9dS5sLHg9dS5kLEU9dS5tLEQ9dS5uLE09OCpzO2Rve2lmKCFBKXt1LmY9bT1MKHIsaywxKTt2YXIgUz1MKHIsaysxLDMpO2lmKGsrPTMsIVMpe3ZhciBWPXJbKEk9KChoPWspLzh8MCkrKDcmaCYmMSkrNCktNF18cltJLTNdPDw4LF89SStWO2lmKF8+cyl7ZyYmVCgwKTticmVha31jJiZkKE8rViksZi5zZXQoci5zdWJhcnJheShJLF8pLE8pLHUuYj1PKz1WLHUucD1rPTgqXztjb250aW51ZX1pZigxPT1TKUE9Yix4PXAsRT05LEQ9NTtlbHNlIGlmKDI9PVMpe3ZhciBqPUwocixrLDMxKSsyNTcsej1MKHIsaysxMCwxNSkrNCxDPWorTChyLGsrNSwzMSkrMTtrKz0xNDtmb3IodmFyIEY9bmV3IGUoQyksUD1uZXcgZSgxOSkscT0wO3E8ejsrK3EpUFtvW3FdXT1MKHIsayszKnEsNyk7ays9Myp6O3ZhciBCPXkoUCksRz0oMTw8QiktMSxIPXcoUCxCLDEpO2ZvcihxPTA7cTxDOyl7dmFyIEksSj1IW0wocixrLEcpXTtpZihrKz0xNSZKLChJPUo+Pj40KTwxNilGW3ErK109STtlbHNlIHt2YXIgSz0wLE49MDtmb3IoMTY9PUk/KE49MytMKHIsaywzKSxrKz0yLEs9RltxLTFdKToxNz09ST8oTj0zK0wocixrLDcpLGsrPTMpOjE4PT1JJiYoTj0xMStMKHIsaywxMjcpLGsrPTcpO04tLTspRltxKytdPUs7fX12YXIgUT1GLnN1YmFycmF5KDAsaiksUj1GLnN1YmFycmF5KGopO0U9eShRKSxEPXkoUiksQT13KFEsRSwxKSx4PXcoUixELDEpO31lbHNlIFQoMSk7aWYoaz5NKXtnJiZUKDApO2JyZWFrfX1jJiZkKE8rMTMxMDcyKTtmb3IodmFyIFc9KDE8PEUpLTEsWD0oMTw8RCktMSxZPWs7O1k9ayl7dmFyIFo9KEs9QVtVKHIsaykmV10pPj4+NDtpZigoays9MTUmSyk+TSl7ZyYmVCgwKTticmVha31pZihLfHxUKDIpLFo8MjU2KWZbTysrXT1aO2Vsc2Uge2lmKDI1Nj09Wil7WT1rLEE9bnVsbDticmVha312YXIgJD1aLTI1NDtpZihaPjI2NCl7dmFyIHJyPWFbcT1aLTI1N107JD1MKHIsaywoMTw8cnIpLTEpK3ZbcV0says9cnI7fXZhciBlcj14W1UocixrKSZYXSxucj1lcj4+PjQ7ZXJ8fFQoMyksays9MTUmZXI7Uj1sW25yXTtpZihucj4zKXtycj1pW25yXTtSKz1VKHIsaykmKDE8PHJyKS0xLGsrPXJyO31pZihrPk0pe2cmJlQoMCk7YnJlYWt9YyYmZChPKzEzMTA3Mik7Zm9yKHZhciB0cj1PKyQ7Tzx0cjtPKz00KWZbT109ZltPLVJdLGZbTysxXT1mW08rMS1SXSxmW08rMl09ZltPKzItUl0sZltPKzNdPWZbTyszLVJdO089dHI7fX11Lmw9QSx1LnA9WSx1LmI9TyxBJiYobT0xLHUubT1FLHUuZD14LHUubj1EKTt9d2hpbGUoIW0pO3JldHVybiBPPT1mLmxlbmd0aD9mOmZ1bmN0aW9uKHIsYSxpKXsobnVsbD09YXx8YTwwKSYmKGE9MCksKG51bGw9PWl8fGk+ci5sZW5ndGgpJiYoaT1yLmxlbmd0aCk7dmFyIG89bmV3KHIgaW5zdGFuY2VvZiBuP246ciBpbnN0YW5jZW9mIHQ/dDplKShpLWEpO3JldHVybiBvLnNldChyLnN1YmFycmF5KGEsaSkpLG99KGYsMCxPKX0sQT1uZXcgZSgwKTt2YXIgeD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXImJm5ldyBUZXh0RGVjb2Rlcjt0cnl7eC5kZWNvZGUoQSx7c3RyZWFtOiEwfSksMTt9Y2F0Y2gocil7fXJldHVybiByLmNvbnZlcnRfc3RyZWFtcz1mdW5jdGlvbihyKXt2YXIgZT1uZXcgRGF0YVZpZXcociksbj0wO2Z1bmN0aW9uIHQoKXt2YXIgcj1lLmdldFVpbnQxNihuKTtyZXR1cm4gbis9MixyfWZ1bmN0aW9uIGEoKXt2YXIgcj1lLmdldFVpbnQzMihuKTtyZXR1cm4gbis9NCxyfWZ1bmN0aW9uIGkocil7bS5zZXRVaW50MTYoYixyKSxiKz0yO31mdW5jdGlvbiBvKHIpe20uc2V0VWludDMyKGIsciksYis9NDt9Zm9yKHZhciBmPXtzaWduYXR1cmU6YSgpLGZsYXZvcjphKCksbGVuZ3RoOmEoKSxudW1UYWJsZXM6dCgpLHJlc2VydmVkOnQoKSx0b3RhbFNmbnRTaXplOmEoKSxtYWpvclZlcnNpb246dCgpLG1pbm9yVmVyc2lvbjp0KCksbWV0YU9mZnNldDphKCksbWV0YUxlbmd0aDphKCksbWV0YU9yaWdMZW5ndGg6YSgpLHByaXZPZmZzZXQ6YSgpLHByaXZMZW5ndGg6YSgpfSx1PTA7TWF0aC5wb3coMix1KTw9Zi5udW1UYWJsZXM7KXUrKzt1LS07Zm9yKHZhciB2PTE2Kk1hdGgucG93KDIsdSkscz0xNipmLm51bVRhYmxlcy12LGw9MTIsYz1bXSxnPTA7ZzxmLm51bVRhYmxlcztnKyspYy5wdXNoKHt0YWc6YSgpLG9mZnNldDphKCksY29tcExlbmd0aDphKCksb3JpZ0xlbmd0aDphKCksb3JpZ0NoZWNrc3VtOmEoKX0pLGwrPTE2O3ZhciBoLHc9bmV3IFVpbnQ4QXJyYXkoMTIrMTYqYy5sZW5ndGgrYy5yZWR1Y2UoKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHIrZS5vcmlnTGVuZ3RoKzR9KSwwKSksZD13LmJ1ZmZlcixtPW5ldyBEYXRhVmlldyhkKSxiPTA7cmV0dXJuIG8oZi5mbGF2b3IpLGkoZi5udW1UYWJsZXMpLGkodiksaSh1KSxpKHMpLGMuZm9yRWFjaCgoZnVuY3Rpb24ocil7byhyLnRhZyksbyhyLm9yaWdDaGVja3N1bSksbyhsKSxvKHIub3JpZ0xlbmd0aCksci5vdXRPZmZzZXQ9bCwobCs9ci5vcmlnTGVuZ3RoKSU0IT0wJiYobCs9NC1sJTQpO30pKSxjLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuLHQ9ci5zbGljZShlLm9mZnNldCxlLm9mZnNldCtlLmNvbXBMZW5ndGgpO2lmKGUuY29tcExlbmd0aCE9ZS5vcmlnTGVuZ3RoKXt2YXIgYT1uZXcgVWludDhBcnJheShlLm9yaWdMZW5ndGgpO249bmV3IFVpbnQ4QXJyYXkodCwyKSxPKG4sYSk7fWVsc2UgYT1uZXcgVWludDhBcnJheSh0KTt3LnNldChhLGUub3V0T2Zmc2V0KTt2YXIgaT0wOyhsPWUub3V0T2Zmc2V0K2Uub3JpZ0xlbmd0aCklNCE9MCYmKGk9NC1sJTQpLHcuc2V0KG5ldyBVaW50OEFycmF5KGkpLmJ1ZmZlcixlLm91dE9mZnNldCtlLm9yaWdMZW5ndGgpLGg9bCtpO30pKSxkLnNsaWNlKDAsaCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHJ9KHt9KS5jb252ZXJ0X3N0cmVhbXN9XG5cbi8qKlxuICogQSBmYWN0b3J5IHdyYXBwZXIgcGFyc2luZyBhIGZvbnQgZmlsZSB1c2luZyBUeXByLlxuICogQWxzbyBhZGRzIHN1cHBvcnQgZm9yIFdPRkYgZmlsZXMgKG5vdCBXT0ZGMikuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90Zikge1xuICBjb25zdCBjbWRBcmdMZW5ndGhzID0ge1xuICAgIE06IDIsXG4gICAgTDogMixcbiAgICBROiA0LFxuICAgIEM6IDYsXG4gICAgWjogMFxuICB9O1xuXG4gIC8vIHtqb2luVHlwZTogXCJza2lwK3N0ZXAsLi4uXCJ9XG4gIGNvbnN0IGpvaW5pbmdUeXBlUmF3RGF0YSA9IHtcIkNcIjpcIjE4ZyxjYSwzNjgsMWt6XCIsXCJEXCI6XCIxN2ssNiwyLDIrNCw1K2MsMis2LDIrMSwxMCsxLDkrZixqKzExLDIrMSxhLDIsMisxLDE1KzIsMyxqKzIsNiszLDIrOCwyLDIsMisxLHcrYSw0K2UsMyszLDIsMysyLDMrNSwyMyt3LDJmKzQsMywyKzksMixiLDIrMywzLDFrKzksNisxLDMrMSwyKzIsMitkLDMwZyxwK3ksMSwxKzFnLGYreCwyLHNkMisxZCxqZjMrNCxmKzMsMis0LDIrMixiKzMsNDIsMiw0KzIsMisxLDIsMyx0KzEsOWYrdywyLGVsKzIsMitnLGQrMiwybCwyKzEsNSwzKzEsMisxLDIsMyw2LDE2d20rMXZcIixcIlJcIjpcIjE3bSszLDIsMiw2KzMsbSwxNSsyLDIrMixoK2gsMTMsMys4LDIsMiwzKzEsMixwKzEseCw1KzQsNSxhLDIsMiwzLHUsYysyLGcrMSw1LDIrMSw0KzEsNWosNisxLDIsYiwyKzIsZiwyKzEsMXMrMiwyLDMrMSw3LDFlejAsMiwyKzEsNCs0LGIsNCwzLGIsNDIsMisyLDQsMywyKzEsMixvKzMsYWUsZXAseCwybysyLDMrMSwzLDUrMSw2XCIsXCJMXCI6XCJ4OXUsamZmLGEsZmQsanZcIixcIlRcIjpcIjR0LGdqKzMzLDdvKzQsMSsxLDdjKzE4LDIsMisxLDIrMSwyLDIxK2EsMiwxYitrLGgsMnUrNiwzKzUsMysxLDIrMyx5LDIsditxLDJrK2EsMW4rOCxhLHArMywyKzgsMisyLDIrNCwxOCsyLDNjK2UsMit2LDFrLDIsNSs3LDUsNCs2LGIrMSx1LDFuLDUrMyw5LGwrMSxyLDMrMSwxbSw1KzEsNSsxLDMrMiw0LHYrMSw0LGMrMSwxbSw1KzQsMisxLDUsbCsxLG4rNSwyLDFuLDMsMiszLDksOCsxLGMrMSx2LDFxLGQsMWYsNCwxbSsyLDYrMiwyKzMsOCsxLGMrMSx1LDFuLDMsNyw2KzEsbCsxLHQrMSwxbSsxLDUrMyw5LGwrMSx1LDIxLDgrMiwyLDJqLDMrNixkKzcsMnIsMys4LGMrNSwyMysxLHMsMiwyLDFrK2QsMis0LDIrMSw2K2EsMit6LGEsMnYrMywyKzUsMisxLDMrMSxxKzEsNSsyLGgrMyxlLDMrMSw3LGcsamsrMixxYisyLHUrMix1KzEsdisxLDF0KzEsMis2LDksMythLGEsMWErMiwzYysxLHosM2IrMiw1KzEsYSw3KzIsNjQrMSwzLDFuLDIrNiwyLDIsMys3LDcrOSwzLDFkK2QsMSwxKzEsMXMrMywxZCwyKzQsMiw2LDE1KzgsZCsxLHgrMywzKzEsMisyLDFsLDIrMSw0LDIrMiwxbis3LDMrMSw0OSsyLDIrYywyKzYsNSw3LDQrMSw1aisxbCwyKzQsZWssMysxLHIrNCwxZSs0LDYrNSwycCtjLDErMywxLDErMiwxK2IsMmRiKzIsM3ksMnArdixmZiszLDMwKzEsbjl4LDErMiwyKzkseCsxLDI5KzEsN2wsNCw1LHErMSw2LDQ4KzEscitoLGUsMTMrNyxxK2EsMWIrMiwxZCwzKzMsMysxLDE0LDF3KzUsMysxLDMrMSxkLDksMWMsMWcsMisyLDMrMSw2KzEsMiwxNysxLDksNm4sMyw1LGZuNSxraStmLGgrZiw1cyw2eSsyLGVhLDZiLDQ2KzQsMWFmKzIsMisxLDYrMywxNSsyLDUsNG0rMSxmeSszLGFzKzEsNGErYSw0eCwxaitlLDFsKzIsMWUrMywzKzEsMXkrMiwxMSs0LDIrNywxcixkKzEsMWgrOCxiKzMsMywybysyLDMsMisxLDcsNGgsNCs3LG0rMSwxbSsxLDQsMTIrNiw0KzQsNWcrNywzKzIsMixvLDJkKzUsMiw1KzEsMisxLDZuKzMsNysxLDIrMSxzKzEsMmUrNywzLDIrMSwyeiwyLDMrNSwyLDJ1KzIsMyszLDIrNCw3OCs4LDIrMSw3NSsxLDIsNSw0MSszLDMrMSw1LHgrOSwxNSs1LDMrMyw5LGErNSwzKzIsMWIrYywyKzEsYmIrNiwyKzUsMiwyYitsLDMrNiwyKzEsMisxLDNmKzUsNCwyKzEsMis2LDIsMjErMSw0LDIsOW8rMSw0NzArOCxhdDQrNCwxbys2LHQ1LDFzKzMsMmEsZjVsKzEsMiszLDQzbysyLGErNywxKzcsMys2LHYrMyw0NSsyLDFqMCsxaSw1KzFkLDksZixuKzQsMitlLDExdCs2LDIrZywzKzYsMisxLDIrNCw3YSs2LGM2KzMsMTV0KzYsMzIrNiwxLGd6YXUsdisybiwzbCs2blwifTtcblxuICBjb25zdCBKVF9MRUZUID0gMSwgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBqb2lucyB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3RlciwgYnV0IGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3Rlci5cbiAgICBKVF9SSUdIVCA9IDIsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciwgYnV0IGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgSlRfRFVBTCA9IDQsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBhbmQgam9pbnMgd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgSlRfVFJBTlNQQVJFTlQgPSA4LCAvL2luZGljYXRlcyB0aGF0IHRoZSBjaGFyYWN0ZXIgZG9lcyBub3Qgam9pbiB3aXRoIGFkamFjZW50IGNoYXJhY3RlcnMgYW5kIHRoYXQgdGhlIGNoYXJhY3RlciBtdXN0IGJlIHNraXBwZWQgb3ZlciB3aGVuIHRoZSBzaGFwaW5nIGVuZ2luZSBpcyBldmFsdWF0aW5nIHRoZSBqb2luaW5nIHBvc2l0aW9ucyBpbiBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMuIFdoZW4gYSBKVF9UUkFOU1BBUkVOVCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gYSBzZXF1ZW5jZSwgdGhlIEpPSU5JTkdfVFlQRSBvZiB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBwYXNzZXMgdGhyb3VnaC4gRGlhY3JpdGljYWwgbWFya3MgYXJlIGZyZXF1ZW50bHkgYXNzaWduZWQgdGhpcyB2YWx1ZS5cbiAgICBKVF9KT0lOX0NBVVNJTkcgPSAxNiwgLy9pbmRpY2F0ZXMgdGhhdCB0aGUgY2hhcmFjdGVyIGZvcmNlcyB0aGUgdXNlIG9mIGpvaW5pbmcgZm9ybXMgd2l0aCB0aGUgcHJlY2VkaW5nIGFuZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMuIEthc2hpZGFzIGFuZCB0aGUgWmVybyBXaWR0aCBKb2luZXIgKFUrMjAwRCkgYXJlIGJvdGggSk9JTl9DQVVTSU5HIGNoYXJhY3RlcnMuXG4gICAgSlRfTk9OX0pPSU5JTkcgPSAzMjsgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHByZWNlZGluZyBvciB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3Rlci4sXG5cbiAgbGV0IGpvaW5pbmdUeXBlTWFwO1xuICBmdW5jdGlvbiBnZXRDaGFySm9pbmluZ1R5cGUoY2gpIHtcbiAgICBpZiAoIWpvaW5pbmdUeXBlTWFwKSB7XG4gICAgICBjb25zdCBtID0ge1xuICAgICAgICBSOiBKVF9SSUdIVCxcbiAgICAgICAgTDogSlRfTEVGVCxcbiAgICAgICAgRDogSlRfRFVBTCxcbiAgICAgICAgQzogSlRfSk9JTl9DQVVTSU5HLFxuICAgICAgICBVOiBKVF9OT05fSk9JTklORyxcbiAgICAgICAgVDogSlRfVFJBTlNQQVJFTlRcbiAgICAgIH07XG4gICAgICBqb2luaW5nVHlwZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gam9pbmluZ1R5cGVSYXdEYXRhKSB7XG4gICAgICAgIGxldCBsYXN0Q29kZSA9IDA7XG4gICAgICAgIGpvaW5pbmdUeXBlUmF3RGF0YVt0eXBlXS5zcGxpdCgnLCcpLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgIGxldCBbc2tpcCwgc3RlcF0gPSByYW5nZS5zcGxpdCgnKycpO1xuICAgICAgICAgIHNraXAgPSBwYXJzZUludChza2lwLDM2KTtcbiAgICAgICAgICBzdGVwID0gc3RlcCA/IHBhcnNlSW50KHN0ZXAsIDM2KSA6IDA7XG4gICAgICAgICAgam9pbmluZ1R5cGVNYXAuc2V0KGxhc3RDb2RlICs9IHNraXAsIG1bdHlwZV0pO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGVwOyBpLS07KSB7XG4gICAgICAgICAgICBqb2luaW5nVHlwZU1hcC5zZXQoKytsYXN0Q29kZSwgbVt0eXBlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpvaW5pbmdUeXBlTWFwLmdldChjaCkgfHwgSlRfTk9OX0pPSU5JTkdcbiAgfVxuXG4gIGNvbnN0IElTT0wgPSAxLCBJTklUID0gMiwgRklOQSA9IDMsIE1FREkgPSA0O1xuICBjb25zdCBmb3Jtc1RvRmVhdHVyZXMgPSBbbnVsbCwgJ2lzb2wnLCAnaW5pdCcsICdmaW5hJywgJ21lZGknXTtcblxuICBmdW5jdGlvbiBkZXRlY3RKb2luaW5nRm9ybXMoc3RyKSB7XG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL244d2lsbGlzL29wZW50eXBlLXNoYXBpbmctZG9jdW1lbnRzL2Jsb2IvbWFzdGVyL29wZW50eXBlLXNoYXBpbmctYXJhYmljLWdlbmVyYWwubWRcbiAgICBjb25zdCBqb2luaW5nRm9ybXMgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICBsZXQgcHJldkpvaW5pbmdUeXBlID0gSlRfTk9OX0pPSU5JTkc7XG4gICAgbGV0IHByZXZGb3JtID0gSVNPTDtcbiAgICBsZXQgcHJldkluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICBsZXQgam9pbmluZ1R5cGUgPSBnZXRDaGFySm9pbmluZ1R5cGUoY29kZSkgfCAwO1xuICAgICAgbGV0IGZvcm0gPSBJU09MO1xuICAgICAgaWYgKGpvaW5pbmdUeXBlICYgSlRfVFJBTlNQQVJFTlQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2Sm9pbmluZ1R5cGUgJiAoSlRfTEVGVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgIGlmIChqb2luaW5nVHlwZSAmIChKVF9SSUdIVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgICAgZm9ybSA9IEZJTkE7XG4gICAgICAgICAgLy8gaXNvbC0+aW5pdCwgZmluYS0+bWVkaVxuICAgICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSVNPTCB8fCBwcmV2Rm9ybSA9PT0gRklOQSkge1xuICAgICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0rKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoam9pbmluZ1R5cGUgJiAoSlRfTEVGVCB8IEpUX05PTl9KT0lOSU5HKSkge1xuICAgICAgICAgIC8vIG1lZGktPmZpbmEsIGluaXQtPmlzb2xcbiAgICAgICAgICBpZiAocHJldkZvcm0gPT09IElOSVQgfHwgcHJldkZvcm0gPT09IE1FREkpIHtcbiAgICAgICAgICAgIGpvaW5pbmdGb3Jtc1twcmV2SW5kZXhdLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcmV2Sm9pbmluZ1R5cGUgJiAoSlRfUklHSFQgfCBKVF9OT05fSk9JTklORykpIHtcbiAgICAgICAgLy8gbWVkaS0+ZmluYSwgaW5pdC0+aXNvbFxuICAgICAgICBpZiAocHJldkZvcm0gPT09IElOSVQgfHwgcHJldkZvcm0gPT09IE1FREkpIHtcbiAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcmV2Rm9ybSA9IGpvaW5pbmdGb3Jtc1tpXSA9IGZvcm07XG4gICAgICBwcmV2Sm9pbmluZ1R5cGUgPSBqb2luaW5nVHlwZTtcbiAgICAgIHByZXZJbmRleCA9IGk7XG4gICAgICBpZiAoY29kZSA+IDB4ZmZmZikgaSsrO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhzdHIuc3BsaXQoJycpLm1hcChjaCA9PiBjaC5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikpKVxuICAgIC8vIGNvbnNvbGUubG9nKHN0ci5zcGxpdCgnJykubWFwKGNoID0+IGdldENoYXJKb2luaW5nVHlwZShjaC5jb2RlUG9pbnRBdCgwKSkpKVxuICAgIC8vIGNvbnNvbGUubG9nKEFycmF5LmZyb20oam9pbmluZ0Zvcm1zKS5tYXAoZiA9PiBmb3Jtc1RvRmVhdHVyZXNbZl0gfHwgJ25vbmUnKSlcbiAgICByZXR1cm4gam9pbmluZ0Zvcm1zXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdUb0dseXBocyAoZm9udCwgc3RyKSB7XG4gICAgY29uc3QgZ2x5cGhJZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2MgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICBpZiAoY2MgPiAweGZmZmYpIGkrKztcbiAgICAgIGdseXBoSWRzLnB1c2goVHlwci5VLmNvZGVUb0dseXBoKGZvbnQsIGNjKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3N1YiA9IGZvbnRbJ0dTVUInXTtcbiAgICBpZiAoZ3N1Yikge1xuICAgICAgY29uc3Qge2xvb2t1cExpc3QsIGZlYXR1cmVMaXN0fSA9IGdzdWI7XG4gICAgICBsZXQgam9pbmluZ0Zvcm1zO1xuICAgICAgY29uc3Qgc3VwcG9ydGVkRmVhdHVyZXMgPSAvXihybGlnfGxpZ2F8bXNldHxpc29sfGluaXR8ZmluYXxtZWRpfGhhbGZ8cHJlc3xibHdzKSQvO1xuICAgICAgY29uc3QgdXNlZExvb2t1cHMgPSBbXTtcbiAgICAgIGZlYXR1cmVMaXN0LmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICAgIGlmIChzdXBwb3J0ZWRGZWF0dXJlcy50ZXN0KGZlYXR1cmUudGFnKSkge1xuICAgICAgICAgIGZvciAobGV0IHRpID0gMDsgdGkgPCBmZWF0dXJlLnRhYi5sZW5ndGg7IHRpKyspIHtcbiAgICAgICAgICAgIGlmICh1c2VkTG9va3Vwc1tmZWF0dXJlLnRhYlt0aV1dKSBjb250aW51ZVxuICAgICAgICAgICAgdXNlZExvb2t1cHNbZmVhdHVyZS50YWJbdGldXSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSBsb29rdXBMaXN0W2ZlYXR1cmUudGFiW3RpXV07XG4gICAgICAgICAgICBjb25zdCBpc0pvaW5pbmdGZWF0dXJlID0gL14oaXNvbHxpbml0fGZpbmF8bWVkaSkkLy50ZXN0KGZlYXR1cmUudGFnKTtcbiAgICAgICAgICAgIGlmIChpc0pvaW5pbmdGZWF0dXJlICYmICFqb2luaW5nRm9ybXMpIHsgLy9sYXp5XG4gICAgICAgICAgICAgIGpvaW5pbmdGb3JtcyA9IGRldGVjdEpvaW5pbmdGb3JtcyhzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY2kgPSAwOyBjaSA8IGdseXBoSWRzLmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgICBpZiAoIWpvaW5pbmdGb3JtcyB8fCAhaXNKb2luaW5nRmVhdHVyZSB8fCBmb3Jtc1RvRmVhdHVyZXNbam9pbmluZ0Zvcm1zW2NpXV0gPT09IGZlYXR1cmUudGFnKSB7XG4gICAgICAgICAgICAgICAgVHlwci5VLl9hcHBseVN1YnMoZ2x5cGhJZHMsIGNpLCB0YWIsIGxvb2t1cExpc3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhJZHNcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcnN0TnVtKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwRm9udE9iaih0eXByRm9udCkge1xuICAgIGNvbnN0IGdseXBoTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGNvbnN0IG9zMiA9IHR5cHJGb250WydPUy8yJ107XG4gICAgY29uc3QgaGhlYSA9IHR5cHJGb250LmhoZWE7XG4gICAgY29uc3QgdW5pdHNQZXJFbSA9IHR5cHJGb250LmhlYWQudW5pdHNQZXJFbTtcbiAgICBjb25zdCBhc2NlbmRlciA9IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9Bc2NlbmRlciwgaGhlYSAmJiBoaGVhLmFzY2VuZGVyLCB1bml0c1BlckVtKTtcblxuICAgIGNvbnN0IGZvbnRPYmogPSB7XG4gICAgICB1bml0c1BlckVtLFxuICAgICAgYXNjZW5kZXIsXG4gICAgICBkZXNjZW5kZXI6IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9EZXNjZW5kZXIsIGhoZWEgJiYgaGhlYS5kZXNjZW5kZXIsIDApLFxuICAgICAgY2FwSGVpZ2h0OiBmaXJzdE51bShvczIgJiYgb3MyLnNDYXBIZWlnaHQsIGFzY2VuZGVyKSxcbiAgICAgIHhIZWlnaHQ6IGZpcnN0TnVtKG9zMiAmJiBvczIuc3hIZWlnaHQsIGFzY2VuZGVyKSxcbiAgICAgIGxpbmVHYXA6IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9MaW5lR2FwLCBoaGVhICYmIGhoZWEubGluZUdhcCksXG4gICAgICBmb3JFYWNoR2x5cGgodGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBnbHlwaFggPSAwO1xuICAgICAgICBjb25zdCBmb250U2NhbGUgPSAxIC8gZm9udE9iai51bml0c1BlckVtICogZm9udFNpemU7XG5cbiAgICAgICAgY29uc3QgZ2x5cGhJbmRpY2VzID0gc3RyaW5nVG9HbHlwaHModHlwckZvbnQsIHRleHQpO1xuICAgICAgICBsZXQgY2hhckluZGV4ID0gMDtcbiAgICAgICAgbGV0IHByZXZHbHlwaEluZGV4ID0gLTE7XG4gICAgICAgIGdseXBoSW5kaWNlcy5mb3JFYWNoKChnbHlwaEluZGV4LCBpKSA9PiB7XG4gICAgICAgICAgLy8gVHlwciByZXR1cm5zIGEgZ2x5cGggaW5kZXggcGVyIHN0cmluZyBjb2RlcG9pbnQsIHdpdGggLTFzIGluIHBsYWNlIG9mIHRob3NlIHRoYXRcbiAgICAgICAgICAvLyB3ZXJlIG9taXR0ZWQgZHVlIHRvIGxpZ2F0dXJlIHN1YnN0aXR1dGlvbi4gU28gd2UgY2FuIHRyYWNrIG9yaWdpbmFsIGluZGV4IGluIHRoZVxuICAgICAgICAgIC8vIHN0cmluZyB2aWEgc2ltcGxlIGluY3JlbWVudCwgYW5kIHNraXAgZXZlcnl0aGluZyBlbHNlIHdoZW4gc2VlaW5nIGEgLTEuXG4gICAgICAgICAgaWYgKGdseXBoSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgZ2x5cGhPYmogPSBnbHlwaE1hcFtnbHlwaEluZGV4XTtcbiAgICAgICAgICAgIGlmICghZ2x5cGhPYmopIHtcbiAgICAgICAgICAgICAgY29uc3Qge2NtZHMsIGNyZHN9ID0gVHlwci5VLmdseXBoVG9QYXRoKHR5cHJGb250LCBnbHlwaEluZGV4KTtcblxuICAgICAgICAgICAgICAvLyBCdWlsZCBwYXRoIHN0cmluZ1xuICAgICAgICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICAgICAgICBsZXQgY3Jkc0lkeCA9IDA7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjbWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtQXJncyA9IGNtZEFyZ0xlbmd0aHNbY21kc1tpXV07XG4gICAgICAgICAgICAgICAgcGF0aCArPSBjbWRzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IG51bUFyZ3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgcGF0aCArPSAoaiA+IDEgPyAnLCcgOiAnJykgKyBjcmRzW2NyZHNJZHgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRmluZCBleHRlbnRzIC0gR2x5ZiBnaXZlcyB0aGlzIGluIG1ldGFkYXRhIGJ1dCBub3QgQ0ZGLCBhbmQgVHlwciBkb2Vzbid0XG4gICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgdHdvLCBzbyBpdCdzIHNpbXBsZXN0IGp1c3QgdG8gaXRlcmF0ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgIGxldCB4TWluLCB5TWluLCB4TWF4LCB5TWF4O1xuICAgICAgICAgICAgICBpZiAoY3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB4TWluID0geU1pbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIHhNYXggPSB5TWF4ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeCA9IGNyZHNbaV07XG4gICAgICAgICAgICAgICAgICBsZXQgeSA9IGNyZHNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgaWYgKHggPCB4TWluKSB4TWluID0geDtcbiAgICAgICAgICAgICAgICAgIGlmICh5IDwgeU1pbikgeU1pbiA9IHk7XG4gICAgICAgICAgICAgICAgICBpZiAoeCA+IHhNYXgpIHhNYXggPSB4O1xuICAgICAgICAgICAgICAgICAgaWYgKHkgPiB5TWF4KSB5TWF4ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeE1pbiA9IHhNYXggPSB5TWluID0geU1heCA9IDA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBnbHlwaE9iaiA9IGdseXBoTWFwW2dseXBoSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBnbHlwaEluZGV4LFxuICAgICAgICAgICAgICAgIGFkdmFuY2VXaWR0aDogdHlwckZvbnQuaG10eC5hV2lkdGhbZ2x5cGhJbmRleF0sXG4gICAgICAgICAgICAgICAgeE1pbixcbiAgICAgICAgICAgICAgICB5TWluLFxuICAgICAgICAgICAgICAgIHhNYXgsXG4gICAgICAgICAgICAgICAgeU1heCxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIHBhdGhDb21tYW5kQ291bnQ6IGNtZHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIC8vIGZvckVhY2hQYXRoQ29tbWFuZChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vICAgbGV0IGFyZ3NJbmRleCA9IDBcbiAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGFyZ3NBcnJheSA9IFtdXG4gICAgICAgICAgICAgICAgLy8gICBmb3IgKGxldCBpID0gMCwgbGVuID0gY21kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBudW1BcmdzID0gY21kQXJnTGVuZ3Roc1tjbWRzW2ldXVxuICAgICAgICAgICAgICAgIC8vICAgICBhcmdzQXJyYXkubGVuZ3RoID0gMSArIG51bUFyZ3NcbiAgICAgICAgICAgICAgICAvLyAgICAgYXJnc0FycmF5WzBdID0gY21kc1tpXVxuICAgICAgICAgICAgICAgIC8vICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBudW1BcmdzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICBhcmdzQXJyYXlbal0gPSBjcmRzW2FyZ3NJbmRleCsrXVxuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3NBcnJheSlcbiAgICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEtlcm5pbmdcbiAgICAgICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZ2x5cGhYICs9IFR5cHIuVS5nZXRQYWlyQWRqdXN0bWVudCh0eXByRm9udCwgcHJldkdseXBoSW5kZXgsIGdseXBoSW5kZXgpICogZm9udFNjYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGdseXBoT2JqLCBnbHlwaFgsIGNoYXJJbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChnbHlwaE9iai5hZHZhbmNlV2lkdGgpIHtcbiAgICAgICAgICAgICAgZ2x5cGhYICs9IGdseXBoT2JqLmFkdmFuY2VXaWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgICAgICAgIGdseXBoWCArPSBsZXR0ZXJTcGFjaW5nICogZm9udFNpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZHbHlwaEluZGV4ID0gZ2x5cGhJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhckluZGV4ICs9ICh0ZXh0LmNvZGVQb2ludEF0KGNoYXJJbmRleCkgPiAweGZmZmYgPyAyIDogMSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2x5cGhYXG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmb250T2JqXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGFyc2UoYnVmZmVyKSB7XG4gICAgLy8gTG9vayB0byBzZWUgaWYgd2UgaGF2ZSBhIFdPRkYgZmlsZSBhbmQgY29udmVydCBpdCBpZiBzbzpcbiAgICBjb25zdCBwZWVrID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCA0KTtcbiAgICBjb25zdCB0YWcgPSBUeXByLl9iaW4ucmVhZEFTQ0lJKHBlZWssIDAsIDQpO1xuICAgIGlmICh0YWcgPT09ICd3T0ZGJykge1xuICAgICAgYnVmZmVyID0gd29mZjJvdGYoYnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3dPRjInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvZmYyIGZvbnRzIG5vdCBzdXBwb3J0ZWQnKVxuICAgIH1cbiAgICByZXR1cm4gd3JhcEZvbnRPYmooVHlwci5wYXJzZShidWZmZXIpWzBdKVxuICB9XG59XG5cblxuY29uc3Qgd29ya2VyTW9kdWxlID0gLyojX19QVVJFX18qL2RlZmluZVdvcmtlck1vZHVsZSh7XG4gIG5hbWU6ICdUeXByIEZvbnQgUGFyc2VyJyxcbiAgZGVwZW5kZW5jaWVzOiBbdHlwckZhY3RvcnksIHdvZmYyb3RmRmFjdG9yeSwgcGFyc2VyRmFjdG9yeV0sXG4gIGluaXQodHlwckZhY3RvcnksIHdvZmYyb3RmRmFjdG9yeSwgcGFyc2VyRmFjdG9yeSkge1xuICAgIGNvbnN0IFR5cHIgPSB0eXByRmFjdG9yeSgpO1xuICAgIGNvbnN0IHdvZmYyb3RmID0gd29mZjJvdGZGYWN0b3J5KCk7XG4gICAgcmV0dXJuIHBhcnNlckZhY3RvcnkoVHlwciwgd29mZjJvdGYpXG4gIH1cbn0pO1xuXG5jb25zdCBDT05GSUcgPSB7XG4gIGRlZmF1bHRGb250VVJMOiAnaHR0cHM6Ly9mb250cy5nc3RhdGljLmNvbS9zL3JvYm90by92MTgvS0ZPbUNucUV1OTJGcjFNdTRteE0ud29mZicsIC8vUm9ib3RvIFJlZ3VsYXJcbiAgc2RmR2x5cGhTaXplOiA2NCxcbiAgc2RmTWFyZ2luOiAxIC8gMTYsXG4gIHNkZkV4cG9uZW50OiA5LFxuICB0ZXh0dXJlV2lkdGg6IDIwNDhcbn07XG5jb25zdCB0ZW1wQ29sb3IgPSAvKiNfX1BVUkVfXyovbmV3IENvbG9yKCk7XG5sZXQgaGFzUmVxdWVzdGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG5vdyQxKCkge1xuICByZXR1cm4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KClcbn1cblxuLyoqXG4gKiBDdXN0b21pemVzIHRoZSB0ZXh0IGJ1aWxkZXIgY29uZmlndXJhdGlvbi4gVGhpcyBtdXN0IGJlIGNhbGxlZCBwcmlvciB0byB0aGUgZmlyc3QgZm9udCBwcm9jZXNzaW5nXG4gKiByZXF1ZXN0LCBhbmQgYXBwbGllcyB0byBhbGwgZm9udHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5kZWZhdWx0Rm9udFVSTCAtIFRoZSBVUkwgb2YgdGhlIGRlZmF1bHQgZm9udCB0byB1c2UgZm9yIHRleHQgcHJvY2Vzc2luZ1xuICogICAgICAgICAgICAgICAgIHJlcXVlc3RzLCBpbiBjYXNlIG5vbmUgaXMgc3BlY2lmaWVkIG9yIHRoZSBzcGVjaWZpZWRlIGZvbnQgZmFpbHMgdG8gbG9hZCBvciBwYXJzZS5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBcIlJvYm90byBSZWd1bGFyXCIgZnJvbSBHb29nbGUgRm9udHMuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZkdseXBoU2l6ZSAtIFRoZSBkZWZhdWx0IHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKVxuICogICAgICAgICAgICAgICAgIHRleHR1cmUgdXNlZCBmb3IgcmVuZGVyaW5nLiBNdXN0IGJlIGEgcG93ZXItb2YtdHdvIG51bWJlciwgYW5kIGFwcGxpZXMgdG8gYWxsIGZvbnRzLFxuICogICAgICAgICAgICAgICAgIGJ1dCBub3RlIHRoYXQgdGhpcyBjYW4gYWxzbyBiZSBvdmVycmlkZGVuIHBlciBjYWxsIHRvIGBnZXRUZXh0UmVuZGVySW5mbygpYC5cbiAqICAgICAgICAgICAgICAgICBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmcgdGhlIHNoYXJwbmVzc1xuICogICAgICAgICAgICAgICAgIG9mIGNvcm5lcnMgYW5kIHByZXZlbnRpbmcgbG9zcyBvZiB2ZXJ5IHRoaW4gbGluZXMsIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeS4gRGVmYXVsdHNcbiAqICAgICAgICAgICAgICAgICB0byA2NCB3aGljaCBpcyBnZW5lcmFsbHkgYSBnb29kIGJhbGFuY2Ugb2Ygc2l6ZSBhbmQgcXVhbGl0eS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuc2RmRXhwb25lbnQgLSBUaGUgZXhwb25lbnQgdXNlZCB3aGVuIGVuY29kaW5nIHRoZSBTREYgdmFsdWVzLiBBIGhpZ2hlciBleHBvbmVudFxuICogICAgICAgICAgICAgICAgIHNoaWZ0cyB0aGUgZW5jb2RlZCA4LWJpdCB2YWx1ZXMgdG8gYWNoaWV2ZSBoaWdoZXIgcHJlY2lzaW9uL2FjY3VyYWN5IGF0IHRleGVscyBuZWFyZXJcbiAqICAgICAgICAgICAgICAgICB0aGUgZ2x5cGgncyBwYXRoLCB3aXRoIGxvd2VyIHByZWNpc2lvbiBmdXJ0aGVyIGF3YXkuIERlZmF1bHRzIHRvIDkuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZk1hcmdpbiAtIEhvdyBtdWNoIHNwYWNlIHRvIHJlc2VydmUgaW4gdGhlIFNERiBhcyBtYXJnaW4gb3V0c2lkZSB0aGUgZ2x5cGgnc1xuICogICAgICAgICAgICAgICAgIHBhdGgsIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgU0RGIHdpZHRoLiBBIGxhcmdlciBtYXJnaW4gaW5jcmVhc2VzIHRoZSBxdWFsaXR5IG9mXG4gKiAgICAgICAgICAgICAgICAgZXh0cnVkZWQgZ2x5cGggb3V0bGluZXMsIGJ1dCBkZWNyZWFzZXMgdGhlIHByZWNpc2lvbiBhdmFpbGFibGUgZm9yIHRoZSBnbHlwaCBpdHNlbGYuXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gMS8xNnRoIG9mIHRoZSBnbHlwaCBzaXplLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy50ZXh0dXJlV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIFNERiB0ZXh0dXJlOyBtdXN0IGJlIGEgcG93ZXIgb2YgMi4gRGVmYXVsdHMgdG9cbiAqICAgICAgICAgICAgICAgICAyMDQ4IHdoaWNoIGlzIGEgc2FmZSBtYXhpbXVtIHRleHR1cmUgZGltZW5zaW9uIGFjY29yZGluZyB0byB0aGUgc3RhdHMgYXRcbiAqICAgICAgICAgICAgICAgICBodHRwczovL3dlYmdsc3RhdHMuY29tL3dlYmdsL3BhcmFtZXRlci9NQVhfVEVYVFVSRV9TSVpFIGFuZCBzaG91bGQgYWxsb3cgZm9yIGFcbiAqICAgICAgICAgICAgICAgICByZWFzb25hYmx5IGxhcmdlIG51bWJlciBvZiBnbHlwaHMgKGRlZmF1bHQgZ2x5cGggc2l6ZSBvZiA2NF4yIGFuZCBzYWZlIHRleHR1cmUgc2l6ZSBvZlxuICogICAgICAgICAgICAgICAgIDIwNDheMiwgdGltZXMgNCBjaGFubmVscywgYWxsb3dzIGZvciA0MDk2IGdseXBocy4pIFRoaXMgY2FuIGJlIGluY3JlYXNlZCBpZiB5b3UgbmVlZCB0b1xuICogICAgICAgICAgICAgICAgIGluY3JlYXNlIHRoZSBnbHlwaCBzaXplIGFuZC9vciBoYXZlIGFuIGV4dHJhb3JkaW5hcnkgbnVtYmVyIG9mIGdseXBocy5cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlVGV4dEJ1aWxkZXIoY29uZmlnKSB7XG4gIGlmIChoYXNSZXF1ZXN0ZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ2NvbmZpZ3VyZVRleHRCdWlsZGVyIGNhbGxlZCBhZnRlciBmaXJzdCBmb250IHJlcXVlc3Q7IHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NpZ24oQ09ORklHLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogUmVwb3NpdG9yeSBmb3IgYWxsIGZvbnQgU0RGIGF0bGFzIHRleHR1cmVzIGFuZCB0aGVpciBnbHlwaCBtYXBwaW5ncy4gVGhlcmUgaXMgYSBzZXBhcmF0ZSBhdGxhcyBmb3JcbiAqIGVhY2ggc2RmR2x5cGhTaXplLiBFYWNoIGF0bGFzIGhhcyBhIHNpbmdsZSBUZXh0dXJlIHRoYXQgaG9sZHMgYWxsIGdseXBocyBmb3IgYWxsIGZvbnRzLlxuICpcbiAqICAge1xuICogICAgIFtzZGZHbHlwaFNpemVdOiB7XG4gKiAgICAgICBnbHlwaENvdW50OiBudW1iZXIsXG4gKiAgICAgICBzZGZHbHlwaFNpemU6IG51bWJlcixcbiAqICAgICAgIHNkZlRleHR1cmU6IFRleHR1cmUsXG4gKiAgICAgICBzZGZDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICogICAgICAgY29udGV4dExvc3Q6IGJvb2xlYW4sXG4gKiAgICAgICBnbHlwaHNCeUZvbnQ6IE1hcDxmb250VVJMLCBNYXA8Z2x5cGhJRCwge3BhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3h9Pj5cbiAqICAgICB9XG4gKiAgIH1cbiAqL1xuY29uc3QgYXRsYXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVHJvaWthVGV4dFJlbmRlckluZm8gLSBGb3JtYXQgb2YgdGhlIHJlc3VsdCBmcm9tIGBnZXRUZXh0UmVuZGVySW5mb2AuXG4gKiBAcHJvcGVydHkge29iamVjdH0gcGFyYW1ldGVycyAtIFRoZSBub3JtYWxpemVkIGlucHV0IGFyZ3VtZW50cyB0byB0aGUgcmVuZGVyIGNhbGwuXG4gKiBAcHJvcGVydHkge1RleHR1cmV9IHNkZlRleHR1cmUgLSBUaGUgU0RGIGF0bGFzIHRleHR1cmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERjsgc2VlIGBjb25maWd1cmVUZXh0QnVpbGRlcmAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2RmRXhwb25lbnQgLSBUaGUgZXhwb25lbnQgdXNlZCBpbiBlbmNvZGluZyB0aGUgU0RGJ3MgdmFsdWVzOyBzZWUgYGNvbmZpZ3VyZVRleHRCdWlsZGVyYC5cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIExpc3Qgb2YgW21pblgsIG1pblksIG1heFgsIG1heFldIHF1YWQgYm91bmRzIGZvciBlYWNoIGdseXBoLlxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGdseXBoQXRsYXNJbmRpY2VzIC0gTGlzdCBob2xkaW5nIGVhY2ggZ2x5cGgncyBpbmRleCBpbiB0aGUgU0RGIGF0bGFzLlxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIC0gTGlzdCBob2xkaW5nIGVhY2ggZ2x5cGgncyBbciwgZywgYl0gY29sb3IsIGlmIGBjb2xvclJhbmdlc2Agd2FzIHN1cHBsaWVkLlxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IFtjYXJldFBvc2l0aW9uc10gLSBBIGxpc3Qgb2YgY2FyZXQgcG9zaXRpb25zIGZvciBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nOyBlYWNoIGlzXG4gKiAgICAgICAgICAgdGhyZWUgZWxlbWVudHM6IHRoZSBzdGFydGluZyBYLCB0aGUgZW5kaW5nIFgsIGFuZCB0aGUgYm90dG9tIFkgZm9yIHRoZSBjYXJldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FyZXRIZWlnaHRdIC0gQW4gYXBwcm9wcmlhdGUgaGVpZ2h0IGZvciBhbGwgc2VsZWN0aW9uIGNhcmV0cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhc2NlbmRlciAtIFRoZSBmb250J3MgYXNjZW5kZXIgbWV0cmljLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2NlbmRlciAtIFRoZSBmb250J3MgZGVzY2VuZGVyIG1ldHJpYy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjYXBIZWlnaHQgLSBUaGUgZm9udCdzIGNhcCBoZWlnaHQgbWV0cmljLCBiYXNlZCBvbiB0aGUgaGVpZ2h0IG9mIExhdGluIGNhcGl0YWwgbGV0dGVycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SGVpZ2h0IC0gVGhlIGZvbnQncyB4IGhlaWdodCBtZXRyaWMsIGJhc2VkIG9uIHRoZSBoZWlnaHQgb2YgTGF0aW4gbG93ZXJjYXNlIGxldHRlcnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZUhlaWdodCAtIFRoZSBmaW5hbCBjb21wdXRlZCBsaW5lSGVpZ2h0IG1lYXN1cmVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcEJhc2VsaW5lIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRvcCBsaW5lJ3MgYmFzZWxpbmUuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGJsb2NrQm91bmRzIC0gVGhlIHRvdGFsIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSByZWN0IG9mIHRoZSB3aG9sZSB0ZXh0IGJsb2NrO1xuICogICAgICAgICAgIHRoaXMgY2FuIGluY2x1ZGUgZXh0cmEgdmVydGljYWwgc3BhY2UgYmV5b25kIHRoZSB2aXNpYmxlIGdseXBocyBkdWUgdG8gbGluZUhlaWdodCwgYW5kIGlzXG4gKiAgICAgICAgICAgZXF1aXZhbGVudCB0byB0aGUgZGltZW5zaW9ucyBvZiBhIGJsb2NrLWxldmVsIHRleHQgZWxlbWVudCBpbiBDU1MuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IHZpc2libGVCb3VuZHMgLSBUaGUgdG90YWwgW21pblgsIG1pblksIG1heFgsIG1heFldIHJlY3Qgb2YgdGhlIHdob2xlIHRleHQgYmxvY2s7XG4gKiAgICAgICAgICAgdW5saWtlIGBibG9ja0JvdW5kc2AgdGhpcyBpcyB0aWdodGx5IHdyYXBwZWQgdG8gdGhlIHZpc2libGUgZ2x5cGggcGF0aHMuXG4gKiBAcHJvcGVydHkge0FycmF5PG9iamVjdD59IGNodW5rZWRCb3VuZHMgLSBMaXN0IG9mIGJvdW5kaW5nIHJlY3RzIGZvciBlYWNoIGNvbnNlY3V0aXZlIHNldCBvZiBOIGdseXBocyxcbiAqICAgICAgICAgICBpbiB0aGUgZm9ybWF0IGB7c3RhcnQ6TiwgZW5kOk4sIHJlY3Q6W21pblgsIG1pblksIG1heFgsIG1heFldfWAuXG4gKiBAcHJvcGVydHkge29iamVjdH0gdGltaW5ncyAtIFRpbWluZyBpbmZvIGZvciB2YXJpb3VzIHBhcnRzIG9mIHRoZSByZW5kZXJpbmcgbG9naWMgaW5jbHVkaW5nIFNERlxuICogICAgICAgICAgIGdlbmVyYXRpb24sIHR5cGVzZXR0aW5nLCBldGMuXG4gKiBAZnJvemVuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZ2V0VGV4dFJlbmRlckluZm9+Y2FsbGJhY2tcbiAqIEBwYXJhbSB7VHJvaWthVGV4dFJlbmRlckluZm99IHRleHRSZW5kZXJJbmZvXG4gKi9cblxuLyoqXG4gKiBNYWluIGVudHJ5IHBvaW50IGZvciByZXF1ZXN0aW5nIHRoZSBkYXRhIG5lZWRlZCB0byByZW5kZXIgYSB0ZXh0IHN0cmluZyB3aXRoIGdpdmVuIGZvbnQgcGFyYW1ldGVycy5cbiAqIFRoaXMgaXMgYW4gYXN5bmNocm9ub3VzIGNhbGwsIHBlcmZvcm1pbmcgbW9zdCBvZiB0aGUgbG9naWMgaW4gYSB3ZWIgd29ya2VyIHRocmVhZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2dldFRleHRSZW5kZXJJbmZvfmNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXRUZXh0UmVuZGVySW5mbyhhcmdzLCBjYWxsYmFjaykge1xuICBoYXNSZXF1ZXN0ZWQgPSB0cnVlO1xuICBhcmdzID0gYXNzaWduKHt9LCBhcmdzKTtcbiAgY29uc3QgdG90YWxTdGFydCA9IG5vdyQxKCk7XG5cbiAgLy8gQXBwbHkgZGVmYXVsdCBmb250IGhlcmUgdG8gYXZvaWQgYSAnbnVsbCcgYXRsYXMsIGFuZCBjb252ZXJ0IHJlbGF0aXZlXG4gIC8vIFVSTHMgdG8gYWJzb2x1dGUgc28gdGhleSBjYW4gYmUgcmVzb2x2ZWQgaW4gdGhlIHdvcmtlclxuICBhcmdzLmZvbnQgPSB0b0Fic29sdXRlVVJMKGFyZ3MuZm9udCB8fCBDT05GSUcuZGVmYXVsdEZvbnRVUkwpO1xuXG4gIC8vIE5vcm1hbGl6ZSB0ZXh0IHRvIGEgc3RyaW5nXG4gIGFyZ3MudGV4dCA9ICcnICsgYXJncy50ZXh0O1xuXG4gIGFyZ3Muc2RmR2x5cGhTaXplID0gYXJncy5zZGZHbHlwaFNpemUgfHwgQ09ORklHLnNkZkdseXBoU2l6ZTtcblxuICAvLyBOb3JtYWxpemUgY29sb3JzXG4gIGlmIChhcmdzLmNvbG9yUmFuZ2VzICE9IG51bGwpIHtcbiAgICBsZXQgY29sb3JzID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGFyZ3MuY29sb3JSYW5nZXMpIHtcbiAgICAgIGlmIChhcmdzLmNvbG9yUmFuZ2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgbGV0IHZhbCA9IGFyZ3MuY29sb3JSYW5nZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFsID0gdGVtcENvbG9yLnNldCh2YWwpLmdldEhleCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yc1trZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBhcmdzLmNvbG9yUmFuZ2VzID0gY29sb3JzO1xuICB9XG5cbiAgT2JqZWN0LmZyZWV6ZShhcmdzKTtcblxuICAvLyBJbml0IHRoZSBhdGxhcyBpZiBuZWVkZWRcbiAgY29uc3Qge3RleHR1cmVXaWR0aCwgc2RmRXhwb25lbnR9ID0gQ09ORklHO1xuICBjb25zdCB7c2RmR2x5cGhTaXplfSA9IGFyZ3M7XG4gIGNvbnN0IGdseXBoc1BlclJvdyA9ICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUgKiA0KTtcbiAgbGV0IGF0bGFzID0gYXRsYXNlc1tzZGZHbHlwaFNpemVdO1xuICBpZiAoIWF0bGFzKSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gdGV4dHVyZVdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzZGZHbHlwaFNpemUgKiAyNTYgLyBnbHlwaHNQZXJSb3c7IC8vIHN0YXJ0IHRhbGwgZW5vdWdoIHRvIGZpdCAyNTYgZ2x5cGhzXG4gICAgYXRsYXMgPSBhdGxhc2VzW3NkZkdseXBoU2l6ZV0gPSB7XG4gICAgICBnbHlwaENvdW50OiAwLFxuICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgc2RmQ2FudmFzOiBjYW52YXMsXG4gICAgICBzZGZUZXh0dXJlOiBuZXcgVGV4dHVyZShcbiAgICAgICAgY2FudmFzLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBMaW5lYXJGaWx0ZXIsXG4gICAgICAgIExpbmVhckZpbHRlclxuICAgICAgKSxcbiAgICAgIGNvbnRleHRMb3N0OiBmYWxzZSxcbiAgICAgIGdseXBoc0J5Rm9udDogbmV3IE1hcCgpXG4gICAgfTtcbiAgICBhdGxhcy5zZGZUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKTtcbiAgfVxuXG4gIGNvbnN0IHtzZGZUZXh0dXJlLCBzZGZDYW52YXN9ID0gYXRsYXM7XG4gIGxldCBmb250R2x5cGhzID0gYXRsYXMuZ2x5cGhzQnlGb250LmdldChhcmdzLmZvbnQpO1xuICBpZiAoIWZvbnRHbHlwaHMpIHtcbiAgICBhdGxhcy5nbHlwaHNCeUZvbnQuc2V0KGFyZ3MuZm9udCwgZm9udEdseXBocyA9IG5ldyBNYXAoKSk7XG4gIH1cblxuICAvLyBJc3N1ZSByZXF1ZXN0IHRvIHRoZSB0eXBlc2V0dGluZyBlbmdpbmUgaW4gdGhlIHdvcmtlclxuICB0eXBlc2V0SW5Xb3JrZXIoYXJncykudGhlbihyZXN1bHQgPT4ge1xuICAgIGNvbnN0IHtnbHlwaElkcywgZ2x5cGhQb3NpdGlvbnMsIGZvbnRTaXplLCB1bml0c1BlckVtLCB0aW1pbmdzfSA9IHJlc3VsdDtcbiAgICBjb25zdCBuZWVkZWRTREZzID0gW107XG4gICAgY29uc3QgZ2x5cGhCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KGdseXBoSWRzLmxlbmd0aCAqIDQpO1xuICAgIGNvbnN0IGZvbnRTaXplTXVsdCA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcbiAgICBsZXQgYm91bmRzSWR4ID0gMDtcbiAgICBsZXQgcG9zaXRpb25zSWR4ID0gMDtcbiAgICBjb25zdCBxdWFkc1N0YXJ0ID0gbm93JDEoKTtcbiAgICBnbHlwaElkcy5mb3JFYWNoKChnbHlwaElkLCBpKSA9PiB7XG4gICAgICBsZXQgZ2x5cGhJbmZvID0gZm9udEdseXBocy5nZXQoZ2x5cGhJZCk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBnbHlwaElkIG5vdCBzZWVuIGJlZm9yZSwgYWRkIGl0IHRvIHRoZSBhdGxhc1xuICAgICAgaWYgKCFnbHlwaEluZm8pIHtcbiAgICAgICAgY29uc3Qge3BhdGgsIHBhdGhCb3VuZHN9ID0gcmVzdWx0LmdseXBoRGF0YVtnbHlwaElkXTtcblxuICAgICAgICAvLyBNYXJnaW4gYXJvdW5kIHBhdGggZWRnZXMgaW4gU0RGLCBiYXNlZCBvbiBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGdseXBoJ3MgbWF4IGRpbWVuc2lvbi5cbiAgICAgICAgLy8gTm90ZSB3ZSBhZGQgYW4gZXh0cmEgMC41IHB4IG92ZXIgdGhlIGNvbmZpZ3VyZWQgdmFsdWUgYmVjYXVzZSB0aGUgb3V0ZXIgMC41IGRvZXNuJ3QgY29udGFpblxuICAgICAgICAvLyB1c2VmdWwgaW50ZXJwb2xhdGVkIHZhbHVlcyBhbmQgd2lsbCBiZSBpZ25vcmVkIGFueXdheS5cbiAgICAgICAgY29uc3QgZm9udFVuaXRzTWFyZ2luID0gTWF0aC5tYXgocGF0aEJvdW5kc1syXSAtIHBhdGhCb3VuZHNbMF0sIHBhdGhCb3VuZHNbM10gLSBwYXRoQm91bmRzWzFdKVxuICAgICAgICAgIC8gc2RmR2x5cGhTaXplICogKENPTkZJRy5zZGZNYXJnaW4gKiBzZGZHbHlwaFNpemUgKyAwLjUpO1xuXG4gICAgICAgIGNvbnN0IGF0bGFzSW5kZXggPSBhdGxhcy5nbHlwaENvdW50Kys7XG4gICAgICAgIGNvbnN0IHNkZlZpZXdCb3ggPSBbXG4gICAgICAgICAgcGF0aEJvdW5kc1swXSAtIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICBwYXRoQm91bmRzWzFdIC0gZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgIHBhdGhCb3VuZHNbMl0gKyBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgICAgcGF0aEJvdW5kc1szXSArIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgXTtcbiAgICAgICAgZm9udEdseXBocy5zZXQoZ2x5cGhJZCwgKGdseXBoSW5mbyA9IHsgcGF0aCwgYXRsYXNJbmRleCwgc2RmVmlld0JveCB9KSk7XG5cbiAgICAgICAgLy8gQ29sbGVjdCB0aG9zZSB0aGF0IG5lZWQgU0RGIGdlbmVyYXRpb25cbiAgICAgICAgbmVlZGVkU0RGcy5wdXNoKGdseXBoSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBib3VuZHMgZm9yIHJlbmRlcmFibGUgcXVhZHNcbiAgICAgIC8vIFRPRE8gY2FuIHdlIGdldCB0aGlzIGJhY2sgb2ZmIHRoZSBtYWluIHRocmVhZD9cbiAgICAgIGNvbnN0IHtzZGZWaWV3Qm94fSA9IGdseXBoSW5mbztcbiAgICAgIGNvbnN0IHBvc1ggPSBnbHlwaFBvc2l0aW9uc1twb3NpdGlvbnNJZHgrK107XG4gICAgICBjb25zdCBwb3NZID0gZ2x5cGhQb3NpdGlvbnNbcG9zaXRpb25zSWR4KytdO1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWCArIHNkZlZpZXdCb3hbMF0gKiBmb250U2l6ZU11bHQ7XG4gICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NZICsgc2RmVmlld0JveFsxXSAqIGZvbnRTaXplTXVsdDtcbiAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1ggKyBzZGZWaWV3Qm94WzJdICogZm9udFNpemVNdWx0O1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWSArIHNkZlZpZXdCb3hbM10gKiBmb250U2l6ZU11bHQ7XG5cbiAgICAgIC8vIENvbnZlcnQgZ2x5cGhJZCB0byBTREYgaW5kZXggZm9yIHRoZSBzaGFkZXJcbiAgICAgIGdseXBoSWRzW2ldID0gZ2x5cGhJbmZvLmF0bGFzSW5kZXg7XG4gICAgfSk7XG4gICAgdGltaW5ncy5xdWFkcyA9ICh0aW1pbmdzLnF1YWRzIHx8IDApICsgKG5vdyQxKCkgLSBxdWFkc1N0YXJ0KTtcblxuICAgIGNvbnN0IHNkZlN0YXJ0ID0gbm93JDEoKTtcbiAgICB0aW1pbmdzLnNkZiA9IHt9O1xuXG4gICAgLy8gR3JvdyB0aGUgdGV4dHVyZSBoZWlnaHQgYnkgcG93ZXIgb2YgMiBpZiBuZWVkZWRcbiAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gc2RmQ2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBuZWVkZWRSb3dzID0gTWF0aC5jZWlsKGF0bGFzLmdseXBoQ291bnQgLyBnbHlwaHNQZXJSb3cpO1xuICAgIGNvbnN0IG5lZWRlZEhlaWdodCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobmVlZGVkUm93cyAqIHNkZkdseXBoU2l6ZSkpKTtcbiAgICBpZiAobmVlZGVkSGVpZ2h0ID4gY3VycmVudEhlaWdodCkge1xuICAgICAgLy8gU2luY2UgcmVzaXppbmcgdGhlIGNhbnZhcyBjbGVhcnMgaXRzIHJlbmRlciBidWZmZXIsIGl0IG5lZWRzIHNwZWNpYWwgaGFuZGxpbmcgdG8gY29weSB0aGUgb2xkIGNvbnRlbnRzIG92ZXJcbiAgICAgIGNvbnNvbGUuaW5mbyhgSW5jcmVhc2luZyBTREYgdGV4dHVyZSBzaXplICR7Y3VycmVudEhlaWdodH0tPiR7bmVlZGVkSGVpZ2h0fWApO1xuICAgICAgcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmcoc2RmQ2FudmFzLCB0ZXh0dXJlV2lkdGgsIG5lZWRlZEhlaWdodCk7XG4gICAgICAvLyBBcyBvZiBUaHJlZSByMTM2IHRleHR1cmVzIGNhbm5vdCBiZSByZXNpemVkIG9uY2UgdGhleSdyZSBhbGxvY2F0ZWQgb24gdGhlIEdQVSwgd2UgbXVzdCBkaXNwb3NlIHRvIHJlYWxsb2NhdGUgaXRcbiAgICAgIHNkZlRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIFByb21pc2UuYWxsKG5lZWRlZFNERnMubWFwKGdseXBoSW5mbyA9PlxuICAgICAgZ2VuZXJhdGVHbHlwaFNERihnbHlwaEluZm8sIGF0bGFzLCBhcmdzLmdwdUFjY2VsZXJhdGVTREYpLnRoZW4oKHt0aW1pbmd9KSA9PiB7XG4gICAgICAgIHRpbWluZ3Muc2RmW2dseXBoSW5mby5hdGxhc0luZGV4XSA9IHRpbWluZztcbiAgICAgIH0pXG4gICAgKSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAobmVlZGVkU0RGcy5sZW5ndGggJiYgIWF0bGFzLmNvbnRleHRMb3N0KSB7XG4gICAgICAgIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcyk7XG4gICAgICAgIHNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGltaW5ncy5zZGZUb3RhbCA9IG5vdyQxKCkgLSBzZGZTdGFydDtcbiAgICAgIHRpbWluZ3MudG90YWwgPSBub3ckMSgpIC0gdG90YWxTdGFydDtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBTREYgLSAke3RpbWluZ3Muc2RmVG90YWx9LCBUb3RhbCAtICR7dGltaW5ncy50b3RhbCAtIHRpbWluZ3MuZm9udExvYWR9YClcblxuICAgICAgLy8gSW52b2tlIGNhbGxiYWNrIHdpdGggdGhlIHRleHQgbGF5b3V0IGFycmF5cyBhbmQgdXBkYXRlZCB0ZXh0dXJlXG4gICAgICBjYWxsYmFjayhPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGFyYW1ldGVyczogYXJncyxcbiAgICAgICAgc2RmVGV4dHVyZSxcbiAgICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgICBzZGZFeHBvbmVudCxcbiAgICAgICAgZ2x5cGhCb3VuZHMsXG4gICAgICAgIGdseXBoQXRsYXNJbmRpY2VzOiBnbHlwaElkcyxcbiAgICAgICAgZ2x5cGhDb2xvcnM6IHJlc3VsdC5nbHlwaENvbG9ycyxcbiAgICAgICAgY2FyZXRQb3NpdGlvbnM6IHJlc3VsdC5jYXJldFBvc2l0aW9ucyxcbiAgICAgICAgY2FyZXRIZWlnaHQ6IHJlc3VsdC5jYXJldEhlaWdodCxcbiAgICAgICAgY2h1bmtlZEJvdW5kczogcmVzdWx0LmNodW5rZWRCb3VuZHMsXG4gICAgICAgIGFzY2VuZGVyOiByZXN1bHQuYXNjZW5kZXIsXG4gICAgICAgIGRlc2NlbmRlcjogcmVzdWx0LmRlc2NlbmRlcixcbiAgICAgICAgbGluZUhlaWdodDogcmVzdWx0LmxpbmVIZWlnaHQsXG4gICAgICAgIGNhcEhlaWdodDogcmVzdWx0LmNhcEhlaWdodCxcbiAgICAgICAgeEhlaWdodDogcmVzdWx0LnhIZWlnaHQsXG4gICAgICAgIHRvcEJhc2VsaW5lOiByZXN1bHQudG9wQmFzZWxpbmUsXG4gICAgICAgIGJsb2NrQm91bmRzOiByZXN1bHQuYmxvY2tCb3VuZHMsXG4gICAgICAgIHZpc2libGVCb3VuZHM6IHJlc3VsdC52aXNpYmxlQm91bmRzLFxuICAgICAgICB0aW1pbmdzOiByZXN1bHQudGltaW5ncyxcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV2hpbGUgdGhlIHR5cGVzZXR0aW5nIHJlcXVlc3QgaXMgYmVpbmcgaGFuZGxlZCwgZ28gYWhlYWQgYW5kIG1ha2Ugc3VyZSB0aGUgYXRsYXMgY2FudmFzIGNvbnRleHQgaXNcbiAgLy8gXCJ3YXJtZWQgdXBcIjsgdGhlIGZpcnN0IHJlcXVlc3Qgd2lsbCBiZSB0aGUgbG9uZ2VzdCBkdWUgdG8gc2hhZGVyIHByb2dyYW0gY29tcGlsYXRpb24gc28gdGhpcyBnZXRzXG4gIC8vIGEgaGVhZCBzdGFydCBvbiB0aGF0IHByb2Nlc3MgYmVmb3JlIFNERnMgYWN0dWFsbHkgc3RhcnQgZ2V0dGluZyBwcm9jZXNzZWQuXG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGlmICghYXRsYXMuY29udGV4dExvc3QpIHtcbiAgICAgIHdhcm1VcFNERkNhbnZhcyhzZGZDYW52YXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlR2x5cGhTREYoe3BhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3h9LCB7c2RmR2x5cGhTaXplLCBzZGZDYW52YXMsIGNvbnRleHRMb3N0fSwgdXNlR1BVKSB7XG4gIGlmIChjb250ZXh0TG9zdCkge1xuICAgIC8vIElmIHRoZSBjb250ZXh0IGlzIGxvc3QgdGhlcmUncyBub3RoaW5nIHdlIGNhbiBkbywganVzdCBxdWl0IHNpbGVudGx5IGFuZCBsZXQgaXRcbiAgICAvLyBnZXQgcmVnZW5lcmF0ZWQgd2hlbiB0aGUgY29udGV4dCBpcyByZXN0b3JlZFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3RpbWluZzogLTF9KVxuICB9XG4gIGNvbnN0IHt0ZXh0dXJlV2lkdGgsIHNkZkV4cG9uZW50fSA9IENPTkZJRztcbiAgY29uc3QgbWF4RGlzdCA9IE1hdGgubWF4KHNkZlZpZXdCb3hbMl0gLSBzZGZWaWV3Qm94WzBdLCBzZGZWaWV3Qm94WzNdIC0gc2RmVmlld0JveFsxXSk7XG4gIGNvbnN0IHNxdWFyZUluZGV4ID0gTWF0aC5mbG9vcihhdGxhc0luZGV4IC8gNCk7XG4gIGNvbnN0IHggPSBzcXVhcmVJbmRleCAlICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUpICogc2RmR2x5cGhTaXplO1xuICBjb25zdCB5ID0gTWF0aC5mbG9vcihzcXVhcmVJbmRleCAvICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUpKSAqIHNkZkdseXBoU2l6ZTtcbiAgY29uc3QgY2hhbm5lbCA9IGF0bGFzSW5kZXggJSA0O1xuICByZXR1cm4gZ2VuZXJhdGVTREYoc2RmR2x5cGhTaXplLCBzZGZHbHlwaFNpemUsIHBhdGgsIHNkZlZpZXdCb3gsIG1heERpc3QsIHNkZkV4cG9uZW50LCBzZGZDYW52YXMsIHgsIHksIGNoYW5uZWwsIHVzZUdQVSlcbn1cblxuZnVuY3Rpb24gaW5pdENvbnRleHRMb3NzSGFuZGxpbmcoYXRsYXMpIHtcbiAgY29uc3QgY2FudmFzID0gYXRsYXMuc2RmQ2FudmFzO1xuXG4gIC8qXG4gIC8vIEJlZ2luIGNvbnRleHQgbG9zcyBzaW11bGF0aW9uXG4gIGlmICghd2luZG93LldlYkdMRGVidWdVdGlscykge1xuICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2ViR0xEZWJ1Z1V0aWxzU2NyaXB0JylcbiAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgIHNjcmlwdC5pZCA9ICdXZWJHTERlYnVnVXRpbHMnXG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICAgIHNjcmlwdC5zcmMgPSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tocm9ub3NHcm91cC9XZWJHTERldmVsb3BlclRvb2xzQGI0MmU3MDIvc3JjL2RlYnVnL3dlYmdsLWRlYnVnLmpzJ1xuICAgIH1cbiAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgd2luZG93LldlYkdMRGVidWdVdGlscy5tYWtlTG9zdENvbnRleHRTaW11bGF0aW5nQ2FudmFzKGNhbnZhcylcbiAgY2FudmFzLmxvc2VDb250ZXh0SW5OQ2FsbHMoNTAwKVxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCAoZXZlbnQpID0+IHtcbiAgICBjYW52YXMubG9zZUNvbnRleHRJbk5DYWxscyg1MDAwKVxuICB9KVxuICAvLyBFbmQgY29udGV4dCBsb3NzIHNpbXVsYXRpb25cbiAgKi9cblxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIChldmVudCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDb250ZXh0IExvc3QnLCBldmVudCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBhdGxhcy5jb250ZXh0TG9zdCA9IHRydWU7XG4gIH0pO1xuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ29udGV4dCBSZXN0b3JlZCcsIGV2ZW50KTtcbiAgICBhdGxhcy5jb250ZXh0TG9zdCA9IGZhbHNlO1xuICAgIC8vIFJlZ2VuZXJhdGUgYWxsIGdseXBocyBpbnRvIHRoZSByZXN0b3JlZCBjYW52YXM6XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBhdGxhcy5nbHlwaHNCeUZvbnQuZm9yRWFjaChnbHlwaE1hcCA9PiB7XG4gICAgICBnbHlwaE1hcC5mb3JFYWNoKGdseXBoID0+IHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChnZW5lcmF0ZUdseXBoU0RGKGdseXBoLCBhdGxhcywgdHJ1ZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgc2FmYXJpUHJlMTVXb3JrYXJvdW5kKGF0bGFzKTtcbiAgICAgIGF0bGFzLnNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcmVsb2FkIGEgZ2l2ZW4gZm9udCBhbmQgb3B0aW9uYWxseSBwcmUtZ2VuZXJhdGUgZ2x5cGggU0RGcyBmb3Igb25lIG9yIG1vcmUgY2hhcmFjdGVyIHNlcXVlbmNlcy5cbiAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCBsb25nIHBhdXNlcyB3aGVuIGZpcnN0IHNob3dpbmcgdGV4dCBpbiBhIHNjZW5lLCBieSBwcmVsb2FkaW5nIHRoZVxuICogbmVlZGVkIGZvbnRzIGFuZCBnbHlwaHMgdXAgZnJvbnQgYWxvbmcgd2l0aCBvdGhlciBhc3NldHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZvbnQgLSBVUkwgb2YgdGhlIGZvbnQgZmlsZSB0byBwcmVsb2FkLiBJZiBub3QgZ2l2ZW4sIHRoZSBkZWZhdWx0IGZvbnQgd2lsbFxuICogICAgICAgIGJlIGxvYWRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLmNoYXJhY3RlcnMgLSBPbmUgb3IgbW9yZSBjaGFyYWN0ZXIgc2VxdWVuY2VzIGZvciB3aGljaCB0byBwcmUtXG4gKiAgICAgICAgZ2VuZXJhdGUgZ2x5cGggU0RGcy4gTm90ZSB0aGF0IHRoaXMgd2lsbCBob25vciBsaWdhdHVyZSBzdWJzdGl0dXRpb24sIHNvIHlvdSBtYXkgbmVlZFxuICogICAgICAgIHRvIHNwZWNpZnkgbGlnYXR1cmUgc2VxdWVuY2VzIGluIGFkZGl0aW9uIHRvIHRoZWlyIGluZGl2aWR1YWwgY2hhcmFjdGVycyB0byBnZXQgYWxsXG4gKiAgICAgICAgcG9zc2libGUgZ2x5cGhzLCBlLmcuIGBbXCJ0XCIsIFwiaFwiLCBcInRoXCJdYCB0byBnZXQgdGhlIFwidFwiIGFuZCBcImhcIiBnbHlwaHMgcGx1cyB0aGUgXCJ0aFwiIGxpZ2F0dXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgYXQgd2hpY2ggdG8gcHJlcmVuZGVyIHRoZSBTREYgdGV4dHVyZXMgZm9yIHRoZVxuICogICAgICAgIHNwZWNpZmllZCBgY2hhcmFjdGVyc2AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBwcmVsb2FkaW5nIGlzIGNvbXBsZXRlLlxuICovXG5mdW5jdGlvbiBwcmVsb2FkRm9udCh7Zm9udCwgY2hhcmFjdGVycywgc2RmR2x5cGhTaXplfSwgY2FsbGJhY2spIHtcbiAgbGV0IHRleHQgPSBBcnJheS5pc0FycmF5KGNoYXJhY3RlcnMpID8gY2hhcmFjdGVycy5qb2luKCdcXG4nKSA6ICcnICsgY2hhcmFjdGVycztcbiAgZ2V0VGV4dFJlbmRlckluZm8oeyBmb250LCBzZGZHbHlwaFNpemUsIHRleHQgfSwgY2FsbGJhY2spO1xufVxuXG5cbi8vIExvY2FsIGFzc2lnbiBpbXBsIHNvIHdlIGRvbid0IGhhdmUgdG8gaW1wb3J0IHRyb2lrYS1jb3JlXG5mdW5jdGlvbiBhc3NpZ24odG9PYmosIGZyb21PYmopIHtcbiAgZm9yIChsZXQga2V5IGluIGZyb21PYmopIHtcbiAgICBpZiAoZnJvbU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB0b09ialtrZXldID0gZnJvbU9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9PYmpcbn1cblxuLy8gVXRpbGl0eSBmb3IgbWFraW5nIFVSTHMgYWJzb2x1dGVcbmxldCBsaW5rRWw7XG5mdW5jdGlvbiB0b0Fic29sdXRlVVJMKHBhdGgpIHtcbiAgaWYgKCFsaW5rRWwpIHtcbiAgICBsaW5rRWwgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8ge30gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIH1cbiAgbGlua0VsLmhyZWYgPSBwYXRoO1xuICByZXR1cm4gbGlua0VsLmhyZWZcbn1cblxuLyoqXG4gKiBTYWZhcmkgPCB2MTUgc2VlbXMgdW5hYmxlIHRvIHVzZSB0aGUgU0RGIHdlYmdsIGNhbnZhcyBhcyBhIHRleHR1cmUuIFRoaXMgYXBwbGllcyBhIHdvcmthcm91bmRcbiAqIHdoZXJlIGl0IHJlYWRzIHRoZSBwaXhlbHMgb3V0IG9mIHRoYXQgY2FudmFzIGFuZCB1cGxvYWRzIHRoZW0gYXMgYSBkYXRhIHRleHR1cmUgaW5zdGVhZCwgYXRcbiAqIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGNvc3QuXG4gKi9cbmZ1bmN0aW9uIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcykge1xuICAvLyBVc2UgY3JlYXRlSW1hZ2VCaXRtYXAgc3VwcG9ydCBhcyBhIHByb3h5IGZvciBTYWZhcmk8MTUsIGFsbCBvdGhlciBtYWluc3RyZWFtIGJyb3dzZXJzXG4gIC8vIGhhdmUgc3VwcG9ydGVkIGl0IGZvciBhIGxvbmcgd2hpbGUgc28gYW55IGZhbHNlIHBvc2l0aXZlcyBzaG91bGQgYmUgbWluaW1hbC5cbiAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuaW5mbygnU2FmYXJpPDE1OiBhcHBseWluZyBTREYgY2FudmFzIHdvcmthcm91bmQnKTtcbiAgICBjb25zdCB7c2RmQ2FudmFzLCBzZGZUZXh0dXJlfSA9IGF0bGFzO1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNkZkNhbnZhcztcbiAgICBjb25zdCBnbCA9IGF0bGFzLnNkZkNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpO1xuICAgIGxldCBwaXhlbHMgPSBzZGZUZXh0dXJlLmltYWdlLmRhdGE7XG4gICAgaWYgKCFwaXhlbHMgfHwgcGl4ZWxzLmxlbmd0aCAhPT0gd2lkdGggKiBoZWlnaHQgKiA0KSB7XG4gICAgICBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgc2RmVGV4dHVyZS5pbWFnZSA9IHt3aWR0aCwgaGVpZ2h0LCBkYXRhOiBwaXhlbHN9O1xuICAgICAgc2RmVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgc2RmVGV4dHVyZS5pc0RhdGFUZXh0dXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpO1xuICB9XG59XG5cblxuY29uc3QgdHlwZXNldHRlcldvcmtlck1vZHVsZSA9IC8qI19fUFVSRV9fKi9kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBuYW1lOiAnVHlwZXNldHRlcicsXG4gIGRlcGVuZGVuY2llczogW1xuICAgIENPTkZJRyxcbiAgICB3b3JrZXJNb2R1bGUsXG4gICAgY3JlYXRlVHlwZXNldHRlcixcbiAgICBiaWRpRmFjdG9yeVxuICBdLFxuICBpbml0KGNvbmZpZywgZm9udFBhcnNlciwgY3JlYXRlVHlwZXNldHRlciwgYmlkaUZhY3RvcnkpIHtcbiAgICBjb25zdCB7ZGVmYXVsdEZvbnRVUkx9ID0gY29uZmlnO1xuICAgIHJldHVybiBjcmVhdGVUeXBlc2V0dGVyKGZvbnRQYXJzZXIsIGJpZGlGYWN0b3J5KCksIHsgZGVmYXVsdEZvbnRVUkwgfSlcbiAgfVxufSk7XG5cbmNvbnN0IHR5cGVzZXRJbldvcmtlciA9IC8qI19fUFVSRV9fKi9kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBuYW1lOiAnVHlwZXNldHRlcicsXG4gIGRlcGVuZGVuY2llczogW1xuICAgIHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUsXG4gIF0sXG4gIGluaXQodHlwZXNldHRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHR5cGVzZXR0ZXIudHlwZXNldChhcmdzLCByZXNvbHZlKTtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICBnZXRUcmFuc2ZlcmFibGVzKHJlc3VsdCkge1xuICAgIC8vIE1hcmsgYXJyYXkgYnVmZmVycyBhcyB0cmFuc2ZlcmFibGUgdG8gYXZvaWQgY2xvbmluZyBkdXJpbmcgcG9zdE1lc3NhZ2VcbiAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW1xuICAgICAgcmVzdWx0LmdseXBoUG9zaXRpb25zLmJ1ZmZlcixcbiAgICAgIHJlc3VsdC5nbHlwaElkcy5idWZmZXJcbiAgICBdO1xuICAgIGlmIChyZXN1bHQuY2FyZXRQb3NpdGlvbnMpIHtcbiAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChyZXN1bHQuY2FyZXRQb3NpdGlvbnMuYnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5nbHlwaENvbG9ycykge1xuICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKHJlc3VsdC5nbHlwaENvbG9ycy5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmZXJhYmxlc1xuICB9XG59KTtcblxuZnVuY3Rpb24gZHVtcFNERlRleHR1cmVzKCkge1xuICBPYmplY3Qua2V5cyhhdGxhc2VzKS5mb3JFYWNoKHNpemUgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGF0bGFzZXNbc2l6ZV0uc2RmQ2FudmFzO1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IGNhbnZhcztcbiAgICBjb25zb2xlLmxvZyhcIiVjLlwiLCBgXG4gICAgICBiYWNrZ3JvdW5kOiB1cmwoJHtjYW52YXMudG9EYXRhVVJMKCl9KTtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogJHt3aWR0aH1weCAke2hlaWdodH1weDtcbiAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgIGZvbnQtc2l6ZTogMDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAke2hlaWdodH1weDtcbiAgICAgIHBhZGRpbmctbGVmdDogJHt3aWR0aH1weDtcbiAgICBgKTtcbiAgfSk7XG59XG5cbmNvbnN0IHRlbXBsYXRlR2VvbWV0cmllcyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRUZW1wbGF0ZUdlb21ldHJ5KGRldGFpbCkge1xuICBsZXQgZ2VvbSA9IHRlbXBsYXRlR2VvbWV0cmllc1tkZXRhaWxdO1xuICBpZiAoIWdlb20pIHtcbiAgICAvLyBHZW9tZXRyeSBpcyB0d28gcGxhbmVzIGJhY2stdG8tYmFjaywgd2hpY2ggd2lsbCBhbHdheXMgYmUgcmVuZGVyZWQgRnJvbnRTaWRlIG9ubHkgYnV0XG4gICAgLy8gYXBwZWFyIGFzIERvdWJsZVNpZGUgYnkgZGVmYXVsdC4gRnJvbnRTaWRlL0JhY2tTaWRlIGFyZSBlbXVsYXRlZCB1c2luZyBkcmF3UmFuZ2UuXG4gICAgLy8gV2UgZG8gaXQgdGhpcyB3YXkgdG8gYXZvaWQgdGhlIHBlcmZvcm1hbmNlIGhpdCBvZiB0d28gZHJhdyBjYWxscyBmb3IgRG91YmxlU2lkZSBtYXRlcmlhbHNcbiAgICAvLyBpbnRyb2R1Y2VkIGJ5IFRocmVlLmpzIGluIHIxMzAgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIxOTY3XG4gICAgY29uc3QgZnJvbnQgPSBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxLCBkZXRhaWwsIGRldGFpbCk7XG4gICAgY29uc3QgYmFjayA9IGZyb250LmNsb25lKCk7XG4gICAgY29uc3QgZnJvbnRBdHRycyA9IGZyb250LmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgYmFja0F0dHJzID0gYmFjay5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGNvbWJpbmVkID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgY29uc3QgdmVydENvdW50ID0gZnJvbnRBdHRycy51di5jb3VudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRDb3VudDsgaSsrKSB7XG4gICAgICBiYWNrQXR0cnMucG9zaXRpb24uYXJyYXlbaSAqIDNdICo9IC0xOyAvLyBmbGlwIHBvc2l0aW9uIHhcbiAgICAgIGJhY2tBdHRycy5ub3JtYWwuYXJyYXlbaSAqIDMgKyAyXSAqPSAtMTsgLy8gZmxpcCBub3JtYWwgelxuICAgIH1cbiAgICBbJ3Bvc2l0aW9uJywgJ25vcm1hbCcsICd1diddLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBjb21iaW5lZC5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgIFsuLi5mcm9udEF0dHJzW25hbWVdLmFycmF5LCAuLi5iYWNrQXR0cnNbbmFtZV0uYXJyYXldLFxuICAgICAgICBmcm9udEF0dHJzW25hbWVdLml0ZW1TaXplKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb21iaW5lZC5zZXRJbmRleChbLi4uZnJvbnQuaW5kZXguYXJyYXksIC4uLmJhY2suaW5kZXguYXJyYXkubWFwKG4gPT4gbiArIHZlcnRDb3VudCldKTtcbiAgICBjb21iaW5lZC50cmFuc2xhdGUoMC41LCAwLjUsIDApO1xuICAgIGdlb20gPSB0ZW1wbGF0ZUdlb21ldHJpZXNbZGV0YWlsXSA9IGNvbWJpbmVkO1xuICB9XG4gIHJldHVybiBnZW9tXG59XG5cbmNvbnN0IGdseXBoQm91bmRzQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQm91bmRzJztcbmNvbnN0IGdseXBoSW5kZXhBdHRyTmFtZSA9ICdhVHJvaWthR2x5cGhJbmRleCc7XG5jb25zdCBnbHlwaENvbG9yQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQ29sb3InO1xuXG4vKipcbkBjbGFzcyBHbHlwaHNHZW9tZXRyeVxuXG5BIHNwZWNpYWxpemVkIEdlb21ldHJ5IGZvciByZW5kZXJpbmcgYSBzZXQgb2YgdGV4dCBnbHlwaHMuIFVzZXMgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgdG9cbnJlbmRlciB0aGUgZ2x5cGhzIHVzaW5nIEdQVSBpbnN0YW5jaW5nIG9mIGEgc2luZ2xlIHF1YWQsIHJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyBhIHdob2xlXG5nZW9tZXRyeSB3aXRoIHZlcnRpY2VzLCBmb3IgbXVjaCBzbWFsbGVyIGF0dHJpYnV0ZSBhcnJheWJ1ZmZlcnMgYWNjb3JkaW5nIHRvIHRoaXMgbWF0aDpcblxuICBXaGVyZSBOID0gbnVtYmVyIG9mIGdseXBocy4uLlxuXG4gIEluc3RhbmNlZDpcbiAgLSBwb3NpdGlvbjogNCAqIDNcbiAgLSBpbmRleDogMiAqIDNcbiAgLSBub3JtYWw6IDQgKiAzXG4gIC0gdXY6IDQgKiAyXG4gIC0gZ2x5cGggeC95IGJvdW5kczogTiAqIDRcbiAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICA9IDVOICsgMzhcblxuICBOb24taW5zdGFuY2VkOlxuICAtIHBvc2l0aW9uOiBOICogNCAqIDNcbiAgLSBpbmRleDogTiAqIDIgKiAzXG4gIC0gbm9ybWFsOiBOICogNCAqIDNcbiAgLSB1djogTiAqIDQgKiAyXG4gIC0gZ2x5cGggaW5kaWNlczogTiAqIDFcbiAgPSAzOU5cblxuQSBkb3duc2lkZSBvZiB0aGlzIGlzIHRoZSByYXJlLWJ1dC1wb3NzaWJsZSBsYWNrIG9mIHRoZSBpbnN0YW5jZWQgYXJyYXlzIGV4dGVuc2lvbixcbndoaWNoIHdlIGNvdWxkIHBvdGVudGlhbGx5IHdvcmsgYXJvdW5kIHdpdGggYSBmYWxsYmFjayBub24taW5zdGFuY2VkIGltcGxlbWVudGF0aW9uLlxuXG4qL1xuY2xhc3MgR2x5cGhzR2VvbWV0cnkgZXh0ZW5kcyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRldGFpbCA9IDE7XG4gICAgdGhpcy5jdXJ2ZVJhZGl1cyA9IDA7XG5cbiAgICAvLyBEZWZpbmUgZ3JvdXBzIGZvciByZW5kZXJpbmcgdGV4dCBvdXRsaW5lIGFzIGEgc2VwYXJhdGUgcGFzczsgdGhlc2Ugd2lsbCBvbmx5XG4gICAgLy8gYmUgdXNlZCB3aGVuIHRoZSBgbWF0ZXJpYWxgIGdldHRlciByZXR1cm5zIGFuIGFycmF5LCBpLmUuIG91dGxpbmVXaWR0aCA+IDAuXG4gICAgdGhpcy5ncm91cHMgPSBbXG4gICAgICB7c3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSwgbWF0ZXJpYWxJbmRleDogMH0sXG4gICAgICB7c3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSwgbWF0ZXJpYWxJbmRleDogMX1cbiAgICBdO1xuXG4gICAgLy8gUHJlYWxsb2NhdGUgZW1wdHkgYm91bmRpbmcgb2JqZWN0c1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG4gIH1cblxuICBjb21wdXRlQm91bmRpbmdTcGhlcmUgKCkge1xuICAgIC8vIE5vLW9wOyB3ZSdsbCBzeW5jIHRoZSBib3VuZGluZ1NwaGVyZSBwcm9hY3RpdmVseSB3aGVuIG5lZWRlZC5cbiAgfVxuXG4gIGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcbiAgICAvLyBOby1vcDsgd2UnbGwgc3luYyB0aGUgYm91bmRpbmdCb3ggcHJvYWN0aXZlbHkgd2hlbiBuZWVkZWQuXG4gIH1cblxuICAvLyBTaW5jZSBvdXIgYmFzZSBnZW9tZXRyeSBjb250YWlucyB0cmlhbmdsZXMgZm9yIGJvdGggZnJvbnQgYW5kIGJhY2sgc2lkZXMsIHdlIGNhbiBlbXVsYXRlXG4gIC8vIHRoZSBcInNpZGVcIiBieSByZXN0cmljdGluZyB0aGUgZHJhdyByYW5nZS5cbiAgc2V0U2lkZShzaWRlKSB7XG4gICAgY29uc3QgdmVydHMgPSB0aGlzLmdldEluZGV4KCkuY291bnQ7XG4gICAgdGhpcy5zZXREcmF3UmFuZ2Uoc2lkZSA9PT0gQmFja1NpZGUgPyB2ZXJ0cyAvIDIgOiAwLCBzaWRlID09PSBEb3VibGVTaWRlID8gdmVydHMgOiB2ZXJ0cyAvIDIpO1xuICB9XG5cbiAgc2V0IGRldGFpbChkZXRhaWwpIHtcbiAgICBpZiAoZGV0YWlsICE9PSB0aGlzLl9kZXRhaWwpIHtcbiAgICAgIHRoaXMuX2RldGFpbCA9IGRldGFpbDtcbiAgICAgIGlmICh0eXBlb2YgZGV0YWlsICE9PSAnbnVtYmVyJyB8fCBkZXRhaWwgPCAxKSB7XG4gICAgICAgIGRldGFpbCA9IDE7XG4gICAgICB9XG4gICAgICBsZXQgdHBsID0gZ2V0VGVtcGxhdGVHZW9tZXRyeShkZXRhaWwpXG4gICAgICA7Wydwb3NpdGlvbicsICdub3JtYWwnLCAndXYnXS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0gPSB0cGwuYXR0cmlidXRlc1thdHRyXS5jbG9uZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldEluZGV4KHRwbC5nZXRJbmRleCgpLmNsb25lKCkpO1xuICAgIH1cbiAgfVxuICBnZXQgZGV0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXRhaWxcbiAgfVxuXG4gIHNldCBjdXJ2ZVJhZGl1cyhyKSB7XG4gICAgaWYgKHIgIT09IHRoaXMuX2N1cnZlUmFkaXVzKSB7XG4gICAgICB0aGlzLl9jdXJ2ZVJhZGl1cyA9IHI7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnZlUmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJ2ZVJhZGl1c1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgZm9yIGEgbmV3IHNldCBvZiBnbHlwaHMuXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEJvdW5kcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIHBsYW5hciBib3VuZHMgZm9yIGFsbCBnbHlwaHNcbiAgICogICAgICAgIHRvIGJlIHJlbmRlcmVkLCA0IGVudHJpZXMgZm9yIGVhY2ggZ2x5cGg6IHgxLHgyLHkxLHkxXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEF0bGFzSW5kaWNlcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIGluZGV4IG9mIGVhY2ggZ2x5cGggd2l0aGluXG4gICAqICAgICAgICB0aGUgU0RGIGF0bGFzIHRleHR1cmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJsb2NrQm91bmRzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgW21pblgsIG1pblksIG1heFgsIG1heFldIGFjcm9zcyBhbGwgZ2x5cGhzXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtjaHVua2VkQm91bmRzXSAtIEFuIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyBib3VuZHMgZm9yIGVhY2ggY2h1bmsgb2YgTlxuICAgKiAgICAgICAgY29uc2VjdXRpdmUgZ2x5cGhzOiBge3N0YXJ0Ok4sIGVuZDpOLCByZWN0OlttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXX1gLiBUaGlzIGNhbiBiZVxuICAgKiAgICAgICAgdXNlZCB3aXRoIGBhcHBseUNsaXBSZWN0YCB0byBjaG9vc2UgYW4gb3B0aW1pemVkIGBpbnN0YW5jZUNvdW50YC5cbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIC0gQW4gYXJyYXkgaG9sZGluZyByLGcsYiB2YWx1ZXMgZm9yIGVhY2ggZ2x5cGguXG4gICAqL1xuICB1cGRhdGVHbHlwaHMoZ2x5cGhCb3VuZHMsIGdseXBoQXRsYXNJbmRpY2VzLCBibG9ja0JvdW5kcywgY2h1bmtlZEJvdW5kcywgZ2x5cGhDb2xvcnMpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGluc3RhbmNlIGF0dHJpYnV0ZXNcbiAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoQm91bmRzQXR0ck5hbWUsIGdseXBoQm91bmRzLCA0KTtcbiAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoSW5kZXhBdHRyTmFtZSwgZ2x5cGhBdGxhc0luZGljZXMsIDEpO1xuICAgIHVwZGF0ZUJ1ZmZlckF0dHIodGhpcywgZ2x5cGhDb2xvckF0dHJOYW1lLCBnbHlwaENvbG9ycywgMyk7XG4gICAgdGhpcy5fYmxvY2tCb3VuZHMgPSBibG9ja0JvdW5kcztcbiAgICB0aGlzLl9jaHVua2VkQm91bmRzID0gY2h1bmtlZEJvdW5kcztcbiAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBnbHlwaEF0bGFzSW5kaWNlcy5sZW5ndGg7XG4gICAgdGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2Jsb2NrQm91bmRzO1xuICAgIGlmIChib3VuZHMpIHtcbiAgICAgIGNvbnN0IHsgY3VydmVSYWRpdXMsIGJvdW5kaW5nQm94OiBiYm94IH0gPSB0aGlzO1xuICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IHsgUEksIGZsb29yLCBtaW4sIG1heCwgc2luLCBjb3MgfSA9IE1hdGg7XG4gICAgICAgIGNvbnN0IGhhbGZQaSA9IFBJIC8gMjtcbiAgICAgICAgY29uc3QgdHdvUGkgPSBQSSAqIDI7XG4gICAgICAgIGNvbnN0IGFic1IgPSBNYXRoLmFicyhjdXJ2ZVJhZGl1cyk7XG4gICAgICAgIGNvbnN0IGxlZnRBbmdsZSA9IGJvdW5kc1swXSAvIGFic1I7XG4gICAgICAgIGNvbnN0IHJpZ2h0QW5nbGUgPSBib3VuZHNbMl0gLyBhYnNSO1xuICAgICAgICBjb25zdCBtaW5YID0gZmxvb3IoKGxlZnRBbmdsZSArIGhhbGZQaSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlICsgaGFsZlBpKSAvIHR3b1BpKVxuICAgICAgICAgID8gLWFic1IgOiBtaW4oc2luKGxlZnRBbmdsZSkgKiBhYnNSLCBzaW4ocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgY29uc3QgbWF4WCA9IGZsb29yKChsZWZ0QW5nbGUgLSBoYWxmUGkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSAtIGhhbGZQaSkgLyB0d29QaSlcbiAgICAgICAgICA/IGFic1IgOiBtYXgoc2luKGxlZnRBbmdsZSkgKiBhYnNSLCBzaW4ocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgY29uc3QgbWF4WiA9IGZsb29yKChsZWZ0QW5nbGUgKyBQSSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlICsgUEkpIC8gdHdvUGkpXG4gICAgICAgICAgPyBhYnNSICogMiA6IG1heChhYnNSIC0gY29zKGxlZnRBbmdsZSkgKiBhYnNSLCBhYnNSIC0gY29zKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgIGJib3gubWluLnNldChtaW5YLCBib3VuZHNbMV0sIGN1cnZlUmFkaXVzIDwgMCA/IC1tYXhaIDogMCk7XG4gICAgICAgIGJib3gubWF4LnNldChtYXhYLCBib3VuZHNbM10sIGN1cnZlUmFkaXVzIDwgMCA/IDAgOiBtYXhaKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJib3gubWluLnNldChib3VuZHNbMF0sIGJvdW5kc1sxXSwgMCk7XG4gICAgICAgIGJib3gubWF4LnNldChib3VuZHNbMl0sIGJvdW5kc1szXSwgMCk7XG4gICAgICB9XG4gICAgICBiYm94LmdldEJvdW5kaW5nU3BoZXJlKHRoaXMuYm91bmRpbmdTcGhlcmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGNsaXBwaW5nIHJlY3QsIGFuZCB0aGUgY2h1bmtlZEJvdW5kcyBmcm9tIHRoZSBsYXN0IHVwZGF0ZUdseXBocyBjYWxsLCBjaG9vc2UgdGhlIGxvd2VzdFxuICAgKiBgaW5zdGFuY2VDb3VudGAgdGhhdCB3aWxsIHNob3cgYWxsIGdseXBocyB3aXRoaW4gdGhlIGNsaXBwZWQgdmlldy4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb25cbiAgICogZm9yIGxvbmcgYmxvY2tzIG9mIHRleHQgdGhhdCBhcmUgY2xpcHBlZCwgdG8gc2tpcCB2ZXJ0ZXggc2hhZGVyIGV2YWx1YXRpb24gZm9yIGdseXBocyB0aGF0IHdvdWxkXG4gICAqIGJlIGNsaXBwZWQgYW55d2F5LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgc2luY2UgYGRyYXdFbGVtZW50c0luc3RhbmNlZFtBTkdMRV1gIG9ubHkgYWNjZXB0cyBhbiBpbnN0YW5jZSBjb3VudCBhbmQgbm90IGEgc3RhcnRpbmdcbiAgICogb2Zmc2V0LCB0aGlzIG9wdGltaXphdGlvbiBiZWNvbWVzIGxlc3MgZWZmZWN0aXZlIGFzIHRoZSBjbGlwUmVjdCBtb3ZlcyBjbG9zZXIgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICogdGV4dCBibG9jay4gV2UgY291bGQgZml4IHRoYXQgYnkgc3dpdGNoaW5nIGZyb20gaW5zdGFuY2luZyB0byBhIGZ1bGwgZ2VvbWV0cnkgd2l0aCBhIGRyYXdSYW5nZSxcbiAgICogYnV0IGF0IHRoZSBleHBlbnNlIG9mIG11Y2ggbGFyZ2VyIGF0dHJpYnV0ZSBidWZmZXJzIChzZWUgY2xhc3Nkb2MgYWJvdmUuKVxuICAgKlxuICAgKiBAcGFyYW0ge1ZlY3RvcjR9IGNsaXBSZWN0XG4gICAqL1xuICBhcHBseUNsaXBSZWN0KGNsaXBSZWN0KSB7XG4gICAgbGV0IGNvdW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoZ2x5cGhJbmRleEF0dHJOYW1lKS5jb3VudDtcbiAgICBsZXQgY2h1bmtzID0gdGhpcy5fY2h1bmtlZEJvdW5kcztcbiAgICBpZiAoY2h1bmtzKSB7XG4gICAgICBmb3IgKGxldCBpID0gY2h1bmtzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb3VudCA9IGNodW5rc1tpXS5lbmQ7XG4gICAgICAgIGxldCByZWN0ID0gY2h1bmtzW2ldLnJlY3Q7XG4gICAgICAgIC8vIG5vdGU6IGJvdGggcmVjdHMgYXJlIGwtYi1yLXRcbiAgICAgICAgaWYgKHJlY3RbMV0gPCBjbGlwUmVjdC53ICYmIHJlY3RbM10gPiBjbGlwUmVjdC55ICYmIHJlY3RbMF0gPCBjbGlwUmVjdC56ICYmIHJlY3RbMl0gPiBjbGlwUmVjdC54KSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBjb3VudDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlckF0dHIoZ2VvbSwgYXR0ck5hbWUsIG5ld0FycmF5LCBpdGVtU2l6ZSkge1xuICBjb25zdCBhdHRyID0gZ2VvbS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICBpZiAobmV3QXJyYXkpIHtcbiAgICAvLyBJZiBsZW5ndGggaXNuJ3QgY2hhbmdpbmcsIGp1c3QgdXBkYXRlIHRoZSBhdHRyaWJ1dGUncyBhcnJheSBkYXRhXG4gICAgaWYgKGF0dHIgJiYgYXR0ci5hcnJheS5sZW5ndGggPT09IG5ld0FycmF5Lmxlbmd0aCkge1xuICAgICAgYXR0ci5hcnJheS5zZXQobmV3QXJyYXkpO1xuICAgICAgYXR0ci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb20uc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKG5ld0FycmF5LCBpdGVtU2l6ZSkpO1xuICAgICAgLy8gSWYgdGhlIG5ldyBhdHRyaWJ1dGUgaGFzIGEgZGlmZmVyZW50IHNpemUsIHdlIGFsc28gaGF2ZSB0byAoYXMgb2YgcjExNykgbWFudWFsbHkgY2xlYXIgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjYWNoZWQgbWF4IGluc3RhbmNlIGNvdW50LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTk3MDZcbiAgICAgIC8vIEl0J3MgdW5jbGVhciBpZiB0aGlzIGlzIGEgdGhyZWVqcyBidWcgb3IgYSB0cnVseSB1bnN1cHBvcnRlZCBzY2VuYXJpbzsgZGlzY3Vzc2lvbiBpblxuICAgICAgLy8gdGhhdCB0aWNrZXQgaXMgYW1iaWd1b3VzIGFzIHRvIHdoZXRoZXIgcmVwbGFjaW5nIGEgQnVmZmVyQXR0cmlidXRlIHdpdGggb25lIG9mIGFcbiAgICAgIC8vIGRpZmZlcmVudCBzaXplIGlzIHN1cHBvcnRlZCwgYnV0IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8xNzQxOCBzdHJvbmdseVxuICAgICAgLy8gaW1wbGllcyBpdCBzaG91bGQgYmUgc3VwcG9ydGVkLiBJdCdzIHBvc3NpYmxlIHdlIG5lZWQgdG9cbiAgICAgIGRlbGV0ZSBnZW9tLl9tYXhJbnN0YW5jZUNvdW50OyAvL2ZvciByMTE3KywgY291bGQgYmUgZnJhZ2lsZVxuICAgICAgZ2VvbS5kaXNwb3NlKCk7IC8vZm9yIHIxMTgrLCBtb3JlIHJvYnVzdCBmZWVsaW5nLCBidXQgbW9yZSBoZWF2eS1oYW5kZWQgdGhhbiBJJ2QgbGlrZVxuICAgIH1cbiAgfSBlbHNlIGlmIChhdHRyKSB7XG4gICAgZ2VvbS5kZWxldGVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICB9XG59XG5cbi8vIGxhbmd1YWdlPUdMU0xcbmNvbnN0IFZFUlRFWF9ERUZTID0gYFxudW5pZm9ybSB2ZWMyIHVUcm9pa2FTREZUZXh0dXJlU2l6ZTtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYVNERkdseXBoU2l6ZTtcbnVuaWZvcm0gdmVjNCB1VHJvaWthVG90YWxCb3VuZHM7XG51bmlmb3JtIHZlYzQgdVRyb2lrYUNsaXBSZWN0O1xudW5pZm9ybSBtYXQzIHVUcm9pa2FPcmllbnQ7XG51bmlmb3JtIGJvb2wgdVRyb2lrYVVzZUdseXBoQ29sb3JzO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthRGlzdGFuY2VPZmZzZXQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FCbHVyUmFkaXVzO1xudW5pZm9ybSB2ZWMyIHVUcm9pa2FQb3NpdGlvbk9mZnNldDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUN1cnZlUmFkaXVzO1xuYXR0cmlidXRlIHZlYzQgYVRyb2lrYUdseXBoQm91bmRzO1xuYXR0cmlidXRlIGZsb2F0IGFUcm9pa2FHbHlwaEluZGV4O1xuYXR0cmlidXRlIHZlYzMgYVRyb2lrYUdseXBoQ29sb3I7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoVVY7XG52YXJ5aW5nIHZlYzQgdlRyb2lrYVRleHR1cmVVVkJvdW5kcztcbnZhcnlpbmcgZmxvYXQgdlRyb2lrYVRleHR1cmVDaGFubmVsO1xudmFyeWluZyB2ZWMzIHZUcm9pa2FHbHlwaENvbG9yO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaERpbWVuc2lvbnM7XG5gO1xuXG4vLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbmNvbnN0IFZFUlRFWF9UUkFOU0ZPUk0gPSBgXG52ZWM0IGJvdW5kcyA9IGFUcm9pa2FHbHlwaEJvdW5kcztcbmJvdW5kcy54eiArPSB1VHJvaWthUG9zaXRpb25PZmZzZXQueDtcbmJvdW5kcy55dyAtPSB1VHJvaWthUG9zaXRpb25PZmZzZXQueTtcblxudmVjNCBvdXRsaW5lQm91bmRzID0gdmVjNChcbiAgYm91bmRzLnh5IC0gdVRyb2lrYURpc3RhbmNlT2Zmc2V0IC0gdVRyb2lrYUJsdXJSYWRpdXMsXG4gIGJvdW5kcy56dyArIHVUcm9pa2FEaXN0YW5jZU9mZnNldCArIHVUcm9pa2FCbHVyUmFkaXVzXG4pO1xudmVjNCBjbGlwcGVkQm91bmRzID0gdmVjNChcbiAgY2xhbXAob3V0bGluZUJvdW5kcy54eSwgdVRyb2lrYUNsaXBSZWN0Lnh5LCB1VHJvaWthQ2xpcFJlY3QuencpLFxuICBjbGFtcChvdXRsaW5lQm91bmRzLnp3LCB1VHJvaWthQ2xpcFJlY3QueHksIHVUcm9pa2FDbGlwUmVjdC56dylcbik7XG5cbnZlYzIgY2xpcHBlZFhZID0gKG1peChjbGlwcGVkQm91bmRzLnh5LCBjbGlwcGVkQm91bmRzLnp3LCBwb3NpdGlvbi54eSkgLSBib3VuZHMueHkpIC8gKGJvdW5kcy56dyAtIGJvdW5kcy54eSk7XG5cbnBvc2l0aW9uLnh5ID0gbWl4KGJvdW5kcy54eSwgYm91bmRzLnp3LCBjbGlwcGVkWFkpO1xuXG51diA9IChwb3NpdGlvbi54eSAtIHVUcm9pa2FUb3RhbEJvdW5kcy54eSkgLyAodVRyb2lrYVRvdGFsQm91bmRzLnp3IC0gdVRyb2lrYVRvdGFsQm91bmRzLnh5KTtcblxuZmxvYXQgcmFkID0gdVRyb2lrYUN1cnZlUmFkaXVzO1xuaWYgKHJhZCAhPSAwLjApIHtcbiAgZmxvYXQgYW5nbGUgPSBwb3NpdGlvbi54IC8gcmFkO1xuICBwb3NpdGlvbi54eiA9IHZlYzIoc2luKGFuZ2xlKSAqIHJhZCwgcmFkIC0gY29zKGFuZ2xlKSAqIHJhZCk7XG4gIG5vcm1hbC54eiA9IHZlYzIoc2luKGFuZ2xlKSwgY29zKGFuZ2xlKSk7XG59XG4gIFxucG9zaXRpb24gPSB1VHJvaWthT3JpZW50ICogcG9zaXRpb247XG5ub3JtYWwgPSB1VHJvaWthT3JpZW50ICogbm9ybWFsO1xuXG52VHJvaWthR2x5cGhVViA9IGNsaXBwZWRYWS54eTtcbnZUcm9pa2FHbHlwaERpbWVuc2lvbnMgPSB2ZWMyKGJvdW5kc1syXSAtIGJvdW5kc1swXSwgYm91bmRzWzNdIC0gYm91bmRzWzFdKTtcblxuJHsnJy8qIE5PVEU6IGl0IHNlZW1zIGltcG9ydGFudCB0byBjYWxjdWxhdGUgdGhlIGdseXBoJ3MgYm91bmRpbmcgdGV4dHVyZSBVVnMgaGVyZSBpbiB0aGVcbiAgdmVydGV4IHNoYWRlciwgcmF0aGVyIHRoYW4gaW4gdGhlIGZyYWdtZW50IHNoYWRlciwgYXMgdGhlIGxhdHRlciBnaXZlcyBzdHJhbmdlIGFydGlmYWN0c1xuICBvbiBzb21lIGdseXBocyAodGhvc2UgaW4gdGhlIGxlZnRtb3N0IHRleHR1cmUgY29sdW1uKSBvbiBzb21lIHN5c3RlbXMuIFRoZSBleGFjdCByZWFzb25cbiAgaXNuJ3QgdW5kZXJzdG9vZCBidXQgZG9pbmcgdGhpcyBoZXJlLCB0aGVuIG1peCgpLWluZyBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyLCBzZWVtcyB0byB3b3JrLiAqL31cbmZsb2F0IHR4Q29scyA9IHVUcm9pa2FTREZUZXh0dXJlU2l6ZS54IC8gdVRyb2lrYVNERkdseXBoU2l6ZTtcbnZlYzIgdHhVdlBlclNxdWFyZSA9IHVUcm9pa2FTREZHbHlwaFNpemUgLyB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG52ZWMyIHR4U3RhcnRVViA9IHR4VXZQZXJTcXVhcmUgKiB2ZWMyKFxuICBtb2QoZmxvb3IoYVRyb2lrYUdseXBoSW5kZXggLyA0LjApLCB0eENvbHMpLFxuICBmbG9vcihmbG9vcihhVHJvaWthR2x5cGhJbmRleCAvIDQuMCkgLyB0eENvbHMpXG4pO1xudlRyb2lrYVRleHR1cmVVVkJvdW5kcyA9IHZlYzQodHhTdGFydFVWLCB2ZWMyKHR4U3RhcnRVVikgKyB0eFV2UGVyU3F1YXJlKTtcbnZUcm9pa2FUZXh0dXJlQ2hhbm5lbCA9IG1vZChhVHJvaWthR2x5cGhJbmRleCwgNC4wKTtcbmA7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbmNvbnN0IEZSQUdNRU5UX0RFRlMgPSBgXG51bmlmb3JtIHNhbXBsZXIyRCB1VHJvaWthU0RGVGV4dHVyZTtcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZFeHBvbmVudDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYURpc3RhbmNlT2Zmc2V0O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthRmlsbE9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FPdXRsaW5lT3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUJsdXJSYWRpdXM7XG51bmlmb3JtIHZlYzMgdVRyb2lrYVN0cm9rZUNvbG9yO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU3Ryb2tlV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTdHJva2VPcGFjaXR5O1xudW5pZm9ybSBib29sIHVUcm9pa2FTREZEZWJ1ZztcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhVVjtcbnZhcnlpbmcgdmVjNCB2VHJvaWthVGV4dHVyZVVWQm91bmRzO1xudmFyeWluZyBmbG9hdCB2VHJvaWthVGV4dHVyZUNoYW5uZWw7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoRGltZW5zaW9ucztcblxuZmxvYXQgdHJvaWthU2RmVmFsdWVUb1NpZ25lZERpc3RhbmNlKGZsb2F0IGFscGhhKSB7XG4gIC8vIEludmVyc2Ugb2YgZXhwb25lbnRpYWwgZW5jb2RpbmcgaW4gd2ViZ2wtc2RmLWdlbmVyYXRvclxuICAkeycnLyogVE9ETyAtIHRoZXJlJ3Mgc29tZSBzbGlnaHQgaW5hY2N1cmFjeSBoZXJlIHdoZW4gZGVhbGluZyB3aXRoIGludGVycG9sYXRlZCBhbHBoYSB2YWx1ZXM7IHRob3NlXG4gICAgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZCB3aGVyZSB0aGUgZW5jb2RpbmcgaXMgZXhwb25lbnRpYWwuIExvb2sgaW50byBpbXByb3ZpbmcgdGhpcyBieSByb3VuZGluZ1xuICAgIHRvIG5lYXJlc3QgMiB3aG9sZSB0ZXhlbHMsIGRlY29kaW5nIHRob3NlIGV4cG9uZW50aWFsIHZhbHVlcywgYW5kIGxpbmVhcmx5IGludGVycG9sYXRpbmcgdGhlIHJlc3VsdC5cbiAgKi99XG4gIGZsb2F0IG1heERpbWVuc2lvbiA9IG1heCh2VHJvaWthR2x5cGhEaW1lbnNpb25zLngsIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMueSk7XG4gIGZsb2F0IGFic0Rpc3QgPSAoMS4wIC0gcG93KDIuMCAqIChhbHBoYSA+IDAuNSA/IDEuMCAtIGFscGhhIDogYWxwaGEpLCAxLjAgLyB1VHJvaWthU0RGRXhwb25lbnQpKSAqIG1heERpbWVuc2lvbjtcbiAgZmxvYXQgc2lnbmVkRGlzdCA9IGFic0Rpc3QgKiAoYWxwaGEgPiAwLjUgPyAtMS4wIDogMS4wKTtcbiAgcmV0dXJuIHNpZ25lZERpc3Q7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb1NkZlZhbHVlKHZlYzIgZ2x5cGhVVikge1xuICB2ZWMyIHRleHR1cmVVViA9IG1peCh2VHJvaWthVGV4dHVyZVVWQm91bmRzLnh5LCB2VHJvaWthVGV4dHVyZVVWQm91bmRzLnp3LCBnbHlwaFVWKTtcbiAgdmVjNCByZ2JhID0gdGV4dHVyZTJEKHVUcm9pa2FTREZUZXh0dXJlLCB0ZXh0dXJlVVYpO1xuICBmbG9hdCBjaCA9IGZsb29yKHZUcm9pa2FUZXh0dXJlQ2hhbm5lbCArIDAuNSk7IC8vTk9URTogY2FuJ3QgdXNlIHJvdW5kKCkgaW4gV2ViR0wxXG4gIHJldHVybiBjaCA9PSAwLjAgPyByZ2JhLnIgOiBjaCA9PSAxLjAgPyByZ2JhLmcgOiBjaCA9PSAyLjAgPyByZ2JhLmIgOiByZ2JhLmE7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKHZlYzIgdXYpIHtcbiAgcmV0dXJuIHRyb2lrYVNkZlZhbHVlVG9TaWduZWREaXN0YW5jZSh0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh1dikpO1xufVxuXG5mbG9hdCB0cm9pa2FHZXRBQURpc3QoKSB7XG4gICR7JycvKlxuICAgIFdoZW4gdGhlIHN0YW5kYXJkIGRlcml2YXRpdmVzIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUsIHdlIGNob29zZSBhbiBhbnRpYWxpYXNpbmcgYWxwaGEgdGhyZXNob2xkIGJhc2VkXG4gICAgb24gdGhlIHBvdGVudGlhbCBjaGFuZ2UgaW4gdGhlIFNERidzIGFscGhhIGZyb20gdGhpcyBmcmFnbWVudCB0byBpdHMgbmVpZ2hib3IuIFRoaXMgc3RyYXRlZ3kgbWF4aW1pemVzIFxuICAgIHJlYWRhYmlsaXR5IGFuZCBlZGdlIGNyaXNwbmVzcyBhdCBhbGwgc2l6ZXMgYW5kIHNjcmVlbiByZXNvbHV0aW9ucy5cbiAgKi99XG4gICNpZiBkZWZpbmVkKEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcykgfHwgX19WRVJTSU9OX18gPj0gMzAwXG4gIHJldHVybiBsZW5ndGgoZndpZHRoKHZUcm9pa2FHbHlwaFVWICogdlRyb2lrYUdseXBoRGltZW5zaW9ucykpICogMC41O1xuICAjZWxzZVxuICByZXR1cm4gdlRyb2lrYUdseXBoRGltZW5zaW9ucy54IC8gNjQuMDtcbiAgI2VuZGlmXG59XG5cbmZsb2F0IHRyb2lrYUdldEZyYWdEaXN0VmFsdWUoKSB7XG4gIHZlYzIgY2xhbXBlZEdseXBoVVYgPSBjbGFtcCh2VHJvaWthR2x5cGhVViwgMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSwgMS4wIC0gMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSk7XG4gIGZsb2F0IGRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UoY2xhbXBlZEdseXBoVVYpO1xuIFxuICAvLyBFeHRyYXBvbGF0ZSBkaXN0YW5jZSB3aGVuIG91dHNpZGUgYm91bmRzOlxuICBkaXN0YW5jZSArPSBjbGFtcGVkR2x5cGhVViA9PSB2VHJvaWthR2x5cGhVViA/IDAuMCA6IFxuICAgIGxlbmd0aCgodlRyb2lrYUdseXBoVVYgLSBjbGFtcGVkR2x5cGhVVikgKiB2VHJvaWthR2x5cGhEaW1lbnNpb25zKTtcblxuICAkeycnLyogXG4gIC8vIFRPRE8gbW9yZSByZWZpbmVkIGV4dHJhcG9sYXRlZCBkaXN0YW5jZSBieSBhZGp1c3RpbmcgZm9yIGFuZ2xlIG9mIGdyYWRpZW50IGF0IGVkZ2UuLi5cbiAgLy8gVGhpcyBoYXMgcG90ZW50aWFsIGJ1dCBjdXJyZW50bHkgZ2l2ZXMgdmVyeSBqYWdnZWQgZXh0ZW5zaW9ucywgbWF5YmUgZHVlIHRvIHByZWNpc2lvbiBpc3N1ZXM/XG4gIGZsb2F0IHV2U3RlcCA9IDEuMCAvIHVUcm9pa2FTREZHbHlwaFNpemU7XG4gIHZlYzIgbmVpZ2hib3IxVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi55KSkgOlxuICAgIHZUcm9pa2FHbHlwaFVWLnkgIT0gY2xhbXBlZEdseXBoVVYueSA/IHZlYzIodXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi54KSwgMC4wKSA6XG4gICAgdmVjMigwLjApXG4gICk7XG4gIHZlYzIgbmVpZ2hib3IyVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogLXNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueSkpIDpcbiAgICB2VHJvaWthR2x5cGhVVi55ICE9IGNsYW1wZWRHbHlwaFVWLnkgPyB2ZWMyKHV2U3RlcCAqIC1zaWduKDAuNSAtIHZUcm9pa2FHbHlwaFVWLngpLCAwLjApIDpcbiAgICB2ZWMyKDAuMClcbiAgKTtcbiAgZmxvYXQgbmVpZ2hib3IxRGlzdGFuY2UgPSB0cm9pa2FHbHlwaFV2VG9EaXN0YW5jZShuZWlnaGJvcjFVVik7XG4gIGZsb2F0IG5laWdoYm9yMkRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UobmVpZ2hib3IyVVYpO1xuICBmbG9hdCBkaXN0VG9VbmNsYW1wZWQgPSBsZW5ndGgoKHZUcm9pa2FHbHlwaFVWIC0gY2xhbXBlZEdseXBoVVYpICogdlRyb2lrYUdseXBoRGltZW5zaW9ucyk7XG4gIGZsb2F0IGRpc3RUb05laWdoYm9yID0gbGVuZ3RoKChjbGFtcGVkR2x5cGhVViAtIG5laWdoYm9yMVVWKSAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMSA9IG1pbihhc2luKGFicyhuZWlnaGJvcjFEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMiA9IG1pbihhc2luKGFicyhuZWlnaGJvcjJEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBkaXN0YW5jZSArPSAoY29zKGdyYWRpZW50QW5nbGUxKSArIGNvcyhncmFkaWVudEFuZ2xlMikpIC8gMi4wICogZGlzdFRvVW5jbGFtcGVkO1xuICAqL31cblxuICByZXR1cm4gZGlzdGFuY2U7XG59XG5cbmZsb2F0IHRyb2lrYUdldEVkZ2VBbHBoYShmbG9hdCBkaXN0YW5jZSwgZmxvYXQgZGlzdGFuY2VPZmZzZXQsIGZsb2F0IGFhRGlzdCkge1xuICAjaWYgZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgfHwgZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbiAgZmxvYXQgYWxwaGEgPSBzdGVwKC1kaXN0YW5jZU9mZnNldCwgLWRpc3RhbmNlKTtcbiAgI2Vsc2VcblxuICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoXG4gICAgZGlzdGFuY2VPZmZzZXQgKyBhYURpc3QsXG4gICAgZGlzdGFuY2VPZmZzZXQgLSBhYURpc3QsXG4gICAgZGlzdGFuY2VcbiAgKTtcbiAgI2VuZGlmXG5cbiAgcmV0dXJuIGFscGhhO1xufVxuYDtcblxuLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG5jb25zdCBGUkFHTUVOVF9UUkFOU0ZPUk0gPSBgXG5mbG9hdCBhYURpc3QgPSB0cm9pa2FHZXRBQURpc3QoKTtcbmZsb2F0IGZyYWdEaXN0YW5jZSA9IHRyb2lrYUdldEZyYWdEaXN0VmFsdWUoKTtcbmZsb2F0IGVkZ2VBbHBoYSA9IHVUcm9pa2FTREZEZWJ1ZyA/XG4gIHRyb2lrYUdseXBoVXZUb1NkZlZhbHVlKHZUcm9pa2FHbHlwaFVWKSA6XG4gIHRyb2lrYUdldEVkZ2VBbHBoYShmcmFnRGlzdGFuY2UsIHVUcm9pa2FEaXN0YW5jZU9mZnNldCwgbWF4KGFhRGlzdCwgdVRyb2lrYUJsdXJSYWRpdXMpKTtcblxuI2lmICFkZWZpbmVkKElTX0RFUFRIX01BVEVSSUFMKSAmJiAhZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbnZlYzQgZmlsbFJHQkEgPSBnbF9GcmFnQ29sb3I7XG5maWxsUkdCQS5hICo9IHVUcm9pa2FGaWxsT3BhY2l0eTtcbnZlYzQgc3Ryb2tlUkdCQSA9IHVUcm9pa2FTdHJva2VXaWR0aCA9PSAwLjAgPyBmaWxsUkdCQSA6IHZlYzQodVRyb2lrYVN0cm9rZUNvbG9yLCB1VHJvaWthU3Ryb2tlT3BhY2l0eSk7XG5pZiAoZmlsbFJHQkEuYSA9PSAwLjApIGZpbGxSR0JBLnJnYiA9IHN0cm9rZVJHQkEucmdiO1xuZ2xfRnJhZ0NvbG9yID0gbWl4KGZpbGxSR0JBLCBzdHJva2VSR0JBLCBzbW9vdGhzdGVwKFxuICAtdVRyb2lrYVN0cm9rZVdpZHRoIC0gYWFEaXN0LFxuICAtdVRyb2lrYVN0cm9rZVdpZHRoICsgYWFEaXN0LFxuICBmcmFnRGlzdGFuY2VcbikpO1xuZ2xfRnJhZ0NvbG9yLmEgKj0gZWRnZUFscGhhO1xuI2VuZGlmXG5cbmlmIChlZGdlQWxwaGEgPT0gMC4wKSB7XG4gIGRpc2NhcmQ7XG59XG5gO1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbWF0ZXJpYWwgZm9yIHJlbmRlcmluZyB0ZXh0LCBkZXJpdmVkIGZyb20gYSBiYXNlTWF0ZXJpYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgY29uc3QgdGV4dE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwge1xuICAgIGNoYWluZWQ6IHRydWUsXG4gICAgZXh0ZW5zaW9uczoge1xuICAgICAgZGVyaXZhdGl2ZXM6IHRydWVcbiAgICB9LFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICB1VHJvaWthU0RGVGV4dHVyZToge3ZhbHVlOiBudWxsfSxcbiAgICAgIHVUcm9pa2FTREZUZXh0dXJlU2l6ZToge3ZhbHVlOiBuZXcgVmVjdG9yMigpfSxcbiAgICAgIHVUcm9pa2FTREZHbHlwaFNpemU6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthU0RGRXhwb25lbnQ6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthVG90YWxCb3VuZHM6IHt2YWx1ZTogbmV3IFZlY3RvcjQoMCwwLDAsMCl9LFxuICAgICAgdVRyb2lrYUNsaXBSZWN0OiB7dmFsdWU6IG5ldyBWZWN0b3I0KDAsMCwwLDApfSxcbiAgICAgIHVUcm9pa2FEaXN0YW5jZU9mZnNldDoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FPdXRsaW5lT3BhY2l0eToge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FGaWxsT3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgIHVUcm9pa2FQb3NpdGlvbk9mZnNldDoge3ZhbHVlOiBuZXcgVmVjdG9yMigpfSxcbiAgICAgIHVUcm9pa2FDdXJ2ZVJhZGl1czoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FCbHVyUmFkaXVzOiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYVN0cm9rZVdpZHRoOiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYVN0cm9rZUNvbG9yOiB7dmFsdWU6IG5ldyBDb2xvcigpfSxcbiAgICAgIHVUcm9pa2FTdHJva2VPcGFjaXR5OiB7dmFsdWU6IDF9LFxuICAgICAgdVRyb2lrYU9yaWVudDoge3ZhbHVlOiBuZXcgTWF0cml4MygpfSxcbiAgICAgIHVUcm9pa2FVc2VHbHlwaENvbG9yczoge3ZhbHVlOiB0cnVlfSxcbiAgICAgIHVUcm9pa2FTREZEZWJ1Zzoge3ZhbHVlOiBmYWxzZX1cbiAgICB9LFxuICAgIHZlcnRleERlZnM6IFZFUlRFWF9ERUZTLFxuICAgIHZlcnRleFRyYW5zZm9ybTogVkVSVEVYX1RSQU5TRk9STSxcbiAgICBmcmFnbWVudERlZnM6IEZSQUdNRU5UX0RFRlMsXG4gICAgZnJhZ21lbnRDb2xvclRyYW5zZm9ybTogRlJBR01FTlRfVFJBTlNGT1JNLFxuICAgIGN1c3RvbVJld3JpdGVyKHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSkge1xuICAgICAgbGV0IHVEaWZmdXNlUkUgPSAvXFxidW5pZm9ybVxccyt2ZWMzXFxzK2RpZmZ1c2VcXGIvO1xuICAgICAgaWYgKHVEaWZmdXNlUkUudGVzdChmcmFnbWVudFNoYWRlcikpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9mIGBkaWZmdXNlYCB3aXRoIG91ciB2YXJ5aW5nXG4gICAgICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXJcbiAgICAgICAgICAucmVwbGFjZSh1RGlmZnVzZVJFLCAndmFyeWluZyB2ZWMzIHZUcm9pa2FHbHlwaENvbG9yJylcbiAgICAgICAgICAucmVwbGFjZSgvXFxiZGlmZnVzZVxcYi9nLCAndlRyb2lrYUdseXBoQ29sb3InKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2ZXJ0ZXggc2hhZGVyIGRlY2xhcmVzIHRoZSB1bmlmb3JtIHNvIHdlIGNhbiBncmFiIGl0IGFzIGEgZmFsbGJhY2tcbiAgICAgICAgaWYgKCF1RGlmZnVzZVJFLnRlc3QodmVydGV4U2hhZGVyKSkge1xuICAgICAgICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKFxuICAgICAgICAgICAgdm9pZE1haW5SZWdFeHAsXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxuJCZcXG52VHJvaWthR2x5cGhDb2xvciA9IHVUcm9pa2FVc2VHbHlwaENvbG9ycyA/IGFUcm9pa2FHbHlwaENvbG9yIC8gMjU1LjAgOiBkaWZmdXNlO1xcbidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIEZvcmNlIHRyYW5zcGFyZW5jeSAtIFRPRE8gaXMgdGhpcyByZWFzb25hYmxlP1xuICB0ZXh0TWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRleHRNYXRlcmlhbCwge1xuICAgIGlzVHJvaWthVGV4dE1hdGVyaWFsOiB7dmFsdWU6IHRydWV9LFxuXG4gICAgLy8gV2ViR0xTaGFkb3dNYXAgcmV2ZXJzZXMgdGhlIHNpZGUgb2YgdGhlIHNoYWRvdyBtYXRlcmlhbCBieSBkZWZhdWx0LCB3aGljaCBmYWlsc1xuICAgIC8vIGZvciBwbGFuZXMsIHNvIGhlcmUgd2UgZm9yY2UgdGhlIGBzaGFkb3dTaWRlYCB0byBhbHdheXMgbWF0Y2ggdGhlIG1haW4gc2lkZS5cbiAgICBzaGFkb3dTaWRlOiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZGVcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIC8vbm8tb3BcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0ZXh0TWF0ZXJpYWxcbn1cblxuY29uc3QgZGVmYXVsdE1hdGVyaWFsID0gLyojX19QVVJFX18qLyBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICBjb2xvcjogMHhmZmZmZmYsXG4gIHNpZGU6IERvdWJsZVNpZGUsXG4gIHRyYW5zcGFyZW50OiB0cnVlXG59KTtcbmNvbnN0IGRlZmF1bHRTdHJva2VDb2xvciA9IDB4ODA4MDgwO1xuXG5jb25zdCB0ZW1wTWF0NCA9IC8qI19fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IHRlbXBWZWMzYSA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXBWZWMzYiA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXBBcnJheSA9IFtdO1xuY29uc3Qgb3JpZ2luID0gLyojX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgZGVmYXVsdE9yaWVudCA9ICcreCt5JztcblxuZnVuY3Rpb24gZmlyc3Qobykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvKSA/IG9bMF0gOiBvXG59XG5cbmxldCBnZXRGbGF0UmF5Y2FzdE1lc2ggPSAoKSA9PiB7XG4gIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAgICBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxKSxcbiAgICBkZWZhdWx0TWF0ZXJpYWxcbiAgKTtcbiAgZ2V0RmxhdFJheWNhc3RNZXNoID0gKCkgPT4gbWVzaDtcbiAgcmV0dXJuIG1lc2hcbn07XG5sZXQgZ2V0Q3VydmVkUmF5Y2FzdE1lc2ggPSAoKSA9PiB7XG4gIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAgICBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxLCAzMiwgMSksXG4gICAgZGVmYXVsdE1hdGVyaWFsXG4gICk7XG4gIGdldEN1cnZlZFJheWNhc3RNZXNoID0gKCkgPT4gbWVzaDtcbiAgcmV0dXJuIG1lc2hcbn07XG5cbmNvbnN0IHN5bmNTdGFydEV2ZW50ID0geyB0eXBlOiAnc3luY3N0YXJ0JyB9O1xuY29uc3Qgc3luY0NvbXBsZXRlRXZlbnQgPSB7IHR5cGU6ICdzeW5jY29tcGxldGUnIH07XG5cbmNvbnN0IFNZTkNBQkxFX1BST1BTID0gW1xuICAnZm9udCcsXG4gICdmb250U2l6ZScsXG4gICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xpbmVIZWlnaHQnLFxuICAnbWF4V2lkdGgnLFxuICAnb3ZlcmZsb3dXcmFwJyxcbiAgJ3RleHQnLFxuICAnZGlyZWN0aW9uJyxcbiAgJ3RleHRBbGlnbicsXG4gICd0ZXh0SW5kZW50JyxcbiAgJ3doaXRlU3BhY2UnLFxuICAnYW5jaG9yWCcsXG4gICdhbmNob3JZJyxcbiAgJ2NvbG9yUmFuZ2VzJyxcbiAgJ3NkZkdseXBoU2l6ZSdcbl07XG5cbmNvbnN0IENPUFlBQkxFX1BST1BTID0gU1lOQ0FCTEVfUFJPUFMuY29uY2F0KFxuICAnbWF0ZXJpYWwnLFxuICAnY29sb3InLFxuICAnZGVwdGhPZmZzZXQnLFxuICAnY2xpcFJlY3QnLFxuICAnY3VydmVSYWRpdXMnLFxuICAnb3JpZW50YXRpb24nLFxuICAnZ2x5cGhHZW9tZXRyeURldGFpbCdcbik7XG5cbi8qKlxuICogQGNsYXNzIFRleHRcbiAqXG4gKiBBIFRocmVlSlMgTWVzaCB0aGF0IHJlbmRlcnMgYSBzdHJpbmcgb2YgdGV4dCBvbiBhIHBsYW5lIGluIDNEIHNwYWNlIHVzaW5nIHNpZ25lZCBkaXN0YW5jZVxuICogZmllbGRzIChTREYpLlxuICovXG5jbGFzcyBUZXh0IGV4dGVuZHMgTWVzaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdseXBoc0dlb21ldHJ5KCk7XG4gICAgc3VwZXIoZ2VvbWV0cnksIG51bGwpO1xuXG4gICAgLy8gPT09IFRleHQgbGF5b3V0IHByb3BlcnRpZXM6ID09PSAvL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0XG4gICAgICogVGhlIHN0cmluZyBvZiB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHRoaXMudGV4dCA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gYW5jaG9yWFxuICAgICAqIERlZmluZXMgdGhlIGhvcml6b250YWwgcG9zaXRpb24gaW4gdGhlIHRleHQgYmxvY2sgdGhhdCBzaG91bGQgbGluZSB1cCB3aXRoIHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBhIG51bWVyaWMgeCBwb3NpdGlvbiBpbiBsb2NhbCB1bml0cywgYSBzdHJpbmcgcGVyY2VudGFnZSBvZiB0aGUgdG90YWxcbiAgICAgKiB0ZXh0IGJsb2NrIHdpZHRoIGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOiAnbGVmdCcsICdjZW50ZXInLFxuICAgICAqIG9yICdyaWdodCcuXG4gICAgICovXG4gICAgdGhpcy5hbmNob3JYID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGFuY2hvclhcbiAgICAgKiBEZWZpbmVzIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiB0aGUgdGV4dCBibG9jayB0aGF0IHNob3VsZCBsaW5lIHVwIHdpdGggdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGEgbnVtZXJpYyB5IHBvc2l0aW9uIGluIGxvY2FsIHVuaXRzIChub3RlOiBkb3duIGlzIG5lZ2F0aXZlIHkpLCBhIHN0cmluZ1xuICAgICAqIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsIHRleHQgYmxvY2sgaGVpZ2h0IGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOlxuICAgICAqICd0b3AnLCAndG9wLWJhc2VsaW5lJywgJ3RvcC1jYXAnLCAndG9wLWV4JywgJ21pZGRsZScsICdib3R0b20tYmFzZWxpbmUnLCBvciAnYm90dG9tJy5cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvclkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBjdXJ2ZVJhZGl1c1xuICAgICAqIERlZmluZXMgYSBjeWxpbmRyaWNhbCByYWRpdXMgYWxvbmcgd2hpY2ggdGhlIHRleHQncyBwbGFuZSB3aWxsIGJlIGN1cnZlZC4gUG9zaXRpdmUgbnVtYmVycyBwdXRcbiAgICAgKiB0aGUgY3lsaW5kZXIncyBjZW50ZXJsaW5lIChvcmllbnRlZCB2ZXJ0aWNhbGx5KSB0aGF0IGRpc3RhbmNlIGluIGZyb250IG9mIHRoZSB0ZXh0LCBmb3IgYSBjb25jYXZlXG4gICAgICogY3VydmF0dXJlLCB3aGlsZSBuZWdhdGl2ZSBudW1iZXJzIHB1dCBpdCBiZWhpbmQgdGhlIHRleHQgZm9yIGEgY29udmV4IGN1cnZhdHVyZS4gVGhlIGNlbnRlcmxpbmVcbiAgICAgKiB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgdGV4dCdzIGxvY2FsIG9yaWdpbjsgeW91IGNhbiB1c2UgYGFuY2hvclhgIHRvIG9mZnNldCBpdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIGVhY2ggZ2x5cGggaXMgYnkgZGVmYXVsdCByZW5kZXJlZCB3aXRoIGEgc2ltcGxlIHF1YWQsIGVhY2ggZ2x5cGggcmVtYWlucyBhIGZsYXQgcGxhbmVcbiAgICAgKiBpbnRlcm5hbGx5LiBZb3UgY2FuIHVzZSBgZ2x5cGhHZW9tZXRyeURldGFpbGAgdG8gYWRkIG1vcmUgdmVydGljZXMgZm9yIGN1cnZhdHVyZSBpbnNpZGUgZ2x5cGhzLlxuICAgICAqL1xuICAgIHRoaXMuY3VydmVSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBTZXRzIHRoZSBiYXNlIGRpcmVjdGlvbiBmb3IgdGhlIHRleHQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIFwiYXV0b1wiIHdpbGwgY2hvb3NlIGEgZGlyZWN0aW9uIGJhc2VkXG4gICAgICogb24gdGhlIHRleHQncyBjb250ZW50IGFjY29yZGluZyB0byB0aGUgYmlkaSBzcGVjLiBBIHZhbHVlIG9mIFwibHRyXCIgb3IgXCJydGxcIiB3aWxsIGZvcmNlIHRoZSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb24gPSAnYXV0byc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGZvbnRcbiAgICAgKiBVUkwgb2YgYSBjdXN0b20gZm9udCB0byBiZSB1c2VkLiBGb250IGZpbGVzIGNhbiBiZSBpbiAudHRmLCAub3RmLCBvciAud29mZiAobm90IC53b2ZmMikgZm9ybWF0cy5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgUm9ib3RvIGZvbnQgbG9hZGVkIGZyb20gR29vZ2xlIEZvbnRzLlxuICAgICAqL1xuICAgIHRoaXMuZm9udCA9IG51bGw7IC8vd2lsbCB1c2UgZGVmYXVsdCBmcm9tIFRleHRCdWlsZGVyXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZvbnRTaXplXG4gICAgICogVGhlIHNpemUgYXQgd2hpY2ggdG8gcmVuZGVyIHRoZSBmb250IGluIGxvY2FsIHVuaXRzOyBjb3JyZXNwb25kcyB0byB0aGUgZW0tYm94IGhlaWdodFxuICAgICAqIG9mIHRoZSBjaG9zZW4gYGZvbnRgLlxuICAgICAqL1xuICAgIHRoaXMuZm9udFNpemUgPSAwLjE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxldHRlclNwYWNpbmdcbiAgICAgKiBTZXRzIGEgdW5pZm9ybSBhZGp1c3RtZW50IHRvIHNwYWNpbmcgYmV0d2VlbiBsZXR0ZXJzIGFmdGVyIGtlcm5pbmcgaXMgYXBwbGllZC4gUG9zaXRpdmVcbiAgICAgKiBudW1iZXJzIGluY3JlYXNlIHNwYWNpbmcgYW5kIG5lZ2F0aXZlIG51bWJlcnMgZGVjcmVhc2UgaXQuXG4gICAgICovXG4gICAgdGhpcy5sZXR0ZXJTcGFjaW5nID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGxpbmVIZWlnaHRcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgZWFjaCBsaW5lIG9mIHRleHQsIGFzIGEgbXVsdGlwbGUgb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvICdub3JtYWwnXG4gICAgICogd2hpY2ggY2hvb3NlcyBhIHJlYXNvbmFibGUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBjaG9zZW4gZm9udCdzIGFzY2VuZGVyL2Rlc2NlbmRlciBtZXRyaWNzLlxuICAgICAqL1xuICAgIHRoaXMubGluZUhlaWdodCA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBtYXhXaWR0aFxuICAgICAqIFRoZSBtYXhpbXVtIHdpZHRoIG9mIHRoZSB0ZXh0IGJsb2NrLCBhYm92ZSB3aGljaCB0ZXh0IG1heSBzdGFydCB3cmFwcGluZyBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICogYHdoaXRlU3BhY2VgIGFuZCBgb3ZlcmZsb3dXcmFwYCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHRoaXMubWF4V2lkdGggPSBJbmZpbml0eTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gb3ZlcmZsb3dXcmFwXG4gICAgICogRGVmaW5lcyBob3cgdGV4dCB3cmFwcyBpZiB0aGUgYHdoaXRlU3BhY2VgIHByb3BlcnR5IGlzIGBub3JtYWxgLiBDYW4gYmUgZWl0aGVyIGAnbm9ybWFsJ2BcbiAgICAgKiB0byBicmVhayBhdCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMsIG9yIGAnYnJlYWstd29yZCdgIHRvIGFsbG93IGJyZWFraW5nIHdpdGhpbiB3b3Jkcy5cbiAgICAgKiBEZWZhdWx0cyB0byBgJ25vcm1hbCdgLlxuICAgICAqL1xuICAgIHRoaXMub3ZlcmZsb3dXcmFwID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRleHRBbGlnblxuICAgICAqIFRoZSBob3Jpem9udGFsIGFsaWdubWVudCBvZiBlYWNoIGxpbmUgb2YgdGV4dCB3aXRoaW4gdGhlIG92ZXJhbGwgdGV4dCBib3VuZGluZyBib3guXG4gICAgICovXG4gICAgdGhpcy50ZXh0QWxpZ24gPSAnbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRleHRJbmRlbnRcbiAgICAgKiBJbmRlbnRhdGlvbiBmb3IgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGxpbmU7IHNlZSBDU1MgYHRleHQtaW5kZW50YC5cbiAgICAgKi9cbiAgICB0aGlzLnRleHRJbmRlbnQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB3aGl0ZVNwYWNlXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRleHQgc2hvdWxkIHdyYXAgd2hlbiBhIGxpbmUgcmVhY2hlcyB0aGUgYG1heFdpZHRoYC4gQ2FuXG4gICAgICogYmUgZWl0aGVyIGAnbm9ybWFsJ2AgKHRoZSBkZWZhdWx0KSwgdG8gYWxsb3cgd3JhcHBpbmcgYWNjb3JkaW5nIHRvIHRoZSBgb3ZlcmZsb3dXcmFwYCBwcm9wZXJ0eSxcbiAgICAgKiBvciBgJ25vd3JhcCdgIHRvIHByZXZlbnQgd3JhcHBpbmcuIE5vdGUgdGhhdCBgJ25vcm1hbCdgIGhlcmUgaG9ub3JzIG5ld2xpbmUgY2hhcmFjdGVycyB0b1xuICAgICAqIG1hbnVhbGx5IGJyZWFrIGxpbmVzLCBtYWtpbmcgaXQgYmVoYXZlIG1vcmUgbGlrZSBgJ3ByZS13cmFwJ2AgZG9lcyBpbiBDU1MuXG4gICAgICovXG4gICAgdGhpcy53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG5cblxuICAgIC8vID09PSBQcmVzZW50YXRpb24gcHJvcGVydGllczogPT09IC8vXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtUSFJFRS5NYXRlcmlhbH0gbWF0ZXJpYWxcbiAgICAgKiBEZWZpbmVzIGEgX2Jhc2VfIG1hdGVyaWFsIHRvIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgdGhlIHRleHQuIFRoaXMgbWF0ZXJpYWwgd2lsbCBiZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgd2l0aCBhIG1hdGVyaWFsIGRlcml2ZWQgZnJvbSBpdCwgdGhhdCBhZGRzIHNoYWRlciBjb2RlIHRvXG4gICAgICogZGVjcmVhc2UgdGhlIGFscGhhIGZvciBlYWNoIGZyYWdtZW50IChwaXhlbCkgb3V0c2lkZSB0aGUgdGV4dCBnbHlwaHMsIHdpdGggYW50aWFsaWFzaW5nLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQgd2lsbCBkZXJpdmUgZnJvbSBhIHNpbXBsZSB3aGl0ZSBNZXNoQmFzaWNNYXRlcmlhbCwgYnV0IHlvdSBjYW4gdXNlIGFueVxuICAgICAqIG9mIHRoZSBvdGhlciBtZXNoIG1hdGVyaWFscyB0byBnYWluIG90aGVyIGZlYXR1cmVzIGxpa2UgbGlnaHRpbmcsIHRleHR1cmUgbWFwcywgZXRjLlxuICAgICAqXG4gICAgICogQWxzbyBzZWUgdGhlIGBjb2xvcmAgc2hvcnRjdXQgcHJvcGVydHkuXG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBjb2xvclxuICAgICAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3Igc2V0dGluZyB0aGUgYGNvbG9yYCBvZiB0aGUgdGV4dCdzIG1hdGVyaWFsLiBZb3UgY2FuIHVzZSB0aGlzXG4gICAgICogaWYgeW91IGRvbid0IHdhbnQgdG8gc3BlY2lmeSBhIHdob2xlIGN1c3RvbSBgbWF0ZXJpYWxgLiBBbHNvLCBpZiB5b3UgZG8gdXNlIGEgY3VzdG9tXG4gICAgICogYG1hdGVyaWFsYCwgdGhpcyBjb2xvciB3aWxsIG9ubHkgYmUgdXNlZCBmb3IgdGhpcyBwYXJ0aWN1YXIgVGV4dCBpbnN0YW5jZSwgZXZlbiBpZlxuICAgICAqIHRoYXQgc2FtZSBtYXRlcmlhbCBpbnN0YW5jZSBpcyBzaGFyZWQgYWNyb3NzIG11bHRpcGxlIFRleHQgb2JqZWN0cy5cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge29iamVjdHxudWxsfSBjb2xvclJhbmdlc1xuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGlzIGFsbG93cyBtb3JlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG9mIGNvbG9ycyBmb3IgaW5kaXZpZHVhbCBvciByYW5nZXMgb2YgY2hhcmFjdGVycyxcbiAgICAgKiB0YWtpbmcgcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXRlcmlhbCdzIGBjb2xvcmAuIEl0cyBmb3JtYXQgaXMgYW4gT2JqZWN0IHdob3NlIGtleXMgZWFjaFxuICAgICAqIGRlZmluZSBhIHN0YXJ0aW5nIGNoYXJhY3RlciBpbmRleCBmb3IgYSByYW5nZSwgYW5kIHdob3NlIHZhbHVlcyBhcmUgdGhlIGNvbG9yIGZvciBlYWNoXG4gICAgICogcmFuZ2UuIFRoZSBjb2xvciB2YWx1ZSBjYW4gYmUgYSBudW1lcmljIGhleCBjb2xvciB2YWx1ZSwgYSBgVEhSRUUuQ29sb3JgIG9iamVjdCwgb3JcbiAgICAgKiBhbnkgb2YgdGhlIHN0cmluZ3MgYWNjZXB0ZWQgYnkgYFRIUkVFLkNvbG9yYC5cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yUmFuZ2VzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVXaWR0aFxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgd2lkdGggb2YgYW4gb3V0bGluZS9oYWxvIHRvIGJlIGRyYXduIGFyb3VuZCBlYWNoIHRleHQgZ2x5cGggdXNpbmcgdGhlIGBvdXRsaW5lQ29sb3JgIGFuZCBgb3V0bGluZU9wYWNpdHlgLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuXG4gICAgICogYFwiMTIlXCJgIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAsIHdoaWNoIG1lYW5zXG4gICAgICogbm8gb3V0bGluZSB3aWxsIGJlIGRyYXduIHVubGVzcyBhbiBgb3V0bGluZU9mZnNldFgvWWAgb3IgYG91dGxpbmVCbHVyYCBpcyBzZXQuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lV2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcnxUSFJFRS5Db2xvcn0gb3V0bGluZUNvbG9yXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBvdXRsaW5lLCBpZiBgb3V0bGluZVdpZHRoYC9gb3V0bGluZUJsdXJgL2BvdXRsaW5lT2Zmc2V0WC9ZYCBhcmUgc2V0LlxuICAgICAqIERlZmF1bHRzIHRvIGJsYWNrLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZUNvbG9yID0gMHgwMDAwMDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IG91dGxpbmVPcGFjaXR5XG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBvdXRsaW5lLCBpZiBgb3V0bGluZVdpZHRoYC9gb3V0bGluZUJsdXJgL2BvdXRsaW5lT2Zmc2V0WC9ZYCBhcmUgc2V0LlxuICAgICAqIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVPcGFjaXR5ID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVCbHVyXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIEEgYmx1ciByYWRpdXMgYXBwbGllZCB0byB0aGUgb3V0ZXIgZWRnZSBvZiB0aGUgdGV4dCdzIG91dGxpbmUuIElmIHRoZSBgb3V0bGluZVdpZHRoYCBpc1xuICAgICAqIHplcm8sIHRoZSBibHVyIHdpbGwgYmUgYXBwbGllZCBhdCB0aGUgZ2x5cGggZWRnZSwgbGlrZSBDU1MncyBgdGV4dC1zaGFkb3dgIGJsdXIgcmFkaXVzLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuXG4gICAgICogYFwiMTIlXCJgIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lQmx1ciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lT2Zmc2V0WFxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBBIGhvcml6b250YWwgb2Zmc2V0IGZvciB0aGUgdGV4dCBvdXRsaW5lLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuIGBcIjEyJVwiYFxuICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lT2Zmc2V0WCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lT2Zmc2V0WVxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBBIHZlcnRpY2FsIG9mZnNldCBmb3IgdGhlIHRleHQgb3V0bGluZS5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLiBgXCIxMiVcImBcbiAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZU9mZnNldFkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gc3Ryb2tlV2lkdGhcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIHdpZHRoIG9mIGFuIGlubmVyIHN0cm9rZSBkcmF3biBpbnNpZGUgZWFjaCB0ZXh0IGdseXBoIHVzaW5nIHRoZSBgc3Ryb2tlQ29sb3JgIGFuZCBgc3Ryb2tlT3BhY2l0eWAuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy4gYFwiMTIlXCJgXG4gICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IHN0cm9rZUNvbG9yXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBzdHJva2UsIGlmIGBzdHJva2VXaWR0aGAgaXMgZ3JlYXRlciB0aGFuIHplcm8uIERlZmF1bHRzIHRvIGdyYXkuXG4gICAgICovXG4gICAgdGhpcy5zdHJva2VDb2xvciA9IGRlZmF1bHRTdHJva2VDb2xvcjtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gc3Ryb2tlT3BhY2l0eVxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgc3Ryb2tlLCBpZiBgc3Ryb2tlV2lkdGhgIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvLiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICovXG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gZmlsbE9wYWNpdHlcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIGdseXBoJ3MgZmlsbCBmcm9tIDAgdG8gMS4gVGhpcyBiZWhhdmVzIGxpa2UgdGhlIG1hdGVyaWFsJ3MgYG9wYWNpdHlgIGJ1dCBhbGxvd3NcbiAgICAgKiBnaXZpbmcgdGhlIGZpbGwgYSBkaWZmZXJlbnQgb3BhY2l0eSB0aGFuIHRoZSBgc3Ryb2tlT3BhY2l0eWAuIEEgZmlsbE9wYWNpdHkgb2YgYDBgIG1ha2VzIHRoZVxuICAgICAqIGludGVyaW9yIG9mIHRoZSBnbHlwaCBpbnZpc2libGUsIGxlYXZpbmcganVzdCB0aGUgYHN0cm9rZVdpZHRoYC4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqL1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBkZXB0aE9mZnNldFxuICAgICAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3Igc2V0dGluZyB0aGUgbWF0ZXJpYWwncyBgcG9seWdvbk9mZnNldGAgYW5kIHJlbGF0ZWQgcHJvcGVydGllcyxcbiAgICAgKiB3aGljaCBjYW4gYmUgdXNlZnVsIGluIHByZXZlbnRpbmcgei1maWdodGluZyB3aGVuIHRoaXMgdGV4dCBpcyBsYWlkIG9uIHRvcCBvZiBhbm90aGVyXG4gICAgICogcGxhbmUgaW4gdGhlIHNjZW5lLiBQb3NpdGl2ZSBudW1iZXJzIGFyZSBmdXJ0aGVyIGZyb20gdGhlIGNhbWVyYSwgbmVnYXRpdmVzIGNsb3Nlci5cbiAgICAgKi9cbiAgICB0aGlzLmRlcHRoT2Zmc2V0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0FycmF5PG51bWJlcj59IGNsaXBSZWN0XG4gICAgICogSWYgc3BlY2lmaWVkLCBkZWZpbmVzIGEgYFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXWAgb2YgYSByZWN0YW5nbGUgb3V0c2lkZSBvZiB3aGljaCBhbGxcbiAgICAgKiBwaXhlbHMgd2lsbCBiZSBkaXNjYXJkZWQuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGUgdG8gY2xpcCBvdmVyZmxvd2luZyB0ZXh0IHdoZW5cbiAgICAgKiBgd2hpdGVTcGFjZT0nbm93cmFwJ2AuXG4gICAgICovXG4gICAgdGhpcy5jbGlwUmVjdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG9yaWVudGF0aW9uXG4gICAgICogRGVmaW5lcyB0aGUgYXhpcyBwbGFuZSBvbiB3aGljaCB0aGUgdGV4dCBzaG91bGQgYmUgbGFpZCBvdXQgd2hlbiB0aGUgbWVzaCBoYXMgbm8gZXh0cmFcbiAgICAgKiByb3RhdGlvbiB0cmFuc2Zvcm0uIEl0IGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZyB3aXRoIHR3byBheGVzOiB0aGUgaG9yaXpvbnRhbCBheGlzIHdpdGhcbiAgICAgKiBwb3NpdGl2ZSBwb2ludGluZyByaWdodCwgYW5kIHRoZSB2ZXJ0aWNhbCBheGlzIHdpdGggcG9zaXRpdmUgcG9pbnRpbmcgdXAuIEJ5IGRlZmF1bHQgdGhpc1xuICAgICAqIGlzICcreCt5JywgbWVhbmluZyB0aGUgdGV4dCBzaXRzIG9uIHRoZSB4eSBwbGFuZSB3aXRoIHRoZSB0ZXh0J3MgdG9wIHRvd2FyZCBwb3NpdGl2ZSB5XG4gICAgICogYW5kIGZhY2luZyBwb3NpdGl2ZSB6LiBBIHZhbHVlIG9mICcreC16JyB3b3VsZCBwbGFjZSBpdCBvbiB0aGUgeHogcGxhbmUgd2l0aCB0aGUgdGV4dCdzXG4gICAgICogdG9wIHRvd2FyZCBuZWdhdGl2ZSB6IGFuZCBmYWNpbmcgcG9zaXRpdmUgeS5cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGF0aW9uID0gZGVmYXVsdE9yaWVudDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gZ2x5cGhHZW9tZXRyeURldGFpbFxuICAgICAqIENvbnRyb2xzIG51bWJlciBvZiB2ZXJ0aWNhbC9ob3Jpem9udGFsIHNlZ21lbnRzIHRoYXQgbWFrZSB1cCBlYWNoIGdseXBoJ3MgcmVjdGFuZ3VsYXJcbiAgICAgKiBwbGFuZS4gRGVmYXVsdHMgdG8gMS4gVGhpcyBjYW4gYmUgaW5jcmVhc2VkIHRvIHByb3ZpZGUgbW9yZSBnZW9tZXRyaWNhbCBkZXRhaWwgZm9yIGN1c3RvbVxuICAgICAqIHZlcnRleCBzaGFkZXIgZWZmZWN0cywgZm9yIGV4YW1wbGUuXG4gICAgICovXG4gICAgdGhpcy5nbHlwaEdlb21ldHJ5RGV0YWlsID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxudWxsfSBzZGZHbHlwaFNpemVcbiAgICAgKiBUaGUgc2l6ZSBvZiBlYWNoIGdseXBoJ3MgU0RGIChzaWduZWQgZGlzdGFuY2UgZmllbGQpIHVzZWQgZm9yIHJlbmRlcmluZy4gVGhpcyBtdXN0IGJlIGFcbiAgICAgKiBwb3dlci1vZi10d28gbnVtYmVyLiBEZWZhdWx0cyB0byA2NCB3aGljaCBpcyBnZW5lcmFsbHkgYSBnb29kIGJhbGFuY2Ugb2Ygc2l6ZSBhbmQgcXVhbGl0eVxuICAgICAqIGZvciBtb3N0IGZvbnRzLiBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmdcbiAgICAgKiB0aGUgc2hhcnBuZXNzIG9mIGNvcm5lcnMgYW5kIHByZXZlbnRpbmcgbG9zcyBvZiB2ZXJ5IHRoaW4gbGluZXMsIGF0IHRoZSBleHBlbnNlIG9mXG4gICAgICogaW5jcmVhc2VkIG1lbW9yeSBmb290cHJpbnQgYW5kIGxvbmdlciBTREYgZ2VuZXJhdGlvbiB0aW1lLlxuICAgICAqL1xuICAgIHRoaXMuc2RmR2x5cGhTaXplID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IGdwdUFjY2VsZXJhdGVTREZcbiAgICAgKiBXaGVuIGB0cnVlYCwgdGhlIFNERiBnZW5lcmF0aW9uIHByb2Nlc3Mgd2lsbCBiZSBHUFUtYWNjZWxlcmF0ZWQgd2l0aCBXZWJHTCB3aGVuIHBvc3NpYmxlLFxuICAgICAqIG1ha2luZyBpdCBtdWNoIGZhc3RlciBlc3BlY2lhbGx5IGZvciBjb21wbGV4IGdseXBocywgYW5kIGZhbGxpbmcgYmFjayB0byBhIEphdmFTY3JpcHQgdmVyc2lvblxuICAgICAqIGV4ZWN1dGVkIGluIHdlYiB3b3JrZXJzIHdoZW4gc3VwcG9ydCBpc24ndCBhdmFpbGFibGUuIEl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IGRldGVjdCBzdXBwb3J0LFxuICAgICAqIGJ1dCBpdCdzIHN0aWxsIHNvbWV3aGF0IGV4cGVyaW1lbnRhbCwgc28geW91IGNhbiBzZXQgaXQgdG8gYGZhbHNlYCB0byBmb3JjZSBpdCB0byB1c2UgdGhlIEpTXG4gICAgICogdmVyc2lvbiBpZiB5b3UgZW5jb3VudGVyIGlzc3VlcyB3aXRoIGl0LlxuICAgICAqL1xuICAgIHRoaXMuZ3B1QWNjZWxlcmF0ZVNERiA9IHRydWU7XG5cbiAgICB0aGlzLmRlYnVnU0RGID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdGV4dCByZW5kZXJpbmcgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHRleHQtcmVsYXRlZCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMuXG4gICAqIFRoaXMgaXMgYW4gYXN5bmMgcHJvY2Vzcywgc28geW91IGNhbiBwYXNzIGluIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBpdFxuICAgKiBmaW5pc2hlcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKi9cbiAgc3luYyhjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9uZWVkc1N5bmMpIHtcbiAgICAgIHRoaXMuX25lZWRzU3luYyA9IGZhbHNlO1xuXG4gICAgICAvLyBJZiB0aGVyZSdzIGFub3RoZXIgc3luYyBzdGlsbCBpbiBwcm9ncmVzcywgcXVldWVcbiAgICAgIGlmICh0aGlzLl9pc1N5bmNpbmcpIHtcbiAgICAgICAgKHRoaXMuX3F1ZXVlZFN5bmNzIHx8ICh0aGlzLl9xdWV1ZWRTeW5jcyA9IFtdKSkucHVzaChjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc1N5bmNpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3luY1N0YXJ0RXZlbnQpO1xuXG4gICAgICAgIGdldFRleHRSZW5kZXJJbmZvKHtcbiAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICAgICAgZm9udDogdGhpcy5mb250LFxuICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplIHx8IDAuMSxcbiAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcgfHwgMCxcbiAgICAgICAgICBsaW5lSGVpZ2h0OiB0aGlzLmxpbmVIZWlnaHQgfHwgJ25vcm1hbCcsXG4gICAgICAgICAgbWF4V2lkdGg6IHRoaXMubWF4V2lkdGgsXG4gICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbiB8fCAnYXV0bycsXG4gICAgICAgICAgdGV4dEFsaWduOiB0aGlzLnRleHRBbGlnbixcbiAgICAgICAgICB0ZXh0SW5kZW50OiB0aGlzLnRleHRJbmRlbnQsXG4gICAgICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgICAgIG92ZXJmbG93V3JhcDogdGhpcy5vdmVyZmxvd1dyYXAsXG4gICAgICAgICAgYW5jaG9yWDogdGhpcy5hbmNob3JYLFxuICAgICAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yWSxcbiAgICAgICAgICBjb2xvclJhbmdlczogdGhpcy5jb2xvclJhbmdlcyxcbiAgICAgICAgICBpbmNsdWRlQ2FyZXRQb3NpdGlvbnM6IHRydWUsIC8vVE9ETyBwYXJhbWV0ZXJpemVcbiAgICAgICAgICBzZGZHbHlwaFNpemU6IHRoaXMuc2RmR2x5cGhTaXplLFxuICAgICAgICAgIGdwdUFjY2VsZXJhdGVTREY6IHRoaXMuZ3B1QWNjZWxlcmF0ZVNERixcbiAgICAgICAgfSwgdGV4dFJlbmRlckluZm8gPT4ge1xuICAgICAgICAgIHRoaXMuX2lzU3luY2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gU2F2ZSByZXN1bHQgZm9yIGxhdGVyIHVzZSBpbiBvbkJlZm9yZVJlbmRlclxuICAgICAgICAgIHRoaXMuX3RleHRSZW5kZXJJbmZvID0gdGV4dFJlbmRlckluZm87XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGdlb21ldHJ5IGF0dHJpYnV0ZXNcbiAgICAgICAgICB0aGlzLmdlb21ldHJ5LnVwZGF0ZUdseXBocyhcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmdseXBoQm91bmRzLFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhBdGxhc0luZGljZXMsXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5ibG9ja0JvdW5kcyxcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmNodW5rZWRCb3VuZHMsXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaENvbG9yc1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBJZiB3ZSBoYWQgZXh0cmEgc3luYyByZXF1ZXN0cyBxdWV1ZWQgdXAsIGtpY2sgaXQgb2ZmXG4gICAgICAgICAgY29uc3QgcXVldWVkID0gdGhpcy5fcXVldWVkU3luY3M7XG4gICAgICAgICAgaWYgKHF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVkU3luY3MgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3luYygoKSA9PiB7XG4gICAgICAgICAgICAgIHF1ZXVlZC5mb3JFYWNoKGZuID0+IGZuICYmIGZuKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN5bmNDb21wbGV0ZUV2ZW50KTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGUgYSBzeW5jIGlmIG5lZWRlZCAtIG5vdGUgaXQgd29uJ3QgY29tcGxldGUgdW50aWwgbmV4dCBmcmFtZSBhdCB0aGVcbiAgICogZWFybGllc3Qgc28gaWYgcG9zc2libGUgaXQncyBhIGdvb2QgaWRlYSB0byBjYWxsIHN5bmMoKSBtYW51YWxseSBhcyBzb29uIGFzXG4gICAqIGFsbCB0aGUgcHJvcGVydGllcyBoYXZlIGJlZW4gc2V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG9uQmVmb3JlUmVuZGVyKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKSB7XG4gICAgdGhpcy5zeW5jKCk7XG5cbiAgICAvLyBUaGlzIG1heSBub3QgYWx3YXlzIGJlIGEgdGV4dCBtYXRlcmlhbCwgZS5nLiBpZiB0aGVyZSdzIGEgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCBwcmVzZW50XG4gICAgaWYgKG1hdGVyaWFsLmlzVHJvaWthVGV4dE1hdGVyaWFsKSB7XG4gICAgICB0aGlzLl9wcmVwYXJlRm9yUmVuZGVyKG1hdGVyaWFsKTtcbiAgICB9XG5cbiAgICAvLyBXZSBuZWVkIHRvIGZvcmNlIHRoZSBtYXRlcmlhbCB0byBGcm9udFNpZGUgdG8gYXZvaWQgdGhlIGRvdWJsZS1kcmF3LWNhbGwgcGVyZm9ybWFuY2UgaGl0XG4gICAgLy8gaW50cm9kdWNlZCBpbiBUaHJlZS5qcyByMTMwOiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjE5NjcgLSBUaGUgc2lkZWRuZXNzXG4gICAgLy8gaXMgaW5zdGVhZCBhcHBsaWVkIHZpYSBkcmF3UmFuZ2UgaW4gdGhlIEdseXBoc0dlb21ldHJ5LlxuICAgIG1hdGVyaWFsLl9oYWRPd25TaWRlID0gbWF0ZXJpYWwuaGFzT3duUHJvcGVydHkoJ3NpZGUnKTtcbiAgICB0aGlzLmdlb21ldHJ5LnNldFNpZGUobWF0ZXJpYWwuX2FjdHVhbFNpZGUgPSBtYXRlcmlhbC5zaWRlKTtcbiAgICBtYXRlcmlhbC5zaWRlID0gRnJvbnRTaWRlO1xuICB9XG5cbiAgb25BZnRlclJlbmRlcihyZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCkge1xuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgbWF0ZXJpYWwgc2lkZVxuICAgIGlmIChtYXRlcmlhbC5faGFkT3duU2lkZSkge1xuICAgICAgbWF0ZXJpYWwuc2lkZSA9IG1hdGVyaWFsLl9hY3R1YWxTaWRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgbWF0ZXJpYWwuc2lkZTsgLy8gYmFjayB0byBpbmhlcml0aW5nIGZyb20gYmFzZSBtYXRlcmlhbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG9ydGN1dCB0byBkaXNwb3NlIHRoZSBnZW9tZXRyeSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlLlxuICAgKiBOb3RlOiB3ZSBkb24ndCBhbHNvIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgaGVyZSBiZWNhdXNlIGlmIGFueXRoaW5nIGVsc2UgaXNcbiAgICogc2hhcmluZyB0aGUgc2FtZSBiYXNlIG1hdGVyaWFsIGl0IHdpbGwgcmVzdWx0IGluIGEgcGF1c2UgbmV4dCBmcmFtZSBhcyB0aGUgcHJvZ3JhbVxuICAgKiBpcyByZWNvbXBpbGVkLiBJbnN0ZWFkIHVzZXJzIGNhbiBkaXNwb3NlIHRoZSBiYXNlIG1hdGVyaWFsIG1hbnVhbGx5LCBsaWtlIG5vcm1hbCxcbiAgICogYW5kIHdlJ2xsIGFsc28gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBhdCB0aGF0IHRpbWUuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7VHJvaWthVGV4dFJlbmRlckluZm98bnVsbH0gdGV4dFJlbmRlckluZm9cbiAgICogQHJlYWRvbmx5XG4gICAqIFRoZSBjdXJyZW50IHByb2Nlc3NlZCByZW5kZXJpbmcgZGF0YSBmb3IgdGhpcyBUZXh0TWVzaCwgcmV0dXJuZWQgYnkgdGhlIFRleHRCdWlsZGVyIGFmdGVyXG4gICAqIGEgYHN5bmMoKWAgY2FsbC4gVGhpcyB3aWxsIGJlIGBudWxsYCBpbml0aWFsbHksIGFuZCBtYXkgYmUgc3RhbGUgZm9yIGEgc2hvcnQgcGVyaW9kIHVudGlsXG4gICAqIHRoZSBhc3luY2hyb3VzIGBzeW5jKClgIHByb2Nlc3MgY29tcGxldGVzLlxuICAgKi9cbiAgZ2V0IHRleHRSZW5kZXJJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0UmVuZGVySW5mbyB8fCBudWxsXG4gIH1cblxuICAvLyBIYW5kbGVyIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIHRoZSBiYXNlIG1hdGVyaWFsIHdpdGggb3VyIHVwZ3JhZGVzLiBXZSBkbyB0aGUgd3JhcHBpbmdcbiAgLy8gbGF6aWx5IG9uIF9yZWFkXyByYXRoZXIgdGhhbiB3cml0ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3cmFwcGluZyBvbiB0cmFuc2llbnQgdmFsdWVzLlxuICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgbGV0IGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbDtcbiAgICBjb25zdCBiYXNlTWF0ZXJpYWwgPSB0aGlzLl9iYXNlTWF0ZXJpYWwgfHwgdGhpcy5fZGVmYXVsdE1hdGVyaWFsIHx8ICh0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgPSBkZWZhdWx0TWF0ZXJpYWwuY2xvbmUoKSk7XG4gICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgZGVyaXZlZE1hdGVyaWFsLmJhc2VNYXRlcmlhbCAhPT0gYmFzZU1hdGVyaWFsKSB7XG4gICAgICBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCk7XG4gICAgICAvLyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHdoZW4gaXRzIGJhc2UgbWF0ZXJpYWwgaXMgZGlzcG9zZWQ6XG4gICAgICBiYXNlTWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGZ1bmN0aW9uIG9uRGlzcG9zZSgpIHtcbiAgICAgICAgYmFzZU1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIElmIHRleHQgb3V0bGluZSBpcyBjb25maWd1cmVkLCByZW5kZXIgaXQgYXMgYSBwcmVsaW1pbmFyeSBkcmF3IHVzaW5nIFRocmVlJ3MgbXVsdGktbWF0ZXJpYWxcbiAgICAvLyBmZWF0dXJlIChzZWUgR2x5cGhzR2VvbWV0cnkgd2hpY2ggc2V0cyB1cCBgZ3JvdXBzYCBmb3IgdGhpcyBwdXJwb3NlKSBEb2luZyBpdCB3aXRoIG11bHRpXG4gICAgLy8gbWF0ZXJpYWxzIGVuc3VyZXMgdGhlIGxheWVycyBhcmUgYWx3YXlzIHJlbmRlcmVkIGNvbnNlY3V0aXZlbHkgaW4gYSBjb25zaXN0ZW50IG9yZGVyLlxuICAgIC8vIEVhY2ggbGF5ZXIgd2lsbCB0cmlnZ2VyIG9uQmVmb3JlUmVuZGVyIHdpdGggdGhlIGFwcHJvcHJpYXRlIG1hdGVyaWFsLlxuICAgIGlmICh0aGlzLm91dGxpbmVXaWR0aCB8fCB0aGlzLm91dGxpbmVCbHVyIHx8IHRoaXMub3V0bGluZU9mZnNldFggfHwgdGhpcy5vdXRsaW5lT2Zmc2V0WSkge1xuICAgICAgbGV0IG91dGxpbmVNYXRlcmlhbCA9IGRlcml2ZWRNYXRlcmlhbC5fb3V0bGluZU10bDtcbiAgICAgIGlmICghb3V0bGluZU1hdGVyaWFsKSB7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbCA9IGRlcml2ZWRNYXRlcmlhbC5fb3V0bGluZU10bCA9IE9iamVjdC5jcmVhdGUoZGVyaXZlZE1hdGVyaWFsLCB7XG4gICAgICAgICAgaWQ6IHt2YWx1ZTogZGVyaXZlZE1hdGVyaWFsLmlkICsgMC4xfVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0bGluZU1hdGVyaWFsLmlzVGV4dE91dGxpbmVNYXRlcmlhbCA9IHRydWU7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbC5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbC5tYXAgPSBudWxsOyAvLz8/P1xuICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGZ1bmN0aW9uIG9uRGlzcG9zZSgpIHtcbiAgICAgICAgICBkZXJpdmVkTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgICAgb3V0bGluZU1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwsXG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbFxuICAgICAgXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVyaXZlZE1hdGVyaWFsXG4gICAgfVxuICB9XG4gIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICBpZiAoYmFzZU1hdGVyaWFsICYmIGJhc2VNYXRlcmlhbC5pc1Ryb2lrYVRleHRNYXRlcmlhbCkgeyAvL3ByZXZlbnQgZG91YmxlLWRlcml2YXRpb25cbiAgICAgIHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbC5iYXNlTWF0ZXJpYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICB9XG4gIH1cblxuICBnZXQgZ2x5cGhHZW9tZXRyeURldGFpbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5kZXRhaWxcbiAgfVxuICBzZXQgZ2x5cGhHZW9tZXRyeURldGFpbChkZXRhaWwpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmRldGFpbCA9IGRldGFpbDtcbiAgfVxuXG4gIGdldCBjdXJ2ZVJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5jdXJ2ZVJhZGl1c1xuICB9XG4gIHNldCBjdXJ2ZVJhZGl1cyhyKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5jdXJ2ZVJhZGl1cyA9IHI7XG4gIH1cblxuICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gIGdldCBjdXN0b21EZXB0aE1hdGVyaWFsKCkge1xuICAgIHJldHVybiBmaXJzdCh0aGlzLm1hdGVyaWFsKS5nZXREZXB0aE1hdGVyaWFsKClcbiAgfVxuICBnZXQgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gZmlyc3QodGhpcy5tYXRlcmlhbCkuZ2V0RGlzdGFuY2VNYXRlcmlhbCgpXG4gIH1cblxuICBfcHJlcGFyZUZvclJlbmRlcihtYXRlcmlhbCkge1xuICAgIGNvbnN0IGlzT3V0bGluZSA9IG1hdGVyaWFsLmlzVGV4dE91dGxpbmVNYXRlcmlhbDtcbiAgICBjb25zdCB1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuICAgIGNvbnN0IHRleHRJbmZvID0gdGhpcy50ZXh0UmVuZGVySW5mbztcbiAgICBpZiAodGV4dEluZm8pIHtcbiAgICAgIGNvbnN0IHtzZGZUZXh0dXJlLCBibG9ja0JvdW5kc30gPSB0ZXh0SW5mbztcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZUZXh0dXJlLnZhbHVlID0gc2RmVGV4dHVyZTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZUZXh0dXJlU2l6ZS52YWx1ZS5zZXQoc2RmVGV4dHVyZS5pbWFnZS53aWR0aCwgc2RmVGV4dHVyZS5pbWFnZS5oZWlnaHQpO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERkdseXBoU2l6ZS52YWx1ZSA9IHRleHRJbmZvLnNkZkdseXBoU2l6ZTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZFeHBvbmVudC52YWx1ZSA9IHRleHRJbmZvLnNkZkV4cG9uZW50O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVRvdGFsQm91bmRzLnZhbHVlLmZyb21BcnJheShibG9ja0JvdW5kcyk7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthVXNlR2x5cGhDb2xvcnMudmFsdWUgPSAhaXNPdXRsaW5lICYmICEhdGV4dEluZm8uZ2x5cGhDb2xvcnM7XG5cbiAgICAgIGxldCBkaXN0YW5jZU9mZnNldCA9IDA7XG4gICAgICBsZXQgYmx1clJhZGl1cyA9IDA7XG4gICAgICBsZXQgc3Ryb2tlV2lkdGggPSAwO1xuICAgICAgbGV0IGZpbGxPcGFjaXR5O1xuICAgICAgbGV0IHN0cm9rZU9wYWNpdHk7XG4gICAgICBsZXQgc3Ryb2tlQ29sb3I7XG4gICAgICBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgICBsZXQgb2Zmc2V0WSA9IDA7XG5cbiAgICAgIGlmIChpc091dGxpbmUpIHtcbiAgICAgICAgbGV0IHtvdXRsaW5lV2lkdGgsIG91dGxpbmVPZmZzZXRYLCBvdXRsaW5lT2Zmc2V0WSwgb3V0bGluZUJsdXIsIG91dGxpbmVPcGFjaXR5fSA9IHRoaXM7XG4gICAgICAgIGRpc3RhbmNlT2Zmc2V0ID0gdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVXaWR0aCkgfHwgMDtcbiAgICAgICAgYmx1clJhZGl1cyA9IE1hdGgubWF4KDAsIHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lQmx1cikgfHwgMCk7XG4gICAgICAgIGZpbGxPcGFjaXR5ID0gb3V0bGluZU9wYWNpdHk7XG4gICAgICAgIG9mZnNldFggPSB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZU9mZnNldFgpIHx8IDA7XG4gICAgICAgIG9mZnNldFkgPSB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZU9mZnNldFkpIHx8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJva2VXaWR0aCA9IE1hdGgubWF4KDAsIHRoaXMuX3BhcnNlUGVyY2VudCh0aGlzLnN0cm9rZVdpZHRoKSB8fCAwKTtcbiAgICAgICAgaWYgKHN0cm9rZVdpZHRoKSB7XG4gICAgICAgICAgc3Ryb2tlQ29sb3IgPSB0aGlzLnN0cm9rZUNvbG9yO1xuICAgICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTdHJva2VDb2xvci52YWx1ZS5zZXQoc3Ryb2tlQ29sb3IgPT0gbnVsbCA/IGRlZmF1bHRTdHJva2VDb2xvciA6IHN0cm9rZUNvbG9yKTtcbiAgICAgICAgICBzdHJva2VPcGFjaXR5ID0gdGhpcy5zdHJva2VPcGFjaXR5O1xuICAgICAgICAgIGlmIChzdHJva2VPcGFjaXR5ID09IG51bGwpIHN0cm9rZU9wYWNpdHkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZpbGxPcGFjaXR5ID0gdGhpcy5maWxsT3BhY2l0eTtcbiAgICAgIH1cblxuICAgICAgdW5pZm9ybXMudVRyb2lrYURpc3RhbmNlT2Zmc2V0LnZhbHVlID0gZGlzdGFuY2VPZmZzZXQ7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthUG9zaXRpb25PZmZzZXQudmFsdWUuc2V0KG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYUJsdXJSYWRpdXMudmFsdWUgPSBibHVyUmFkaXVzO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZVdpZHRoLnZhbHVlID0gc3Ryb2tlV2lkdGg7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU3Ryb2tlT3BhY2l0eS52YWx1ZSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthRmlsbE9wYWNpdHkudmFsdWUgPSBmaWxsT3BhY2l0eSA9PSBudWxsID8gMSA6IGZpbGxPcGFjaXR5O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYUN1cnZlUmFkaXVzLnZhbHVlID0gdGhpcy5jdXJ2ZVJhZGl1cyB8fCAwO1xuXG4gICAgICBsZXQgY2xpcFJlY3QgPSB0aGlzLmNsaXBSZWN0O1xuICAgICAgaWYgKGNsaXBSZWN0ICYmIEFycmF5LmlzQXJyYXkoY2xpcFJlY3QpICYmIGNsaXBSZWN0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthQ2xpcFJlY3QudmFsdWUuZnJvbUFycmF5KGNsaXBSZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIGNsaXBwaW5nIC0gY2hvb3NlIGEgZmluaXRlIHJlY3QgdGhhdCBzaG91bGRuJ3QgZXZlciBiZSByZWFjaGVkIGJ5IG92ZXJmbG93aW5nIGdseXBocyBvciBvdXRsaW5lc1xuICAgICAgICBjb25zdCBwYWQgPSAodGhpcy5mb250U2l6ZSB8fCAwLjEpICogMTAwO1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthQ2xpcFJlY3QudmFsdWUuc2V0KFxuICAgICAgICAgIGJsb2NrQm91bmRzWzBdIC0gcGFkLFxuICAgICAgICAgIGJsb2NrQm91bmRzWzFdIC0gcGFkLFxuICAgICAgICAgIGJsb2NrQm91bmRzWzJdICsgcGFkLFxuICAgICAgICAgIGJsb2NrQm91bmRzWzNdICsgcGFkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLmdlb21ldHJ5LmFwcGx5Q2xpcFJlY3QodW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlKTtcbiAgICB9XG4gICAgdW5pZm9ybXMudVRyb2lrYVNERkRlYnVnLnZhbHVlID0gISF0aGlzLmRlYnVnU0RGO1xuICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQgPSAhIXRoaXMuZGVwdGhPZmZzZXQ7XG4gICAgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciA9IG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMuZGVwdGhPZmZzZXQgfHwgMDtcblxuICAgIC8vIFNob3J0Y3V0IGZvciBzZXR0aW5nIG1hdGVyaWFsIGNvbG9yIHZpYSBgY29sb3JgIHByb3Agb24gdGhlIG1lc2g7IHRoaXMgaXNcbiAgICAvLyBhcHBsaWVkIG9ubHkgdG8gdGhlIGRlcml2ZWQgbWF0ZXJpYWwgdG8gYXZvaWQgbXV0YXRpbmcgYSBzaGFyZWQgYmFzZSBtYXRlcmlhbC5cbiAgICBjb25zdCBjb2xvciA9IGlzT3V0bGluZSA/ICh0aGlzLm91dGxpbmVDb2xvciB8fCAwKSA6IHRoaXMuY29sb3I7XG5cbiAgICBpZiAoY29sb3IgPT0gbnVsbCkge1xuICAgICAgZGVsZXRlIG1hdGVyaWFsLmNvbG9yOyAvL2luaGVyaXQgZnJvbSBiYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbG9yT2JqID0gbWF0ZXJpYWwuaGFzT3duUHJvcGVydHkoJ2NvbG9yJykgPyBtYXRlcmlhbC5jb2xvciA6IChtYXRlcmlhbC5jb2xvciA9IG5ldyBDb2xvcigpKTtcbiAgICAgIGlmIChjb2xvciAhPT0gY29sb3JPYmouX2lucHV0IHx8IHR5cGVvZiBjb2xvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29sb3JPYmouc2V0KGNvbG9yT2JqLl9pbnB1dCA9IGNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiYXNlIG9yaWVudGF0aW9uXG4gICAgbGV0IG9yaWVudCA9IHRoaXMub3JpZW50YXRpb24gfHwgZGVmYXVsdE9yaWVudDtcbiAgICBpZiAob3JpZW50ICE9PSBtYXRlcmlhbC5fb3JpZW50YXRpb24pIHtcbiAgICAgIGxldCByb3RNYXQgPSB1bmlmb3Jtcy51VHJvaWthT3JpZW50LnZhbHVlO1xuICAgICAgb3JpZW50ID0gb3JpZW50LnJlcGxhY2UoL1teLSt4eXpdL2csICcnKTtcbiAgICAgIGxldCBtYXRjaCA9IG9yaWVudCAhPT0gZGVmYXVsdE9yaWVudCAmJiBvcmllbnQubWF0Y2goL14oWy0rXSkoW3h5el0pKFstK10pKFt4eXpdKSQvKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBsZXQgWywgaFNpZ24sIGhBeGlzLCB2U2lnbiwgdkF4aXNdID0gbWF0Y2g7XG4gICAgICAgIHRlbXBWZWMzYS5zZXQoMCwgMCwgMClbaEF4aXNdID0gaFNpZ24gPT09ICctJyA/IDEgOiAtMTtcbiAgICAgICAgdGVtcFZlYzNiLnNldCgwLCAwLCAwKVt2QXhpc10gPSB2U2lnbiA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICB0ZW1wTWF0NC5sb29rQXQob3JpZ2luLCB0ZW1wVmVjM2EuY3Jvc3ModGVtcFZlYzNiKSwgdGVtcFZlYzNiKTtcbiAgICAgICAgcm90TWF0LnNldEZyb21NYXRyaXg0KHRlbXBNYXQ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdE1hdC5pZGVudGl0eSgpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwuX29yaWVudGF0aW9uID0gb3JpZW50O1xuICAgIH1cbiAgfVxuXG4gIF9wYXJzZVBlcmNlbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IG1hdGNoID0gdmFsdWUubWF0Y2goL14oLT9bXFxkLl0rKSUkLyk7XG4gICAgICBsZXQgcGN0ID0gbWF0Y2ggPyBwYXJzZUZsb2F0KG1hdGNoWzFdKSA6IE5hTjtcbiAgICAgIHZhbHVlID0gKGlzTmFOKHBjdCkgPyAwIDogcGN0IC8gMTAwKSAqIHRoaXMuZm9udFNpemU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSBhIHBvaW50IGluIGxvY2FsIHNwYWNlIHRvIGFuIHgveSBpbiB0aGUgdGV4dCBwbGFuZS5cbiAgICovXG4gIGxvY2FsUG9zaXRpb25Ub1RleHRDb29yZHMocG9zaXRpb24sIHRhcmdldCA9IG5ldyBWZWN0b3IyKCkpIHtcbiAgICB0YXJnZXQuY29weShwb3NpdGlvbik7IC8vc2ltcGxlIG5vbi1jdXJ2ZWQgY2FzZSBpcyAxOjFcbiAgICBjb25zdCByID0gdGhpcy5jdXJ2ZVJhZGl1cztcbiAgICBpZiAocikgeyAvL2ZsYXR0ZW4gdGhlIGN1cnZlXG4gICAgICB0YXJnZXQueCA9IE1hdGguYXRhbjIocG9zaXRpb24ueCwgTWF0aC5hYnMocikgLSBNYXRoLmFicyhwb3NpdGlvbi56KSkgKiBNYXRoLmFicyhyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSBhIHBvaW50IGluIHdvcmxkIHNwYWNlIHRvIGFuIHgveSBpbiB0aGUgdGV4dCBwbGFuZS5cbiAgICovXG4gIHdvcmxkUG9zaXRpb25Ub1RleHRDb29yZHMocG9zaXRpb24sIHRhcmdldCA9IG5ldyBWZWN0b3IyKCkpIHtcbiAgICB0ZW1wVmVjM2EuY29weShwb3NpdGlvbik7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxQb3NpdGlvblRvVGV4dENvb3Jkcyh0aGlzLndvcmxkVG9Mb2NhbCh0ZW1wVmVjM2EpLCB0YXJnZXQpXG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlIEN1c3RvbSByYXljYXN0aW5nIHRvIHRlc3QgYWdhaW5zdCB0aGUgd2hvbGUgdGV4dCBibG9jaydzIG1heCByZWN0YW5ndWxhciBib3VuZHNcbiAgICogVE9ETyBpcyB0aGVyZSBhbnkgcmVhc29uIHRvIG1ha2UgdGhpcyBtb3JlIGdyYW51bGFyLCBsaWtlIHdpdGhpbiBpbmRpdmlkdWFsIGxpbmUgb3IgZ2x5cGggcmVjdHM/XG4gICAqL1xuICByYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuICAgIGNvbnN0IHt0ZXh0UmVuZGVySW5mbywgY3VydmVSYWRpdXN9ID0gdGhpcztcbiAgICBpZiAodGV4dFJlbmRlckluZm8pIHtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IHRleHRSZW5kZXJJbmZvLmJsb2NrQm91bmRzO1xuICAgICAgY29uc3QgcmF5Y2FzdE1lc2ggPSBjdXJ2ZVJhZGl1cyA/IGdldEN1cnZlZFJheWNhc3RNZXNoKCkgOiBnZXRGbGF0UmF5Y2FzdE1lc2goKTtcbiAgICAgIGNvbnN0IGdlb20gPSByYXljYXN0TWVzaC5nZW9tZXRyeTtcbiAgICAgIGNvbnN0IHtwb3NpdGlvbiwgdXZ9ID0gZ2VvbS5hdHRyaWJ1dGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1di5jb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCB4ID0gYm91bmRzWzBdICsgKHV2LmdldFgoaSkgKiAoYm91bmRzWzJdIC0gYm91bmRzWzBdKSk7XG4gICAgICAgIGNvbnN0IHkgPSBib3VuZHNbMV0gKyAodXYuZ2V0WShpKSAqIChib3VuZHNbM10gLSBib3VuZHNbMV0pKTtcbiAgICAgICAgbGV0IHogPSAwO1xuICAgICAgICBpZiAoY3VydmVSYWRpdXMpIHtcbiAgICAgICAgICB6ID0gY3VydmVSYWRpdXMgLSBNYXRoLmNvcyh4IC8gY3VydmVSYWRpdXMpICogY3VydmVSYWRpdXM7XG4gICAgICAgICAgeCA9IE1hdGguc2luKHggLyBjdXJ2ZVJhZGl1cykgKiBjdXJ2ZVJhZGl1cztcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbi5zZXRYWVooaSwgeCwgeSwgeik7XG4gICAgICB9XG4gICAgICBnZW9tLmJvdW5kaW5nU3BoZXJlID0gdGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZTtcbiAgICAgIGdlb20uYm91bmRpbmdCb3ggPSB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nQm94O1xuICAgICAgcmF5Y2FzdE1lc2gubWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuICAgICAgcmF5Y2FzdE1lc2gubWF0ZXJpYWwuc2lkZSA9IHRoaXMubWF0ZXJpYWwuc2lkZTtcbiAgICAgIHRlbXBBcnJheS5sZW5ndGggPSAwO1xuICAgICAgcmF5Y2FzdE1lc2gucmF5Y2FzdChyYXljYXN0ZXIsIHRlbXBBcnJheSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZW1wQXJyYXlbaV0ub2JqZWN0ID0gdGhpcztcbiAgICAgICAgaW50ZXJzZWN0cy5wdXNoKHRlbXBBcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29weShzb3VyY2UpIHtcbiAgICAvLyBQcmV2ZW50IGNvcHlpbmcgdGhlIGdlb21ldHJ5IHJlZmVyZW5jZSBzbyB3ZSBkb24ndCBlbmQgdXAgc2hhcmluZyBhdHRyaWJ1dGVzIGJldHdlZW4gaW5zdGFuY2VzXG4gICAgY29uc3QgZ2VvbSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgc3VwZXIuY29weShzb3VyY2UpO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tO1xuXG4gICAgQ09QWUFCTEVfUFJPUFMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIHRoaXNbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcylcbiAgfVxufVxuXG5cbi8vIENyZWF0ZSBzZXR0ZXJzIGZvciBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRleHQgbGF5b3V0OlxuU1lOQ0FCTEVfUFJPUFMuZm9yRWFjaChwcm9wID0+IHtcbiAgY29uc3QgcHJpdmF0ZUtleSA9ICdfcHJpdmF0ZV8nICsgcHJvcDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHQucHJvdG90eXBlLCBwcm9wLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbcHJpdmF0ZUtleV1cbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB0aGlzW3ByaXZhdGVLZXldKSB7XG4gICAgICAgIHRoaXNbcHJpdmF0ZUtleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSk7XG5cbi8vPT09IFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWFsaW5nIHdpdGggY2FyZXRzIGFuZCBzZWxlY3Rpb24gcmFuZ2VzID09PS8vXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVGV4dENhcmV0XG4gKiBAcHJvcGVydHkge251bWJlcn0geCAtIHggcG9zaXRpb24gb2YgdGhlIGNhcmV0XG4gKiBAcHJvcGVydHkge251bWJlcn0geSAtIHkgcG9zaXRpb24gb2YgdGhlIGNhcmV0J3MgYm90dG9tXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBjYXJldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNoYXJJbmRleCAtIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nIG9mIHRoaXMgY2FyZXQncyB0YXJnZXRcbiAqICAgY2hhcmFjdGVyOyB0aGUgY2FyZXQgd2lsbCBiZSBmb3IgdGhlIHBvc2l0aW9uIF9iZWZvcmVfIHRoYXQgY2hhcmFjdGVyLlxuICovXG5cbi8qKlxuICogR2l2ZW4gYSBsb2NhbCB4L3kgY29vcmRpbmF0ZSBpbiB0aGUgdGV4dCBibG9jayBwbGFuZSwgZmluZCB0aGUgbmVhcmVzdCBjYXJldCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7VHJvaWthVGV4dFJlbmRlckluZm99IHRleHRSZW5kZXJJbmZvIC0gYSByZXN1bHQgb2JqZWN0IGZyb20gVGV4dEJ1aWxkZXIjZ2V0VGV4dFJlbmRlckluZm9cbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHJldHVybiB7VGV4dENhcmV0IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FyZXRBdFBvaW50KHRleHRSZW5kZXJJbmZvLCB4LCB5KSB7XG4gIGxldCBjbG9zZXN0Q2FyZXQgPSBudWxsO1xuICBjb25zdCB7Y2FyZXRIZWlnaHR9ID0gdGV4dFJlbmRlckluZm87XG4gIGNvbnN0IGNhcmV0c0J5Um93ID0gZ3JvdXBDYXJldHNCeVJvdyh0ZXh0UmVuZGVySW5mbyk7XG5cbiAgLy8gRmluZCBuZWFyZXN0IHJvdyBieSB5IGZpcnN0XG4gIGxldCBjbG9zZXN0Um93WSA9IEluZmluaXR5O1xuICBjYXJldHNCeVJvdy5mb3JFYWNoKChjYXJldHMsIHJvd1kpID0+IHtcbiAgICBpZiAoTWF0aC5hYnMoeSAtIChyb3dZICsgY2FyZXRIZWlnaHQgLyAyKSkgPCBNYXRoLmFicyh5IC0gKGNsb3Nlc3RSb3dZICsgY2FyZXRIZWlnaHQgLyAyKSkpIHtcbiAgICAgIGNsb3Nlc3RSb3dZID0gcm93WTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoZW4gZmluZCBjbG9zZXN0IGNhcmV0IGJ5IHggd2l0aGluIHRoYXQgcm93XG4gIGNhcmV0c0J5Um93LmdldChjbG9zZXN0Um93WSkuZm9yRWFjaChjYXJldCA9PiB7XG4gICAgaWYgKCFjbG9zZXN0Q2FyZXQgfHwgTWF0aC5hYnMoeCAtIGNhcmV0LngpIDwgTWF0aC5hYnMoeCAtIGNsb3Nlc3RDYXJldC54KSkge1xuICAgICAgY2xvc2VzdENhcmV0ID0gY2FyZXQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNsb3Nlc3RDYXJldFxufVxuXG5cbmNvbnN0IF9yZWN0c0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBHaXZlbiBzdGFydCBhbmQgZW5kIGNoYXJhY3RlciBpbmRleGVzLCByZXR1cm4gYSBsaXN0IG9mIHJlY3RhbmdsZXMgY292ZXJpbmcgYWxsIHRoZVxuICogY2hhcmFjdGVycyB3aXRoaW4gdGhhdCBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge1Ryb2lrYVRleHRSZW5kZXJJbmZvfSB0ZXh0UmVuZGVySW5mb1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gaW5kZXggb2YgdGhlIGZpcnN0IGNoYXIgaW4gdGhlIHNlbGVjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzZWxlY3Rpb25cbiAqIEByZXR1cm4ge0FycmF5PHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219PiB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvblJlY3RzKHRleHRSZW5kZXJJbmZvLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZWN0cztcbiAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgLy8gQ2hlY2sgY2FjaGUgLSB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gICAgbGV0IHByZXZSZXN1bHQgPSBfcmVjdHNDYWNoZS5nZXQodGV4dFJlbmRlckluZm8pO1xuICAgIGlmIChwcmV2UmVzdWx0ICYmIHByZXZSZXN1bHQuc3RhcnQgPT09IHN0YXJ0ICYmIHByZXZSZXN1bHQuZW5kID09PSBlbmQpIHtcbiAgICAgIHJldHVybiBwcmV2UmVzdWx0LnJlY3RzXG4gICAgfVxuXG4gICAgY29uc3Qge2NhcmV0UG9zaXRpb25zLCBjYXJldEhlaWdodH0gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgY29uc3QgcyA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICBlbmQgPSBzO1xuICAgIH1cbiAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNhcmV0UG9zaXRpb25zLmxlbmd0aCArIDEpO1xuXG4gICAgLy8gQnVpbGQgbGlzdCBvZiByZWN0cywgZXhwYW5kaW5nIHRoZSBjdXJyZW50IHJlY3QgZm9yIGFsbCBjaGFyYWN0ZXJzIGluIGEgcnVuIGFuZCBzdGFydGluZ1xuICAgIC8vIGEgbmV3IHJlY3Qgd2hlbmV2ZXIgcmVhY2hpbmcgYSBuZXcgbGluZSBvciBhIG5ldyBiaWRpIGRpcmVjdGlvblxuICAgIHJlY3RzID0gW107XG4gICAgbGV0IGN1cnJlbnRSZWN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgeDEgPSBjYXJldFBvc2l0aW9uc1tpICogM107XG4gICAgICBjb25zdCB4MiA9IGNhcmV0UG9zaXRpb25zW2kgKiAzICsgMV07XG4gICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IGNhcmV0UG9zaXRpb25zW2kgKiAzICsgMl07XG4gICAgICBpZiAoIWN1cnJlbnRSZWN0IHx8IGJvdHRvbSAhPT0gY3VycmVudFJlY3QuYm90dG9tIHx8IGxlZnQgPiBjdXJyZW50UmVjdC5yaWdodCB8fCByaWdodCA8IGN1cnJlbnRSZWN0LmxlZnQpIHtcbiAgICAgICAgY3VycmVudFJlY3QgPSB7XG4gICAgICAgICAgbGVmdDogSW5maW5pdHksXG4gICAgICAgICAgcmlnaHQ6IC1JbmZpbml0eSxcbiAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICB0b3A6IGJvdHRvbSArIGNhcmV0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHJlY3RzLnB1c2goY3VycmVudFJlY3QpO1xuICAgICAgfVxuICAgICAgY3VycmVudFJlY3QubGVmdCA9IE1hdGgubWluKGxlZnQsIGN1cnJlbnRSZWN0LmxlZnQpO1xuICAgICAgY3VycmVudFJlY3QucmlnaHQgPSBNYXRoLm1heChyaWdodCwgY3VycmVudFJlY3QucmlnaHQpO1xuICAgIH1cblxuICAgIC8vIE1lcmdlIGFueSBvdmVybGFwcGluZyByZWN0cywgZS5nLiB0aG9zZSBmb3JtZWQgYnkgYWRqYWNlbnQgYmlkaSBydW5zXG4gICAgcmVjdHMuc29ydCgoYSwgYikgPT4gYi5ib3R0b20gLSBhLmJvdHRvbSB8fCBhLmxlZnQgLSBiLmxlZnQpO1xuICAgIGZvciAobGV0IGkgPSByZWN0cy5sZW5ndGggLSAxOyBpLS0gPiAwOykge1xuICAgICAgY29uc3QgcmVjdEEgPSByZWN0c1tpXTtcbiAgICAgIGNvbnN0IHJlY3RCID0gcmVjdHNbaSArIDFdO1xuICAgICAgaWYgKHJlY3RBLmJvdHRvbSA9PT0gcmVjdEIuYm90dG9tICYmIHJlY3RBLmxlZnQgPD0gcmVjdEIucmlnaHQgJiYgcmVjdEEucmlnaHQgPj0gcmVjdEIubGVmdCkge1xuICAgICAgICByZWN0Qi5sZWZ0ID0gTWF0aC5taW4ocmVjdEIubGVmdCwgcmVjdEEubGVmdCk7XG4gICAgICAgIHJlY3RCLnJpZ2h0ID0gTWF0aC5tYXgocmVjdEIucmlnaHQsIHJlY3RBLnJpZ2h0KTtcbiAgICAgICAgcmVjdHMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9yZWN0c0NhY2hlLnNldCh0ZXh0UmVuZGVySW5mbywge3N0YXJ0LCBlbmQsIHJlY3RzfSk7XG4gIH1cbiAgcmV0dXJuIHJlY3RzXG59XG5cbmNvbnN0IF9jYXJldHNCeVJvd0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gZ3JvdXBDYXJldHNCeVJvdyh0ZXh0UmVuZGVySW5mbykge1xuICAvLyB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gIGxldCBjYXJldHNCeVJvdyA9IF9jYXJldHNCeVJvd0NhY2hlLmdldCh0ZXh0UmVuZGVySW5mbyk7XG4gIGlmICghY2FyZXRzQnlSb3cpIHtcbiAgICBjb25zdCB7Y2FyZXRQb3NpdGlvbnMsIGNhcmV0SGVpZ2h0fSA9IHRleHRSZW5kZXJJbmZvO1xuICAgIGNhcmV0c0J5Um93ID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FyZXRQb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGNvbnN0IHJvd1kgPSBjYXJldFBvc2l0aW9uc1tpICsgMl07XG4gICAgICBsZXQgcm93Q2FyZXRzID0gY2FyZXRzQnlSb3cuZ2V0KHJvd1kpO1xuICAgICAgaWYgKCFyb3dDYXJldHMpIHtcbiAgICAgICAgY2FyZXRzQnlSb3cuc2V0KHJvd1ksIHJvd0NhcmV0cyA9IFtdKTtcbiAgICAgIH1cbiAgICAgIHJvd0NhcmV0cy5wdXNoKHtcbiAgICAgICAgeDogY2FyZXRQb3NpdGlvbnNbaV0sXG4gICAgICAgIHk6IHJvd1ksXG4gICAgICAgIGhlaWdodDogY2FyZXRIZWlnaHQsXG4gICAgICAgIGNoYXJJbmRleDogaSAvIDNcbiAgICAgIH0pO1xuICAgICAgLy8gQWRkIG9uZSBtb3JlIGNhcmV0IGFmdGVyIHRoZSBmaW5hbCBjaGFyXG4gICAgICBpZiAoaSArIDMgPj0gY2FyZXRQb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJvd0NhcmV0cy5wdXNoKHtcbiAgICAgICAgICB4OiBjYXJldFBvc2l0aW9uc1tpICsgMV0sXG4gICAgICAgICAgeTogcm93WSxcbiAgICAgICAgICBoZWlnaHQ6IGNhcmV0SGVpZ2h0LFxuICAgICAgICAgIGNoYXJJbmRleDogaSAvIDMgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfY2FyZXRzQnlSb3dDYWNoZS5zZXQodGV4dFJlbmRlckluZm8sIGNhcmV0c0J5Um93KTtcbiAgcmV0dXJuIGNhcmV0c0J5Um93XG59XG5cbmV4cG9ydCB7IEdseXBoc0dlb21ldHJ5LCBUZXh0LCBjb25maWd1cmVUZXh0QnVpbGRlciwgY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbCwgZHVtcFNERlRleHR1cmVzLCBnZXRDYXJldEF0UG9pbnQsIGdldFNlbGVjdGlvblJlY3RzLCBwcmVsb2FkRm9udCwgdHlwZXNldHRlcldvcmtlck1vZHVsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/troika-three-text/dist/troika-three-text.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.esm.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezierMesh: function() { return /* binding */ BezierMesh; },\n/* harmony export */   createDerivedMaterial: function() { return /* binding */ createDerivedMaterial; },\n/* harmony export */   expandShaderIncludes: function() { return /* binding */ expandShaderIncludes; },\n/* harmony export */   getShaderUniformTypes: function() { return /* binding */ getShaderUniformTypes; },\n/* harmony export */   getShadersForMaterial: function() { return /* binding */ getShadersForMaterial; },\n/* harmony export */   invertMatrix4: function() { return /* binding */ invertMatrix4; },\n/* harmony export */   voidMainRegExp: function() { return /* binding */ voidMainRegExp; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */\nfunction expandShaderIncludes( source ) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    let chunk = three__WEBPACK_IMPORTED_MODULE_0__.ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match\n  }\n  return source.replace( pattern, replace )\n}\n\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n}\n\nfunction generateUUID() {\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n    _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n    _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n    _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase()\n\n}\n\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function(/*target, ...sources*/) {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target\n};\n\n\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object} options.defines - Custom `defines` for the material\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]()\n  }\n\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  const onBeforeCompile = function (shaderInfo, renderer) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {return Date.now() - epoch}\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\n  };\n\n  const derive = function(base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n    derived.uuid = generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n\n    return derived\n  };\n\n  const descriptor = {\n    constructor: {value: DerivedMaterial},\n    isDerivedMaterial: {value: true},\n\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n      }\n    },\n\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile\n      },\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone(source.uniforms));\n        }\n        return this\n      }\n    },\n\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this)\n      }\n    },\n\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDepthMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial({ depthPacking: three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking }),\n            options\n          );\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }\n    },\n\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDistanceMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDistanceMaterial(),\n            options\n          );\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }\n    },\n\n    dispose: {\n      writable: true,\n      configurable: true,\n      value() {\n        const {_depthMaterial, _distanceMaterial} = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial()\n}\n\n\nfunction upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(\n      /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n    );\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    let res = customRewriter({vertexShader, fragmentShader});\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n      match => {\n        postChunks.push(match);\n        return ''\n      }\n    );\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n    vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n    });\n\n    // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n    // Perhaps the other textures too going forward?\n    if (!(material.map && material.map.channel > 0)) {\n      vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n    }\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n  return {\n    vertexShader,\n    fragmentShader\n  }\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n    );\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n  return shaderCode\n}\n\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n}\n\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n  }\n  return id\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n}\n\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms\n}\n\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */\nfunction invertMatrix4(srcMatrix, tgtMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()) {\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n  return tgtMatrix\n}\n\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\n\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(\n    baseMaterial,\n    {\n      chained: true,\n      uniforms: {\n        pointA: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        controlA: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        controlB: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        pointB: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        radius: {value: 0.01},\n        dashing: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()} //on, off, offset\n      },\n      vertexDefs,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro\n    }\n  )\n}\n\nlet geometry = null;\n\nconst defaultBaseMaterial = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({color: 0xffffff, side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide});\n\n\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */\nclass BezierMesh extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n  static getGeometry() {\n    return geometry || (geometry =\n      new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n    )\n  }\n\n  constructor() {\n    super(\n      BezierMesh.getGeometry(),\n      defaultBaseMaterial\n    );\n\n    this.pointA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.controlA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.controlB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.pointB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.radius = 0.01;\n    this.dashArray = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    this.frustumCulled = false;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    return derivedMaterial\n  }\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial()\n  }\n\n  onBeforeRender() {\n    const {uniforms} = this.material;\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n\n  raycast(/*raycaster, intersects*/) {\n    // TODO - just fail for now\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdXRpbHMvZGlzdC90cm9pa2EtdGhyZWUtdXRpbHMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQThNOztBQUU5TTtBQUNBLHFEQUFxRDtBQUNyRCxVQUFVO0FBQ1Y7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVEsa0VBQWtFLGtCQUFrQjtBQUN2RyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7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LDBDQUFPO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsbUVBQW1FO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVnSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLmVzbS5qcz9lN2NjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoYWRlckNodW5rLCBVbmlmb3Jtc1V0aWxzLCBNZXNoRGVwdGhNYXRlcmlhbCwgUkdCQURlcHRoUGFja2luZywgTWVzaERpc3RhbmNlTWF0ZXJpYWwsIFNoYWRlckxpYiwgTWF0cml4NCwgVmVjdG9yMywgTWVzaCwgQ3lsaW5kZXJHZW9tZXRyeSwgVmVjdG9yMiwgTWVzaFN0YW5kYXJkTWF0ZXJpYWwsIERvdWJsZVNpZGUgfSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyB0aGUgYHZvaWQgbWFpbigpIHtgIG9wZW5lciBsaW5lIGluIEdMU0wuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCB2b2lkTWFpblJlZ0V4cCA9IC9cXGJ2b2lkXFxzK21haW5cXHMqXFwoXFxzKlxcKVxccyp7L2c7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZXhwYW5kcyBhbGwgYCNpbmNsdWRlIDx4eXo+YCBzdGF0ZW1lbnRzIHdpdGhpbiBzdHJpbmcgb2Ygc2hhZGVyIGNvZGUuXG4gKiBDb3BpZWQgZnJvbSB0aHJlZSdzIFdlYkdMUHJvZ3JhbSNwYXJzZUluY2x1ZGVzIGZvciBleHRlcm5hbCB1c2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBHTFNMIHNvdXJjZSBjb2RlIHRvIGV2YWx1YXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBHTFNMIGNvZGUgd2l0aCBhbGwgaW5jbHVkZXMgZXhwYW5kZWRcbiAqL1xuZnVuY3Rpb24gZXhwYW5kU2hhZGVySW5jbHVkZXMoIHNvdXJjZSApIHtcbiAgY29uc3QgcGF0dGVybiA9IC9eWyBcXHRdKiNpbmNsdWRlICs8KFtcXHdcXGQuL10rKT4vZ207XG4gIGZ1bmN0aW9uIHJlcGxhY2UobWF0Y2gsIGluY2x1ZGUpIHtcbiAgICBsZXQgY2h1bmsgPSBTaGFkZXJDaHVua1tpbmNsdWRlXTtcbiAgICByZXR1cm4gY2h1bmsgPyBleHBhbmRTaGFkZXJJbmNsdWRlcyhjaHVuaykgOiBtYXRjaFxuICB9XG4gIHJldHVybiBzb3VyY2UucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApXG59XG5cbi8qXG4gKiBUaGlzIGlzIGEgZGlyZWN0IGNvcHkgb2YgTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCBmcm9tIFRocmVlLmpzLCB0byBwcmVzZXJ2ZSBjb21wYXRpYmlsaXR5IHdpdGggdGhyZWVcbiAqIHZlcnNpb25zIGJlZm9yZSAwLjExMy4wIGFzIGl0IHdhcyBjaGFuZ2VkIGZyb20gTWF0aCB0byBNYXRoVXRpbHMgaW4gdGhhdCB2ZXJzaW9uLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL2RkOGI1YWEzYjI3MGMxNzA5NmI5MDk0NWNkMmQ2ZDFiMTNhYWVjNTMvc3JjL21hdGgvTWF0aFV0aWxzLmpzI0wxNlxuICovXG5cbmNvbnN0IF9sdXQgPSBbXTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBfbHV0W2ldID0gKGkgPCAxNiA/ICcwJyA6ICcnKSArIChpKS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcblxuICBjb25zdCBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgdXVpZCA9IF9sdXRbZDAgJiAweGZmXSArIF9sdXRbZDAgPj4gOCAmIDB4ZmZdICsgX2x1dFtkMCA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMCA+PiAyNCAmIDB4ZmZdICsgJy0nICtcbiAgICBfbHV0W2QxICYgMHhmZl0gKyBfbHV0W2QxID4+IDggJiAweGZmXSArICctJyArIF9sdXRbZDEgPj4gMTYgJiAweDBmIHwgMHg0MF0gKyBfbHV0W2QxID4+IDI0ICYgMHhmZl0gKyAnLScgK1xuICAgIF9sdXRbZDIgJiAweDNmIHwgMHg4MF0gKyBfbHV0W2QyID4+IDggJiAweGZmXSArICctJyArIF9sdXRbZDIgPj4gMTYgJiAweGZmXSArIF9sdXRbZDIgPj4gMjQgJiAweGZmXSArXG4gICAgX2x1dFtkMyAmIDB4ZmZdICsgX2x1dFtkMyA+PiA4ICYgMHhmZl0gKyBfbHV0W2QzID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QzID4+IDI0ICYgMHhmZl07XG5cbiAgLy8gLnRvVXBwZXJDYXNlKCkgaGVyZSBmbGF0dGVucyBjb25jYXRlbmF0ZWQgc3RyaW5ncyB0byBzYXZlIGhlYXAgbWVtb3J5IHNwYWNlLlxuICByZXR1cm4gdXVpZC50b1VwcGVyQ2FzZSgpXG5cbn1cblxuLy8gTG9jYWwgYXNzaWduIHBvbHlmaWxsIHRvIGF2b2lkIGltcG9ydGluZyB0cm9pa2EtY29yZVxuY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbigvKnRhcmdldCwgLi4uc291cmNlcyovKSB7XG4gIGxldCB0YXJnZXQgPSBhcmd1bWVudHNbMF07XG4gIGZvciAobGV0IGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIGZvciAobGV0IHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0XG59O1xuXG5cbmNvbnN0IGVwb2NoID0gRGF0ZS5ub3coKTtcbmNvbnN0IENPTlNUUlVDVE9SX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IFNIQURFUl9VUEdSQURFX0NBQ0hFID0gbmV3IE1hcCgpO1xuXG4vLyBNYXRlcmlhbCBpZHMgbXVzdCBiZSBpbnRlZ2VycywgYnV0IHdlIGNhbid0IGFjY2VzcyB0aGUgaW5jcmVtZW50IGZyb20gVGhyZWUncyBgTWF0ZXJpYWxgIG1vZHVsZSxcbi8vIHNvIGxldCdzIGNob29zZSBhIHN1ZmZpY2llbnRseSBsYXJnZSBzdGFydGluZyB2YWx1ZSB0aGF0IHNob3VsZCB0aGVvcmV0aWNhbGx5IG5ldmVyIGNvbGxpZGUuXG5sZXQgbWF0ZXJpYWxJbnN0YW5jZUlkID0gMWUxMDtcblxuLyoqXG4gKiBBIHV0aWxpdHkgZm9yIGNyZWF0aW5nIGEgY3VzdG9tIHNoYWRlciBtYXRlcmlhbCBkZXJpdmVkIGZyb20gYW5vdGhlciBtYXRlcmlhbCdzXG4gKiBzaGFkZXJzLiBUaGlzIGFsbG93cyB5b3UgdG8gaW5qZWN0IGN1c3RvbSBzaGFkZXIgbG9naWMgYW5kIHRyYW5zZm9ybXMgaW50byB0aGVcbiAqIGJ1aWx0aW4gVGhyZWVKUyBtYXRlcmlhbHMgd2l0aG91dCBoYXZpbmcgdG8gcmVjcmVhdGUgdGhlbSBmcm9tIHNjcmF0Y2guXG4gKlxuICogQHBhcmFtIHtUSFJFRS5NYXRlcmlhbH0gYmFzZU1hdGVyaWFsIC0gdGhlIG9yaWdpbmFsIG1hdGVyaWFsIHRvIGRlcml2ZSBmcm9tXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBIb3cgdGhlIGJhc2UgbWF0ZXJpYWwgc2hvdWxkIGJlIG1vZGlmaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGVmaW5lcyAtIEN1c3RvbSBgZGVmaW5lc2AgZm9yIHRoZSBtYXRlcmlhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZXh0ZW5zaW9ucyAtIEN1c3RvbSBgZXh0ZW5zaW9uc2AgZm9yIHRoZSBtYXRlcmlhbCwgZS5nLiBge2Rlcml2YXRpdmVzOiB0cnVlfWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnVuaWZvcm1zIC0gQ3VzdG9tIGB1bmlmb3Jtc2AgZm9yIHVzZSBpbiB0aGUgbW9kaWZpZWQgc2hhZGVyLiBUaGVzZSBjYW5cbiAqICAgICAgICBiZSBhY2Nlc3NlZCBhbmQgbWFuaXB1bGF0ZWQgdmlhIHRoZSByZXN1bHRpbmcgbWF0ZXJpYWwncyBgdW5pZm9ybXNgIHByb3BlcnR5LCBqdXN0IGxpa2VcbiAqICAgICAgICBpbiBhIFNoYWRlck1hdGVyaWFsLiBZb3UgZG8gbm90IG5lZWQgdG8gcmVwZWF0IHRoZSBiYXNlIG1hdGVyaWFsJ3Mgb3duIHVuaWZvcm1zIGhlcmUuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1lVW5pZm9ybSAtIElmIHNwZWNpZmllZCwgYSB1bmlmb3JtIG9mIHRoaXMgbmFtZSB3aWxsIGJlIGluamVjdGVkIGludG9cbiAqICAgICAgICBib3RoIHNoYWRlcnMsIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgdXBkYXRlZCBvbiBlYWNoIHJlbmRlciBmcmFtZSB3aXRoIGEgbnVtYmVyIG9mXG4gKiAgICAgICAgZWxhcHNlZCBtaWxsaXNlY29uZHMuIFRoZSBcInplcm9cIiBlcG9jaCB0aW1lIGlzIG5vdCBzaWduaWZpY2FudCBzbyBkb24ndCByZWx5IG9uIHRoaXMgYXMgYVxuICogICAgICAgIHRydWUgY2FsZW5kYXIgdGltZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleERlZnMgLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBpbnRvIHRoZSB2ZXJ0ZXggc2hhZGVyJ3MgdG9wLWxldmVsXG4gKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudmVydGV4TWFpbkludHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIHRvcCBvZiB0aGUgdmVydGV4XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhNYWluT3V0cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgZW5kIG9mIHRoZSB2ZXJ0ZXhcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleFRyYW5zZm9ybSAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gbWFuaXB1bGF0ZSB0aGUgYHBvc2l0aW9uYCwgYG5vcm1hbGAsXG4gKiAgICAgICAgYW5kL29yIGB1dmAgdmVydGV4IGF0dHJpYnV0ZXMuIFRoaXMgY29kZSB3aWxsIGJlIHdyYXBwZWQgd2l0aGluIGEgc3RhbmRhbG9uZSBmdW5jdGlvbiB3aXRoXG4gKiAgICAgICAgdGhvc2UgYXR0cmlidXRlcyBleHBvc2VkIGJ5IHRoZWlyIG5vcm1hbCBuYW1lcyBhcyByZWFkL3dyaXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50RGVmcyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGludG8gdGhlIGZyYWdtZW50IHNoYWRlcidzIHRvcC1sZXZlbFxuICogICAgICAgIGRlZmluaXRpb25zLCBhYm92ZSB0aGUgYHZvaWQgbWFpbigpYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50TWFpbkludHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIHRvcCBvZiB0aGUgZnJhZ21lbnRcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50TWFpbk91dHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnRcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi4gWW91IGNhbiBtYW5pcHVsYXRlIGBnbF9GcmFnQ29sb3JgIGhlcmUgYnV0IGtlZXAgaW4gbWluZCBpdCBnb2VzXG4gKiAgICAgICAgYWZ0ZXIgYW55IG9mIFRocmVlSlMncyBjb2xvciBwb3N0cHJvY2Vzc2luZyBzaGFkZXIgY2h1bmtzICh0b25lbWFwcGluZywgZm9nLCBldGMuKSwgc28gaWYgeW91XG4gKiAgICAgICAgd2FudCB0aG9zZSB0byBhcHBseSB0byB5b3VyIGNoYW5nZXMgdXNlIGBmcmFnbWVudENvbG9yVHJhbnNmb3JtYCBpbnN0ZWFkLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnRDb2xvclRyYW5zZm9ybSAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gbWFuaXB1bGF0ZSB0aGUgYGdsX0ZyYWdDb2xvcmBcbiAqICAgICAgICBvdXRwdXQgdmFsdWUuIFdpbGwgYmUgaW5qZWN0ZWQgbmVhciB0aGUgZW5kIG9mIHRoZSBgdm9pZCBtYWluYCBmdW5jdGlvbiwgYnV0IGJlZm9yZSBhbnlcbiAqICAgICAgICBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIGFuZCBiZWZvcmUgdGhlXG4gKiAgICAgICAgYGZyYWdtZW50TWFpbk91dHJvYC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb248e3ZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcn0+Ont2ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXJ9fSBvcHRpb25zLmN1c3RvbVJld3JpdGVyIC0gQSBmdW5jdGlvblxuICogICAgICAgIGZvciBwZXJmb3JtaW5nIGN1c3RvbSByZXdyaXRlcyBvZiB0aGUgZnVsbCBzaGFkZXIgY29kZS4gVXNlZnVsIGlmIHlvdSBuZWVkIHRvIGRvIHNvbWV0aGluZ1xuICogICAgICAgIHNwZWNpYWwgdGhhdCdzIG5vdCBjb3ZlcmVkIGJ5IHRoZSBvdGhlciBidWlsdGluIG9wdGlvbnMuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZCBiZWZvcmVcbiAqICAgICAgICBhbnkgb3RoZXIgdHJhbnNmb3JtcyBhcmUgYXBwbGllZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jaGFpbmVkIC0gU2V0IHRvIGB0cnVlYCB0byBwcm90b3R5cGUtY2hhaW4gdGhlIGRlcml2ZWQgbWF0ZXJpYWwgdG8gdGhlIGJhc2VcbiAqICAgICAgICBtYXRlcmlhbCwgcmF0aGVyIHRoYW4gdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgY29weWluZyBpdC4gVGhpcyBhbGxvd3MgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgdG9cbiAqICAgICAgICBhdXRvbWF0aWNhbGx5IHBpY2sgdXAgY2hhbmdlcyBtYWRlIHRvIHRoZSBiYXNlIG1hdGVyaWFsIGFuZCBpdHMgcHJvcGVydGllcy4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gKiAgICAgICAgd2hlcmUgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgaXMgaGlkZGVuIGZyb20gdGhlIHVzZXIgYXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLCBhbGxvd2luZyB0aGVtXG4gKiAgICAgICAgdG8gd29yayB3aXRoIHRoZSBvcmlnaW5hbCBtYXRlcmlhbCBsaWtlIG5vcm1hbC4gQnV0IGl0IGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvciBpZiBub3RcbiAqICAgICAgICBoYW5kbGVkIGNhcmVmdWxseS5cbiAqXG4gKiBAcmV0dXJuIHtUSFJFRS5NYXRlcmlhbH1cbiAqXG4gKiBUaGUgcmV0dXJuZWQgbWF0ZXJpYWwgd2lsbCBhbHNvIGhhdmUgdHdvIG5ldyBtZXRob2RzLCBgZ2V0RGVwdGhNYXRlcmlhbCgpYCBhbmQgYGdldERpc3RhbmNlTWF0ZXJpYWwoKWAsXG4gKiB3aGljaCBjYW4gYmUgY2FsbGVkIHRvIGdldCBhIHZhcmlhbnQgb2YgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgZm9yIHVzZSBpbiBzaGFkb3cgY2FzdGluZy4gSWYgdGhlXG4gKiB0YXJnZXQgbWVzaCBpcyBleHBlY3RlZCB0byBjYXN0IHNoYWRvd3MsIHRoZW4geW91IGNhbiBhc3NpZ24gdGhlc2UgdG8gdGhlIG1lc2gncyBgY3VzdG9tRGVwdGhNYXRlcmlhbGBcbiAqIChmb3IgZGlyZWN0aW9uYWwgYW5kIHNwb3QgbGlnaHRzKSBhbmQvb3IgYGN1c3RvbURpc3RhbmNlTWF0ZXJpYWxgIChmb3IgcG9pbnQgbGlnaHRzKSBwcm9wZXJ0aWVzIHRvXG4gKiBhbGxvdyB0aGUgY2FzdCBzaGFkb3cgdG8gaG9ub3IgeW91ciBkZXJpdmVkIHNoYWRlcidzIHZlcnRleCB0cmFuc2Zvcm1zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLiBUaGVzZVxuICogd2lsbCBhbHNvIHNldCBhIGN1c3RvbSBgI2RlZmluZSBJU19ERVBUSF9NQVRFUklBTGAgb3IgYCNkZWZpbmUgSVNfRElTVEFOQ0VfTUFURVJJQUxgIHRoYXQgeW91IGNhbiBsb29rXG4gKiBmb3IgaW4geW91ciBkZXJpdmVkIHNoYWRlcnMgd2l0aCBgI2lmZGVmYCB0byBjdXN0b21pemUgdGhlaXIgYmVoYXZpb3IgZm9yIHRoZSBkZXB0aCBvciBkaXN0YW5jZVxuICogc2NlbmFyaW9zLCBlLmcuIHNraXBwaW5nIGFudGlhbGlhc2luZyBvciBleHBlbnNpdmUgc2hhZGVyIGxvZ2ljLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsLCBvcHRpb25zKSB7XG4gIC8vIEdlbmVyYXRlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSBjb250ZW50IG9mIHRoZXNlIGBvcHRpb25zYC4gV2UnbGwgdXNlIHRoaXNcbiAgLy8gdGhyb3VnaG91dCBmb3IgY2FjaGluZyBhbmQgZm9yIGdlbmVyYXRpbmcgdGhlIHVwZ3JhZGVkIHNoYWRlciBjb2RlLiBUaGlzIGluY3JlYXNlc1xuICAvLyB0aGUgbGlrZWxpaG9vZCB0aGF0IHRoZSByZXN1bHRpbmcgc2hhZGVycyB3aWxsIGxpbmUgdXAgYWNyb3NzIG11bHRpcGxlIGNhbGxzIHNvXG4gIC8vIHRoZWlyIEdMIHByb2dyYW1zIGNhbiBiZSBzaGFyZWQgYW5kIGNhY2hlZC5cbiAgY29uc3Qgb3B0aW9uc0tleSA9IGdldEtleUZvck9wdGlvbnMob3B0aW9ucyk7XG5cbiAgLy8gRmlyc3QgY2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGFscmVhZHkgZGVyaXZlZCBmcm9tIHRoaXMgYmFzZU1hdGVyaWFsIHVzaW5nIHRoaXNcbiAgLy8gdW5pcXVlIHNldCBvZiBvcHRpb25zLCBhbmQgaWYgc28gcmV1c2UgdGhlIGNvbnN0cnVjdG9yIHRvIGF2b2lkIHNvbWUgYWxsb2NhdGlvbnMuXG4gIGxldCBjdG9yc0J5RGVyaXZhdGlvbiA9IENPTlNUUlVDVE9SX0NBQ0hFLmdldChiYXNlTWF0ZXJpYWwpO1xuICBpZiAoIWN0b3JzQnlEZXJpdmF0aW9uKSB7XG4gICAgQ09OU1RSVUNUT1JfQ0FDSEUuc2V0KGJhc2VNYXRlcmlhbCwgKGN0b3JzQnlEZXJpdmF0aW9uID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpO1xuICB9XG4gIGlmIChjdG9yc0J5RGVyaXZhdGlvbltvcHRpb25zS2V5XSkge1xuICAgIHJldHVybiBuZXcgY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0oKVxuICB9XG5cbiAgY29uc3QgcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wID0gYF9vbkJlZm9yZUNvbXBpbGUke29wdGlvbnNLZXl9YDtcblxuICAvLyBQcml2YXRlIG9uQmVmb3JlQ29tcGlsZSBoYW5kbGVyIHRoYXQgaW5qZWN0cyB0aGUgbW9kaWZpZWQgc2hhZGVycyBhbmQgdW5pZm9ybXMgd2hlblxuICAvLyB0aGUgcmVuZGVyZXIgc3dpdGNoZXMgdG8gdGhpcyBtYXRlcmlhbCdzIHByb2dyYW1cbiAgY29uc3Qgb25CZWZvcmVDb21waWxlID0gZnVuY3Rpb24gKHNoYWRlckluZm8sIHJlbmRlcmVyKSB7XG4gICAgYmFzZU1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZS5jYWxsKHRoaXMsIHNoYWRlckluZm8sIHJlbmRlcmVyKTtcblxuICAgIC8vIFVwZ3JhZGUgdGhlIHNoYWRlcnMsIGNhY2hpbmcgdGhlIHJlc3VsdCBieSBpbmNvbWluZyBzb3VyY2UgY29kZVxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKSArICd8JyArIHNoYWRlckluZm8udmVydGV4U2hhZGVyICsgJ3wnICsgc2hhZGVySW5mby5mcmFnbWVudFNoYWRlcjtcbiAgICBsZXQgdXBncmFkZWRTaGFkZXJzID0gU0hBREVSX1VQR1JBREVfQ0FDSEVbY2FjaGVLZXldO1xuICAgIGlmICghdXBncmFkZWRTaGFkZXJzKSB7XG4gICAgICBjb25zdCB1cGdyYWRlZCA9IHVwZ3JhZGVTaGFkZXJzKHRoaXMsIHNoYWRlckluZm8sIG9wdGlvbnMsIG9wdGlvbnNLZXkpO1xuICAgICAgdXBncmFkZWRTaGFkZXJzID0gU0hBREVSX1VQR1JBREVfQ0FDSEVbY2FjaGVLZXldID0gdXBncmFkZWQ7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IHVwZ3JhZGVkIHNoYWRlcnMgYW5kIHVuaWZvcm1zIGludG8gdGhlIHByb2dyYW1cbiAgICBzaGFkZXJJbmZvLnZlcnRleFNoYWRlciA9IHVwZ3JhZGVkU2hhZGVycy52ZXJ0ZXhTaGFkZXI7XG4gICAgc2hhZGVySW5mby5mcmFnbWVudFNoYWRlciA9IHVwZ3JhZGVkU2hhZGVycy5mcmFnbWVudFNoYWRlcjtcbiAgICBhc3NpZ24oc2hhZGVySW5mby51bmlmb3JtcywgdGhpcy51bmlmb3Jtcyk7XG5cbiAgICAvLyBJbmplY3QgYXV0by11cGRhdGluZyB0aW1lIHVuaWZvcm0gaWYgcmVxdWVzdGVkXG4gICAgaWYgKG9wdGlvbnMudGltZVVuaWZvcm0pIHtcbiAgICAgIHNoYWRlckluZm8udW5pZm9ybXNbb3B0aW9ucy50aW1lVW5pZm9ybV0gPSB7XG4gICAgICAgIGdldCB2YWx1ZSgpIHtyZXR1cm4gRGF0ZS5ub3coKSAtIGVwb2NofVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBVc2VycyBjYW4gc3RpbGwgYWRkIHRoZWlyIG93biBoYW5kbGVycyBvbiB0b3Agb2Ygb3Vyc1xuICAgIGlmICh0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0pIHtcbiAgICAgIHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXShzaGFkZXJJbmZvKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgRGVyaXZlZE1hdGVyaWFsID0gZnVuY3Rpb24gRGVyaXZlZE1hdGVyaWFsKCkge1xuICAgIHJldHVybiBkZXJpdmUob3B0aW9ucy5jaGFpbmVkID8gYmFzZU1hdGVyaWFsIDogYmFzZU1hdGVyaWFsLmNsb25lKCkpXG4gIH07XG5cbiAgY29uc3QgZGVyaXZlID0gZnVuY3Rpb24oYmFzZSkge1xuICAgIC8vIFByb3RvdHlwZSBjaGFpbiB0byB0aGUgYmFzZSBtYXRlcmlhbFxuICAgIGNvbnN0IGRlcml2ZWQgPSBPYmplY3QuY3JlYXRlKGJhc2UsIGRlc2NyaXB0b3IpO1xuXG4gICAgLy8gU3RvcmUgdGhlIGJhc2VNYXRlcmlhbCBmb3IgcmVmZXJlbmNlOyB0aGlzIGlzIGFsd2F5cyB0aGUgb3JpZ2luYWwgZXZlbiB3aGVuIGNsb25pbmdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVyaXZlZCwgJ2Jhc2VNYXRlcmlhbCcsIHsgdmFsdWU6IGJhc2VNYXRlcmlhbCB9KTtcblxuICAgIC8vIE5lZWRzIGl0cyBvd24gaWRzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWQsICdpZCcsIHsgdmFsdWU6IG1hdGVyaWFsSW5zdGFuY2VJZCsrIH0pO1xuICAgIGRlcml2ZWQudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG4gICAgLy8gTWVyZ2UgdW5pZm9ybXMsIGRlZmluZXMsIGFuZCBleHRlbnNpb25zXG4gICAgZGVyaXZlZC51bmlmb3JtcyA9IGFzc2lnbih7fSwgYmFzZS51bmlmb3Jtcywgb3B0aW9ucy51bmlmb3Jtcyk7XG4gICAgZGVyaXZlZC5kZWZpbmVzID0gYXNzaWduKHt9LCBiYXNlLmRlZmluZXMsIG9wdGlvbnMuZGVmaW5lcyk7XG4gICAgZGVyaXZlZC5kZWZpbmVzW2BUUk9JS0FfREVSSVZFRF9NQVRFUklBTF8ke29wdGlvbnNLZXl9YF0gPSAnJzsgLy9mb3JjZSBhIHByb2dyYW0gY2hhbmdlIGZyb20gdGhlIGJhc2UgbWF0ZXJpYWxcbiAgICBkZXJpdmVkLmV4dGVuc2lvbnMgPSBhc3NpZ24oe30sIGJhc2UuZXh0ZW5zaW9ucywgb3B0aW9ucy5leHRlbnNpb25zKTtcblxuICAgIC8vIERvbid0IGluaGVyaXQgRXZlbnREaXNwYXRjaGVyIGxpc3RlbmVyc1xuICAgIGRlcml2ZWQuX2xpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBkZXJpdmVkXG4gIH07XG5cbiAgY29uc3QgZGVzY3JpcHRvciA9IHtcbiAgICBjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBEZXJpdmVkTWF0ZXJpYWx9LFxuICAgIGlzRGVyaXZlZE1hdGVyaWFsOiB7dmFsdWU6IHRydWV9LFxuXG4gICAgY3VzdG9tUHJvZ3JhbUNhY2hlS2V5OiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBiYXNlTWF0ZXJpYWwuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkgKyAnfCcgKyBvcHRpb25zS2V5XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uQmVmb3JlQ29tcGlsZToge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gb25CZWZvcmVDb21waWxlXG4gICAgICB9LFxuICAgICAgc2V0KGZuKSB7XG4gICAgICAgIHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXSA9IGZuO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb3B5OiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5jb3B5LmNhbGwodGhpcywgc291cmNlKTtcbiAgICAgICAgaWYgKCFiYXNlTWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiAhYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsKSB7XG4gICAgICAgICAgYXNzaWduKHRoaXMuZXh0ZW5zaW9ucywgc291cmNlLmV4dGVuc2lvbnMpO1xuICAgICAgICAgIGFzc2lnbih0aGlzLmRlZmluZXMsIHNvdXJjZS5kZWZpbmVzKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy51bmlmb3JtcywgVW5pZm9ybXNVdGlscy5jbG9uZShzb3VyY2UudW5pZm9ybXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjbG9uZToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBuZXdCYXNlID0gbmV3IGJhc2VNYXRlcmlhbC5jb25zdHJ1Y3RvcigpO1xuICAgICAgICByZXR1cm4gZGVyaXZlKG5ld0Jhc2UpLmNvcHkodGhpcylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBnZXQgYSBNZXNoRGVwdGhNYXRlcmlhbCB0aGF0IHdpbGwgaG9ub3IgdGhpcyBkZXJpdmVkIG1hdGVyaWFsJ3MgdmVydGV4XG4gICAgICogdHJhbnNmb3JtYXRpb25zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLlxuICAgICAqL1xuICAgIGdldERlcHRoTWF0ZXJpYWw6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgZGVwdGhNYXRlcmlhbCA9IHRoaXMuX2RlcHRoTWF0ZXJpYWw7XG4gICAgICAgIGlmICghZGVwdGhNYXRlcmlhbCkge1xuICAgICAgICAgIGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgICAgICAgYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsXG4gICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICA6IG5ldyBNZXNoRGVwdGhNYXRlcmlhbCh7IGRlcHRoUGFja2luZzogUkdCQURlcHRoUGFja2luZyB9KSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGRlcHRoTWF0ZXJpYWwuZGVmaW5lcy5JU19ERVBUSF9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgIGRlcHRoTWF0ZXJpYWwudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zOyAvL2F1dG9tYXRpY2FsbHkgcmVjaWV2ZSBzYW1lIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcHRoTWF0ZXJpYWxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBnZXQgYSBNZXNoRGlzdGFuY2VNYXRlcmlhbCB0aGF0IHdpbGwgaG9ub3IgdGhpcyBkZXJpdmVkIG1hdGVyaWFsJ3MgdmVydGV4XG4gICAgICogdHJhbnNmb3JtYXRpb25zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLlxuICAgICAqL1xuICAgIGdldERpc3RhbmNlTWF0ZXJpYWw6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgZGlzdGFuY2VNYXRlcmlhbCA9IHRoaXMuX2Rpc3RhbmNlTWF0ZXJpYWw7XG4gICAgICAgIGlmICghZGlzdGFuY2VNYXRlcmlhbCkge1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgICAgICAgYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsXG4gICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICA6IG5ldyBNZXNoRGlzdGFuY2VNYXRlcmlhbCgpLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbC5kZWZpbmVzLklTX0RJU1RBTkNFX01BVEVSSUFMID0gJyc7XG4gICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbC51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7IC8vYXV0b21hdGljYWxseSByZWNpZXZlIHNhbWUgdW5pZm9ybSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdGFuY2VNYXRlcmlhbFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlKCkge1xuICAgICAgICBjb25zdCB7X2RlcHRoTWF0ZXJpYWwsIF9kaXN0YW5jZU1hdGVyaWFsfSA9IHRoaXM7XG4gICAgICAgIGlmIChfZGVwdGhNYXRlcmlhbCkgX2RlcHRoTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICBpZiAoX2Rpc3RhbmNlTWF0ZXJpYWwpIF9kaXN0YW5jZU1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgYmFzZU1hdGVyaWFsLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0gPSBEZXJpdmVkTWF0ZXJpYWw7XG4gIHJldHVybiBuZXcgRGVyaXZlZE1hdGVyaWFsKClcbn1cblxuXG5mdW5jdGlvbiB1cGdyYWRlU2hhZGVycyhtYXRlcmlhbCwge3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9LCBvcHRpb25zLCBrZXkpIHtcbiAgbGV0IHtcbiAgICB2ZXJ0ZXhEZWZzLFxuICAgIHZlcnRleE1haW5JbnRybyxcbiAgICB2ZXJ0ZXhNYWluT3V0cm8sXG4gICAgdmVydGV4VHJhbnNmb3JtLFxuICAgIGZyYWdtZW50RGVmcyxcbiAgICBmcmFnbWVudE1haW5JbnRybyxcbiAgICBmcmFnbWVudE1haW5PdXRybyxcbiAgICBmcmFnbWVudENvbG9yVHJhbnNmb3JtLFxuICAgIGN1c3RvbVJld3JpdGVyLFxuICAgIHRpbWVVbmlmb3JtXG4gIH0gPSBvcHRpb25zO1xuXG4gIHZlcnRleERlZnMgPSB2ZXJ0ZXhEZWZzIHx8ICcnO1xuICB2ZXJ0ZXhNYWluSW50cm8gPSB2ZXJ0ZXhNYWluSW50cm8gfHwgJyc7XG4gIHZlcnRleE1haW5PdXRybyA9IHZlcnRleE1haW5PdXRybyB8fCAnJztcbiAgZnJhZ21lbnREZWZzID0gZnJhZ21lbnREZWZzIHx8ICcnO1xuICBmcmFnbWVudE1haW5JbnRybyA9IGZyYWdtZW50TWFpbkludHJvIHx8ICcnO1xuICBmcmFnbWVudE1haW5PdXRybyA9IGZyYWdtZW50TWFpbk91dHJvIHx8ICcnO1xuXG4gIC8vIEV4cGFuZCBpbmNsdWRlcyBpZiBuZWVkZWRcbiAgaWYgKHZlcnRleFRyYW5zZm9ybSB8fCBjdXN0b21SZXdyaXRlcikge1xuICAgIHZlcnRleFNoYWRlciA9IGV4cGFuZFNoYWRlckluY2x1ZGVzKHZlcnRleFNoYWRlcik7XG4gIH1cbiAgaWYgKGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGJlIGFibGUgdG8gZmluZCBwb3N0cHJvY2Vzc2luZyBjaHVua3MgYWZ0ZXIgaW5jbHVkZSBleHBhbnNpb24gaW4gb3JkZXIgdG9cbiAgICAvLyBwdXQgdGhlbSBhZnRlciB0aGUgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgc28gbWFyayB0aGVtIHdpdGggY29tbWVudHMgZmlyc3QuIEV2ZW4gaWZcbiAgICAvLyB0aGlzIHBhcnRpY3VsYXIgZGVyaXZhdGlvbiBkb2Vzbid0IGhhdmUgYSBmcmFnbWVudENvbG9yVHJhbnNmb3JtLCBvdGhlciBkZXJpdmF0aW9ucyBtYXksXG4gICAgLy8gc28gd2Ugc3RpbGwgbWFyayB0aGVtLlxuICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcbiAgICAgIC9eWyBcXHRdKiNpbmNsdWRlIDwoKD86dG9uZW1hcHBpbmd8ZW5jb2RpbmdzfGZvZ3xwcmVtdWx0aXBsaWVkX2FscGhhfGRpdGhlcmluZylfZnJhZ21lbnQpPi9nbSxcbiAgICAgICdcXG4vLyFCRUdJTl9QT1NUX0NIVU5LICQxXFxuJCZcXG4vLyFFTkRfUE9TVF9DSFVOS1xcbidcbiAgICApO1xuICAgIGZyYWdtZW50U2hhZGVyID0gZXhwYW5kU2hhZGVySW5jbHVkZXMoZnJhZ21lbnRTaGFkZXIpO1xuICB9XG5cbiAgLy8gQXBwbHkgY3VzdG9tIHJld3JpdGVyIGZ1bmN0aW9uXG4gIGlmIChjdXN0b21SZXdyaXRlcikge1xuICAgIGxldCByZXMgPSBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0pO1xuICAgIHZlcnRleFNoYWRlciA9IHJlcy52ZXJ0ZXhTaGFkZXI7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSByZXMuZnJhZ21lbnRTaGFkZXI7XG4gIH1cblxuICAvLyBUaGUgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSBuZWVkcyB0byBnbyBiZWZvcmUgYW55IHBvc3Rwcm9jZXNzaW5nIGNodW5rcywgc28gZXh0cmFjdFxuICAvLyB0aG9zZSBhbmQgcmUtaW5zZXJ0IHRoZW0gaW50byB0aGUgb3V0cm8gaW4gdGhlIGNvcnJlY3QgcGxhY2U6XG4gIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtKSB7XG4gICAgbGV0IHBvc3RDaHVua3MgPSBbXTtcbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAvXlxcL1xcLyFCRUdJTl9QT1NUX0NIVU5LW15dKz9eXFwvXFwvIUVORF9QT1NUX0NIVU5LL2dtLCAvLyBbXl0rPyA9IG5vbi1ncmVlZHkgbWF0Y2ggb2YgYW55IGNoYXJzIGluY2x1ZGluZyBuZXdsaW5lc1xuICAgICAgbWF0Y2ggPT4ge1xuICAgICAgICBwb3N0Q2h1bmtzLnB1c2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cbiAgICApO1xuICAgIGZyYWdtZW50TWFpbk91dHJvID0gYCR7ZnJhZ21lbnRDb2xvclRyYW5zZm9ybX1cXG4ke3Bvc3RDaHVua3Muam9pbignXFxuJyl9XFxuJHtmcmFnbWVudE1haW5PdXRyb31gO1xuICB9XG5cbiAgLy8gSW5qZWN0IGF1dG8tdXBkYXRpbmcgdGltZSB1bmlmb3JtIGlmIHJlcXVlc3RlZFxuICBpZiAodGltZVVuaWZvcm0pIHtcbiAgICBjb25zdCBjb2RlID0gYFxcbnVuaWZvcm0gZmxvYXQgJHt0aW1lVW5pZm9ybX07XFxuYDtcbiAgICB2ZXJ0ZXhEZWZzID0gY29kZSArIHZlcnRleERlZnM7XG4gICAgZnJhZ21lbnREZWZzID0gY29kZSArIGZyYWdtZW50RGVmcztcbiAgfVxuXG4gIC8vIEluamVjdCBhIGZ1bmN0aW9uIGZvciB0aGUgdmVydGV4VHJhbnNmb3JtIGFuZCByZW5hbWUgYWxsIHVzYWdlcyBvZiBwb3NpdGlvbi9ub3JtYWwvdXZcbiAgaWYgKHZlcnRleFRyYW5zZm9ybSkge1xuICAgIC8vIEhvaXN0IHRoZXNlIGRlZnMgdG8gdGhlIHZlcnkgdG9wIHNvIHRoZXkgd29yayBpbiBvdGhlciBmdW5jdGlvbiBkZWZzXG4gICAgdmVydGV4U2hhZGVyID0gYHZlYzMgdHJvaWthX3Bvc2l0aW9uXyR7a2V5fTtcbnZlYzMgdHJvaWthX25vcm1hbF8ke2tleX07XG52ZWMyIHRyb2lrYV91dl8ke2tleX07XG4ke3ZlcnRleFNoYWRlcn1cbmA7XG4gICAgdmVydGV4RGVmcyA9IGAke3ZlcnRleERlZnN9XG52b2lkIHRyb2lrYVZlcnRleFRyYW5zZm9ybSR7a2V5fShpbm91dCB2ZWMzIHBvc2l0aW9uLCBpbm91dCB2ZWMzIG5vcm1hbCwgaW5vdXQgdmVjMiB1dikge1xuICAke3ZlcnRleFRyYW5zZm9ybX1cbn1cbmA7XG4gICAgdmVydGV4TWFpbkludHJvID0gYFxudHJvaWthX3Bvc2l0aW9uXyR7a2V5fSA9IHZlYzMocG9zaXRpb24pO1xudHJvaWthX25vcm1hbF8ke2tleX0gPSB2ZWMzKG5vcm1hbCk7XG50cm9pa2FfdXZfJHtrZXl9ID0gdmVjMih1dik7XG50cm9pa2FWZXJ0ZXhUcmFuc2Zvcm0ke2tleX0odHJvaWthX3Bvc2l0aW9uXyR7a2V5fSwgdHJvaWthX25vcm1hbF8ke2tleX0sIHRyb2lrYV91dl8ke2tleX0pO1xuJHt2ZXJ0ZXhNYWluSW50cm99XG5gO1xuICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKC9cXGIocG9zaXRpb258bm9ybWFsfHV2KVxcYi9nLCAobWF0Y2gsIG1hdGNoMSwgaW5kZXgsIGZ1bGxTdHIpID0+IHtcbiAgICAgIHJldHVybiAvXFxiYXR0cmlidXRlXFxzK3ZlY1syM11cXHMrJC8udGVzdChmdWxsU3RyLnN1YnN0cigwLCBpbmRleCkpID8gbWF0Y2gxIDogYHRyb2lrYV8ke21hdGNoMX1fJHtrZXl9YFxuICAgIH0pO1xuXG4gICAgLy8gVGhyZWUgcjE1MiBpbnRyb2R1Y2VkIHRoZSBNQVBfVVYgdG9rZW4sIHJlcGxhY2UgaXQgdG9vIGlmIGl0J3MgcG9pbnRpbmcgdG8gdGhlIG1haW4gJ3V2J1xuICAgIC8vIFBlcmhhcHMgdGhlIG90aGVyIHRleHR1cmVzIHRvbyBnb2luZyBmb3J3YXJkP1xuICAgIGlmICghKG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuY2hhbm5lbCA+IDApKSB7XG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxiTUFQX1VWXFxiL2csIGB0cm9pa2FfdXZfJHtrZXl9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5qZWN0IGRlZnMgYW5kIGludHJvL291dHJvIHNuaXBwZXRzXG4gIHZlcnRleFNoYWRlciA9IGluamVjdEludG9TaGFkZXJDb2RlKHZlcnRleFNoYWRlciwga2V5LCB2ZXJ0ZXhEZWZzLCB2ZXJ0ZXhNYWluSW50cm8sIHZlcnRleE1haW5PdXRybyk7XG4gIGZyYWdtZW50U2hhZGVyID0gaW5qZWN0SW50b1NoYWRlckNvZGUoZnJhZ21lbnRTaGFkZXIsIGtleSwgZnJhZ21lbnREZWZzLCBmcmFnbWVudE1haW5JbnRybywgZnJhZ21lbnRNYWluT3V0cm8pO1xuXG4gIHJldHVybiB7XG4gICAgdmVydGV4U2hhZGVyLFxuICAgIGZyYWdtZW50U2hhZGVyXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b1NoYWRlckNvZGUoc2hhZGVyQ29kZSwgaWQsIGRlZnMsIGludHJvLCBvdXRybykge1xuICBpZiAoaW50cm8gfHwgb3V0cm8gfHwgZGVmcykge1xuICAgIHNoYWRlckNvZGUgPSBzaGFkZXJDb2RlLnJlcGxhY2Uodm9pZE1haW5SZWdFeHAsIGBcbiR7ZGVmc31cbnZvaWQgdHJvaWthT3JpZ01haW4ke2lkfSgpIHtgXG4gICAgKTtcbiAgICBzaGFkZXJDb2RlICs9IGBcbnZvaWQgbWFpbigpIHtcbiAgJHtpbnRyb31cbiAgdHJvaWthT3JpZ01haW4ke2lkfSgpO1xuICAke291dHJvfVxufWA7XG4gIH1cbiAgcmV0dXJuIHNoYWRlckNvZGVcbn1cblxuXG5mdW5jdGlvbiBvcHRpb25zSnNvblJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ3VuaWZvcm1zJyA/IHVuZGVmaW5lZCA6IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZVxufVxuXG5sZXQgX2lkQ3RyID0gMDtcbmNvbnN0IG9wdGlvbnNIYXNoZXNUb0lkcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEtleUZvck9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zSGFzaCA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG9wdGlvbnNKc29uUmVwbGFjZXIpO1xuICBsZXQgaWQgPSBvcHRpb25zSGFzaGVzVG9JZHMuZ2V0KG9wdGlvbnNIYXNoKTtcbiAgaWYgKGlkID09IG51bGwpIHtcbiAgICBvcHRpb25zSGFzaGVzVG9JZHMuc2V0KG9wdGlvbnNIYXNoLCAoaWQgPSArK19pZEN0cikpO1xuICB9XG4gIHJldHVybiBpZFxufVxuXG4vLyBDb3BpZWQgZnJvbSB0aHJlZWpzIFdlYkdMUHJvZ3JhbXMuanMgc28gd2UgY2FuIHJlc29sdmUgYnVpbHRpbiBtYXRlcmlhbHMgdG8gdGhlaXIgc2hhZGVyc1xuLy8gVE9ETyBob3cgY2FuIHdlIGtlZXAgdGhpcyBmcm9tIGdldHRpbmcgc3RhbGU/XG5jb25zdCBNQVRFUklBTF9UWVBFU19UT19TSEFERVJTID0ge1xuICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgTWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxuICBNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgTWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuICBNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcbiAgTWVzaFRvb25NYXRlcmlhbDogJ3Rvb24nLFxuICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgTWVzaFBoeXNpY2FsTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG4gIE1lc2hNYXRjYXBNYXRlcmlhbDogJ21hdGNhcCcsXG4gIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICBMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuICBQb2ludHNNYXRlcmlhbDogJ3BvaW50cycsXG4gIFNoYWRvd01hdGVyaWFsOiAnc2hhZG93JyxcbiAgU3ByaXRlTWF0ZXJpYWw6ICdzcHJpdGUnXG59O1xuXG4vKipcbiAqIEdpdmVuIGEgVGhyZWUuanMgYE1hdGVyaWFsYCBpbnN0YW5jZSwgZmluZCB0aGUgc2hhZGVycy91bmlmb3JtcyB0aGF0IHdpbGwgYmVcbiAqIHVzZWQgdG8gcmVuZGVyIHRoYXQgbWF0ZXJpYWwuXG4gKlxuICogQHBhcmFtIG1hdGVyaWFsIC0gdGhlIE1hdGVyaWFsIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gdGhlIG1hdGVyaWFsJ3Mgc2hhZGVyIGluZm86IGB7dW5pZm9ybXM6e30sIGZyYWdtZW50U2hhZGVyOicnLCB2ZXJ0ZXhTaGFkZXI6Jyd9YFxuICovXG5mdW5jdGlvbiBnZXRTaGFkZXJzRm9yTWF0ZXJpYWwobWF0ZXJpYWwpIHtcbiAgbGV0IGJ1aWx0aW5UeXBlID0gTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSU1ttYXRlcmlhbC50eXBlXTtcbiAgcmV0dXJuIGJ1aWx0aW5UeXBlID8gU2hhZGVyTGliW2J1aWx0aW5UeXBlXSA6IG1hdGVyaWFsIC8vVE9ETyBmYWxsYmFjayBmb3IgdW5rbm93biB0eXBlP1xufVxuXG4vKipcbiAqIEZpbmQgYWxsIHVuaWZvcm1zIGFuZCB0aGVpciB0eXBlcyB3aXRoaW4gYSBzaGFkZXIgY29kZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlciAtIFRoZSBzaGFkZXIgY29kZSB0byBwYXJzZVxuICogQHJldHVybiB7b2JqZWN0fSBtYXBwaW5nIG9mIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgZ2xzbCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldFNoYWRlclVuaWZvcm1UeXBlcyhzaGFkZXIpIHtcbiAgbGV0IHVuaWZvcm1SRSA9IC9cXGJ1bmlmb3JtXFxzKyhpbnR8ZmxvYXR8dmVjWzIzNF18bWF0WzM0XSlcXHMrKFtBLVphLXpfXVtcXHddKikvZztcbiAgbGV0IHVuaWZvcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gdW5pZm9ybVJFLmV4ZWMoc2hhZGVyKSkgIT09IG51bGwpIHtcbiAgICB1bmlmb3Jtc1ttYXRjaFsyXV0gPSBtYXRjaFsxXTtcbiAgfVxuICByZXR1cm4gdW5pZm9ybXNcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHNtb290aGluZyBvdXQgdGhlIGBtLmdldEludmVyc2UoeClgIC0tPiBgbS5jb3B5KHgpLmludmVydCgpYCBjb252ZXJzaW9uXG4gKiB0aGF0IGhhcHBlbmVkIGluIFRocmVlSlMgcjEyMy5cbiAqIEBwYXJhbSB7TWF0cml4NH0gc3JjTWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDR9IFt0Z3RNYXRyaXhdXG4gKi9cbmZ1bmN0aW9uIGludmVydE1hdHJpeDQoc3JjTWF0cml4LCB0Z3RNYXRyaXggPSBuZXcgTWF0cml4NCgpKSB7XG4gIGlmICh0eXBlb2YgdGd0TWF0cml4LmludmVydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRndE1hdHJpeC5jb3B5KHNyY01hdHJpeCkuaW52ZXJ0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGd0TWF0cml4LmdldEludmVyc2Uoc3JjTWF0cml4KTtcbiAgfVxuICByZXR1cm4gdGd0TWF0cml4XG59XG5cbi8qXG5JbnB1dCBnZW9tZXRyeSBpcyBhIGN5bGluZGVyIHdpdGggcj0xLCBoZWlnaHQgaW4geSBkaW1lbnNpb24gZnJvbSAwIHRvIDEsXG5kaXZpZGVkIGludG8gYSByZWFzb25hYmxlIG51bWJlciBvZiBoZWlnaHQgc2VnbWVudHMuXG4qL1xuXG5jb25zdCB2ZXJ0ZXhEZWZzID0gYFxudW5pZm9ybSB2ZWMzIHBvaW50QTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQjtcbnVuaWZvcm0gdmVjMyBwb2ludEI7XG51bmlmb3JtIGZsb2F0IHJhZGl1cztcbnZhcnlpbmcgZmxvYXQgYmV6aWVyVDtcblxudmVjMyBjdWJpY0Jlemllcih2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgZmxvYXQgYjAgPSB0MiAqIHQyICogdDI7XG4gIGZsb2F0IGIxID0gMy4wICogdCAqIHQyICogdDI7XG4gIGZsb2F0IGIyID0gMy4wICogdCAqIHQgKiB0MjtcbiAgZmxvYXQgYjMgPSB0ICogdCAqIHQ7XG4gIHJldHVybiBiMCAqIHAxICsgYjEgKiBjMSArIGIyICogYzIgKyBiMyAqIHAyO1xufVxuXG52ZWMzIGN1YmljQmV6aWVyRGVyaXZhdGl2ZSh2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgcmV0dXJuIC0zLjAgKiBwMSAqIHQyICogdDIgK1xuICAgIGMxICogKDMuMCAqIHQyICogdDIgLSA2LjAgKiB0MiAqIHQpICtcbiAgICBjMiAqICg2LjAgKiB0MiAqIHQgLSAzLjAgKiB0ICogdCkgK1xuICAgIDMuMCAqIHAyICogdCAqIHQ7XG59XG5gO1xuXG5jb25zdCB2ZXJ0ZXhUcmFuc2Zvcm0gPSBgXG5mbG9hdCB0ID0gcG9zaXRpb24ueTtcbmJlemllclQgPSB0O1xudmVjMyBiZXppZXJDZW50ZXJQb3MgPSBjdWJpY0Jlemllcihwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KTtcbnZlYzMgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KSk7XG5cbi8vIE1ha2UgXCJzaWRld2F5c1wiIGFsd2F5cyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBjYW1lcmEgcmF5OyB0aGlzIGVuc3VyZXMgdGhhdCBhbnkgdHdpc3RzXG4vLyBpbiB0aGUgY3lsaW5kZXIgb2NjdXIgd2hlcmUgeW91IHdvbid0IHNlZSB0aGVtOiBcbnZlYzMgdmlld0RpcmVjdGlvbiA9IG5vcm1hbE1hdHJpeCAqIHZlYzMoMC4wLCAwLjAsIDEuMCk7XG5pZiAoYmV6aWVyRGlyID09IHZpZXdEaXJlY3Rpb24pIHtcbiAgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0ID09IDEuMCA/IHQgLSAwLjAwMDEgOiB0ICsgMC4wMDAxKSk7XG59XG52ZWMzIHNpZGV3YXlzID0gbm9ybWFsaXplKGNyb3NzKGJlemllckRpciwgdmlld0RpcmVjdGlvbikpO1xudmVjMyB1cGlzaCA9IG5vcm1hbGl6ZShjcm9zcyhzaWRld2F5cywgYmV6aWVyRGlyKSk7XG5cbi8vIEJ1aWxkIGEgbWF0cml4IGZvciB0cmFuc2Zvcm1pbmcgdGhpcyBkaXNjIGluIHRoZSBjeWxpbmRlcjpcbm1hdDQgZGlzY1R4O1xuZGlzY1R4WzBdLnh5eiA9IHNpZGV3YXlzICogcmFkaXVzO1xuZGlzY1R4WzFdLnh5eiA9IGJlemllckRpciAqIHJhZGl1cztcbmRpc2NUeFsyXS54eXogPSB1cGlzaCAqIHJhZGl1cztcbmRpc2NUeFszXS54eXogPSBiZXppZXJDZW50ZXJQb3M7XG5kaXNjVHhbM11bM10gPSAxLjA7XG5cbi8vIEFwcGx5IHRyYW5zZm9ybSwgaWdub3Jpbmcgb3JpZ2luYWwgeVxucG9zaXRpb24gPSAoZGlzY1R4ICogdmVjNChwb3NpdGlvbi54LCAwLjAsIHBvc2l0aW9uLnosIDEuMCkpLnh5ejtcbm5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKGRpc2NUeCkgKiBub3JtYWwpO1xuYDtcblxuY29uc3QgZnJhZ21lbnREZWZzID0gYFxudW5pZm9ybSB2ZWMzIGRhc2hpbmc7XG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XG5gO1xuXG5jb25zdCBmcmFnbWVudE1haW5JbnRybyA9IGBcbmlmIChkYXNoaW5nLnggKyBkYXNoaW5nLnkgPiAwLjApIHtcbiAgZmxvYXQgZGFzaEZyYWMgPSBtb2QoYmV6aWVyVCAtIGRhc2hpbmcueiwgZGFzaGluZy54ICsgZGFzaGluZy55KTtcbiAgaWYgKGRhc2hGcmFjID4gZGFzaGluZy54KSB7XG4gICAgZGlzY2FyZDtcbiAgfVxufVxuYDtcblxuLy8gRGVidWdnaW5nOiBzZXBhcmF0ZSBjb2xvciBmb3IgZWFjaCBvZiB0aGUgNiBzaWRlczpcbi8vIGNvbnN0IGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gPSBgXG4vLyBmbG9hdCBzaWRlTnVtID0gZmxvb3IodlVWLnggKiA2LjApO1xuLy8gdmVjMyBtaXhDb2xvciA9IHNpZGVOdW0gPCAxLjAgPyB2ZWMzKDEuMCwgMC4wLCAwLjApIDpcbi8vICAgc2lkZU51bSA8IDIuMCA/IHZlYzMoMC4wLCAxLjAsIDEuMCkgOlxuLy8gICBzaWRlTnVtIDwgMy4wID8gdmVjMygxLjAsIDEuMCwgMC4wKSA6XG4vLyAgIHNpZGVOdW0gPCA0LjAgPyB2ZWMzKDAuMCwgMC4wLCAxLjApIDpcbi8vICAgc2lkZU51bSA8IDUuMCA/IHZlYzMoMC4wLCAxLjAsIDAuMCkgOlxuLy8gICB2ZWMzKDEuMCwgMC4wLCAxLjApO1xuLy8gZ2xfRnJhZ0NvbG9yLnh5eiA9IG1peChnbF9GcmFnQ29sb3IueHl6LCBtaXhDb2xvciwgMC41KTtcbi8vIGBcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgcmV0dXJuIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICBiYXNlTWF0ZXJpYWwsXG4gICAge1xuICAgICAgY2hhaW5lZDogdHJ1ZSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHBvaW50QToge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgY29udHJvbEE6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIGNvbnRyb2xCOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICBwb2ludEI6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIHJhZGl1czoge3ZhbHVlOiAwLjAxfSxcbiAgICAgICAgZGFzaGluZzoge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSAvL29uLCBvZmYsIG9mZnNldFxuICAgICAgfSxcbiAgICAgIHZlcnRleERlZnMsXG4gICAgICB2ZXJ0ZXhUcmFuc2Zvcm0sXG4gICAgICBmcmFnbWVudERlZnMsXG4gICAgICBmcmFnbWVudE1haW5JbnRyb1xuICAgIH1cbiAgKVxufVxuXG5sZXQgZ2VvbWV0cnkgPSBudWxsO1xuXG5jb25zdCBkZWZhdWx0QmFzZU1hdGVyaWFsID0gLyojX19QVVJFX18qL25ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7Y29sb3I6IDB4ZmZmZmZmLCBzaWRlOiBEb3VibGVTaWRlfSk7XG5cblxuLyoqXG4gKiBBIFRocmVlSlMgYE1lc2hgIHRoYXQgYmVuZHMgYSB0dWJlIHNoYXBlIGFsb25nIGEgM0QgY3ViaWMgYmV6aWVyIHBhdGguIFRoZSBiZW5kaW5nIGlzIGRvbmVcbiAqIGJ5IGRlZm9ybWluZyBhIHN0cmFpZ2h0IGN5bGluZHJpY2FsIGdlb21ldHJ5IGluIHRoZSB2ZXJ0ZXggc2hhZGVyIGJhc2VkIG9uIGEgc2V0IG9mIGZvdXJcbiAqIGNvbnRyb2wgcG9pbnQgdW5pZm9ybXMuIEl0IHBhdGNoZXMgdGhlIG5lY2Vzc2FyeSBHTFNMIGludG8gdGhlIG1lc2gncyBhc3NpZ25lZCBgbWF0ZXJpYWxgXG4gKiBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIFRoZSBjdWJpeiBiZXppZXIgcGF0aCBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBmb3VyIGBWZWN0b3IzYCBwcm9wZXJ0aWVzOlxuICogLSBgcG9pbnRBYFxuICogLSBgY29udHJvbEFgXG4gKiAtIGBjb250cm9sQmBcbiAqIC0gYHBvaW50QmBcbiAqXG4gKiBUaGUgdHViZSdzIHJhZGl1cyBpcyBjb250cm9sbGVkIGJ5IGl0cyBgcmFkaXVzYCBwcm9wZXJ0eSwgd2hpY2ggZGVmYXVsdHMgdG8gYDAuMDFgLlxuICpcbiAqIFlvdSBjYW4gYWxzbyBnaXZlIHRoZSB0dWJlIGEgZGFzaGVkIGFwcGVhcmFuY2Ugd2l0aCB0d28gcHJvcGVydGllczpcbiAqXG4gKiAtIGBkYXNoQXJyYXlgIC0gYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMsIGRlZmluaW5nIHRoZSBsZW5ndGggb2YgXCJvblwiIGFuZCBcIm9mZlwiIHBhcnRzIG9mXG4gKiAgIHRoZSBkYXNoLiBFYWNoIGlzIGEgMC0xIHJhdGlvIG9mIHRoZSBlbnRpcmUgcGF0aCdzIGxlbmd0aC4gKEFjdHVhbGx5IHRoaXMgaXMgdGhlIGB0YCBsZW5ndGhcbiAqICAgdXNlZCBhcyBpbnB1dCB0byB0aGUgY3ViaWMgYmV6aWVyIGZ1bmN0aW9uLCBub3QgaXRzIHZpc2libGUgbGVuZ3RoLilcbiAqIC0gYGRhc2hPZmZzZXRgIC0gb2Zmc2V0IG9mIHdoZXJlIHRoZSBkYXNoIHN0YXJ0cy4gWW91IGNhbiBhbmltYXRlIHRoaXMgdG8gbWFrZSB0aGUgZGFzaGVzIG1vdmUuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBkYXNoZXMgd2lsbCBhcHBlYXIgbGlrZSBhIGhvbGxvdyB0dWJlLCBub3Qgc29saWQuIFRoaXMgd2lsbCBiZSBtb3JlIGFwcGFyZW50IG9uXG4gKiB0aGlja2VyIHR1YmVzLlxuICpcbiAqIFRPRE86IHByb3BlciBnZW9tZXRyeSBib3VuZGluZyBzcGhlcmUgYW5kIHJheWNhc3RpbmdcbiAqIFRPRE86IGFsbG93IGNvbnRyb2wgb2YgdGhlIGdlb21ldHJ5J3Mgc2VnbWVudCBjb3VudHNcbiAqL1xuY2xhc3MgQmV6aWVyTWVzaCBleHRlbmRzIE1lc2gge1xuICBzdGF0aWMgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIGdlb21ldHJ5IHx8IChnZW9tZXRyeSA9XG4gICAgICBuZXcgQ3lsaW5kZXJHZW9tZXRyeSgxLCAxLCAxLCA2LCA2NCkudHJhbnNsYXRlKDAsIDAuNSwgMClcbiAgICApXG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcbiAgICAgIEJlemllck1lc2guZ2V0R2VvbWV0cnkoKSxcbiAgICAgIGRlZmF1bHRCYXNlTWF0ZXJpYWxcbiAgICApO1xuXG4gICAgdGhpcy5wb2ludEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY29udHJvbEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY29udHJvbEIgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMucG9pbnRCID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLnJhZGl1cyA9IDAuMDE7XG4gICAgdGhpcy5kYXNoQXJyYXkgPSBuZXcgVmVjdG9yMigpO1xuICAgIHRoaXMuZGFzaE9mZnNldCA9IDA7XG5cbiAgICAvLyBUT0RPIC0gZGlzYWJsaW5nIGZydXN0dW0gY3VsbGluZyB1bnRpbCBJIGZpZ3VyZSBvdXQgaG93IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICAvLyAgZ2VvbWV0cnkncyBib3VuZGluZyBzcGhlcmUgdGhhdCBnZXRzIHVzZWRcbiAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEhhbmRsZXIgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgdGhlIGJhc2UgbWF0ZXJpYWwgd2l0aCBvdXIgdXBncmFkZXMuIFdlIGRvIHRoZSB3cmFwcGluZ1xuICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gIGdldCBtYXRlcmlhbCgpIHtcbiAgICBsZXQgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsO1xuICAgIGNvbnN0IGJhc2VNYXRlcmlhbCA9IHRoaXMuX2Jhc2VNYXRlcmlhbCB8fCB0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgfHwgKHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRCYXNlTWF0ZXJpYWwuY2xvbmUoKSk7XG4gICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgZGVyaXZlZE1hdGVyaWFsLmJhc2VNYXRlcmlhbCAhPT0gYmFzZU1hdGVyaWFsKSB7XG4gICAgICBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVCZXppZXJNZXNoTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKTtcbiAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgIGJhc2VNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICB9XG4gIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gIH1cblxuICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gIGdldCBjdXN0b21EZXB0aE1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICB9XG4gIGdldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICB9XG5cbiAgb25CZWZvcmVSZW5kZXIoKSB7XG4gICAgY29uc3Qge3VuaWZvcm1zfSA9IHRoaXMubWF0ZXJpYWw7XG4gICAgY29uc3Qge3BvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHJhZGl1cywgZGFzaEFycmF5LCBkYXNoT2Zmc2V0fSA9IHRoaXM7XG4gICAgdW5pZm9ybXMucG9pbnRBLnZhbHVlLmNvcHkocG9pbnRBKTtcbiAgICB1bmlmb3Jtcy5jb250cm9sQS52YWx1ZS5jb3B5KGNvbnRyb2xBKTtcbiAgICB1bmlmb3Jtcy5jb250cm9sQi52YWx1ZS5jb3B5KGNvbnRyb2xCKTtcbiAgICB1bmlmb3Jtcy5wb2ludEIudmFsdWUuY29weShwb2ludEIpO1xuICAgIHVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHJhZGl1cztcbiAgICB1bmlmb3Jtcy5kYXNoaW5nLnZhbHVlLnNldChkYXNoQXJyYXkueCwgZGFzaEFycmF5LnksIGRhc2hPZmZzZXQgfHwgMCk7XG4gIH1cblxuICByYXljYXN0KC8qcmF5Y2FzdGVyLCBpbnRlcnNlY3RzKi8pIHtcbiAgICAvLyBUT0RPIC0ganVzdCBmYWlsIGZvciBub3dcbiAgfVxufVxuXG5leHBvcnQgeyBCZXppZXJNZXNoLCBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwsIGV4cGFuZFNoYWRlckluY2x1ZGVzLCBnZXRTaGFkZXJVbmlmb3JtVHlwZXMsIGdldFNoYWRlcnNGb3JNYXRlcmlhbCwgaW52ZXJ0TWF0cml4NCwgdm9pZE1haW5SZWdFeHAgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineWorkerModule: function() { return /* binding */ defineWorkerModule; },\n/* harmony export */   stringifyFunction: function() { return /* binding */ stringifyFunction; },\n/* harmony export */   terminateWorker: function() { return /* binding */ terminateWorker; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Main content for the worker that handles the loading and execution of\n * modules within it.\n */\nfunction workerBootstrap() {\n  var modules = Object.create(null);\n\n  // Handle messages for registering a module\n  function registerModule(ref, callback) {\n    var id = ref.id;\n    var name = ref.name;\n    var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n    var init = ref.init; if ( init === void 0 ) init = function(){};\n    var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n    // Only register once\n    if (modules[id]) { return }\n\n    try {\n      // If any dependencies are modules, ensure they're registered and grab their value\n      dependencies = dependencies.map(function (dep) {\n        if (dep && dep.isWorkerModule) {\n          registerModule(dep, function (depResult) {\n            if (depResult instanceof Error) { throw depResult }\n          });\n          dep = modules[dep.id].value;\n        }\n        return dep\n      });\n\n      // Rehydrate functions\n      init = rehydrate((\"<\" + name + \">.init\"), init);\n      if (getTransferables) {\n        getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\n      }\n\n      // Initialize the module and store its value\n      var value = null;\n      if (typeof init === 'function') {\n        value = init.apply(void 0, dependencies);\n      } else {\n        console.error('worker module init function failed to rehydrate');\n      }\n      modules[id] = {\n        id: id,\n        value: value,\n        getTransferables: getTransferables\n      };\n      callback(value);\n    } catch(err) {\n      if (!(err && err.noLog)) {\n        console.error(err);\n      }\n      callback(err);\n    }\n  }\n\n  // Handle messages for calling a registered module's result function\n  function callModule(ref, callback) {\n    var ref$1;\n\n    var id = ref.id;\n    var args = ref.args;\n    if (!modules[id] || typeof modules[id].value !== 'function') {\n      callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n    }\n    try {\n      var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n      if (result && typeof result.then === 'function') {\n        result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n      } else {\n        handleResult(result);\n      }\n    } catch(err) {\n      callback(err);\n    }\n    function handleResult(result) {\n      try {\n        var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n        if (!tx || !Array.isArray(tx) || !tx.length) {\n          tx = undefined; //postMessage is very picky about not passing null or empty transferables\n        }\n        callback(result, tx);\n      } catch(err) {\n        console.error(err);\n        callback(err);\n      }\n    }\n  }\n\n  function rehydrate(name, str) {\n    var result = void 0;\n    self.troikaDefine = function (r) { return result = r; };\n    var url = URL.createObjectURL(\n      new Blob(\n        [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\n        {type: 'application/javascript'}\n      )\n    );\n    try {\n      importScripts(url);\n    } catch(err) {\n      console.error(err);\n    }\n    URL.revokeObjectURL(url);\n    delete self.troikaDefine;\n    return result\n  }\n\n  // Handler for all messages within the worker\n  self.addEventListener('message', function (e) {\n    var ref = e.data;\n    var messageId = ref.messageId;\n    var action = ref.action;\n    var data = ref.data;\n    try {\n      // Module registration\n      if (action === 'registerModule') {\n        registerModule(data, function (result) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: {isCallable: typeof result === 'function'}\n            });\n          }\n        });\n      }\n      // Invocation\n      if (action === 'callModule') {\n        callModule(data, function (result, transferables) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: result\n            }, transferables || undefined);\n          }\n        });\n      }\n    } catch(err) {\n      postMessage({\n        messageId: messageId,\n        success: false,\n        error: err.stack\n      });\n    }\n  });\n}\n\n/**\n * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n * thread, for when the execution environment doesn't support web workers or they\n * are disallowed due to e.g. CSP security restrictions.\n */\nfunction defineMainThreadModule(options) {\n  var moduleFunc = function() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return moduleFunc._getInitResult().then(function (initResult) {\n      if (typeof initResult === 'function') {\n        return initResult.apply(void 0, args)\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  };\n  moduleFunc._getInitResult = function() {\n    // We can ignore getTransferables in main thread. TODO workerId?\n    var dependencies = options.dependencies;\n    var init = options.init;\n\n    // Resolve dependencies\n    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }\n    ) : [];\n\n    // Invoke init with the resolved dependencies\n    var initPromise = Promise.all(dependencies).then(function (deps) {\n      return init.apply(null, deps)\n    });\n\n    // Cache the resolved promise for subsequent calls\n    moduleFunc._getInitResult = function () { return initPromise; };\n\n    return initPromise\n  };\n  return moduleFunc\n}\n\nvar supportsWorkers = function () {\n  var supported = false;\n\n  // Only attempt worker initialization in browsers; elsewhere it would just be\n  // noise e.g. loading into a Node environment for SSR.\n  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n    try {\n      // TODO additional checks for things like importScripts within the worker?\n      //  Would need to be an async check.\n      var worker = new Worker(\n        URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))\n      );\n      worker.terminate();\n      supported = true;\n    } catch (err) {\n      if (typeof process !== 'undefined' && \"development\" === 'test') {} else {\n        console.log(\n          (\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\")\n        );\n      }\n    }\n  }\n\n  // Cached result\n  supportsWorkers = function () { return supported; };\n  return supported\n};\n\nvar _workerModuleId = 0;\nvar _messageId = 0;\nvar _allowInitAsString = false;\nvar workers = Object.create(null);\nvar registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\nvar openRequests = Object.create(null);\n\n\n/**\n * Define a module of code that will be executed with a web worker. This provides a simple\n * interface for moving chunks of logic off the main thread, and managing their dependencies\n * among one another.\n *\n * @param {object} options\n * @param {function} options.init\n * @param {array} [options.dependencies]\n * @param {function} [options.getTransferables]\n * @param {string} [options.name]\n * @param {string} [options.workerId]\n * @return {function(...[*]): {then}}\n */\nfunction defineWorkerModule(options) {\n  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n    throw new Error('requires `options.init` function')\n  }\n  var dependencies = options.dependencies;\n  var init = options.init;\n  var getTransferables = options.getTransferables;\n  var workerId = options.workerId;\n\n  if (!supportsWorkers()) {\n    return defineMainThreadModule(options)\n  }\n\n  if (workerId == null) {\n    workerId = '#default';\n  }\n  var id = \"workerModule\" + (++_workerModuleId);\n  var name = options.name || id;\n  var registrationPromise = null;\n\n  dependencies = dependencies && dependencies.map(function (dep) {\n    // Wrap raw functions as worker modules with no dependencies\n    if (typeof dep === 'function' && !dep.workerModuleData) {\n      _allowInitAsString = true;\n      dep = defineWorkerModule({\n        workerId: workerId,\n        name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\n        init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\n      });\n      _allowInitAsString = false;\n    }\n    // Grab postable data for worker modules\n    if (dep && dep.workerModuleData) {\n      dep = dep.workerModuleData;\n    }\n    return dep\n  });\n\n  function moduleFunc() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    // Register this module if needed\n    if (!registrationPromise) {\n      registrationPromise = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n      var unregister = function () {\n        registrationPromise = null;\n        registeredModules[workerId].delete(unregister);\n      }\n      ;(registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\n    }\n\n    // Invoke the module, returning a promise\n    return registrationPromise.then(function (ref) {\n      var isCallable = ref.isCallable;\n\n      if (isCallable) {\n        return callWorker(workerId,'callModule', {id: id, args: args})\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  }\n  moduleFunc.workerModuleData = {\n    isWorkerModule: true,\n    id: id,\n    name: name,\n    dependencies: dependencies,\n    init: stringifyFunction(init),\n    getTransferables: getTransferables && stringifyFunction(getTransferables)\n  };\n  return moduleFunc\n}\n\n/**\n * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\n * This only terminates the Worker itself; the worker module will remain available\n * and if you call it again its Worker will be respawned.\n * @param {string} workerId\n */\nfunction terminateWorker(workerId) {\n  // Unregister all modules that were registered in that worker\n  if (registeredModules[workerId]) {\n    registeredModules[workerId].forEach(function (unregister) {\n      unregister();\n    });\n  }\n  // Terminate the Worker object\n  if (workers[workerId]) {\n    workers[workerId].terminate();\n    delete workers[workerId];\n  }\n}\n\n/**\n * Stringifies a function into a form that can be deserialized in the worker\n * @param fn\n */\nfunction stringifyFunction(fn) {\n  var str = fn.toString();\n  // If it was defined in object method/property format, it needs to be modified\n  if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n    str = 'function ' + str;\n  }\n  return str\n}\n\n\nfunction getWorker(workerId) {\n  var worker = workers[workerId];\n  if (!worker) {\n    // Bootstrap the worker's content\n    var bootstrap = stringifyFunction(workerBootstrap);\n\n    // Create the worker from the bootstrap function content\n    worker = workers[workerId] = new Worker(\n      URL.createObjectURL(\n        new Blob(\n          [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\n          {type: 'application/javascript'}\n        )\n      )\n    );\n\n    // Single handler for response messages from the worker\n    worker.onmessage = function (e) {\n      var response = e.data;\n      var msgId = response.messageId;\n      var callback = openRequests[msgId];\n      if (!callback) {\n        throw new Error('WorkerModule response with empty or unknown messageId')\n      }\n      delete openRequests[msgId];\n      callback(response);\n    };\n  }\n  return worker\n}\n\n// Issue a call to the worker with a callback to handle the response\nfunction callWorker(workerId, action, data) {\n  return new Promise(function (resolve, reject) {\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        resolve(response.result);\n      } else {\n        reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n      }\n    };\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n  })\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90cm9pa2Etd29ya2VyLXV0aWxzL2Rpc3QvdHJvaWthLXdvcmtlci11dGlscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5QkFBeUI7QUFDekIsaURBQWlEOztBQUVqRDtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9FQUFvRTtBQUN2SCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1GQUFtRjtBQUNuRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixpQkFBaUIsT0FBTyxvQkFBb0IsYUFBb0IsYUFBYSxFQUFDLENBQUM7QUFDL0U7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUE4QztBQUN6RSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsbUJBQW1CO0FBQ3JFLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRWtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90cm9pa2Etd29ya2VyLXV0aWxzL2Rpc3QvdHJvaWthLXdvcmtlci11dGlscy5lc20uanM/NWQ2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1haW4gY29udGVudCBmb3IgdGhlIHdvcmtlciB0aGF0IGhhbmRsZXMgdGhlIGxvYWRpbmcgYW5kIGV4ZWN1dGlvbiBvZlxuICogbW9kdWxlcyB3aXRoaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIHdvcmtlckJvb3RzdHJhcCgpIHtcbiAgdmFyIG1vZHVsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIEhhbmRsZSBtZXNzYWdlcyBmb3IgcmVnaXN0ZXJpbmcgYSBtb2R1bGVcbiAgZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGUocmVmLCBjYWxsYmFjaykge1xuICAgIHZhciBpZCA9IHJlZi5pZDtcbiAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSByZWYuZGVwZW5kZW5jaWVzOyBpZiAoIGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwICkgZGVwZW5kZW5jaWVzID0gW107XG4gICAgdmFyIGluaXQgPSByZWYuaW5pdDsgaWYgKCBpbml0ID09PSB2b2lkIDAgKSBpbml0ID0gZnVuY3Rpb24oKXt9O1xuICAgIHZhciBnZXRUcmFuc2ZlcmFibGVzID0gcmVmLmdldFRyYW5zZmVyYWJsZXM7IGlmICggZ2V0VHJhbnNmZXJhYmxlcyA9PT0gdm9pZCAwICkgZ2V0VHJhbnNmZXJhYmxlcyA9IG51bGw7XG5cbiAgICAvLyBPbmx5IHJlZ2lzdGVyIG9uY2VcbiAgICBpZiAobW9kdWxlc1tpZF0pIHsgcmV0dXJuIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBJZiBhbnkgZGVwZW5kZW5jaWVzIGFyZSBtb2R1bGVzLCBlbnN1cmUgdGhleSdyZSByZWdpc3RlcmVkIGFuZCBncmFiIHRoZWlyIHZhbHVlXG4gICAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgaWYgKGRlcCAmJiBkZXAuaXNXb3JrZXJNb2R1bGUpIHtcbiAgICAgICAgICByZWdpc3Rlck1vZHVsZShkZXAsIGZ1bmN0aW9uIChkZXBSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZXBSZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikgeyB0aHJvdyBkZXBSZXN1bHQgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlcCA9IG1vZHVsZXNbZGVwLmlkXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVwXG4gICAgICB9KTtcblxuICAgICAgLy8gUmVoeWRyYXRlIGZ1bmN0aW9uc1xuICAgICAgaW5pdCA9IHJlaHlkcmF0ZSgoXCI8XCIgKyBuYW1lICsgXCI+LmluaXRcIiksIGluaXQpO1xuICAgICAgaWYgKGdldFRyYW5zZmVyYWJsZXMpIHtcbiAgICAgICAgZ2V0VHJhbnNmZXJhYmxlcyA9IHJlaHlkcmF0ZSgoXCI8XCIgKyBuYW1lICsgXCI+LmdldFRyYW5zZmVyYWJsZXNcIiksIGdldFRyYW5zZmVyYWJsZXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBtb2R1bGUgYW5kIHN0b3JlIGl0cyB2YWx1ZVxuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IGluaXQuYXBwbHkodm9pZCAwLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignd29ya2VyIG1vZHVsZSBpbml0IGZ1bmN0aW9uIGZhaWxlZCB0byByZWh5ZHJhdGUnKTtcbiAgICAgIH1cbiAgICAgIG1vZHVsZXNbaWRdID0ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZ2V0VHJhbnNmZXJhYmxlczogZ2V0VHJhbnNmZXJhYmxlc1xuICAgICAgfTtcbiAgICAgIGNhbGxiYWNrKHZhbHVlKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgaWYgKCEoZXJyICYmIGVyci5ub0xvZykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgbWVzc2FnZXMgZm9yIGNhbGxpbmcgYSByZWdpc3RlcmVkIG1vZHVsZSdzIHJlc3VsdCBmdW5jdGlvblxuICBmdW5jdGlvbiBjYWxsTW9kdWxlKHJlZiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVmJDE7XG5cbiAgICB2YXIgaWQgPSByZWYuaWQ7XG4gICAgdmFyIGFyZ3MgPSByZWYuYXJncztcbiAgICBpZiAoIW1vZHVsZXNbaWRdIHx8IHR5cGVvZiBtb2R1bGVzW2lkXS52YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKChcIldvcmtlciBtb2R1bGUgXCIgKyBpZCArIFwiOiBub3QgZm91bmQgb3IgaXRzICdpbml0JyBkaWQgbm90IHJldHVybiBhIGZ1bmN0aW9uXCIpKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKHJlZiQxID0gbW9kdWxlc1tpZF0pLnZhbHVlLmFwcGx5KHJlZiQxLCBhcmdzKTtcbiAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKGhhbmRsZVJlc3VsdCwgZnVuY3Rpb24gKHJlaikgeyByZXR1cm4gY2FsbGJhY2socmVqIGluc3RhbmNlb2YgRXJyb3IgPyByZWogOiBuZXcgRXJyb3IoJycgKyByZWopKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVSZXN1bHQocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0KHJlc3VsdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHR4ID0gbW9kdWxlc1tpZF0uZ2V0VHJhbnNmZXJhYmxlcyAmJiBtb2R1bGVzW2lkXS5nZXRUcmFuc2ZlcmFibGVzKHJlc3VsdCk7XG4gICAgICAgIGlmICghdHggfHwgIUFycmF5LmlzQXJyYXkodHgpIHx8ICF0eC5sZW5ndGgpIHtcbiAgICAgICAgICB0eCA9IHVuZGVmaW5lZDsgLy9wb3N0TWVzc2FnZSBpcyB2ZXJ5IHBpY2t5IGFib3V0IG5vdCBwYXNzaW5nIG51bGwgb3IgZW1wdHkgdHJhbnNmZXJhYmxlc1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCwgdHgpO1xuICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlaHlkcmF0ZShuYW1lLCBzdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgIHNlbGYudHJvaWthRGVmaW5lID0gZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHJlc3VsdCA9IHI7IH07XG4gICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICBuZXcgQmxvYihcbiAgICAgICAgWyhcIi8qKiBcIiArIChuYW1lLnJlcGxhY2UoL1xcKi9nLCAnJykpICsgXCIgKiovXFxuXFxudHJvaWthRGVmaW5lKFxcblwiICsgc3RyICsgXCJcXG4pXCIpXSxcbiAgICAgICAge3R5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J31cbiAgICAgIClcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICBpbXBvcnRTY3JpcHRzKHVybCk7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgIGRlbGV0ZSBzZWxmLnRyb2lrYURlZmluZTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBIYW5kbGVyIGZvciBhbGwgbWVzc2FnZXMgd2l0aGluIHRoZSB3b3JrZXJcbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcmVmID0gZS5kYXRhO1xuICAgIHZhciBtZXNzYWdlSWQgPSByZWYubWVzc2FnZUlkO1xuICAgIHZhciBhY3Rpb24gPSByZWYuYWN0aW9uO1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE1vZHVsZSByZWdpc3RyYXRpb25cbiAgICAgIGlmIChhY3Rpb24gPT09ICdyZWdpc3Rlck1vZHVsZScpIHtcbiAgICAgICAgcmVnaXN0ZXJNb2R1bGUoZGF0YSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiByZXN1bHQubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgIHJlc3VsdDoge2lzQ2FsbGFibGU6IHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbid9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gSW52b2NhdGlvblxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ2NhbGxNb2R1bGUnKSB7XG4gICAgICAgIGNhbGxNb2R1bGUoZGF0YSwgZnVuY3Rpb24gKHJlc3VsdCwgdHJhbnNmZXJhYmxlcykge1xuICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiByZXN1bHQubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnIuc3RhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogRmFsbGJhY2sgZm9yIGBkZWZpbmVXb3JrZXJNb2R1bGVgIHRoYXQgYmVoYXZlcyBpZGVudGljYWxseSBidXQgcnVucyBpbiB0aGUgbWFpblxuICogdGhyZWFkLCBmb3Igd2hlbiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB3ZWIgd29ya2VycyBvciB0aGV5XG4gKiBhcmUgZGlzYWxsb3dlZCBkdWUgdG8gZS5nLiBDU1Agc2VjdXJpdHkgcmVzdHJpY3Rpb25zLlxuICovXG5mdW5jdGlvbiBkZWZpbmVNYWluVGhyZWFkTW9kdWxlKG9wdGlvbnMpIHtcbiAgdmFyIG1vZHVsZUZ1bmMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICByZXR1cm4gbW9kdWxlRnVuYy5fZ2V0SW5pdFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24gKGluaXRSZXN1bHQpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5pdFJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaW5pdFJlc3VsdC5hcHBseSh2b2lkIDAsIGFyZ3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlciBtb2R1bGUgZnVuY3Rpb24gd2FzIGNhbGxlZCBidXQgYGluaXRgIGRpZCBub3QgcmV0dXJuIGEgY2FsbGFibGUgZnVuY3Rpb24nKVxuICAgICAgfVxuICAgIH0pXG4gIH07XG4gIG1vZHVsZUZ1bmMuX2dldEluaXRSZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBXZSBjYW4gaWdub3JlIGdldFRyYW5zZmVyYWJsZXMgaW4gbWFpbiB0aHJlYWQuIFRPRE8gd29ya2VySWQ/XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IG9wdGlvbnMuZGVwZW5kZW5jaWVzO1xuICAgIHZhciBpbml0ID0gb3B0aW9ucy5pbml0O1xuXG4gICAgLy8gUmVzb2x2ZSBkZXBlbmRlbmNpZXNcbiAgICBkZXBlbmRlbmNpZXMgPSBBcnJheS5pc0FycmF5KGRlcGVuZGVuY2llcykgPyBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIGRlcCAmJiBkZXAuX2dldEluaXRSZXN1bHQgPyBkZXAuX2dldEluaXRSZXN1bHQoKSA6IGRlcDsgfVxuICAgICkgOiBbXTtcblxuICAgIC8vIEludm9rZSBpbml0IHdpdGggdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llc1xuICAgIHZhciBpbml0UHJvbWlzZSA9IFByb21pc2UuYWxsKGRlcGVuZGVuY2llcykudGhlbihmdW5jdGlvbiAoZGVwcykge1xuICAgICAgcmV0dXJuIGluaXQuYXBwbHkobnVsbCwgZGVwcylcbiAgICB9KTtcblxuICAgIC8vIENhY2hlIHRoZSByZXNvbHZlZCBwcm9taXNlIGZvciBzdWJzZXF1ZW50IGNhbGxzXG4gICAgbW9kdWxlRnVuYy5fZ2V0SW5pdFJlc3VsdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluaXRQcm9taXNlOyB9O1xuXG4gICAgcmV0dXJuIGluaXRQcm9taXNlXG4gIH07XG4gIHJldHVybiBtb2R1bGVGdW5jXG59XG5cbnZhciBzdXBwb3J0c1dvcmtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAvLyBPbmx5IGF0dGVtcHQgd29ya2VyIGluaXRpYWxpemF0aW9uIGluIGJyb3dzZXJzOyBlbHNld2hlcmUgaXQgd291bGQganVzdCBiZVxuICAvLyBub2lzZSBlLmcuIGxvYWRpbmcgaW50byBhIE5vZGUgZW52aXJvbm1lbnQgZm9yIFNTUi5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRPRE8gYWRkaXRpb25hbCBjaGVja3MgZm9yIHRoaW5ncyBsaWtlIGltcG9ydFNjcmlwdHMgd2l0aGluIHRoZSB3b3JrZXI/XG4gICAgICAvLyAgV291bGQgbmVlZCB0byBiZSBhbiBhc3luYyBjaGVjay5cbiAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKFxuICAgICAgICBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFsnJ10sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pKVxuICAgICAgKTtcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIDsgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIChcIlRyb2lrYSBjcmVhdGVXb3JrZXJNb2R1bGU6IHdlYiB3b3JrZXJzIG5vdCBhbGxvd2VkOyBmYWxsaW5nIGJhY2sgdG8gbWFpbiB0aHJlYWQgZXhlY3V0aW9uLiBDYXVzZTogW1wiICsgKGVyci5tZXNzYWdlKSArIFwiXVwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENhY2hlZCByZXN1bHRcbiAgc3VwcG9ydHNXb3JrZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3VwcG9ydGVkOyB9O1xuICByZXR1cm4gc3VwcG9ydGVkXG59O1xuXG52YXIgX3dvcmtlck1vZHVsZUlkID0gMDtcbnZhciBfbWVzc2FnZUlkID0gMDtcbnZhciBfYWxsb3dJbml0QXNTdHJpbmcgPSBmYWxzZTtcbnZhciB3b3JrZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciByZWdpc3RlcmVkTW9kdWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vd29ya2VySWQgLT4gU2V0PHVucmVnaXN0ZXJGbj5cbnZhciBvcGVuUmVxdWVzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cbi8qKlxuICogRGVmaW5lIGEgbW9kdWxlIG9mIGNvZGUgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdpdGggYSB3ZWIgd29ya2VyLiBUaGlzIHByb3ZpZGVzIGEgc2ltcGxlXG4gKiBpbnRlcmZhY2UgZm9yIG1vdmluZyBjaHVua3Mgb2YgbG9naWMgb2ZmIHRoZSBtYWluIHRocmVhZCwgYW5kIG1hbmFnaW5nIHRoZWlyIGRlcGVuZGVuY2llc1xuICogYW1vbmcgb25lIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuaW5pdFxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuZGVwZW5kZW5jaWVzXVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZ2V0VHJhbnNmZXJhYmxlc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLndvcmtlcklkXVxuICogQHJldHVybiB7ZnVuY3Rpb24oLi4uWypdKToge3RoZW59fVxuICovXG5mdW5jdGlvbiBkZWZpbmVXb3JrZXJNb2R1bGUob3B0aW9ucykge1xuICBpZiAoKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zLmluaXQgIT09ICdmdW5jdGlvbicpICYmICFfYWxsb3dJbml0QXNTdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIGBvcHRpb25zLmluaXRgIGZ1bmN0aW9uJylcbiAgfVxuICB2YXIgZGVwZW5kZW5jaWVzID0gb3B0aW9ucy5kZXBlbmRlbmNpZXM7XG4gIHZhciBpbml0ID0gb3B0aW9ucy5pbml0O1xuICB2YXIgZ2V0VHJhbnNmZXJhYmxlcyA9IG9wdGlvbnMuZ2V0VHJhbnNmZXJhYmxlcztcbiAgdmFyIHdvcmtlcklkID0gb3B0aW9ucy53b3JrZXJJZDtcblxuICBpZiAoIXN1cHBvcnRzV29ya2VycygpKSB7XG4gICAgcmV0dXJuIGRlZmluZU1haW5UaHJlYWRNb2R1bGUob3B0aW9ucylcbiAgfVxuXG4gIGlmICh3b3JrZXJJZCA9PSBudWxsKSB7XG4gICAgd29ya2VySWQgPSAnI2RlZmF1bHQnO1xuICB9XG4gIHZhciBpZCA9IFwid29ya2VyTW9kdWxlXCIgKyAoKytfd29ya2VyTW9kdWxlSWQpO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBpZDtcbiAgdmFyIHJlZ2lzdHJhdGlvblByb21pc2UgPSBudWxsO1xuXG4gIGRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcyAmJiBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAvLyBXcmFwIHJhdyBmdW5jdGlvbnMgYXMgd29ya2VyIG1vZHVsZXMgd2l0aCBubyBkZXBlbmRlbmNpZXNcbiAgICBpZiAodHlwZW9mIGRlcCA9PT0gJ2Z1bmN0aW9uJyAmJiAhZGVwLndvcmtlck1vZHVsZURhdGEpIHtcbiAgICAgIF9hbGxvd0luaXRBc1N0cmluZyA9IHRydWU7XG4gICAgICBkZXAgPSBkZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgICAgICB3b3JrZXJJZDogd29ya2VySWQsXG4gICAgICAgIG5hbWU6IChcIjxcIiArIG5hbWUgKyBcIj4gZnVuY3Rpb24gZGVwZW5kZW5jeTogXCIgKyAoZGVwLm5hbWUpKSxcbiAgICAgICAgaW5pdDogKFwiZnVuY3Rpb24oKXtyZXR1cm4gKFxcblwiICsgKHN0cmluZ2lmeUZ1bmN0aW9uKGRlcCkpICsgXCJcXG4pfVwiKVxuICAgICAgfSk7XG4gICAgICBfYWxsb3dJbml0QXNTdHJpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gR3JhYiBwb3N0YWJsZSBkYXRhIGZvciB3b3JrZXIgbW9kdWxlc1xuICAgIGlmIChkZXAgJiYgZGVwLndvcmtlck1vZHVsZURhdGEpIHtcbiAgICAgIGRlcCA9IGRlcC53b3JrZXJNb2R1bGVEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGVwXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG1vZHVsZUZ1bmMoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhpcyBtb2R1bGUgaWYgbmVlZGVkXG4gICAgaWYgKCFyZWdpc3RyYXRpb25Qcm9taXNlKSB7XG4gICAgICByZWdpc3RyYXRpb25Qcm9taXNlID0gY2FsbFdvcmtlcih3b3JrZXJJZCwncmVnaXN0ZXJNb2R1bGUnLCBtb2R1bGVGdW5jLndvcmtlck1vZHVsZURhdGEpO1xuICAgICAgdmFyIHVucmVnaXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICByZWdpc3RlcmVkTW9kdWxlc1t3b3JrZXJJZF0uZGVsZXRlKHVucmVnaXN0ZXIpO1xuICAgICAgfVxuICAgICAgOyhyZWdpc3RlcmVkTW9kdWxlc1t3b3JrZXJJZF0gfHwgKHJlZ2lzdGVyZWRNb2R1bGVzW3dvcmtlcklkXSA9IG5ldyBTZXQoKSkpLmFkZCh1bnJlZ2lzdGVyKTtcbiAgICB9XG5cbiAgICAvLyBJbnZva2UgdGhlIG1vZHVsZSwgcmV0dXJuaW5nIGEgcHJvbWlzZVxuICAgIHJldHVybiByZWdpc3RyYXRpb25Qcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGlzQ2FsbGFibGUgPSByZWYuaXNDYWxsYWJsZTtcblxuICAgICAgaWYgKGlzQ2FsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxXb3JrZXIod29ya2VySWQsJ2NhbGxNb2R1bGUnLCB7aWQ6IGlkLCBhcmdzOiBhcmdzfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIG1vZHVsZSBmdW5jdGlvbiB3YXMgY2FsbGVkIGJ1dCBgaW5pdGAgZGlkIG5vdCByZXR1cm4gYSBjYWxsYWJsZSBmdW5jdGlvbicpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBtb2R1bGVGdW5jLndvcmtlck1vZHVsZURhdGEgPSB7XG4gICAgaXNXb3JrZXJNb2R1bGU6IHRydWUsXG4gICAgaWQ6IGlkLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMsXG4gICAgaW5pdDogc3RyaW5naWZ5RnVuY3Rpb24oaW5pdCksXG4gICAgZ2V0VHJhbnNmZXJhYmxlczogZ2V0VHJhbnNmZXJhYmxlcyAmJiBzdHJpbmdpZnlGdW5jdGlvbihnZXRUcmFuc2ZlcmFibGVzKVxuICB9O1xuICByZXR1cm4gbW9kdWxlRnVuY1xufVxuXG4vKipcbiAqIFRlcm1pbmF0ZSBhbiBhY3RpdmUgV29ya2VyIGJ5IGEgd29ya2VySWQgdGhhdCB3YXMgcGFzc2VkIHRvIGRlZmluZVdvcmtlck1vZHVsZS5cbiAqIFRoaXMgb25seSB0ZXJtaW5hdGVzIHRoZSBXb3JrZXIgaXRzZWxmOyB0aGUgd29ya2VyIG1vZHVsZSB3aWxsIHJlbWFpbiBhdmFpbGFibGVcbiAqIGFuZCBpZiB5b3UgY2FsbCBpdCBhZ2FpbiBpdHMgV29ya2VyIHdpbGwgYmUgcmVzcGF3bmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHdvcmtlcklkXG4gKi9cbmZ1bmN0aW9uIHRlcm1pbmF0ZVdvcmtlcih3b3JrZXJJZCkge1xuICAvLyBVbnJlZ2lzdGVyIGFsbCBtb2R1bGVzIHRoYXQgd2VyZSByZWdpc3RlcmVkIGluIHRoYXQgd29ya2VyXG4gIGlmIChyZWdpc3RlcmVkTW9kdWxlc1t3b3JrZXJJZF0pIHtcbiAgICByZWdpc3RlcmVkTW9kdWxlc1t3b3JrZXJJZF0uZm9yRWFjaChmdW5jdGlvbiAodW5yZWdpc3Rlcikge1xuICAgICAgdW5yZWdpc3RlcigpO1xuICAgIH0pO1xuICB9XG4gIC8vIFRlcm1pbmF0ZSB0aGUgV29ya2VyIG9iamVjdFxuICBpZiAod29ya2Vyc1t3b3JrZXJJZF0pIHtcbiAgICB3b3JrZXJzW3dvcmtlcklkXS50ZXJtaW5hdGUoKTtcbiAgICBkZWxldGUgd29ya2Vyc1t3b3JrZXJJZF07XG4gIH1cbn1cblxuLyoqXG4gKiBTdHJpbmdpZmllcyBhIGZ1bmN0aW9uIGludG8gYSBmb3JtIHRoYXQgY2FuIGJlIGRlc2VyaWFsaXplZCBpbiB0aGUgd29ya2VyXG4gKiBAcGFyYW0gZm5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5RnVuY3Rpb24oZm4pIHtcbiAgdmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gIC8vIElmIGl0IHdhcyBkZWZpbmVkIGluIG9iamVjdCBtZXRob2QvcHJvcGVydHkgZm9ybWF0LCBpdCBuZWVkcyB0byBiZSBtb2RpZmllZFxuICBpZiAoIS9eZnVuY3Rpb24vLnRlc3Qoc3RyKSAmJiAvXlxcdytcXHMqXFwoLy50ZXN0KHN0cikpIHtcbiAgICBzdHIgPSAnZnVuY3Rpb24gJyArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cblxuZnVuY3Rpb24gZ2V0V29ya2VyKHdvcmtlcklkKSB7XG4gIHZhciB3b3JrZXIgPSB3b3JrZXJzW3dvcmtlcklkXTtcbiAgaWYgKCF3b3JrZXIpIHtcbiAgICAvLyBCb290c3RyYXAgdGhlIHdvcmtlcidzIGNvbnRlbnRcbiAgICB2YXIgYm9vdHN0cmFwID0gc3RyaW5naWZ5RnVuY3Rpb24od29ya2VyQm9vdHN0cmFwKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgd29ya2VyIGZyb20gdGhlIGJvb3RzdHJhcCBmdW5jdGlvbiBjb250ZW50XG4gICAgd29ya2VyID0gd29ya2Vyc1t3b3JrZXJJZF0gPSBuZXcgV29ya2VyKFxuICAgICAgVVJMLmNyZWF0ZU9iamVjdFVSTChcbiAgICAgICAgbmV3IEJsb2IoXG4gICAgICAgICAgWyhcIi8qKiBXb3JrZXIgTW9kdWxlIEJvb3RzdHJhcDogXCIgKyAod29ya2VySWQucmVwbGFjZSgvXFwqL2csICcnKSkgKyBcIiAqKi9cXG5cXG47KFwiICsgYm9vdHN0cmFwICsgXCIpKClcIildLFxuICAgICAgICAgIHt0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCd9XG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gU2luZ2xlIGhhbmRsZXIgZm9yIHJlc3BvbnNlIG1lc3NhZ2VzIGZyb20gdGhlIHdvcmtlclxuICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHJlc3BvbnNlID0gZS5kYXRhO1xuICAgICAgdmFyIG1zZ0lkID0gcmVzcG9uc2UubWVzc2FnZUlkO1xuICAgICAgdmFyIGNhbGxiYWNrID0gb3BlblJlcXVlc3RzW21zZ0lkXTtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXJNb2R1bGUgcmVzcG9uc2Ugd2l0aCBlbXB0eSBvciB1bmtub3duIG1lc3NhZ2VJZCcpXG4gICAgICB9XG4gICAgICBkZWxldGUgb3BlblJlcXVlc3RzW21zZ0lkXTtcbiAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3b3JrZXJcbn1cblxuLy8gSXNzdWUgYSBjYWxsIHRvIHRoZSB3b3JrZXIgd2l0aCBhIGNhbGxiYWNrIHRvIGhhbmRsZSB0aGUgcmVzcG9uc2VcbmZ1bmN0aW9uIGNhbGxXb3JrZXIod29ya2VySWQsIGFjdGlvbiwgZGF0YSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBtZXNzYWdlSWQgPSArK19tZXNzYWdlSWQ7XG4gICAgb3BlblJlcXVlc3RzW21lc3NhZ2VJZF0gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoKFwiRXJyb3IgaW4gd29ya2VyIFwiICsgYWN0aW9uICsgXCIgY2FsbDogXCIgKyAocmVzcG9uc2UuZXJyb3IpKSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgZ2V0V29ya2VyKHdvcmtlcklkKS5wb3N0TWVzc2FnZSh7XG4gICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCxcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9KVxufVxuXG5leHBvcnQgeyBkZWZpbmVXb3JrZXJNb2R1bGUsIHN0cmluZ2lmeUZ1bmN0aW9uLCB0ZXJtaW5hdGVXb3JrZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/bidi-js/dist/bidi.mjs":
/*!********************************************!*\
  !*** ./node_modules/bidi-js/dist/bidi.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nfunction bidiFactory() {\nvar bidi = (function (exports) {\n\n  // Bidi character types data, auto generated\n  var DATA = {\n    \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n    \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n    \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n    \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n    \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n    \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n    \"B\": \"a,3,f+2,2v,690\",\n    \"S\": \"9,2,k\",\n    \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n    \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n    \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n    \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n    \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n    \"LRO\": \"6ct\",\n    \"RLO\": \"6cu\",\n    \"LRE\": \"6cq\",\n    \"RLE\": \"6cr\",\n    \"PDF\": \"6cs\",\n    \"LRI\": \"6ee\",\n    \"RLI\": \"6ef\",\n    \"FSI\": \"6eg\",\n    \"PDI\": \"6eh\"\n  };\n\n  var TYPES = {};\n  var TYPES_TO_NAMES = {};\n  TYPES.L = 1; //L is the default\n  TYPES_TO_NAMES[1] = 'L';\n  Object.keys(DATA).forEach(function (type, i) {\n    TYPES[type] = 1 << (i + 1);\n    TYPES_TO_NAMES[TYPES[type]] = type;\n  });\n  Object.freeze(TYPES);\n\n  var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n  var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n  var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n  var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n  var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n\n  var map = null;\n\n  function parseData () {\n    if (!map) {\n      //const start = performance.now()\n      map = new Map();\n      var loop = function ( type ) {\n        if (DATA.hasOwnProperty(type)) {\n          var lastCode = 0;\n          DATA[type].split(',').forEach(function (range) {\n            var ref = range.split('+');\n            var skip = ref[0];\n            var step = ref[1];\n            skip = parseInt(skip, 36);\n            step = step ? parseInt(step, 36) : 0;\n            map.set(lastCode += skip, TYPES[type]);\n            for (var i = 0; i < step; i++) {\n              map.set(++lastCode, TYPES[type]);\n            }\n          });\n        }\n      };\n\n      for (var type in DATA) loop( type );\n      //console.log(`char types parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  /**\n   * @param {string} char\n   * @return {number}\n   */\n  function getBidiCharType (char) {\n    parseData();\n    return map.get(char.codePointAt(0)) || TYPES.L\n  }\n\n  function getBidiCharTypeName(char) {\n    return TYPES_TO_NAMES[getBidiCharType(char)]\n  }\n\n  // Bidi bracket pairs data, auto generated\n  var data$1 = {\n    \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n    \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n  };\n\n  /**\n   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n   * @param {string} encodedString\n   * @param {boolean} includeReverse - true if you want reverseMap in the output\n   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n   */\n  function parseCharacterMap (encodedString, includeReverse) {\n    var radix = 36;\n    var lastCode = 0;\n    var map = new Map();\n    var reverseMap = includeReverse && new Map();\n    var prevPair;\n    encodedString.split(',').forEach(function visit(entry) {\n      if (entry.indexOf('+') !== -1) {\n        for (var i = +entry; i--;) {\n          visit(prevPair);\n        }\n      } else {\n        prevPair = entry;\n        var ref = entry.split('>');\n        var a = ref[0];\n        var b = ref[1];\n        a = String.fromCodePoint(lastCode += parseInt(a, radix));\n        b = String.fromCodePoint(lastCode += parseInt(b, radix));\n        map.set(a, b);\n        includeReverse && reverseMap.set(b, a);\n      }\n    });\n    return { map: map, reverseMap: reverseMap }\n  }\n\n  var openToClose, closeToOpen, canonical;\n\n  function parse$1 () {\n    if (!openToClose) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data$1.pairs, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      openToClose = map;\n      closeToOpen = reverseMap;\n      canonical = parseCharacterMap(data$1.canonical, false).map;\n      //console.log(`brackets parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function openingToClosingBracket (char) {\n    parse$1();\n    return openToClose.get(char) || null\n  }\n\n  function closingToOpeningBracket (char) {\n    parse$1();\n    return closeToOpen.get(char) || null\n  }\n\n  function getCanonicalBracket (char) {\n    parse$1();\n    return canonical.get(char) || null\n  }\n\n  // Local type aliases\n  var TYPE_L = TYPES.L;\n  var TYPE_R = TYPES.R;\n  var TYPE_EN = TYPES.EN;\n  var TYPE_ES = TYPES.ES;\n  var TYPE_ET = TYPES.ET;\n  var TYPE_AN = TYPES.AN;\n  var TYPE_CS = TYPES.CS;\n  var TYPE_B = TYPES.B;\n  var TYPE_S = TYPES.S;\n  var TYPE_ON = TYPES.ON;\n  var TYPE_BN = TYPES.BN;\n  var TYPE_NSM = TYPES.NSM;\n  var TYPE_AL = TYPES.AL;\n  var TYPE_LRO = TYPES.LRO;\n  var TYPE_RLO = TYPES.RLO;\n  var TYPE_LRE = TYPES.LRE;\n  var TYPE_RLE = TYPES.RLE;\n  var TYPE_PDF = TYPES.PDF;\n  var TYPE_LRI = TYPES.LRI;\n  var TYPE_RLI = TYPES.RLI;\n  var TYPE_FSI = TYPES.FSI;\n  var TYPE_PDI = TYPES.PDI;\n\n  /**\n   * @typedef {object} GetEmbeddingLevelsResult\n   * @property {{start, end, level}[]} paragraphs\n   * @property {Uint8Array} levels\n   */\n\n  /**\n   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n   * base embedding level.\n   *\n   * @param {string} string - The input string\n   * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n   *        otherwise a direction will be chosen automatically from each paragraph's contents.\n   * @return {GetEmbeddingLevelsResult}\n   */\n  function getEmbeddingLevels (string, baseDirection) {\n    var MAX_DEPTH = 125;\n\n    // Start by mapping all characters to their unicode type, as a bitmask integer\n    var charTypes = new Uint32Array(string.length);\n    for (var i = 0; i < string.length; i++) {\n      charTypes[i] = getBidiCharType(string[i]);\n    }\n\n    var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n    function changeCharType(i, type) {\n      var oldType = charTypes[i];\n      charTypes[i] = type;\n      charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n      if (oldType & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n      }\n      charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n      if (type & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n      }\n    }\n\n    var embedLevels = new Uint8Array(string.length);\n    var isolationPairs = new Map(); //init->pdi and pdi->init\n\n    // === 3.3.1 The Paragraph Level ===\n    // 3.3.1 P1: Split the text into paragraphs\n    var paragraphs = []; // [{start, end, level}, ...]\n    var paragraph = null;\n    for (var i$1 = 0; i$1 < string.length; i$1++) {\n      if (!paragraph) {\n        paragraphs.push(paragraph = {\n          start: i$1,\n          end: string.length - 1,\n          // 3.3.1 P2-P3: Determine the paragraph level\n          level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n        });\n      }\n      if (charTypes[i$1] & TYPE_B) {\n        paragraph.end = i$1;\n        paragraph = null;\n      }\n    }\n\n    var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n    var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };\n    var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };\n\n    // Everything from here on will operate per paragraph.\n    for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n      paragraph = paragraphs[paraIdx];\n      var statusStack = [{\n        _level: paragraph.level,\n        _override: 0, //0=neutral, 1=L, 2=R\n        _isolate: 0 //bool\n      }];\n      var stackTop = (void 0);\n      var overflowIsolateCount = 0;\n      var overflowEmbeddingCount = 0;\n      var validIsolateCount = 0;\n      charTypeCounts.clear();\n\n      // === 3.3.2 Explicit Levels and Directions ===\n      for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n        var charType = charTypes[i$2];\n        stackTop = statusStack[statusStack.length - 1];\n\n        // Set initial counts\n        charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n        if (charType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n\n        // Explicit Embeddings: 3.3.2 X2 - X3\n        if (charType & FORMATTING_TYPES) { //prefilter all formatters\n          if (charType & (TYPE_RLE | TYPE_LRE)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level,\n                _override: 0,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Explicit Overrides: 3.3.2 X4 - X5\n          else if (charType & (TYPE_RLO | TYPE_LRO)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level$1,\n                _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Isolates: 3.3.2 X5a - X5c\n          else if (charType & ISOLATE_INIT_TYPES) {\n            // X5c - FSI becomes either RLI or LRI\n            if (charType & TYPE_FSI) {\n              charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n            }\n\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n              validIsolateCount++;\n              statusStack.push({\n                _level: level$2,\n                _override: 0,\n                _isolate: 1,\n                _isolInitIndex: i$2\n              });\n            } else {\n              overflowIsolateCount++;\n            }\n          }\n\n          // Terminating Isolates: 3.3.2 X6a\n          else if (charType & TYPE_PDI) {\n            if (overflowIsolateCount > 0) {\n              overflowIsolateCount--;\n            } else if (validIsolateCount > 0) {\n              overflowEmbeddingCount = 0;\n              while (!statusStack[statusStack.length - 1]._isolate) {\n                statusStack.pop();\n              }\n              // Add to isolation pairs bidirectional mapping:\n              var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n              if (isolInitIndex != null) {\n                isolationPairs.set(isolInitIndex, i$2);\n                isolationPairs.set(i$2, isolInitIndex);\n              }\n              statusStack.pop();\n              validIsolateCount--;\n            }\n            stackTop = statusStack[statusStack.length - 1];\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n          }\n\n\n          // Terminating Embeddings and Overrides: 3.3.2 X7\n          else if (charType & TYPE_PDF) {\n            if (overflowIsolateCount === 0) {\n              if (overflowEmbeddingCount > 0) {\n                overflowEmbeddingCount--;\n              } else if (!stackTop._isolate && statusStack.length > 1) {\n                statusStack.pop();\n                stackTop = statusStack[statusStack.length - 1];\n              }\n            }\n            embedLevels[i$2] = stackTop._level; // 5.2\n          }\n\n          // End of Paragraph: 3.3.2 X8\n          else if (charType & TYPE_B) {\n            embedLevels[i$2] = paragraph.level;\n          }\n        }\n\n        // Non-formatting characters: 3.3.2 X6\n        else {\n          embedLevels[i$2] = stackTop._level;\n          // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n          if (stackTop._override && charType !== TYPE_BN) {\n            changeCharType(i$2, stackTop._override);\n          }\n        }\n      }\n\n      // === 3.3.3 Preparations for Implicit Processing ===\n\n      // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n      // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n      // easily ignore them all from here on out.\n\n      // 3.3.3 X10\n      // Compute the set of isolating run sequences as specified by BD13\n      var levelRuns = [];\n      var currentRun = null;\n      for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n        var charType$1 = charTypes[i$3];\n        if (!(charType$1 & BN_LIKE_TYPES)) {\n          var lvl = embedLevels[i$3];\n          var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n          var isPDI = charType$1 === TYPE_PDI;\n          if (currentRun && lvl === currentRun._level) {\n            currentRun._end = i$3;\n            currentRun._endsWithIsolInit = isIsolInit;\n          } else {\n            levelRuns.push(currentRun = {\n              _start: i$3,\n              _end: i$3,\n              _level: lvl,\n              _startsWithPDI: isPDI,\n              _endsWithIsolInit: isIsolInit\n            });\n          }\n        }\n      }\n      var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n      for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n        var run = levelRuns[runIdx];\n        if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {\n          var seqRuns = [currentRun = run];\n          for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n            for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n              if (levelRuns[i$4]._start === pdiIndex) {\n                seqRuns.push(currentRun = levelRuns[i$4]);\n                break\n              }\n            }\n          }\n          // build flat list of indices across all runs:\n          var seqIndices = [];\n          for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n            var run$1 = seqRuns[i$5];\n            for (var j = run$1._start; j <= run$1._end; j++) {\n              seqIndices.push(j);\n            }\n          }\n          // determine the sos/eos types:\n          var firstLevel = embedLevels[seqIndices[0]];\n          var prevLevel = paragraph.level;\n          for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n            if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2\n              prevLevel = embedLevels[i$6];\n              break\n            }\n          }\n          var lastIndex = seqIndices[seqIndices.length - 1];\n          var lastLevel = embedLevels[lastIndex];\n          var nextLevel = paragraph.level;\n          if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n            for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n              if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2\n                nextLevel = embedLevels[i$7];\n                break\n              }\n            }\n          }\n          isolatingRunSeqs.push({\n            _seqIndices: seqIndices,\n            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n          });\n        }\n      }\n\n      // The next steps are done per isolating run sequence\n      for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n        var ref = isolatingRunSeqs[seqIdx];\n        var seqIndices$1 = ref._seqIndices;\n        var sosType = ref._sosType;\n        var eosType = ref._eosType;\n        /**\n         * All the level runs in an isolating run sequence have the same embedding level.\n         * \n         * DO NOT change any `embedLevels[i]` within the current scope.\n         */\n        var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;\n\n        // === 3.3.4 Resolving Weak Types ===\n\n        // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n        // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n        // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n        if (charTypeCounts.get(TYPE_NSM)) {\n          for (var si = 0; si < seqIndices$1.length; si++) {\n            var i$8 = seqIndices$1[si];\n            if (charTypes[i$8] & TYPE_NSM) {\n              var prevType = sosType;\n              for (var sj = si - 1; sj >= 0; sj--) {\n                if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN\n                  prevType = charTypes[seqIndices$1[sj]];\n                  break\n                }\n              }\n              changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);\n            }\n          }\n        }\n\n        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n        // is found. If an AL is found, change the type of the European number to Arabic number.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n            var i$9 = seqIndices$1[si$1];\n            if (charTypes[i$9] & TYPE_EN) {\n              for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n                if (prevCharType & STRONG_TYPES) {\n                  if (prevCharType === TYPE_AL) {\n                    changeCharType(i$9, TYPE_AN);\n                  }\n                  break\n                }\n              }\n            }\n          }\n        }\n\n        // W3. Change all ALs to R\n        if (charTypeCounts.get(TYPE_AL)) {\n          for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n            var i$10 = seqIndices$1[si$2];\n            if (charTypes[i$10] & TYPE_AL) {\n              changeCharType(i$10, TYPE_R);\n            }\n          }\n        }\n\n        // W4. A single European separator between two European numbers changes to a European number. A single common\n        // separator between two numbers of the same type changes to that type.\n        if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n            var i$11 = seqIndices$1[si$3];\n            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n              var prevType$1 = 0, nextType = 0;\n              for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                prevType$1 = charTypes[seqIndices$1[sj$2]];\n                if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                nextType = charTypes[seqIndices$1[sj$3]];\n                if (!(nextType & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {\n                changeCharType(i$11, prevType$1);\n              }\n            }\n          }\n        }\n\n        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n            var i$12 = seqIndices$1[si$4];\n            if (charTypes[i$12] & TYPE_EN) {\n              for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {\n                changeCharType(seqIndices$1[sj$4], TYPE_EN);\n              }\n              for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {\n                if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {\n                  changeCharType(seqIndices$1[si$4], TYPE_EN);\n                }\n              }\n            }\n          }\n        }\n\n        // W6. Otherwise, separators and terminators change to Other Neutral.\n        if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n            var i$13 = seqIndices$1[si$5];\n            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n              changeCharType(i$13, TYPE_ON);\n              // 5.2 transform adjacent BNs too:\n              for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {\n                changeCharType(seqIndices$1[sj$5], TYPE_ON);\n              }\n              for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {\n                changeCharType(seqIndices$1[sj$6], TYPE_ON);\n              }\n            }\n          }\n        }\n\n        // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n        // is found. If an L is found, then change the type of the European number to L.\n        // NOTE: implemented in single forward pass for efficiency\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n            var i$14 = seqIndices$1[si$6];\n            var type = charTypes[i$14];\n            if (type & TYPE_EN) {\n              if (prevStrongType === TYPE_L) {\n                changeCharType(i$14, TYPE_L);\n              }\n            } else if (type & STRONG_TYPES) {\n              prevStrongType = type;\n            }\n          }\n        }\n\n        // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n        if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n          // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n          // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n          // types EN and AN are treated as R.\n          var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);\n          var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n          // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n          var bracketPairs = [];\n          {\n            var openerStack = [];\n            for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n              // NOTE: for any potential bracket character we also test that it still carries a NI\n              // type, as that may have been changed earlier. This doesn't seem to be explicitly\n              // called out in the spec, but is required for passage of certain tests.\n              if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                var char = string[seqIndices$1[si$7]];\n                var oppositeBracket = (void 0);\n                // Opening bracket\n                if (openingToClosingBracket(char) !== null) {\n                  if (openerStack.length < 63) {\n                    openerStack.push({ char: char, seqIndex: si$7 });\n                  } else {\n                    break\n                  }\n                }\n                // Closing bracket\n                else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                  for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                    var stackChar = openerStack[stackIdx].char;\n                    if (stackChar === oppositeBracket ||\n                      stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||\n                      openingToClosingBracket(getCanonicalBracket(stackChar)) === char\n                    ) {\n                      bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                      openerStack.length = stackIdx; //pop the matching bracket and all following\n                      break\n                    }\n                  }\n                }\n              }\n            }\n            bracketPairs.sort(function (a, b) { return a[0] - b[0]; });\n          }\n          // * For each bracket-pair element in the list of pairs of text positions\n          for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n            var ref$1 = bracketPairs[pairIdx];\n            var openSeqIdx = ref$1[0];\n            var closeSeqIdx = ref$1[1];\n            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n            // brackets in the pair to match the embedding direction.\n            var foundStrongType = false;\n            var useStrongType = 0;\n            for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n              var i$15 = seqIndices$1[si$8];\n              if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                foundStrongType = true;\n                var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                if (lr === embedDirection) {\n                  useStrongType = lr;\n                  break\n                }\n              }\n            }\n            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n            // for an established context with a preceding strong type by checking backwards before the opening paired\n            // bracket until the first strong type (L, R, or sos) is found.\n            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n            //    set the type for both brackets in the pair to that direction.\n            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n            if (foundStrongType && !useStrongType) {\n              useStrongType = sosType;\n              for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                var i$16 = seqIndices$1[si$9];\n                if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                  var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  if (lr$1 !== embedDirection) {\n                    useStrongType = lr$1;\n                  } else {\n                    useStrongType = embedDirection;\n                  }\n                  break\n                }\n              }\n            }\n            if (useStrongType) {\n              charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;\n              // * Any number of characters that had original bidirectional character type NSM prior to the application\n              // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n              // the type of their preceding bracket.\n              if (useStrongType !== embedDirection) {\n                for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                  if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$10]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n              if (useStrongType !== embedDirection) {\n                for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                  if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$11]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n            }\n          }\n\n          // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n          // same direction.\n          // N2. Any remaining NIs take the embedding direction.\n          for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n              var niRunStart = si$12, niRunEnd = si$12;\n              var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n              for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                  niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                } else {\n                  prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              var nextType$1 = eosType;\n              for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                  niRunEnd = si2$1;\n                } else {\n                  nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {\n                charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;\n              }\n              si$12 = niRunEnd;\n            }\n          }\n        }\n      }\n\n      // === 3.3.6 Resolving Implicit Levels ===\n\n      for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n        var level$3 = embedLevels[i$17];\n        var type$1 = charTypes[i$17];\n        // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n        if (level$3 & 1) {\n          if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n            embedLevels[i$17]++;\n          }\n        }\n          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n        // and those of type AN or EN go up two levels.\n        else {\n          if (type$1 & TYPE_R) {\n            embedLevels[i$17]++;\n          } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n            embedLevels[i$17] += 2;\n          }\n        }\n\n        // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n        // and otherwise to the base level.\n        if (type$1 & BN_LIKE_TYPES) {\n          embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n        }\n\n        // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n        // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n        // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n        if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n          for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {\n            embedLevels[j$1] = paragraph.level;\n          }\n        }\n      }\n    }\n\n    // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n    // according to section 3.4 Reordering Resolved Levels\n    return {\n      levels: embedLevels,\n      paragraphs: paragraphs\n    }\n\n    function determineAutoEmbedLevel (start, isFSI) {\n      // 3.3.1 P2 - P3\n      for (var i = start; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & (TYPE_R | TYPE_AL)) {\n          return 1\n        }\n        if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {\n          return 0\n        }\n        if (charType & ISOLATE_INIT_TYPES) {\n          var pdi = indexOfMatchingPDI(i);\n          i = pdi === -1 ? string.length : pdi;\n        }\n      }\n      return 0\n    }\n\n    function indexOfMatchingPDI (isolateStart) {\n      // 3.1.2 BD9\n      var isolationLevel = 1;\n      for (var i = isolateStart + 1; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & TYPE_B) {\n          break\n        }\n        if (charType & TYPE_PDI) {\n          if (--isolationLevel === 0) {\n            return i\n          }\n        } else if (charType & ISOLATE_INIT_TYPES) {\n          isolationLevel++;\n        }\n      }\n      return -1\n    }\n  }\n\n  // Bidi mirrored chars data, auto generated\n  var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n\n  var mirrorMap;\n\n  function parse () {\n    if (!mirrorMap) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      // Combine both maps into one\n      reverseMap.forEach(function (value, key) {\n        map.set(key, value);\n      });\n      mirrorMap = map;\n      //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function getMirroredCharacter (char) {\n    parse();\n    return mirrorMap.get(char) || null\n  }\n\n  /**\n   * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n   * for any characters in right-to-left segments that have defined mirrored characters.\n   * @param string\n   * @param embeddingLevels\n   * @param [start]\n   * @param [end]\n   * @return {Map<number, string>}\n   */\n  function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var map = new Map();\n    for (var i = start; i <= end; i++) {\n      if (embeddingLevels[i] & 1) { //only odd (rtl) levels\n        var mirror = getMirroredCharacter(string[i]);\n        if (mirror !== null) {\n          map.set(i, mirror);\n        }\n      }\n    }\n    return map\n  }\n\n  /**\n   * Given a start and end denoting a single line within a string, and a set of precalculated\n   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n   * @param {string} string - the full input string\n   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n   * @param {number} [start] - first character in a subset of the full string\n   * @param {number} [end] - last character in a subset of the full string\n   * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n   */\n  function getReorderSegments(string, embeddingLevelsResult, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var segments = [];\n    embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n      var lineStart = Math.max(start, paragraph.start);\n      var lineEnd = Math.min(end, paragraph.end);\n      if (lineStart < lineEnd) {\n        // Local slice for mutation\n        var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);\n\n        // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n        // end of the line to the paragraph level.\n        for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {\n          lineLevels[i] = paragraph.level;\n        }\n\n        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n        // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n        var maxLevel = paragraph.level;\n        var minOddLevel = Infinity;\n        for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n          var level = lineLevels[i$1];\n          if (level > maxLevel) { maxLevel = level; }\n          if (level < minOddLevel) { minOddLevel = level | 1; }\n        }\n        for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n          for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n            if (lineLevels[i$2] >= lvl) {\n              var segStart = i$2;\n              while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                i$2++;\n              }\n              if (i$2 > segStart) {\n                segments.push([segStart + lineStart, i$2 + lineStart]);\n              }\n            }\n          }\n        }\n      }\n    });\n    return segments\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {string} the new string with bidi segments reordered\n   */\n  function getReorderedString(string, embedLevelsResult, start, end) {\n    var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n    var chars = [].concat( string );\n    indices.forEach(function (charIndex, i) {\n      chars[i] = (\n        (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null\n      ) || string[charIndex];\n    });\n    return chars.join('')\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {number[]} an array with character indices in their new bidi order\n   */\n  function getReorderedIndices(string, embedLevelsResult, start, end) {\n    var segments = getReorderSegments(string, embedLevelsResult, start, end);\n    // Fill an array with indices\n    var indices = [];\n    for (var i = 0; i < string.length; i++) {\n      indices[i] = i;\n    }\n    // Reverse each segment in order\n    segments.forEach(function (ref) {\n      var start = ref[0];\n      var end = ref[1];\n\n      var slice = indices.slice(start, end + 1);\n      for (var i = slice.length; i--;) {\n        indices[end - i] = slice[i];\n      }\n    });\n    return indices\n  }\n\n  exports.closingToOpeningBracket = closingToOpeningBracket;\n  exports.getBidiCharType = getBidiCharType;\n  exports.getBidiCharTypeName = getBidiCharTypeName;\n  exports.getCanonicalBracket = getCanonicalBracket;\n  exports.getEmbeddingLevels = getEmbeddingLevels;\n  exports.getMirroredCharacter = getMirroredCharacter;\n  exports.getMirroredCharactersMap = getMirroredCharactersMap;\n  exports.getReorderSegments = getReorderSegments;\n  exports.getReorderedIndices = getReorderedIndices;\n  exports.getReorderedString = getReorderedString;\n  exports.openingToClosingBracket = openingToClosingBracket;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn bidi}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (bidiFactory);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iaWRpLWpzL2Rpc3QvYmlkaS5tanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsMEJBQTBCO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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RUEsK0RBQWUsV0FBVyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iaWRpLWpzL2Rpc3QvYmlkaS5tanM/MzdjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBiaWRpRmFjdG9yeSgpIHtcbnZhciBiaWRpID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgLy8gQmlkaSBjaGFyYWN0ZXIgdHlwZXMgZGF0YSwgYXV0byBnZW5lcmF0ZWRcbiAgdmFyIERBVEEgPSB7XG4gICAgXCJSXCI6IFwiMTNrLDFhLDIsMywzLDIrMWosY2grMTYsYSsxLDUrMiwyK24sNSxhLDQsNisxNiw0KzMsaCsxYiw0bW8sMTc5cSwyKzksMisxMSwyaTkrN3ksMis2OCw0LDMrNCw1KzEzLDQrMywyKzRrLDMrMjksOCtjZiwxdCs3eix3KzE3LDMrM20sMXQrM3osMTZvMSs1ciw4KzMwLDgrbWMsMjkrMXIsMjkrNHYsNzUrNzNcIixcbiAgICBcIkVOXCI6IFwiMWMrOSwzZCsxLDYsMTg3KzksNTEzLDQrNSw3Kzksc2YraiwxNzVoKzkscXcrcSwxNjFmKzFkLDR4dCthLDI1aSs5XCIsXG4gICAgXCJFU1wiOiBcIjE3LDIsNmRwKzEsZisxLGF2LDE2dnIsbXgrMSw0bywyXCIsXG4gICAgXCJFVFwiOiBcInorMiwzaCszLGIrMSx5bSwzZSsxLDJvLHA0KzEsOCw2dSw3YyxnNiwxd2MsMW45KzQsMzArMWIsMm4sNmQscWh4KzEsaDBtLGErMSw0OSsyLDYzKzEsNCsxLDZiYiszLDEyampcIixcbiAgICBcIkFOXCI6IFwiMTZvKzUsMmorOSwyKzEsMzUsZWQsMWZmMis5LDg3K3VcIixcbiAgICBcIkNTXCI6IFwiMTgsMisxLGIsMnUsMTJrLDU1dixsLDE3djAsMiwzLDUzLDIrMSxiXCIsXG4gICAgXCJCXCI6IFwiYSwzLGYrMiwydiw2OTBcIixcbiAgICBcIlNcIjogXCI5LDIsa1wiLFxuICAgIFwiV1NcIjogXCJjLGssNGY0LDF2aythLHUsMWosMzM1XCIsXG4gICAgXCJPTlwiOiBcIngrMSw0KzQsaCs1LHIrNSxyKzMseiw1KzMsMisxLDIrMSw1LDIrMiwzKzQsbyx3LGNpKzEsOCtkLDMrZCw2KzgsMitnLDM5KzEsOSw2KzEsMiwzMyxiOCwzKzEsM2MrMSw3KzEsNXIsYiw3aCszLHNhKzUsMiwzaSs2LGpnKzMsdXIrOSwydixpaisxLDlnKzksNythLDhtLDQrMSw0OSt4LDE0dSwyKzIsYysyLGUrMixlKzIsZSsxLGkrbixlK2UsMitwLHUrMixlKzIsMzYrMSwyKzMsMisxLGIsMisyLDYrNSwyLDIsMixoKzEsNSs0LDYrMywzK2YsMTYrMiw1KzNsLDMrODEsMXkrcCwyKzQwLHErYSxtKzEzLDJyK2NoLDIrOWUsNzUraGYsMyt2LDIrMncsNmUrNSxmKzYsNzUrMmEsMWErcCwyKzJnLGQrNXgscitiLDYrMyw0K28sZyw2KzEsNisyLDJrKzEsNCwyaiw1aCt6LDFtKzEsMWUrZix0KzIsMWYrZSxkKzMsNG8rMywycysxLHcsNTM1KzFyLGgzbCsxaSw5MysyLDJzLGIrMSwzbCt4LDJ2LDRnKzMsMjErMyxreisxLGc1disxLDVhLGorOSxuK3YsMiwzLDIrOCwyKzEsMysyLDIsMyw0NisxLDQrNCxoKzUscis1LHIrYSwzaCsyLDQrNixiKzQsNzgsMXIrMjQsNCtjLDQsMWhiLGV5KzYsMTAzK2osMTZqK2MsMXV4KzcsNStnLGZzaCxqZHErMXQsNCw1NysyZSxwMSwxbSwxbSwxbSwxbSw0a3QrMSw3aisxNyw1KzJyLGQrZSwzK2UsMitlLDIrMTAsbSs0LHcsMW4rNSwxcSw0eis1LDRiK3JiLDkrYyw0K2MsNCszNyxkKzJnLDgrYixsK2IsNSsxaiw5KzksNysxMyw5K3QsMysxLDI3KzNjLDIrMjksMiszcSxkK2QsMys0LDQrMiw2KzYsYStvLDgrNixhKzIsZSs2LDE2KzQyLDIrMWlcIixcbiAgICBcIkJOXCI6IFwiMCs4LDYrZCwycys1LDIrcCxlLDRtOSwxa3QrMiwyYis1LDUrNSwxN3E5K3YsN2ssNnArOCw2KzEsMTE5ZCszLDQ0MCs3LDk2cysxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZis3NSw2cCsycnosMWJlbisxLDFla2YrMSwxZWtmKzFcIixcbiAgICBcIk5TTVwiOiBcImxjKzMzLDdvKzYsN2MrMTgsMiwyKzEsMisxLDIsMjErYSwxZCtrLGgsMnUrNiwzKzUsMysxLDIrMywxMCx2K3EsMmsrYSwxbis4LGEscCszLDIrOCwyKzIsMis0LDE4KzIsM2MrZSwyK3YsMWssMiw1KzcsNSw0KzYsYisxLHUsMW4sNSszLDksbCsxLHIsMysxLDFtLDUrMSw1KzEsMysyLDQsdisxLDQsYysxLDFtLDUrNCwyKzEsNSxsKzEsbis1LDIsMW4sMywyKzMsOSw4KzEsYysxLHYsMXEsZCwxZiw0LDFtKzIsNisyLDIrMyw4KzEsYysxLHUsMW4sZysxLGwrMSx0KzEsMW0rMSw1KzMsOSxsKzEsdSwyMSw4KzIsMiwyaiwzKzYsZCs3LDJyLDMrOCxjKzUsMjMrMSxzLDIsMiwxaytkLDIrNCwyKzEsNithLDIreixhLDJ2KzMsMis1LDIrMSwzKzEscSsxLDUrMixoKzMsZSwzKzEsNyxnLGprKzIscWIrMix1KzIsdSsxLHYrMSwxdCsxLDIrNiw5LDMrYSxhLDFhKzIsM2MrMSx6LDNiKzIsNSsxLGEsNysyLDY0KzEsMywxbiwyKzYsMiwyLDMrNyw3KzksMywxZCtnLDFzKzMsMWQsMis0LDIsNiwxNSs4LGQrMSx4KzMsMysxLDIrMiwxbCwyKzEsNCwyKzIsMW4rNywzKzEsNDkrMiwyK2MsMis2LDUsNyw0KzEsNWorMWwsMis0LGsxK3csMmRiKzIsM3ksMnArdixmZiszLDMwKzEsbjl4KzMsMis5LHgrMSwyOSsxLDdsLDQsNSxxKzEsNiw0OCsxLHIraCxlLDEzKzcscSthLDFiKzIsMWQsMyszLDMrMSwxNCwxdys1LDMrMSwzKzEsZCw5LDFjLDFnLDIrMiwzKzEsNisxLDIsMTcrMSw5LDZuLDMsNSxmbjUsa2krZixoK2YscjIsNmIsNDYrNCwxYWYrMiwyKzEsNiszLDE1KzIsNSw0bSsxLGZ5KzMsYXMrMSw0YSthLDR4LDFqK2UsMWwrMiwxZSszLDMrMSwxeSsyLDExKzQsMis3LDFyLGQrMSwxaCs4LGIrMywzLDJvKzIsMywyKzEsNyw0aCw0KzcsbSsxLDFtKzEsNCwxMis2LDQrNCw1Zys3LDMrMiwyLG8sMmQrNSwyLDUrMSwyKzEsNm4rMyw3KzEsMisxLHMrMSwyZSs3LDMsMisxLDJ6LDIsMys1LDIsMnUrMiwzKzMsMis0LDc4KzgsMisxLDc1KzEsMiw1LDQxKzMsMysxLDUseCs1LDMrMSwxNSs1LDMrMyw5LGErNSwzKzIsMWIrYywyKzEsYmIrNiwyKzUsMmQrbCwzKzYsMisxLDIrMSwzZis1LDQsMisxLDIrNiwyLDIxKzEsNCwyLDlvKzEsZjBjKzQsMW8rNix0NSwxcyszLDJhLGY1bCsxLDQzdCsyLGkrNywzKzYsdiszLDQ1KzIsMWowKzFpLDUrMWQsOSxmLG4rNCwyK2UsMTF0KzYsMitnLDMrNiwyKzEsMis0LDdhKzYsYzYrMywxNXQrNiwzMis2LGd6aHkrNm5cIixcbiAgICBcIkFMXCI6IFwiMTZ3LDMsMixlKzFiLHorMiwyKzJzLGcrMSw4KzEsYittLDIrdCxzKzJpLGMrZSw0aCtmLDFkKzFlLDFid2UrZHAsMyszeix4K2MsMisxLDM1KzN5LDJybSt6LDUrNyxiKzUsZHQrbCxjK3UsMTdubCsyNywxdCsyNyw0eCs2biwzK2RcIixcbiAgICBcIkxST1wiOiBcIjZjdFwiLFxuICAgIFwiUkxPXCI6IFwiNmN1XCIsXG4gICAgXCJMUkVcIjogXCI2Y3FcIixcbiAgICBcIlJMRVwiOiBcIjZjclwiLFxuICAgIFwiUERGXCI6IFwiNmNzXCIsXG4gICAgXCJMUklcIjogXCI2ZWVcIixcbiAgICBcIlJMSVwiOiBcIjZlZlwiLFxuICAgIFwiRlNJXCI6IFwiNmVnXCIsXG4gICAgXCJQRElcIjogXCI2ZWhcIlxuICB9O1xuXG4gIHZhciBUWVBFUyA9IHt9O1xuICB2YXIgVFlQRVNfVE9fTkFNRVMgPSB7fTtcbiAgVFlQRVMuTCA9IDE7IC8vTCBpcyB0aGUgZGVmYXVsdFxuICBUWVBFU19UT19OQU1FU1sxXSA9ICdMJztcbiAgT2JqZWN0LmtleXMoREFUQSkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgIFRZUEVTW3R5cGVdID0gMSA8PCAoaSArIDEpO1xuICAgIFRZUEVTX1RPX05BTUVTW1RZUEVTW3R5cGVdXSA9IHR5cGU7XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKFRZUEVTKTtcblxuICB2YXIgSVNPTEFURV9JTklUX1RZUEVTID0gVFlQRVMuTFJJIHwgVFlQRVMuUkxJIHwgVFlQRVMuRlNJO1xuICB2YXIgU1RST05HX1RZUEVTID0gVFlQRVMuTCB8IFRZUEVTLlIgfCBUWVBFUy5BTDtcbiAgdmFyIE5FVVRSQUxfSVNPTEFURV9UWVBFUyA9IFRZUEVTLkIgfCBUWVBFUy5TIHwgVFlQRVMuV1MgfCBUWVBFUy5PTiB8IFRZUEVTLkZTSSB8IFRZUEVTLkxSSSB8IFRZUEVTLlJMSSB8IFRZUEVTLlBESTtcbiAgdmFyIEJOX0xJS0VfVFlQRVMgPSBUWVBFUy5CTiB8IFRZUEVTLlJMRSB8IFRZUEVTLkxSRSB8IFRZUEVTLlJMTyB8IFRZUEVTLkxSTyB8IFRZUEVTLlBERjtcbiAgdmFyIFRSQUlMSU5HX1RZUEVTID0gVFlQRVMuUyB8IFRZUEVTLldTIHwgVFlQRVMuQiB8IElTT0xBVEVfSU5JVF9UWVBFUyB8IFRZUEVTLlBESSB8IEJOX0xJS0VfVFlQRVM7XG5cbiAgdmFyIG1hcCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcGFyc2VEYXRhICgpIHtcbiAgICBpZiAoIW1hcCkge1xuICAgICAgLy9jb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggdHlwZSApIHtcbiAgICAgICAgaWYgKERBVEEuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgICAgICB2YXIgbGFzdENvZGUgPSAwO1xuICAgICAgICAgIERBVEFbdHlwZV0uc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIHJlZiA9IHJhbmdlLnNwbGl0KCcrJyk7XG4gICAgICAgICAgICB2YXIgc2tpcCA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciBzdGVwID0gcmVmWzFdO1xuICAgICAgICAgICAgc2tpcCA9IHBhcnNlSW50KHNraXAsIDM2KTtcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwID8gcGFyc2VJbnQoc3RlcCwgMzYpIDogMDtcbiAgICAgICAgICAgIG1hcC5zZXQobGFzdENvZGUgKz0gc2tpcCwgVFlQRVNbdHlwZV0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwOyBpKyspIHtcbiAgICAgICAgICAgICAgbWFwLnNldCgrK2xhc3RDb2RlLCBUWVBFU1t0eXBlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHR5cGUgaW4gREFUQSkgbG9vcCggdHlwZSApO1xuICAgICAgLy9jb25zb2xlLmxvZyhgY2hhciB0eXBlcyBwYXJzZWQgaW4gJHtwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0fW1zYClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QmlkaUNoYXJUeXBlIChjaGFyKSB7XG4gICAgcGFyc2VEYXRhKCk7XG4gICAgcmV0dXJuIG1hcC5nZXQoY2hhci5jb2RlUG9pbnRBdCgwKSkgfHwgVFlQRVMuTFxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmlkaUNoYXJUeXBlTmFtZShjaGFyKSB7XG4gICAgcmV0dXJuIFRZUEVTX1RPX05BTUVTW2dldEJpZGlDaGFyVHlwZShjaGFyKV1cbiAgfVxuXG4gIC8vIEJpZGkgYnJhY2tldCBwYWlycyBkYXRhLCBhdXRvIGdlbmVyYXRlZFxuICB2YXIgZGF0YSQxID0ge1xuICAgIFwicGFpcnNcIjogXCIxND4xLDFlPjIsdT4yLDJ3dD4xLDE+MSwxZ2U+MSwxd3A+MSwxaj4xLGY+MSxobT4xLDE+MSx1PjEsdTY+MSwxPjEsKzUsMjg+MSx3PjEsMT4xLCszLGI4PjEsMT4xLCszLDE+MywtMT4tMSwzPjEsMT4xLCsyLDFzPjEsMT4xLHg+MSx0aD4xLDE+MSwrMixkYj4xLDE+MSwrMywzPjEsMT4xLCsyLDE0cW0+MSwxPjEsKzEsNHE+MSwxZT4yLHU+MiwyPjEsKzFcIixcbiAgICBcImNhbm9uaWNhbFwiOiBcIjZmMT4tNmR4LDZkeT4tNmR4LDZlYz4tNmVkLDZlZT4tNmVkLDZ3dz4yamosLTJqaT4yamosMTRyND4tMWU3bCwxZTdtPi0xZTdsLDFlN20+LTFlNWMsMWU1ZD4tMWU1YiwxZTVjPi0xNHF4LDE0cXk+LTE0cXgsMTR2bj4tMWVjZywxZWNoPi0xZWNnLDFlZHU+LTFlY2csMWVjaT4tMWVjZywxZWRhPi0xZWNnLDFlY2k+LTFlY2csMWVjaT4tMTY4cSwxNjhyPi0xNjhxLDE2OHM+LTE0eWUsMTR5Zj4tMTR5ZVwiXG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBzdHJpbmcgdGhhdCBob2xkcyBlbmNvZGVkIGNvZGVwb2ludCBtYXBwaW5ncywgZS5nLiBmb3IgYnJhY2tldCBwYWlycyBvclxuICAgKiBtaXJyb3JpbmcgY2hhcmFjdGVycywgYXMgZW5jb2RlZCBieSBzY3JpcHRzL2dlbmVyYXRlQmlkaURhdGEuanMuIFJldHVybnMgYW4gb2JqZWN0XG4gICAqIGhvbGRpbmcgdGhlIGBtYXBgLCBhbmQgb3B0aW9uYWxseSBhIGByZXZlcnNlTWFwYCBpZiBgaW5jbHVkZVJldmVyc2U6dHJ1ZWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGVkU3RyaW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZVJldmVyc2UgLSB0cnVlIGlmIHlvdSB3YW50IHJldmVyc2VNYXAgaW4gdGhlIG91dHB1dFxuICAgKiBAcmV0dXJuIHt7bWFwOiBNYXA8bnVtYmVyLCBudW1iZXI+LCByZXZlcnNlTWFwPzogTWFwPG51bWJlciwgbnVtYmVyPn19XG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUNoYXJhY3Rlck1hcCAoZW5jb2RlZFN0cmluZywgaW5jbHVkZVJldmVyc2UpIHtcbiAgICB2YXIgcmFkaXggPSAzNjtcbiAgICB2YXIgbGFzdENvZGUgPSAwO1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgdmFyIHJldmVyc2VNYXAgPSBpbmNsdWRlUmV2ZXJzZSAmJiBuZXcgTWFwKCk7XG4gICAgdmFyIHByZXZQYWlyO1xuICAgIGVuY29kZWRTdHJpbmcuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIHZpc2l0KGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkuaW5kZXhPZignKycpICE9PSAtMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gK2VudHJ5OyBpLS07KSB7XG4gICAgICAgICAgdmlzaXQocHJldlBhaXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2UGFpciA9IGVudHJ5O1xuICAgICAgICB2YXIgcmVmID0gZW50cnkuc3BsaXQoJz4nKTtcbiAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgIHZhciBiID0gcmVmWzFdO1xuICAgICAgICBhID0gU3RyaW5nLmZyb21Db2RlUG9pbnQobGFzdENvZGUgKz0gcGFyc2VJbnQoYSwgcmFkaXgpKTtcbiAgICAgICAgYiA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGxhc3RDb2RlICs9IHBhcnNlSW50KGIsIHJhZGl4KSk7XG4gICAgICAgIG1hcC5zZXQoYSwgYik7XG4gICAgICAgIGluY2x1ZGVSZXZlcnNlICYmIHJldmVyc2VNYXAuc2V0KGIsIGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IG1hcDogbWFwLCByZXZlcnNlTWFwOiByZXZlcnNlTWFwIH1cbiAgfVxuXG4gIHZhciBvcGVuVG9DbG9zZSwgY2xvc2VUb09wZW4sIGNhbm9uaWNhbDtcblxuICBmdW5jdGlvbiBwYXJzZSQxICgpIHtcbiAgICBpZiAoIW9wZW5Ub0Nsb3NlKSB7XG4gICAgICAvL2NvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIHZhciByZWYgPSBwYXJzZUNoYXJhY3Rlck1hcChkYXRhJDEucGFpcnMsIHRydWUpO1xuICAgICAgdmFyIG1hcCA9IHJlZi5tYXA7XG4gICAgICB2YXIgcmV2ZXJzZU1hcCA9IHJlZi5yZXZlcnNlTWFwO1xuICAgICAgb3BlblRvQ2xvc2UgPSBtYXA7XG4gICAgICBjbG9zZVRvT3BlbiA9IHJldmVyc2VNYXA7XG4gICAgICBjYW5vbmljYWwgPSBwYXJzZUNoYXJhY3Rlck1hcChkYXRhJDEuY2Fub25pY2FsLCBmYWxzZSkubWFwO1xuICAgICAgLy9jb25zb2xlLmxvZyhgYnJhY2tldHMgcGFyc2VkIGluICR7cGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydH1tc2ApXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQgKGNoYXIpIHtcbiAgICBwYXJzZSQxKCk7XG4gICAgcmV0dXJuIG9wZW5Ub0Nsb3NlLmdldChjaGFyKSB8fCBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldCAoY2hhcikge1xuICAgIHBhcnNlJDEoKTtcbiAgICByZXR1cm4gY2xvc2VUb09wZW4uZ2V0KGNoYXIpIHx8IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENhbm9uaWNhbEJyYWNrZXQgKGNoYXIpIHtcbiAgICBwYXJzZSQxKCk7XG4gICAgcmV0dXJuIGNhbm9uaWNhbC5nZXQoY2hhcikgfHwgbnVsbFxuICB9XG5cbiAgLy8gTG9jYWwgdHlwZSBhbGlhc2VzXG4gIHZhciBUWVBFX0wgPSBUWVBFUy5MO1xuICB2YXIgVFlQRV9SID0gVFlQRVMuUjtcbiAgdmFyIFRZUEVfRU4gPSBUWVBFUy5FTjtcbiAgdmFyIFRZUEVfRVMgPSBUWVBFUy5FUztcbiAgdmFyIFRZUEVfRVQgPSBUWVBFUy5FVDtcbiAgdmFyIFRZUEVfQU4gPSBUWVBFUy5BTjtcbiAgdmFyIFRZUEVfQ1MgPSBUWVBFUy5DUztcbiAgdmFyIFRZUEVfQiA9IFRZUEVTLkI7XG4gIHZhciBUWVBFX1MgPSBUWVBFUy5TO1xuICB2YXIgVFlQRV9PTiA9IFRZUEVTLk9OO1xuICB2YXIgVFlQRV9CTiA9IFRZUEVTLkJOO1xuICB2YXIgVFlQRV9OU00gPSBUWVBFUy5OU007XG4gIHZhciBUWVBFX0FMID0gVFlQRVMuQUw7XG4gIHZhciBUWVBFX0xSTyA9IFRZUEVTLkxSTztcbiAgdmFyIFRZUEVfUkxPID0gVFlQRVMuUkxPO1xuICB2YXIgVFlQRV9MUkUgPSBUWVBFUy5MUkU7XG4gIHZhciBUWVBFX1JMRSA9IFRZUEVTLlJMRTtcbiAgdmFyIFRZUEVfUERGID0gVFlQRVMuUERGO1xuICB2YXIgVFlQRV9MUkkgPSBUWVBFUy5MUkk7XG4gIHZhciBUWVBFX1JMSSA9IFRZUEVTLlJMSTtcbiAgdmFyIFRZUEVfRlNJID0gVFlQRVMuRlNJO1xuICB2YXIgVFlQRV9QREkgPSBUWVBFUy5QREk7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtvYmplY3R9IEdldEVtYmVkZGluZ0xldmVsc1Jlc3VsdFxuICAgKiBAcHJvcGVydHkge3tzdGFydCwgZW5kLCBsZXZlbH1bXX0gcGFyYWdyYXBoc1xuICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IGxldmVsc1xuICAgKi9cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhcHBsaWVzIHRoZSBCaWRpcmVjdGlvbmFsIEFsZ29yaXRobSB0byBhIHN0cmluZywgcmV0dXJuaW5nIHRoZSByZXNvbHZlZCBlbWJlZGRpbmcgbGV2ZWxzXG4gICAqIGluIGEgc2luZ2xlIFVpbnQ4QXJyYXkgcGx1cyBhIGxpc3Qgb2Ygb2JqZWN0cyBob2xkaW5nIGVhY2ggcGFyYWdyYXBoJ3Mgc3RhcnQgYW5kIGVuZCBpbmRpY2VzIGFuZCByZXNvbHZlZFxuICAgKiBiYXNlIGVtYmVkZGluZyBsZXZlbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBpbnB1dCBzdHJpbmdcbiAgICogQHBhcmFtIHtcImx0clwifFwicnRsXCJ8XCJhdXRvXCJ9IFtiYXNlRGlyZWN0aW9uXSAtIFVzZSBcImx0clwiIG9yIFwicnRsXCIgdG8gZm9yY2UgYSBiYXNlIHBhcmFncmFwaCBkaXJlY3Rpb24sXG4gICAqICAgICAgICBvdGhlcndpc2UgYSBkaXJlY3Rpb24gd2lsbCBiZSBjaG9zZW4gYXV0b21hdGljYWxseSBmcm9tIGVhY2ggcGFyYWdyYXBoJ3MgY29udGVudHMuXG4gICAqIEByZXR1cm4ge0dldEVtYmVkZGluZ0xldmVsc1Jlc3VsdH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEVtYmVkZGluZ0xldmVscyAoc3RyaW5nLCBiYXNlRGlyZWN0aW9uKSB7XG4gICAgdmFyIE1BWF9ERVBUSCA9IDEyNTtcblxuICAgIC8vIFN0YXJ0IGJ5IG1hcHBpbmcgYWxsIGNoYXJhY3RlcnMgdG8gdGhlaXIgdW5pY29kZSB0eXBlLCBhcyBhIGJpdG1hc2sgaW50ZWdlclxuICAgIHZhciBjaGFyVHlwZXMgPSBuZXcgVWludDMyQXJyYXkoc3RyaW5nLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJUeXBlc1tpXSA9IGdldEJpZGlDaGFyVHlwZShzdHJpbmdbaV0pO1xuICAgIH1cblxuICAgIHZhciBjaGFyVHlwZUNvdW50cyA9IG5ldyBNYXAoKTsgLy93aWxsIGJlIGNsZWFyZWQgYXQgc3RhcnQgb2YgZWFjaCBwYXJhZ3JhcGhcbiAgICBmdW5jdGlvbiBjaGFuZ2VDaGFyVHlwZShpLCB0eXBlKSB7XG4gICAgICB2YXIgb2xkVHlwZSA9IGNoYXJUeXBlc1tpXTtcbiAgICAgIGNoYXJUeXBlc1tpXSA9IHR5cGU7XG4gICAgICBjaGFyVHlwZUNvdW50cy5zZXQob2xkVHlwZSwgY2hhclR5cGVDb3VudHMuZ2V0KG9sZFR5cGUpIC0gMSk7XG4gICAgICBpZiAob2xkVHlwZSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICBjaGFyVHlwZUNvdW50cy5zZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTLCBjaGFyVHlwZUNvdW50cy5nZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTKSAtIDEpO1xuICAgICAgfVxuICAgICAgY2hhclR5cGVDb3VudHMuc2V0KHR5cGUsIChjaGFyVHlwZUNvdW50cy5nZXQodHlwZSkgfHwgMCkgKyAxKTtcbiAgICAgIGlmICh0eXBlICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgIGNoYXJUeXBlQ291bnRzLnNldChORVVUUkFMX0lTT0xBVEVfVFlQRVMsIChjaGFyVHlwZUNvdW50cy5nZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB8fCAwKSArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlbWJlZExldmVscyA9IG5ldyBVaW50OEFycmF5KHN0cmluZy5sZW5ndGgpO1xuICAgIHZhciBpc29sYXRpb25QYWlycyA9IG5ldyBNYXAoKTsgLy9pbml0LT5wZGkgYW5kIHBkaS0+aW5pdFxuXG4gICAgLy8gPT09IDMuMy4xIFRoZSBQYXJhZ3JhcGggTGV2ZWwgPT09XG4gICAgLy8gMy4zLjEgUDE6IFNwbGl0IHRoZSB0ZXh0IGludG8gcGFyYWdyYXBoc1xuICAgIHZhciBwYXJhZ3JhcGhzID0gW107IC8vIFt7c3RhcnQsIGVuZCwgbGV2ZWx9LCAuLi5dXG4gICAgdmFyIHBhcmFncmFwaCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc3RyaW5nLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgIGlmICghcGFyYWdyYXBoKSB7XG4gICAgICAgIHBhcmFncmFwaHMucHVzaChwYXJhZ3JhcGggPSB7XG4gICAgICAgICAgc3RhcnQ6IGkkMSxcbiAgICAgICAgICBlbmQ6IHN0cmluZy5sZW5ndGggLSAxLFxuICAgICAgICAgIC8vIDMuMy4xIFAyLVAzOiBEZXRlcm1pbmUgdGhlIHBhcmFncmFwaCBsZXZlbFxuICAgICAgICAgIGxldmVsOiBiYXNlRGlyZWN0aW9uID09PSAncnRsJyA/IDEgOiBiYXNlRGlyZWN0aW9uID09PSAnbHRyJyA/IDAgOiBkZXRlcm1pbmVBdXRvRW1iZWRMZXZlbChpJDEsIGZhbHNlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyVHlwZXNbaSQxXSAmIFRZUEVfQikge1xuICAgICAgICBwYXJhZ3JhcGguZW5kID0gaSQxO1xuICAgICAgICBwYXJhZ3JhcGggPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBGT1JNQVRUSU5HX1RZUEVTID0gVFlQRV9STEUgfCBUWVBFX0xSRSB8IFRZUEVfUkxPIHwgVFlQRV9MUk8gfCBJU09MQVRFX0lOSVRfVFlQRVMgfCBUWVBFX1BESSB8IFRZUEVfUERGIHwgVFlQRV9CO1xuICAgIHZhciBuZXh0RXZlbiA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuICsgKChuICYgMSkgPyAxIDogMik7IH07XG4gICAgdmFyIG5leHRPZGQgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gbiArICgobiAmIDEpID8gMiA6IDEpOyB9O1xuXG4gICAgLy8gRXZlcnl0aGluZyBmcm9tIGhlcmUgb24gd2lsbCBvcGVyYXRlIHBlciBwYXJhZ3JhcGguXG4gICAgZm9yICh2YXIgcGFyYUlkeCA9IDA7IHBhcmFJZHggPCBwYXJhZ3JhcGhzLmxlbmd0aDsgcGFyYUlkeCsrKSB7XG4gICAgICBwYXJhZ3JhcGggPSBwYXJhZ3JhcGhzW3BhcmFJZHhdO1xuICAgICAgdmFyIHN0YXR1c1N0YWNrID0gW3tcbiAgICAgICAgX2xldmVsOiBwYXJhZ3JhcGgubGV2ZWwsXG4gICAgICAgIF9vdmVycmlkZTogMCwgLy8wPW5ldXRyYWwsIDE9TCwgMj1SXG4gICAgICAgIF9pc29sYXRlOiAwIC8vYm9vbFxuICAgICAgfV07XG4gICAgICB2YXIgc3RhY2tUb3AgPSAodm9pZCAwKTtcbiAgICAgIHZhciBvdmVyZmxvd0lzb2xhdGVDb3VudCA9IDA7XG4gICAgICB2YXIgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA9IDA7XG4gICAgICB2YXIgdmFsaWRJc29sYXRlQ291bnQgPSAwO1xuICAgICAgY2hhclR5cGVDb3VudHMuY2xlYXIoKTtcblxuICAgICAgLy8gPT09IDMuMy4yIEV4cGxpY2l0IExldmVscyBhbmQgRGlyZWN0aW9ucyA9PT1cbiAgICAgIGZvciAodmFyIGkkMiA9IHBhcmFncmFwaC5zdGFydDsgaSQyIDw9IHBhcmFncmFwaC5lbmQ7IGkkMisrKSB7XG4gICAgICAgIHZhciBjaGFyVHlwZSA9IGNoYXJUeXBlc1tpJDJdO1xuICAgICAgICBzdGFja1RvcCA9IHN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIC8vIFNldCBpbml0aWFsIGNvdW50c1xuICAgICAgICBjaGFyVHlwZUNvdW50cy5zZXQoY2hhclR5cGUsIChjaGFyVHlwZUNvdW50cy5nZXQoY2hhclR5cGUpIHx8IDApICsgMSk7XG4gICAgICAgIGlmIChjaGFyVHlwZSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICAgIGNoYXJUeXBlQ291bnRzLnNldChORVVUUkFMX0lTT0xBVEVfVFlQRVMsIChjaGFyVHlwZUNvdW50cy5nZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB8fCAwKSArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhwbGljaXQgRW1iZWRkaW5nczogMy4zLjIgWDIgLSBYM1xuICAgICAgICBpZiAoY2hhclR5cGUgJiBGT1JNQVRUSU5HX1RZUEVTKSB7IC8vcHJlZmlsdGVyIGFsbCBmb3JtYXR0ZXJzXG4gICAgICAgICAgaWYgKGNoYXJUeXBlICYgKFRZUEVfUkxFIHwgVFlQRV9MUkUpKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsOyAvLyA1LjJcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IChjaGFyVHlwZSA9PT0gVFlQRV9STEUgPyBuZXh0T2RkIDogbmV4dEV2ZW4pKHN0YWNrVG9wLl9sZXZlbCk7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPD0gTUFYX0RFUFRIICYmICFvdmVyZmxvd0lzb2xhdGVDb3VudCAmJiAhb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCkge1xuICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICBfbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgIF9vdmVycmlkZTogMCxcbiAgICAgICAgICAgICAgICBfaXNvbGF0ZTogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW92ZXJmbG93SXNvbGF0ZUNvdW50KSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93RW1iZWRkaW5nQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeHBsaWNpdCBPdmVycmlkZXM6IDMuMy4yIFg0IC0gWDVcbiAgICAgICAgICBlbHNlIGlmIChjaGFyVHlwZSAmIChUWVBFX1JMTyB8IFRZUEVfTFJPKSkge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDsgLy8gNS4yXG4gICAgICAgICAgICB2YXIgbGV2ZWwkMSA9IChjaGFyVHlwZSA9PT0gVFlQRV9STE8gPyBuZXh0T2RkIDogbmV4dEV2ZW4pKHN0YWNrVG9wLl9sZXZlbCk7XG4gICAgICAgICAgICBpZiAobGV2ZWwkMSA8PSBNQVhfREVQVEggJiYgIW92ZXJmbG93SXNvbGF0ZUNvdW50ICYmICFvdmVyZmxvd0VtYmVkZGluZ0NvdW50KSB7XG4gICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIF9sZXZlbDogbGV2ZWwkMSxcbiAgICAgICAgICAgICAgICBfb3ZlcnJpZGU6IChjaGFyVHlwZSAmIFRZUEVfUkxPKSA/IFRZUEVfUiA6IFRZUEVfTCxcbiAgICAgICAgICAgICAgICBfaXNvbGF0ZTogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW92ZXJmbG93SXNvbGF0ZUNvdW50KSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93RW1iZWRkaW5nQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJc29sYXRlczogMy4zLjIgWDVhIC0gWDVjXG4gICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBJU09MQVRFX0lOSVRfVFlQRVMpIHtcbiAgICAgICAgICAgIC8vIFg1YyAtIEZTSSBiZWNvbWVzIGVpdGhlciBSTEkgb3IgTFJJXG4gICAgICAgICAgICBpZiAoY2hhclR5cGUgJiBUWVBFX0ZTSSkge1xuICAgICAgICAgICAgICBjaGFyVHlwZSA9IGRldGVybWluZUF1dG9FbWJlZExldmVsKGkkMiArIDEsIHRydWUpID09PSAxID8gVFlQRV9STEkgOiBUWVBFX0xSSTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDtcbiAgICAgICAgICAgIGlmIChzdGFja1RvcC5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQyLCBzdGFja1RvcC5fb3ZlcnJpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxldmVsJDIgPSAoY2hhclR5cGUgPT09IFRZUEVfUkxJID8gbmV4dE9kZCA6IG5leHRFdmVuKShzdGFja1RvcC5fbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGxldmVsJDIgPD0gTUFYX0RFUFRIICYmIG92ZXJmbG93SXNvbGF0ZUNvdW50ID09PSAwICYmIG92ZXJmbG93RW1iZWRkaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgdmFsaWRJc29sYXRlQ291bnQrKztcbiAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgX2xldmVsOiBsZXZlbCQyLFxuICAgICAgICAgICAgICAgIF9vdmVycmlkZTogMCxcbiAgICAgICAgICAgICAgICBfaXNvbGF0ZTogMSxcbiAgICAgICAgICAgICAgICBfaXNvbEluaXRJbmRleDogaSQyXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3dJc29sYXRlQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUZXJtaW5hdGluZyBJc29sYXRlczogMy4zLjIgWDZhXG4gICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBUWVBFX1BESSkge1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93SXNvbGF0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICBvdmVyZmxvd0lzb2xhdGVDb3VudC0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWxpZElzb2xhdGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA9IDA7XG4gICAgICAgICAgICAgIHdoaWxlICghc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV0uX2lzb2xhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBBZGQgdG8gaXNvbGF0aW9uIHBhaXJzIGJpZGlyZWN0aW9uYWwgbWFwcGluZzpcbiAgICAgICAgICAgICAgdmFyIGlzb2xJbml0SW5kZXggPSBzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXS5faXNvbEluaXRJbmRleDtcbiAgICAgICAgICAgICAgaWYgKGlzb2xJbml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlzb2xhdGlvblBhaXJzLnNldChpc29sSW5pdEluZGV4LCBpJDIpO1xuICAgICAgICAgICAgICAgIGlzb2xhdGlvblBhaXJzLnNldChpJDIsIGlzb2xJbml0SW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICB2YWxpZElzb2xhdGVDb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2tUb3AgPSBzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7XG4gICAgICAgICAgICBpZiAoc3RhY2tUb3AuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMiwgc3RhY2tUb3AuX292ZXJyaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIC8vIFRlcm1pbmF0aW5nIEVtYmVkZGluZ3MgYW5kIE92ZXJyaWRlczogMy4zLjIgWDdcbiAgICAgICAgICBlbHNlIGlmIChjaGFyVHlwZSAmIFRZUEVfUERGKSB7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dJc29sYXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKG92ZXJmbG93RW1iZWRkaW5nQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudC0tO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFzdGFja1RvcC5faXNvbGF0ZSAmJiBzdGF0dXNTdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgc3RhY2tUb3AgPSBzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDsgLy8gNS4yXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRW5kIG9mIFBhcmFncmFwaDogMy4zLjIgWDhcbiAgICAgICAgICBlbHNlIGlmIChjaGFyVHlwZSAmIFRZUEVfQikge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb24tZm9ybWF0dGluZyBjaGFyYWN0ZXJzOiAzLjMuMiBYNlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsO1xuICAgICAgICAgIC8vIE5PVEU6IFRoaXMgZXhjbHVzaW9uIG9mIEJOIHNlZW1zIHRvIGdvIGFnYWluc3Qgd2hhdCBzZWN0aW9uIDUuMiBzYXlzLCBidXQgaXMgcmVxdWlyZWQgZm9yIHRlc3QgcGFzc2FnZVxuICAgICAgICAgIGlmIChzdGFja1RvcC5fb3ZlcnJpZGUgJiYgY2hhclR5cGUgIT09IFRZUEVfQk4pIHtcbiAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMiwgc3RhY2tUb3AuX292ZXJyaWRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gPT09IDMuMy4zIFByZXBhcmF0aW9ucyBmb3IgSW1wbGljaXQgUHJvY2Vzc2luZyA9PT1cblxuICAgICAgLy8gUmVtb3ZlIGFsbCBSTEUsIExSRSwgUkxPLCBMUk8sIFBERiwgYW5kIEJOIGNoYXJhY3RlcnM6IDMuMy4zIFg5XG4gICAgICAvLyBOb3RlOiBEdWUgdG8gc2VjdGlvbiA1LjIsIHdlIHdvbid0IHJlbW92ZSB0aGVtLCBidXQgd2UnbGwgdXNlIHRoZSBCTl9MSUtFX1RZUEVTIGJpdHNldCB0b1xuICAgICAgLy8gZWFzaWx5IGlnbm9yZSB0aGVtIGFsbCBmcm9tIGhlcmUgb24gb3V0LlxuXG4gICAgICAvLyAzLjMuMyBYMTBcbiAgICAgIC8vIENvbXB1dGUgdGhlIHNldCBvZiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlcyBhcyBzcGVjaWZpZWQgYnkgQkQxM1xuICAgICAgdmFyIGxldmVsUnVucyA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSdW4gPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSQzID0gcGFyYWdyYXBoLnN0YXJ0OyBpJDMgPD0gcGFyYWdyYXBoLmVuZDsgaSQzKyspIHtcbiAgICAgICAgdmFyIGNoYXJUeXBlJDEgPSBjaGFyVHlwZXNbaSQzXTtcbiAgICAgICAgaWYgKCEoY2hhclR5cGUkMSAmIEJOX0xJS0VfVFlQRVMpKSB7XG4gICAgICAgICAgdmFyIGx2bCA9IGVtYmVkTGV2ZWxzW2kkM107XG4gICAgICAgICAgdmFyIGlzSXNvbEluaXQgPSBjaGFyVHlwZSQxICYgSVNPTEFURV9JTklUX1RZUEVTO1xuICAgICAgICAgIHZhciBpc1BESSA9IGNoYXJUeXBlJDEgPT09IFRZUEVfUERJO1xuICAgICAgICAgIGlmIChjdXJyZW50UnVuICYmIGx2bCA9PT0gY3VycmVudFJ1bi5fbGV2ZWwpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSdW4uX2VuZCA9IGkkMztcbiAgICAgICAgICAgIGN1cnJlbnRSdW4uX2VuZHNXaXRoSXNvbEluaXQgPSBpc0lzb2xJbml0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXZlbFJ1bnMucHVzaChjdXJyZW50UnVuID0ge1xuICAgICAgICAgICAgICBfc3RhcnQ6IGkkMyxcbiAgICAgICAgICAgICAgX2VuZDogaSQzLFxuICAgICAgICAgICAgICBfbGV2ZWw6IGx2bCxcbiAgICAgICAgICAgICAgX3N0YXJ0c1dpdGhQREk6IGlzUERJLFxuICAgICAgICAgICAgICBfZW5kc1dpdGhJc29sSW5pdDogaXNJc29sSW5pdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaXNvbGF0aW5nUnVuU2VxcyA9IFtdOyAvLyBbe3NlcUluZGljZXM6IFtdLCBzb3NUeXBlOiBMfFIsIGVvc1R5cGU6IEx8Un1dXG4gICAgICBmb3IgKHZhciBydW5JZHggPSAwOyBydW5JZHggPCBsZXZlbFJ1bnMubGVuZ3RoOyBydW5JZHgrKykge1xuICAgICAgICB2YXIgcnVuID0gbGV2ZWxSdW5zW3J1bklkeF07XG4gICAgICAgIGlmICghcnVuLl9zdGFydHNXaXRoUERJIHx8IChydW4uX3N0YXJ0c1dpdGhQREkgJiYgIWlzb2xhdGlvblBhaXJzLmhhcyhydW4uX3N0YXJ0KSkpIHtcbiAgICAgICAgICB2YXIgc2VxUnVucyA9IFtjdXJyZW50UnVuID0gcnVuXTtcbiAgICAgICAgICBmb3IgKHZhciBwZGlJbmRleCA9ICh2b2lkIDApOyBjdXJyZW50UnVuICYmIGN1cnJlbnRSdW4uX2VuZHNXaXRoSXNvbEluaXQgJiYgKHBkaUluZGV4ID0gaXNvbGF0aW9uUGFpcnMuZ2V0KGN1cnJlbnRSdW4uX2VuZCkpICE9IG51bGw7KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDQgPSBydW5JZHggKyAxOyBpJDQgPCBsZXZlbFJ1bnMubGVuZ3RoOyBpJDQrKykge1xuICAgICAgICAgICAgICBpZiAobGV2ZWxSdW5zW2kkNF0uX3N0YXJ0ID09PSBwZGlJbmRleCkge1xuICAgICAgICAgICAgICAgIHNlcVJ1bnMucHVzaChjdXJyZW50UnVuID0gbGV2ZWxSdW5zW2kkNF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYnVpbGQgZmxhdCBsaXN0IG9mIGluZGljZXMgYWNyb3NzIGFsbCBydW5zOlxuICAgICAgICAgIHZhciBzZXFJbmRpY2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSQ1ID0gMDsgaSQ1IDwgc2VxUnVucy5sZW5ndGg7IGkkNSsrKSB7XG4gICAgICAgICAgICB2YXIgcnVuJDEgPSBzZXFSdW5zW2kkNV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gcnVuJDEuX3N0YXJ0OyBqIDw9IHJ1biQxLl9lbmQ7IGorKykge1xuICAgICAgICAgICAgICBzZXFJbmRpY2VzLnB1c2goaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgc29zL2VvcyB0eXBlczpcbiAgICAgICAgICB2YXIgZmlyc3RMZXZlbCA9IGVtYmVkTGV2ZWxzW3NlcUluZGljZXNbMF1dO1xuICAgICAgICAgIHZhciBwcmV2TGV2ZWwgPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgZm9yICh2YXIgaSQ2ID0gc2VxSW5kaWNlc1swXSAtIDE7IGkkNiA+PSAwOyBpJDYtLSkge1xuICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW2kkNl0gJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMlxuICAgICAgICAgICAgICBwcmV2TGV2ZWwgPSBlbWJlZExldmVsc1tpJDZdO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gc2VxSW5kaWNlc1tzZXFJbmRpY2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhciBsYXN0TGV2ZWwgPSBlbWJlZExldmVsc1tsYXN0SW5kZXhdO1xuICAgICAgICAgIHZhciBuZXh0TGV2ZWwgPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgaWYgKCEoY2hhclR5cGVzW2xhc3RJbmRleF0gJiBJU09MQVRFX0lOSVRfVFlQRVMpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDcgPSBsYXN0SW5kZXggKyAxOyBpJDcgPD0gcGFyYWdyYXBoLmVuZDsgaSQ3KyspIHtcbiAgICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW2kkN10gJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMlxuICAgICAgICAgICAgICAgIG5leHRMZXZlbCA9IGVtYmVkTGV2ZWxzW2kkN107XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc29sYXRpbmdSdW5TZXFzLnB1c2goe1xuICAgICAgICAgICAgX3NlcUluZGljZXM6IHNlcUluZGljZXMsXG4gICAgICAgICAgICBfc29zVHlwZTogTWF0aC5tYXgocHJldkxldmVsLCBmaXJzdExldmVsKSAlIDIgPyBUWVBFX1IgOiBUWVBFX0wsXG4gICAgICAgICAgICBfZW9zVHlwZTogTWF0aC5tYXgobmV4dExldmVsLCBsYXN0TGV2ZWwpICUgMiA/IFRZUEVfUiA6IFRZUEVfTFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBuZXh0IHN0ZXBzIGFyZSBkb25lIHBlciBpc29sYXRpbmcgcnVuIHNlcXVlbmNlXG4gICAgICBmb3IgKHZhciBzZXFJZHggPSAwOyBzZXFJZHggPCBpc29sYXRpbmdSdW5TZXFzLmxlbmd0aDsgc2VxSWR4KyspIHtcbiAgICAgICAgdmFyIHJlZiA9IGlzb2xhdGluZ1J1blNlcXNbc2VxSWR4XTtcbiAgICAgICAgdmFyIHNlcUluZGljZXMkMSA9IHJlZi5fc2VxSW5kaWNlcztcbiAgICAgICAgdmFyIHNvc1R5cGUgPSByZWYuX3Nvc1R5cGU7XG4gICAgICAgIHZhciBlb3NUeXBlID0gcmVmLl9lb3NUeXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHRoZSBsZXZlbCBydW5zIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2UgaGF2ZSB0aGUgc2FtZSBlbWJlZGRpbmcgbGV2ZWwuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBETyBOT1QgY2hhbmdlIGFueSBgZW1iZWRMZXZlbHNbaV1gIHdpdGhpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBlbWJlZERpcmVjdGlvbiA9ICgoZW1iZWRMZXZlbHNbc2VxSW5kaWNlcyQxWzBdXSkgJiAxKSA/IFRZUEVfUiA6IFRZUEVfTDtcblxuICAgICAgICAvLyA9PT0gMy4zLjQgUmVzb2x2aW5nIFdlYWsgVHlwZXMgPT09XG5cbiAgICAgICAgLy8gVzEgKyA1LjIuIFNlYXJjaCBiYWNrd2FyZCBmcm9tIGVhY2ggTlNNIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIGlzb2xhdGluZyBydW4gc2VxdWVuY2Ugd2hvc2VcbiAgICAgICAgLy8gYmlkaXJlY3Rpb25hbCB0eXBlIGlzIG5vdCBCTiwgYW5kIHNldCB0aGUgTlNNIHRvIE9OIGlmIGl0IGlzIGFuIGlzb2xhdGUgaW5pdGlhdG9yIG9yIFBESSwgYW5kIHRvIGl0c1xuICAgICAgICAvLyB0eXBlIG90aGVyd2lzZS4gSWYgdGhlIE5TTSBpcyB0aGUgZmlyc3Qgbm9uLUJOIGNoYXJhY3RlciwgY2hhbmdlIHRoZSBOU00gdG8gdGhlIHR5cGUgb2Ygc29zLlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfTlNNKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSsrKSB7XG4gICAgICAgICAgICB2YXIgaSQ4ID0gc2VxSW5kaWNlcyQxW3NpXTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQ4XSAmIFRZUEVfTlNNKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2VHlwZSA9IHNvc1R5cGU7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqID0gc2kgLSAxOyBzaiA+PSAwOyBzai0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzal1dICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjIgc2NhbiBiYWNrIHRvIGZpcnN0IG5vbi1CTlxuICAgICAgICAgICAgICAgICAgcHJldlR5cGUgPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqXV07XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDgsIChwcmV2VHlwZSAmIChJU09MQVRFX0lOSVRfVFlQRVMgfCBUWVBFX1BESSkpID8gVFlQRV9PTiA6IHByZXZUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlciB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIEFMLCBvciBzb3MpXG4gICAgICAgIC8vIGlzIGZvdW5kLiBJZiBhbiBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljIG51bWJlci5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VOKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDEgPSAwOyBzaSQxIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMSsrKSB7XG4gICAgICAgICAgICB2YXIgaSQ5ID0gc2VxSW5kaWNlcyQxW3NpJDFdO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDldICYgVFlQRV9FTikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQxID0gc2kkMSAtIDE7IHNqJDEgPj0gLTE7IHNqJDEtLSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Q2hhclR5cGUgPSBzaiQxID09PSAtMSA/IHNvc1R5cGUgOiBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDFdXTtcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoYXJUeXBlICYgU1RST05HX1RZUEVTKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocHJldkNoYXJUeXBlID09PSBUWVBFX0FMKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkOSwgVFlQRV9BTik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9BTCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQyID0gMDsgc2kkMiA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDIrKykge1xuICAgICAgICAgICAgdmFyIGkkMTAgPSBzZXFJbmRpY2VzJDFbc2kkMl07XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTBdICYgVFlQRV9BTCkge1xuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDEwLCBUWVBFX1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFc0LiBBIHNpbmdsZSBFdXJvcGVhbiBzZXBhcmF0b3IgYmV0d2VlbiB0d28gRXVyb3BlYW4gbnVtYmVycyBjaGFuZ2VzIHRvIGEgRXVyb3BlYW4gbnVtYmVyLiBBIHNpbmdsZSBjb21tb25cbiAgICAgICAgLy8gc2VwYXJhdG9yIGJldHdlZW4gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VTKSB8fCBjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9DUykpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQzID0gMTsgc2kkMyA8IHNlcUluZGljZXMkMS5sZW5ndGggLSAxOyBzaSQzKyspIHtcbiAgICAgICAgICAgIHZhciBpJDExID0gc2VxSW5kaWNlcyQxW3NpJDNdO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDExXSAmIChUWVBFX0VTIHwgVFlQRV9DUykpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZUeXBlJDEgPSAwLCBuZXh0VHlwZSA9IDA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDIgPSBzaSQzIC0gMTsgc2okMiA+PSAwOyBzaiQyLS0pIHtcbiAgICAgICAgICAgICAgICBwcmV2VHlwZSQxID0gY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQyXV07XG4gICAgICAgICAgICAgICAgaWYgKCEocHJldlR5cGUkMSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQzID0gc2kkMyArIDE7IHNqJDMgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaiQzKyspIHtcbiAgICAgICAgICAgICAgICBuZXh0VHlwZSA9IGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okM11dO1xuICAgICAgICAgICAgICAgIGlmICghKG5leHRUeXBlICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjJcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwcmV2VHlwZSQxID09PSBuZXh0VHlwZSAmJiAoY2hhclR5cGVzW2kkMTFdID09PSBUWVBFX0VTID8gcHJldlR5cGUkMSA9PT0gVFlQRV9FTiA6IChwcmV2VHlwZSQxICYgKFRZUEVfRU4gfCBUWVBFX0FOKSkpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQxMSwgcHJldlR5cGUkMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhbiBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FTikpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQ0ID0gMDsgc2kkNCA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDQrKykge1xuICAgICAgICAgICAgdmFyIGkkMTIgPSBzZXFJbmRpY2VzJDFbc2kkNF07XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTJdICYgVFlQRV9FTikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQ0ID0gc2kkNCAtIDE7IHNqJDQgPj0gMCAmJiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQ0XV0gJiAoVFlQRV9FVCB8IEJOX0xJS0VfVFlQRVMpKTsgc2okNC0tKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NqJDRdLCBUWVBFX0VOKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHNpJDQrKzsgc2kkNCA8IHNlcUluZGljZXMkMS5sZW5ndGggJiYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkNF1dICYgKFRZUEVfRVQgfCBCTl9MSUtFX1RZUEVTIHwgVFlQRV9FTikpOyBzaSQ0KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQ0XV0gIT09IFRZUEVfRU4pIHtcbiAgICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKHNlcUluZGljZXMkMVtzaSQ0XSwgVFlQRV9FTik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzYuIE90aGVyd2lzZSwgc2VwYXJhdG9ycyBhbmQgdGVybWluYXRvcnMgY2hhbmdlIHRvIE90aGVyIE5ldXRyYWwuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FVCkgfHwgY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRVMpIHx8IGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0NTKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDUgPSAwOyBzaSQ1IDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkNSsrKSB7XG4gICAgICAgICAgICB2YXIgaSQxMyA9IHNlcUluZGljZXMkMVtzaSQ1XTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxM10gJiAoVFlQRV9FVCB8IFRZUEVfRVMgfCBUWVBFX0NTKSkge1xuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDEzLCBUWVBFX09OKTtcbiAgICAgICAgICAgICAgLy8gNS4yIHRyYW5zZm9ybSBhZGphY2VudCBCTnMgdG9vOlxuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQ1ID0gc2kkNSAtIDE7IHNqJDUgPj0gMCAmJiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQ1XV0gJiBCTl9MSUtFX1RZUEVTKTsgc2okNS0tKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NqJDVdLCBUWVBFX09OKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQ2ID0gc2kkNSArIDE7IHNqJDYgPCBzZXFJbmRpY2VzJDEubGVuZ3RoICYmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDZdXSAmIEJOX0xJS0VfVFlQRVMpOyBzaiQ2KyspIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShzZXFJbmRpY2VzJDFbc2okNl0sIFRZUEVfT04pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZCBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXIgdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3MpXG4gICAgICAgIC8vIGlzIGZvdW5kLiBJZiBhbiBMIGlzIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICAgIC8vIE5PVEU6IGltcGxlbWVudGVkIGluIHNpbmdsZSBmb3J3YXJkIHBhc3MgZm9yIGVmZmljaWVuY3lcbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VOKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDYgPSAwLCBwcmV2U3Ryb25nVHlwZSA9IHNvc1R5cGU7IHNpJDYgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQ2KyspIHtcbiAgICAgICAgICAgIHZhciBpJDE0ID0gc2VxSW5kaWNlcyQxW3NpJDZdO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBjaGFyVHlwZXNbaSQxNF07XG4gICAgICAgICAgICBpZiAodHlwZSAmIFRZUEVfRU4pIHtcbiAgICAgICAgICAgICAgaWYgKHByZXZTdHJvbmdUeXBlID09PSBUWVBFX0wpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDE0LCBUWVBFX0wpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgJiBTVFJPTkdfVFlQRVMpIHtcbiAgICAgICAgICAgICAgcHJldlN0cm9uZ1R5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vID09PSAzLjMuNSBSZXNvbHZpbmcgTmV1dHJhbCBhbmQgSXNvbGF0ZSBGb3JtYXR0aW5nIFR5cGVzID09PVxuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTKSkge1xuICAgICAgICAgIC8vIE4wLiBQcm9jZXNzIGJyYWNrZXQgcGFpcnMgaW4gYW4gaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZSBzZXF1ZW50aWFsbHkgaW4gdGhlIGxvZ2ljYWwgb3JkZXIgb2YgdGhlIHRleHRcbiAgICAgICAgICAvLyBwb3NpdGlvbnMgb2YgdGhlIG9wZW5pbmcgcGFpcmVkIGJyYWNrZXRzIHVzaW5nIHRoZSBsb2dpYyBnaXZlbiBiZWxvdy4gV2l0aGluIHRoaXMgc2NvcGUsIGJpZGlyZWN0aW9uYWxcbiAgICAgICAgICAvLyB0eXBlcyBFTiBhbmQgQU4gYXJlIHRyZWF0ZWQgYXMgUi5cbiAgICAgICAgICB2YXIgUl9UWVBFU19GT1JfTl9TVEVQUyA9IChUWVBFX1IgfCBUWVBFX0VOIHwgVFlQRV9BTik7XG4gICAgICAgICAgdmFyIFNUUk9OR19UWVBFU19GT1JfTl9TVEVQUyA9IFJfVFlQRVNfRk9SX05fU1RFUFMgfCBUWVBFX0w7XG5cbiAgICAgICAgICAvLyAqIElkZW50aWZ5IHRoZSBicmFja2V0IHBhaXJzIGluIHRoZSBjdXJyZW50IGlzb2xhdGluZyBydW4gc2VxdWVuY2UgYWNjb3JkaW5nIHRvIEJEMTYuXG4gICAgICAgICAgdmFyIGJyYWNrZXRQYWlycyA9IFtdO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvcGVuZXJTdGFjayA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgc2kkNyA9IDA7IHNpJDcgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQ3KyspIHtcbiAgICAgICAgICAgICAgLy8gTk9URTogZm9yIGFueSBwb3RlbnRpYWwgYnJhY2tldCBjaGFyYWN0ZXIgd2UgYWxzbyB0ZXN0IHRoYXQgaXQgc3RpbGwgY2FycmllcyBhIE5JXG4gICAgICAgICAgICAgIC8vIHR5cGUsIGFzIHRoYXQgbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIGVhcmxpZXIuIFRoaXMgZG9lc24ndCBzZWVtIHRvIGJlIGV4cGxpY2l0bHlcbiAgICAgICAgICAgICAgLy8gY2FsbGVkIG91dCBpbiB0aGUgc3BlYywgYnV0IGlzIHJlcXVpcmVkIGZvciBwYXNzYWdlIG9mIGNlcnRhaW4gdGVzdHMuXG4gICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDddXSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICAgICAgICAgIHZhciBjaGFyID0gc3RyaW5nW3NlcUluZGljZXMkMVtzaSQ3XV07XG4gICAgICAgICAgICAgICAgdmFyIG9wcG9zaXRlQnJhY2tldCA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICAgIC8vIE9wZW5pbmcgYnJhY2tldFxuICAgICAgICAgICAgICAgIGlmIChvcGVuaW5nVG9DbG9zaW5nQnJhY2tldChjaGFyKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lclN0YWNrLmxlbmd0aCA8IDYzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lclN0YWNrLnB1c2goeyBjaGFyOiBjaGFyLCBzZXFJbmRleDogc2kkNyB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENsb3NpbmcgYnJhY2tldFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChvcHBvc2l0ZUJyYWNrZXQgPSBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldChjaGFyKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHN0YWNrSWR4ID0gb3BlbmVyU3RhY2subGVuZ3RoIC0gMTsgc3RhY2tJZHggPj0gMDsgc3RhY2tJZHgtLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tDaGFyID0gb3BlbmVyU3RhY2tbc3RhY2tJZHhdLmNoYXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFja0NoYXIgPT09IG9wcG9zaXRlQnJhY2tldCB8fFxuICAgICAgICAgICAgICAgICAgICAgIHN0YWNrQ2hhciA9PT0gY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQoZ2V0Q2Fub25pY2FsQnJhY2tldChjaGFyKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICBvcGVuaW5nVG9DbG9zaW5nQnJhY2tldChnZXRDYW5vbmljYWxCcmFja2V0KHN0YWNrQ2hhcikpID09PSBjaGFyXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIGJyYWNrZXRQYWlycy5wdXNoKFtvcGVuZXJTdGFja1tzdGFja0lkeF0uc2VxSW5kZXgsIHNpJDddKTtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJTdGFjay5sZW5ndGggPSBzdGFja0lkeDsgLy9wb3AgdGhlIG1hdGNoaW5nIGJyYWNrZXQgYW5kIGFsbCBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmFja2V0UGFpcnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyAqIEZvciBlYWNoIGJyYWNrZXQtcGFpciBlbGVtZW50IGluIHRoZSBsaXN0IG9mIHBhaXJzIG9mIHRleHQgcG9zaXRpb25zXG4gICAgICAgICAgZm9yICh2YXIgcGFpcklkeCA9IDA7IHBhaXJJZHggPCBicmFja2V0UGFpcnMubGVuZ3RoOyBwYWlySWR4KyspIHtcbiAgICAgICAgICAgIHZhciByZWYkMSA9IGJyYWNrZXRQYWlyc1twYWlySWR4XTtcbiAgICAgICAgICAgIHZhciBvcGVuU2VxSWR4ID0gcmVmJDFbMF07XG4gICAgICAgICAgICB2YXIgY2xvc2VTZXFJZHggPSByZWYkMVsxXTtcbiAgICAgICAgICAgIC8vIGEuIEluc3BlY3QgdGhlIGJpZGlyZWN0aW9uYWwgdHlwZXMgb2YgdGhlIGNoYXJhY3RlcnMgZW5jbG9zZWQgd2l0aGluIHRoZSBicmFja2V0IHBhaXIuXG4gICAgICAgICAgICAvLyBiLiBJZiBhbnkgc3Ryb25nIHR5cGUgKGVpdGhlciBMIG9yIFIpIG1hdGNoaW5nIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uIGlzIGZvdW5kLCBzZXQgdGhlIHR5cGUgZm9yIGJvdGhcbiAgICAgICAgICAgIC8vIGJyYWNrZXRzIGluIHRoZSBwYWlyIHRvIG1hdGNoIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgICAgdmFyIGZvdW5kU3Ryb25nVHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHVzZVN0cm9uZ1R5cGUgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgc2kkOCA9IG9wZW5TZXFJZHggKyAxOyBzaSQ4IDwgY2xvc2VTZXFJZHg7IHNpJDgrKykge1xuICAgICAgICAgICAgICB2YXIgaSQxNSA9IHNlcUluZGljZXMkMVtzaSQ4XTtcbiAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDE1XSAmIFNUUk9OR19UWVBFU19GT1JfTl9TVEVQUykge1xuICAgICAgICAgICAgICAgIGZvdW5kU3Ryb25nVHlwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGxyID0gKGNoYXJUeXBlc1tpJDE1XSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MO1xuICAgICAgICAgICAgICAgIGlmIChsciA9PT0gZW1iZWREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgIHVzZVN0cm9uZ1R5cGUgPSBscjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjLiBPdGhlcndpc2UsIGlmIHRoZXJlIGlzIGEgc3Ryb25nIHR5cGUgaXQgbXVzdCBiZSBvcHBvc2l0ZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi4gVGhlcmVmb3JlLCB0ZXN0XG4gICAgICAgICAgICAvLyBmb3IgYW4gZXN0YWJsaXNoZWQgY29udGV4dCB3aXRoIGEgcHJlY2VkaW5nIHN0cm9uZyB0eXBlIGJ5IGNoZWNraW5nIGJhY2t3YXJkcyBiZWZvcmUgdGhlIG9wZW5pbmcgcGFpcmVkXG4gICAgICAgICAgICAvLyBicmFja2V0IHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoTCwgUiwgb3Igc29zKSBpcyBmb3VuZC5cbiAgICAgICAgICAgIC8vICAgIDEuIElmIHRoZSBwcmVjZWRpbmcgc3Ryb25nIHR5cGUgaXMgYWxzbyBvcHBvc2l0ZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbiwgY29udGV4dCBpcyBlc3RhYmxpc2hlZCwgc29cbiAgICAgICAgICAgIC8vICAgIHNldCB0aGUgdHlwZSBmb3IgYm90aCBicmFja2V0cyBpbiB0aGUgcGFpciB0byB0aGF0IGRpcmVjdGlvbi5cbiAgICAgICAgICAgIC8vICAgIDIuIE90aGVyd2lzZSBzZXQgdGhlIHR5cGUgZm9yIGJvdGggYnJhY2tldHMgaW4gdGhlIHBhaXIgdG8gdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAgICBpZiAoZm91bmRTdHJvbmdUeXBlICYmICF1c2VTdHJvbmdUeXBlKSB7XG4gICAgICAgICAgICAgIHVzZVN0cm9uZ1R5cGUgPSBzb3NUeXBlO1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaSQ5ID0gb3BlblNlcUlkeCAtIDE7IHNpJDkgPj0gMDsgc2kkOS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkkMTYgPSBzZXFJbmRpY2VzJDFbc2kkOV07XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDE2XSAmIFNUUk9OR19UWVBFU19GT1JfTl9TVEVQUykge1xuICAgICAgICAgICAgICAgICAgdmFyIGxyJDEgPSAoY2hhclR5cGVzW2kkMTZdICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0w7XG4gICAgICAgICAgICAgICAgICBpZiAobHIkMSAhPT0gZW1iZWREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlU3Ryb25nVHlwZSA9IGxyJDE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1c2VTdHJvbmdUeXBlID0gZW1iZWREaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZVN0cm9uZ1R5cGUpIHtcbiAgICAgICAgICAgICAgY2hhclR5cGVzW3NlcUluZGljZXMkMVtvcGVuU2VxSWR4XV0gPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW2Nsb3NlU2VxSWR4XV0gPSB1c2VTdHJvbmdUeXBlO1xuICAgICAgICAgICAgICAvLyAqIEFueSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGhhZCBvcmlnaW5hbCBiaWRpcmVjdGlvbmFsIGNoYXJhY3RlciB0eXBlIE5TTSBwcmlvciB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgICAgICAgLy8gb2YgVzEgdGhhdCBpbW1lZGlhdGVseSBmb2xsb3cgYSBwYWlyZWQgYnJhY2tldCB3aGljaCBjaGFuZ2VkIHRvIEwgb3IgUiB1bmRlciBOMCBzaG91bGQgY2hhbmdlIHRvIG1hdGNoXG4gICAgICAgICAgICAgIC8vIHRoZSB0eXBlIG9mIHRoZWlyIHByZWNlZGluZyBicmFja2V0LlxuICAgICAgICAgICAgICBpZiAodXNlU3Ryb25nVHlwZSAhPT0gZW1iZWREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSQxMCA9IG9wZW5TZXFJZHggKyAxOyBzaSQxMCA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDEwKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTBdXSAmIEJOX0xJS0VfVFlQRVMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW3NlcUluZGljZXMkMVtzaSQxMF1dKSAmIFRZUEVfTlNNKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQxMF1dID0gdXNlU3Ryb25nVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodXNlU3Ryb25nVHlwZSAhPT0gZW1iZWREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSQxMSA9IGNsb3NlU2VxSWR4ICsgMTsgc2kkMTEgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxMSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDExXV0gJiBCTl9MSUtFX1RZUEVTKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tzZXFJbmRpY2VzJDFbc2kkMTFdXSkgJiBUWVBFX05TTSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTFdXSA9IHVzZVN0cm9uZ1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBOSXMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlXG4gICAgICAgICAgLy8gc2FtZSBkaXJlY3Rpb24uXG4gICAgICAgICAgLy8gTjIuIEFueSByZW1haW5pbmcgTklzIHRha2UgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAgZm9yICh2YXIgc2kkMTIgPSAwOyBzaSQxMiA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDEyKyspIHtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDEyXV0gJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgICAgICAgdmFyIG5pUnVuU3RhcnQgPSBzaSQxMiwgbmlSdW5FbmQgPSBzaSQxMjtcbiAgICAgICAgICAgICAgdmFyIHByZXZUeXBlJDIgPSBzb3NUeXBlOyAvL3NpID09PSAwID8gc29zVHlwZSA6IChjaGFyVHlwZXNbc2VxSW5kaWNlc1tzaSAtIDFdXSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MXG4gICAgICAgICAgICAgIGZvciAodmFyIHNpMiA9IHNpJDEyIC0gMTsgc2kyID49IDA7IHNpMi0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kyXV0gJiBCTl9MSUtFX1RZUEVTKSB7XG4gICAgICAgICAgICAgICAgICBuaVJ1blN0YXJ0ID0gc2kyOyAvLzUuMiB0cmVhdCBCTnMgYWRqYWNlbnQgdG8gTklzIGFzIE5Jc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwcmV2VHlwZSQyID0gKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kyXV0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBuZXh0VHlwZSQxID0gZW9zVHlwZTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2kyJDEgPSBzaSQxMiArIDE7IHNpMiQxIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kyJDErKykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpMiQxXV0gJiAoTkVVVFJBTF9JU09MQVRFX1RZUEVTIHwgQk5fTElLRV9UWVBFUykpIHtcbiAgICAgICAgICAgICAgICAgIG5pUnVuRW5kID0gc2kyJDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5leHRUeXBlJDEgPSAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaTIkMV1dICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0w7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQ3ID0gbmlSdW5TdGFydDsgc2okNyA8PSBuaVJ1bkVuZDsgc2okNysrKSB7XG4gICAgICAgICAgICAgICAgY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQ3XV0gPSBwcmV2VHlwZSQyID09PSBuZXh0VHlwZSQxID8gcHJldlR5cGUkMiA6IGVtYmVkRGlyZWN0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNpJDEyID0gbmlSdW5FbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vID09PSAzLjMuNiBSZXNvbHZpbmcgSW1wbGljaXQgTGV2ZWxzID09PVxuXG4gICAgICBmb3IgKHZhciBpJDE3ID0gcGFyYWdyYXBoLnN0YXJ0OyBpJDE3IDw9IHBhcmFncmFwaC5lbmQ7IGkkMTcrKykge1xuICAgICAgICB2YXIgbGV2ZWwkMyA9IGVtYmVkTGV2ZWxzW2kkMTddO1xuICAgICAgICB2YXIgdHlwZSQxID0gY2hhclR5cGVzW2kkMTddO1xuICAgICAgICAvLyBJMi4gRm9yIGFsbCBjaGFyYWN0ZXJzIHdpdGggYW4gb2RkIChyaWdodC10by1sZWZ0KSBlbWJlZGRpbmcgbGV2ZWwsIHRob3NlIG9mIHR5cGUgTCwgRU4gb3IgQU4gZ28gdXAgb25lIGxldmVsLlxuICAgICAgICBpZiAobGV2ZWwkMyAmIDEpIHtcbiAgICAgICAgICBpZiAodHlwZSQxICYgKFRZUEVfTCB8IFRZUEVfRU4gfCBUWVBFX0FOKSkge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQxN10rKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgICAvLyBJMS4gRm9yIGFsbCBjaGFyYWN0ZXJzIHdpdGggYW4gZXZlbiAobGVmdC10by1yaWdodCkgZW1iZWRkaW5nIGxldmVsLCB0aG9zZSBvZiB0eXBlIFIgZ28gdXAgb25lIGxldmVsXG4gICAgICAgIC8vIGFuZCB0aG9zZSBvZiB0eXBlIEFOIG9yIEVOIGdvIHVwIHR3byBsZXZlbHMuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlJDEgJiBUWVBFX1IpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddKys7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlJDEgJiAoVFlQRV9BTiB8IFRZUEVfRU4pKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDE3XSArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuMjogUmVzb2x2ZSBhbnkgTFJFLCBSTEUsIExSTywgUkxPLCBQREYsIG9yIEJOIHRvIHRoZSBsZXZlbCBvZiB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBpZiB0aGVyZSBpcyBvbmUsXG4gICAgICAgIC8vIGFuZCBvdGhlcndpc2UgdG8gdGhlIGJhc2UgbGV2ZWwuXG4gICAgICAgIGlmICh0eXBlJDEgJiBCTl9MSUtFX1RZUEVTKSB7XG4gICAgICAgICAgZW1iZWRMZXZlbHNbaSQxN10gPSBpJDE3ID09PSAwID8gcGFyYWdyYXBoLmxldmVsIDogZW1iZWRMZXZlbHNbaSQxNyAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy40IEwxLjEtNDogUmVzZXQgdGhlIGVtYmVkZGluZyBsZXZlbCBvZiBzZWdtZW50L3BhcmFncmFwaCBzZXBhcmF0b3JzLCBhbmQgYW55IHNlcXVlbmNlIG9mIHdoaXRlc3BhY2Ugb3JcbiAgICAgICAgLy8gaXNvbGF0ZSBmb3JtYXR0aW5nIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZW0gb3IgdGhlIGVuZCBvZiB0aGUgcGFyYWdyYXBoLCB0byB0aGUgcGFyYWdyYXBoIGxldmVsLlxuICAgICAgICAvLyBOT1RFOiB0aGlzIHdpbGwgYWxzbyBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gZWFjaCBpbmRpdmlkdWFsIGxpbmUgZW5kaW5nIGFmdGVyIGxpbmUgd3JhcHBpbmcgb2NjdXJzLlxuICAgICAgICBpZiAoaSQxNyA9PT0gcGFyYWdyYXBoLmVuZCB8fCBnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW2kkMTddKSAmIChUWVBFX1MgfCBUWVBFX0IpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiQxID0gaSQxNzsgaiQxID49IDAgJiYgKGdldEJpZGlDaGFyVHlwZShzdHJpbmdbaiQxXSkgJiBUUkFJTElOR19UWVBFUyk7IGokMS0tKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tqJDFdID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERPTkUhIFRoZSByZXNvbHZlZCBsZXZlbHMgY2FuIHRoZW4gYmUgdXNlZCwgYWZ0ZXIgbGluZSB3cmFwcGluZywgdG8gZmxpcCBydW5zIG9mIGNoYXJhY3RlcnNcbiAgICAvLyBhY2NvcmRpbmcgdG8gc2VjdGlvbiAzLjQgUmVvcmRlcmluZyBSZXNvbHZlZCBMZXZlbHNcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWxzOiBlbWJlZExldmVscyxcbiAgICAgIHBhcmFncmFwaHM6IHBhcmFncmFwaHNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmVBdXRvRW1iZWRMZXZlbCAoc3RhcnQsIGlzRlNJKSB7XG4gICAgICAvLyAzLjMuMSBQMiAtIFAzXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJUeXBlID0gY2hhclR5cGVzW2ldO1xuICAgICAgICBpZiAoY2hhclR5cGUgJiAoVFlQRV9SIHwgVFlQRV9BTCkpIHtcbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9XG4gICAgICAgIGlmICgoY2hhclR5cGUgJiAoVFlQRV9CIHwgVFlQRV9MKSkgfHwgKGlzRlNJICYmIGNoYXJUeXBlID09PSBUWVBFX1BESSkpIHtcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyVHlwZSAmIElTT0xBVEVfSU5JVF9UWVBFUykge1xuICAgICAgICAgIHZhciBwZGkgPSBpbmRleE9mTWF0Y2hpbmdQREkoaSk7XG4gICAgICAgICAgaSA9IHBkaSA9PT0gLTEgPyBzdHJpbmcubGVuZ3RoIDogcGRpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluZGV4T2ZNYXRjaGluZ1BESSAoaXNvbGF0ZVN0YXJ0KSB7XG4gICAgICAvLyAzLjEuMiBCRDlcbiAgICAgIHZhciBpc29sYXRpb25MZXZlbCA9IDE7XG4gICAgICBmb3IgKHZhciBpID0gaXNvbGF0ZVN0YXJ0ICsgMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhclR5cGUgPSBjaGFyVHlwZXNbaV07XG4gICAgICAgIGlmIChjaGFyVHlwZSAmIFRZUEVfQikge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJUeXBlICYgVFlQRV9QREkpIHtcbiAgICAgICAgICBpZiAoLS1pc29sYXRpb25MZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhclR5cGUgJiBJU09MQVRFX0lOSVRfVFlQRVMpIHtcbiAgICAgICAgICBpc29sYXRpb25MZXZlbCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gIH1cblxuICAvLyBCaWRpIG1pcnJvcmVkIGNoYXJzIGRhdGEsIGF1dG8gZ2VuZXJhdGVkXG4gIHZhciBkYXRhID0gXCIxND4xLGo+Mix0PjIsdT4yLDFhPmcsMnYzPjEsMT4xLDFnZT4xLDF3ZD4xLGI+MSwxaj4xLGY+MSxhaT4zLC0yPjMsKzEsOD4xazAsLTFqcT4xeTcsLTF5Nj4xaGYsLTFoZT4xaDYsLTFoNT4xaGEsLTFoOD4xcWksLTFwdT4xLDY+M3UsLTNzPjcsNj4xLDE+MSxmPjEsMT4xLCsyLDM+MSwxPjEsKzEzLDQ+MSwxPjEsNj4xZW8sLTFlZT4xLDM+MW1nLC0xbWU+MW1rLC0xbWo+MW1pLC0xbWc+MW1pLC0xbWQ+MSwxPjEsKzIsMT4xMGssLTEwMz4xLDE+MSw0PjEsNT4xLDE+MSwrMTAsMz4xLDE+OCwtNz44LCsxLC02PjcsKzEsYT4xLDE+MSx1PjEsdTY+MSwxPjEsKzUsMjY+MSwxPjEsMj4xLDI+Miw4PjEsNz4xLDQ+MSwxPjEsKzUsYjg+MSwxPjEsKzMsMT4zLC0yPjEsMj4xLDE+MSwrMixjPjEsMz4xLDE+MSwrMixoPjEsMz4xLGE+MSwxPjEsMj4xLDM+MSwxPjEsZD4xLGY+MSwzPjEsMWE+MSwxPjEsNj4xLDc+MSwxMz4xLGs+MSwxPjEsKzE5LDQ+MSwxPjEsKzIsMj4xLDE+MSwrMTgsbT4xLGE+MSwxPjEsbGs+MSwxPjEsND4xLDI+MSxmPjEsMz4xLDE+MSwrMyxkYj4xLDE+MSwrMywzPjEsMT4xLCsyLDE0cW0+MSwxPjEsKzEsNj4xLDRqPjEsaj4yLHQ+Mix1PjIsMj4xLCsxXCI7XG5cbiAgdmFyIG1pcnJvck1hcDtcblxuICBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gICAgaWYgKCFtaXJyb3JNYXApIHtcbiAgICAgIC8vY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgdmFyIHJlZiA9IHBhcnNlQ2hhcmFjdGVyTWFwKGRhdGEsIHRydWUpO1xuICAgICAgdmFyIG1hcCA9IHJlZi5tYXA7XG4gICAgICB2YXIgcmV2ZXJzZU1hcCA9IHJlZi5yZXZlcnNlTWFwO1xuICAgICAgLy8gQ29tYmluZSBib3RoIG1hcHMgaW50byBvbmVcbiAgICAgIHJldmVyc2VNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBtaXJyb3JNYXAgPSBtYXA7XG4gICAgICAvL2NvbnNvbGUubG9nKGBtaXJyb3JlZCBjaGFycyBwYXJzZWQgaW4gJHtwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0fW1zYClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNaXJyb3JlZENoYXJhY3RlciAoY2hhcikge1xuICAgIHBhcnNlKCk7XG4gICAgcmV0dXJuIG1pcnJvck1hcC5nZXQoY2hhcikgfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgc3RyaW5nIGFuZCBpdHMgcmVzb2x2ZWQgZW1iZWRkaW5nIGxldmVscywgYnVpbGQgYSBtYXAgb2YgaW5kaWNlcyB0byByZXBsYWNlbWVudCBjaGFyc1xuICAgKiBmb3IgYW55IGNoYXJhY3RlcnMgaW4gcmlnaHQtdG8tbGVmdCBzZWdtZW50cyB0aGF0IGhhdmUgZGVmaW5lZCBtaXJyb3JlZCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gc3RyaW5nXG4gICAqIEBwYXJhbSBlbWJlZGRpbmdMZXZlbHNcbiAgICogQHBhcmFtIFtzdGFydF1cbiAgICogQHBhcmFtIFtlbmRdXG4gICAqIEByZXR1cm4ge01hcDxudW1iZXIsIHN0cmluZz59XG4gICAqL1xuICBmdW5jdGlvbiBnZXRNaXJyb3JlZENoYXJhY3RlcnNNYXAoc3RyaW5nLCBlbWJlZGRpbmdMZXZlbHMsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0ID09IG51bGwgPyAwIDogK3N0YXJ0KTtcbiAgICBlbmQgPSBNYXRoLm1pbihzdHJMZW4gLSAxLCBlbmQgPT0gbnVsbCA/IHN0ckxlbiAtIDEgOiArZW5kKTtcblxuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICBpZiAoZW1iZWRkaW5nTGV2ZWxzW2ldICYgMSkgeyAvL29ubHkgb2RkIChydGwpIGxldmVsc1xuICAgICAgICB2YXIgbWlycm9yID0gZ2V0TWlycm9yZWRDaGFyYWN0ZXIoc3RyaW5nW2ldKTtcbiAgICAgICAgaWYgKG1pcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcC5zZXQoaSwgbWlycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBzdGFydCBhbmQgZW5kIGRlbm90aW5nIGEgc2luZ2xlIGxpbmUgd2l0aGluIGEgc3RyaW5nLCBhbmQgYSBzZXQgb2YgcHJlY2FsY3VsYXRlZFxuICAgKiBiaWRpIGVtYmVkZGluZyBsZXZlbHMsIHByb2R1Y2UgYSBsaXN0IG9mIHNlZ21lbnRzIHdob3NlIG9yZGVyaW5nIHNob3VsZCBiZSBmbGlwcGVkLCBpbiBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIHRoZSBmdWxsIGlucHV0IHN0cmluZ1xuICAgKiBAcGFyYW0ge0dldEVtYmVkZGluZ0xldmVsc1Jlc3VsdH0gZW1iZWRkaW5nTGV2ZWxzUmVzdWx0IC0gdGhlIHJlc3VsdCBvYmplY3QgZnJvbSBnZXRFbWJlZGRpbmdMZXZlbHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF0gLSBmaXJzdCBjaGFyYWN0ZXIgaW4gYSBzdWJzZXQgb2YgdGhlIGZ1bGwgc3RyaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXSAtIGxhc3QgY2hhcmFjdGVyIGluIGEgc3Vic2V0IG9mIHRoZSBmdWxsIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJbXVtdfSAtIHRoZSBsaXN0IG9mIHN0YXJ0L2VuZCBzZWdtZW50cyB0aGF0IHNob3VsZCBiZSBmbGlwcGVkLCBpbiBvcmRlci5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlb3JkZXJTZWdtZW50cyhzdHJpbmcsIGVtYmVkZGluZ0xldmVsc1Jlc3VsdCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQgPT0gbnVsbCA/IDAgOiArc3RhcnQpO1xuICAgIGVuZCA9IE1hdGgubWluKHN0ckxlbiAtIDEsIGVuZCA9PSBudWxsID8gc3RyTGVuIC0gMSA6ICtlbmQpO1xuXG4gICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgZW1iZWRkaW5nTGV2ZWxzUmVzdWx0LnBhcmFncmFwaHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYWdyYXBoKSB7XG4gICAgICB2YXIgbGluZVN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIHBhcmFncmFwaC5zdGFydCk7XG4gICAgICB2YXIgbGluZUVuZCA9IE1hdGgubWluKGVuZCwgcGFyYWdyYXBoLmVuZCk7XG4gICAgICBpZiAobGluZVN0YXJ0IDwgbGluZUVuZCkge1xuICAgICAgICAvLyBMb2NhbCBzbGljZSBmb3IgbXV0YXRpb25cbiAgICAgICAgdmFyIGxpbmVMZXZlbHMgPSBlbWJlZGRpbmdMZXZlbHNSZXN1bHQubGV2ZWxzLnNsaWNlKGxpbmVTdGFydCwgbGluZUVuZCArIDEpO1xuXG4gICAgICAgIC8vIDMuNCBMMS40OiBSZXNldCBhbnkgc2VxdWVuY2Ugb2Ygd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGFuZC9vciBpc29sYXRlIGZvcm1hdHRpbmcgY2hhcmFjdGVycyBhdCB0aGVcbiAgICAgICAgLy8gZW5kIG9mIHRoZSBsaW5lIHRvIHRoZSBwYXJhZ3JhcGggbGV2ZWwuXG4gICAgICAgIGZvciAodmFyIGkgPSBsaW5lRW5kOyBpID49IGxpbmVTdGFydCAmJiAoZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tpXSkgJiBUUkFJTElOR19UWVBFUyk7IGktLSkge1xuICAgICAgICAgIGxpbmVMZXZlbHNbaV0gPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMMi4gRnJvbSB0aGUgaGlnaGVzdCBsZXZlbCBmb3VuZCBpbiB0aGUgdGV4dCB0byB0aGUgbG93ZXN0IG9kZCBsZXZlbCBvbiBlYWNoIGxpbmUsIGluY2x1ZGluZyBpbnRlcm1lZGlhdGUgbGV2ZWxzXG4gICAgICAgIC8vIG5vdCBhY3R1YWxseSBwcmVzZW50IGluIHRoZSB0ZXh0LCByZXZlcnNlIGFueSBjb250aWd1b3VzIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgYXQgdGhhdCBsZXZlbCBvciBoaWdoZXIuXG4gICAgICAgIHZhciBtYXhMZXZlbCA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgdmFyIG1pbk9kZExldmVsID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVMZXZlbHMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHZhciBsZXZlbCA9IGxpbmVMZXZlbHNbaSQxXTtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBtYXhMZXZlbCkgeyBtYXhMZXZlbCA9IGxldmVsOyB9XG4gICAgICAgICAgaWYgKGxldmVsIDwgbWluT2RkTGV2ZWwpIHsgbWluT2RkTGV2ZWwgPSBsZXZlbCB8IDE7IH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBsdmwgPSBtYXhMZXZlbDsgbHZsID49IG1pbk9kZExldmVsOyBsdmwtLSkge1xuICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGxpbmVMZXZlbHMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVMZXZlbHNbaSQyXSA+PSBsdmwpIHtcbiAgICAgICAgICAgICAgdmFyIHNlZ1N0YXJ0ID0gaSQyO1xuICAgICAgICAgICAgICB3aGlsZSAoaSQyICsgMSA8IGxpbmVMZXZlbHMubGVuZ3RoICYmIGxpbmVMZXZlbHNbaSQyICsgMV0gPj0gbHZsKSB7XG4gICAgICAgICAgICAgICAgaSQyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGkkMiA+IHNlZ1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChbc2VnU3RhcnQgKyBsaW5lU3RhcnQsIGkkMiArIGxpbmVTdGFydF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlZ21lbnRzXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcGFyYW0ge0dldEVtYmVkZGluZ0xldmVsc1Jlc3VsdH0gZW1iZWRMZXZlbHNSZXN1bHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIG5ldyBzdHJpbmcgd2l0aCBiaWRpIHNlZ21lbnRzIHJlb3JkZXJlZFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmVvcmRlcmVkU3RyaW5nKHN0cmluZywgZW1iZWRMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaW5kaWNlcyA9IGdldFJlb3JkZXJlZEluZGljZXMoc3RyaW5nLCBlbWJlZExldmVsc1Jlc3VsdCwgc3RhcnQsIGVuZCk7XG4gICAgdmFyIGNoYXJzID0gW10uY29uY2F0KCBzdHJpbmcgKTtcbiAgICBpbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYXJJbmRleCwgaSkge1xuICAgICAgY2hhcnNbaV0gPSAoXG4gICAgICAgIChlbWJlZExldmVsc1Jlc3VsdC5sZXZlbHNbY2hhckluZGV4XSAmIDEpID8gZ2V0TWlycm9yZWRDaGFyYWN0ZXIoc3RyaW5nW2NoYXJJbmRleF0pIDogbnVsbFxuICAgICAgKSB8fCBzdHJpbmdbY2hhckluZGV4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqIEBwYXJhbSB7R2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0fSBlbWJlZExldmVsc1Jlc3VsdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7bnVtYmVyW119IGFuIGFycmF5IHdpdGggY2hhcmFjdGVyIGluZGljZXMgaW4gdGhlaXIgbmV3IGJpZGkgb3JkZXJcbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlb3JkZXJlZEluZGljZXMoc3RyaW5nLCBlbWJlZExldmVsc1Jlc3VsdCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzZWdtZW50cyA9IGdldFJlb3JkZXJTZWdtZW50cyhzdHJpbmcsIGVtYmVkTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKTtcbiAgICAvLyBGaWxsIGFuIGFycmF5IHdpdGggaW5kaWNlc1xuICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluZGljZXNbaV0gPSBpO1xuICAgIH1cbiAgICAvLyBSZXZlcnNlIGVhY2ggc2VnbWVudCBpbiBvcmRlclxuICAgIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIHN0YXJ0ID0gcmVmWzBdO1xuICAgICAgdmFyIGVuZCA9IHJlZlsxXTtcblxuICAgICAgdmFyIHNsaWNlID0gaW5kaWNlcy5zbGljZShzdGFydCwgZW5kICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gc2xpY2UubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGluZGljZXNbZW5kIC0gaV0gPSBzbGljZVtpXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaW5kaWNlc1xuICB9XG5cbiAgZXhwb3J0cy5jbG9zaW5nVG9PcGVuaW5nQnJhY2tldCA9IGNsb3NpbmdUb09wZW5pbmdCcmFja2V0O1xuICBleHBvcnRzLmdldEJpZGlDaGFyVHlwZSA9IGdldEJpZGlDaGFyVHlwZTtcbiAgZXhwb3J0cy5nZXRCaWRpQ2hhclR5cGVOYW1lID0gZ2V0QmlkaUNoYXJUeXBlTmFtZTtcbiAgZXhwb3J0cy5nZXRDYW5vbmljYWxCcmFja2V0ID0gZ2V0Q2Fub25pY2FsQnJhY2tldDtcbiAgZXhwb3J0cy5nZXRFbWJlZGRpbmdMZXZlbHMgPSBnZXRFbWJlZGRpbmdMZXZlbHM7XG4gIGV4cG9ydHMuZ2V0TWlycm9yZWRDaGFyYWN0ZXIgPSBnZXRNaXJyb3JlZENoYXJhY3RlcjtcbiAgZXhwb3J0cy5nZXRNaXJyb3JlZENoYXJhY3RlcnNNYXAgPSBnZXRNaXJyb3JlZENoYXJhY3RlcnNNYXA7XG4gIGV4cG9ydHMuZ2V0UmVvcmRlclNlZ21lbnRzID0gZ2V0UmVvcmRlclNlZ21lbnRzO1xuICBleHBvcnRzLmdldFJlb3JkZXJlZEluZGljZXMgPSBnZXRSZW9yZGVyZWRJbmRpY2VzO1xuICBleHBvcnRzLmdldFJlb3JkZXJlZFN0cmluZyA9IGdldFJlb3JkZXJlZFN0cmluZztcbiAgZXhwb3J0cy5vcGVuaW5nVG9DbG9zaW5nQnJhY2tldCA9IG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oe30pKTtcbnJldHVybiBiaWRpfVxuXG5leHBvcnQgZGVmYXVsdCBiaWRpRmFjdG9yeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/bidi-js/dist/bidi.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nconst version = parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\n\n//# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvX3BvbHlmaWxsL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQUNqQyx5QkFBeUIsMkNBQVE7QUFHL0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanM/YzJjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KFJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgXCJcIikpO1xuZXhwb3J0IHtcbiAgdmVyc2lvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-stdlib/_polyfill/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: function() { return /* binding */ MeshoptDecoder; }\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = () => {\n  if (generated)\n    return generated;\n  const wasm_base = \"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\";\n  const wasm_simd = \"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\";\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11\n  ]);\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167\n  ]);\n  if (typeof WebAssembly !== \"object\") {\n    return {\n      supported: false\n    };\n  }\n  let wasm = wasm_base;\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n  }\n  let instance;\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance;\n    instance.exports.__wasm_call_ctors();\n  });\n  function unpack(data) {\n    const result = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i);\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n    }\n    let write = 0;\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n    }\n    return result.buffer.slice(0, write);\n  }\n  function decode(fun, target, count, size, source, filter) {\n    const sbrk = instance.exports.sbrk;\n    const count4 = count + 3 & ~3;\n    const tp = sbrk(count4 * size);\n    const sp = sbrk(source.length);\n    const heap = new Uint8Array(instance.exports.memory.buffer);\n    heap.set(source, sp);\n    const res = fun(tp, count, size, sp, source.length);\n    if (res === 0 && filter) {\n      filter(tp, count4, size);\n    }\n    target.set(heap.subarray(tp, tp + count * size));\n    sbrk(tp - sbrk(0));\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`);\n    }\n  }\n  const filters = {\n    // legacy index-based enums for glTF\n    0: \"\",\n    1: \"meshopt_decodeFilterOct\",\n    2: \"meshopt_decodeFilterQuat\",\n    3: \"meshopt_decodeFilterExp\",\n    // string-based enums for glTF\n    NONE: \"\",\n    OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n    QUATERNION: \"meshopt_decodeFilterQuat\",\n    EXPONENTIAL: \"meshopt_decodeFilterExp\"\n  };\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: \"meshopt_decodeVertexBuffer\",\n    1: \"meshopt_decodeIndexBuffer\",\n    2: \"meshopt_decodeIndexSequence\",\n    // string-based enums for glTF\n    ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n    TRIANGLES: \"meshopt_decodeIndexBuffer\",\n    INDICES: \"meshopt_decodeIndexSequence\"\n  };\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    }\n  };\n  return generated;\n};\n\n//# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbGlicy9NZXNob3B0RGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanM/NTE5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZ2VuZXJhdGVkO1xuY29uc3QgTWVzaG9wdERlY29kZXIgPSAoKSA9PiB7XG4gIGlmIChnZW5lcmF0ZWQpXG4gICAgcmV0dXJuIGdlbmVyYXRlZDtcbiAgY29uc3Qgd2FzbV9iYXNlID0gXCJCOWg5ejl0RkJCQkY4Zkw5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmE5Z0VhYWFGYUVNY0JGRkZHR0dFSUlJTEY5d0ZGRkxFRkJGS05GYUZDeC9JRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJGOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCR3k5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCRW45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQklpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCS0k5ejlpcWxCT2MreDh5Y0dCTS9xUUZUYThqVVVVVUJDVS9FQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHVGtVVVVCUk5DVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSVkFFQ0ZKUklDQlJjR1hFWEFjQUY5UFFGQVZBRkFjbEFjQVZKQUY5SnlSTUdYR1hBRzlGUUJBTUNiSkhLQzl3WlJTQUtDSXJDRUpDR3JSUUFOQ1VHSlJmQ0JSYkFJUlRFWEdYQU9BVGxBUTlQUUJDQlJJU0VNQVRBUUpSSUdYQVM5RlFCQ0JSdENCUkVFWEdYQU9BSWxDaTlQUUJDQlJJU0xNQU5DVS9DQkpBRUpSS0dYR1hHWEdYR1hBVEFFQ0tySjJCQkF0Q0tackNFWmZJQkZHRUJNQUtoQjgzRUJBS0NOSmhCODNFQlNFTUFLQUkyQklBSTJCQkhtQ0tySFlBWUNFNkhZeTg2QkJBS0NGSkFJQ0lKQVlKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDR0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ0VKQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NJSkFZQW1KSFkyQkJBSTJCRkhtQ0tySFBBUENFNkhQeTg2QkJBS0NMSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDS0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ09KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NOSkFZQW1KSFkyQkJBSTJCR0htQ0tySFBBUENFNkhQeTg2QkJBS0NWSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDY0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ01KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NTSkFZQW1KSG0yQkJBSTJCRUhJQ0tySFlBWUNFNkhZeTg2QkJBS0NRSkFtQVlKSG0yQkJBSUNJckNFWkhZQVlDRTZIWXk4NkJCQUtDZkpBbUFZSkhtMkJCQUlDR3JDRVpIWUFZQ0U2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ0VaSElBSUNFNkhJeTg2QkJBS0FJSlJJU0dNQUtBSTJCTkFJMkJCSG1DSXJIWUFZQ2I2SFl5ODZCQkFLQ0ZKQUlDTkpBWUpIWTJCQkFtQ2JaSG1BbUNiNkhteTg2QkJBS0NHSkFZQW1KSG0yQkJBSTJCRkhZQ0lySFBBUENiNkhQeTg2QkJBS0NFSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDSUpBbUFZSkhtMkJCQUkyQkdIWUNJckhQQVBDYjZIUHk4NkJCQUtDTEpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ0tKQW1BWUpIbTJCQkFJMkJFSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ09KQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NOSkFtQVlKSG0yQkJBSTJCSUhZQ0lySFBBUENiNkhQeTg2QkJBS0NWSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDY0pBbUFZSkhtMkJCQUkyQkxIWUNJckhQQVBDYjZIUHk4NkJCQUtDTUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ1NKQW1BWUpIbTJCQkFJMkJLSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1FKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSTJCT0hJQ0lySFlBWUNiNkhZeTg2QkJBS0NiSkFtQVlKSEsyQkJBSUNiWkhJQUlDYjZISXk4NkJCQUtBSUpSSVNGTUFLQUk4cEJCODNCQkFLQ05KQUlDTko4cEJCODNCQkFJQ1RKUklNQXRDR0pSdEFFQ1RKSEVBUzlKUUJNTUdYQUlRQkNCUklTRU1HWEFNOUZRQkFOQWJKMkJCUnRDQlJLQWZSRUVYQUVBTkNVL0NCSkFLSjJCQkhUQ0ZyQ0JBVENGWmw5ekF0Skh0ODZCQkFFQUdKUkVBS0NGSkhLQU05SFFCTU1BZkNGSlJmQUlSVEFiQ0ZKSGJBRzlIUUJNTUFCQWNBRzlzSkFOQ1VHSkFNQUc5c1RrVVVVQnBBTkFOQ1VHSkFNQ2FKQUc5c0pBR1RrVVVVQnBNQU1DQkFJeUFjSlJjQUlRQk1DOStSS1NGTUNCQzk5QU9BSWxBR0NBQUdDQTlMeTZ5UktNQUxDVS9FQko4a1VVVVVCQUtNK09tRlRhOGpVVVVVQkNvRmxITDhrVVVVVUJDOStSS0dYQUZDRTl1SE9DdEpBSTlMUUJDYVJLQUUyQkJITkMvd0ZaQy9nRjlIUUJBTkNiWkhWQ0Y5TFFCQUxDb0JKQ2dGQ1VGVCtKVVVVQnBBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNK2xMS0ZhRjk5R2FHOTlGYUc5OUdYR1hBR0NJOUhRQkFGOUZRRkVYR1hHWDlEQkJCOC85REJCQisvQUJDR0pIRzFCQit5QUIxQkJIRSt5SEkrTCtUQUJDRkpITDFCQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REJCLytoQU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg2QkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg2QkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg2QkJBQkNJSlJCQUZDYUpIRlFCU0dNTUFGOUZRQkVYR1hHWDlEQkJCOC85REJCQisvQUJDSUpIRzh1RkIreUFCOHVGQkhFK3lISStMK1RBQkNHSkhMOHVGQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REIvK2c2QU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg3RkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg3RkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg3RkJBQkNOSlJCQUZDYUpIRlFCTU1NL1NFSUVhRTk5RWFGOTlHWEFGOUZRQkNCUkVBQlJJRVhHWEdYOUQvekk4MTgvQUlDS0o4dUZCSExDRXEreStWSEtBSTh1RkIreStVSE85REIvK2c2K1U5REJCQjgvOURCQkIrL0FPOURCQkJCOWd5K1NITitMOURCQkI5UDlkOUZRQkFOK29SVlNGTUNVVVVVOTRSVk1BSUNJSjh1RkJSY0FJQ0dKOHVGQlJNQUJBTENGSkNFWkFFcUNGV0pBVjg3RkJHWEdYQUtBTSt5K1VITjlEQi8rZzYrVTlEQkJCOC85REJCQisvQU45REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JNU0ZNQ1VVVVU5NFJNTUFCQUxDR0pDRVpBRXFDRldKQU04N0ZCR1hHWEFLQWMreStVSEs5REIvK2c2K1U5REJCQjgvOURCQkIrL0FLOURCQkJCOWd5K1NIUytMOURCQkI5UDlkOUZRQkFTK29SY1NGTUNVVVVVOTRSY01BQkFMQ2FKQ0VaQUVxQ0ZXSkFjODdGQkdYR1g5REJCVTgvQU9BTytVK1RBTkFOK1UrVEFLQUsrVStUSE85REJCQkJBTzlEQkJCQjlneStSOURCLytnNitVOURCQkI4LytTSE8rTDlEQkJCOVA5ZDlGUUJBTytvUmNTRk1DVVVVVTk0UmNNQUJBTENFWkFFcUNGV0pBYzg3RkJBSUNOSlJJQUVDSUpSRUFGQ2FKSEZRQk1NTTlKQkdYQUdDR3JBRjlzSEY5RlFCRVhBQkFCOG9HQkhHQ05XQ045MSt5QUdDaTkxQ25XQ1VVVS84RUorKytVODRHQkFCQ0lKUkJBRkNhSkhGUUJNTU05VEZFYUNCQ0I4b0dVa1VVQkhGQUJDRUpDOThaSkhCakdVa1VVQkdYR1hBQjgvQkNUV0hHdVFCQ2FSRUFCQUdsQ2dnRUpDVHJYQkNhNlFGTUFGUkVNQUVNL2xGRkZhR1hHWEFGQUJxQ0VaOUZRQkFCUkVTRk1HWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBRjhvR0JqR0JBRUNJSkFGQ0lKOG9HQmpHQkFFQ05KQUZDTko4b0dCakdCQUVDU0pBRkNTSjhvR0JqR0JBRUNUSlJFQUZDVEpSRkFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBRjhvR0JqR0JBRkNJSlJGQUVDSUpSRUFHQzk4SkhHQ0U5TFFCTU1HWEFHOUZRQkVYQUVBRjJCQjg2QkJBRUNGSlJFQUZDRkpSRkFHQ2FKSEdRQk1NQUJNb0ZGR2FHWEdYQUJDRVo5RlFCQUJSRVNGTUFGQ2dGWkMrQndzTjlzUklHWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBSWpHQkFFQ1NKQUlqR0JBRUNOSkFJakdCQUVDSUpBSWpHQkFFQ1RKUkVBR0M5d0pIR0NiOUxRQk1NQUdDSTlKUUJFWEFFQUlqR0JBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGODZCQkFFQ0ZKUkVBR0NhSkhHUUJNTUFCTU1NRkJDVU5NSVQ5a0JCXCI7XG4gIGNvbnN0IHdhc21fc2ltZCA9IFwiQjloOXo5dEZCQkJGaUk5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmFFTWNCQkZCRkZHR0dFSUxGOXdGRkZMRUZCRktORmFGQ3gvYUZNTy9MRlZLOXR2OXQ5dnE5NUdCdDlmOWY5MzloOXo5dDlmOWo5aDlzOXM5ZjlqVzl2cTl6QkJwOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OVd2cVd2OTRoOTE5bTltdnFCRzhaOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0aDkxOW05bXZxQkl5OXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0OVR2Wjkxdjl1OWp2QkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UDlqV0JLaTl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVI5MTloV0JPbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOUY5NDl3Qk5JOXo5aXFsQlZjK045SWNJQlRFTTkrRkxhOGpVVVVVQkNUbFJCQ0JSRkVYQ0JSR0NCUkVFWEFCQ05KQUdKQUVDVWFBRkFHckNGWkhJeTg2QkJBRUFJSlJFQUdDRkpIR0NOOUhRQk1BRkN4K1lVVUJKQUU4NkJCQUZDRVdDeGtVVUJKQUI4cEVOODNFQkFGQ0ZKSEZDVUc5SFFCTU1rOGxMYmFFOTdGOStGYUw5NzhqVVVVVUJDVS9LQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHLzhjQkJDVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSTkFFQ0ZKUktDQlJWR1hFWEFWQUY5UFFGQU5BRkFWbEFWQU5KQUY5SnlSY0dYR1hBRzlGUUJBY0NiSkhJQzl3WkhNQ0U5c1JTQU1DRldSUUFJQ0lyQ0VKQ0dyUmZDQlJiRVhBS1JUQ0JSdEdYRVhHWEFPQVRsQWY5UFFCQ0JSS1NMTUFMQ1UvQ0JKQXRBTTlzSlJtQVRBZkpSS0NCUkVHWEFNQ29COUpRQkFPQUtsQy9nQjlKUUJDQlJJRVhBbUFJSlJFR1hHWEdYR1hHWEFUQUlDS3JKMkJCSFlDRVpmSUJGR0VCTUFFQ0JEdERNSUJTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlCQUtDVEpSS01HWEdYR1hHWEdYQVlDR3JDRVpmSUJGR0VCTUFFQ0JEdERNSVRTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlUQUtDVEpSS01HWEdYR1hHWEdYQVlDSXJDRVpmSUJGR0VCTUFFQ0JEdERNSUFTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlBQUtDVEpSS01HWEdYR1hHWEdYQVlDS3JmSUJGR0VCTUFFQ0JEdERNSTh3U0VNQUVBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIWUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JOHdBS0NJSkFlRGVCSkFZQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJBWUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSFlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSTh3QUtDTkpBZURlQkpBWUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUk4d0FLQ1RKUktNQUlDb0JKUkVBSUNVRkpBTTlMUUZBRVJJQU9BS2xDL2ZCOUxRQk1NR1hBRUFNOVBRQkFFQ0VyUklFWEdYQU9BS2xDaTlQUUJDQlJLU09NQW1BRUpSWUdYR1hHWEdYR1hBVEFFQ0tySjJCQkFJQ0tackNFWmZJQkZHRUJNQVlDQkR0RE1JQlNFTUFZQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BWUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BWUFLREJCQkRNSUJBS0NUSlJLTUFJQ0dKUklBRUNUSkhFQU05SlFCTU1HWEFLOUZRQkFLUlRBdENGSkh0Q0k2UUdTRk1NQ0JSS1NFTUdYQU05RlFCQUxDVUdKQWJKUkVBTEFiSkRCR0JSZUNCUllFWEFFQUxDVS9DQkpBWUpISURCSUJIZENGRDl0QWRDRkRiSFBEOU9EOWhEOVJIZEFJQU1KREJJQkg4WkNGRDl0QThaQVBEOU9EOWhEOVJIOFpEUUJURnRHbUVZSVBMZEtlT25IcEFJQVFKREJJQkh5Q0ZEOXRBeUFQRDlPRDloRDlSSHlBSUFTSkRCSUJIOGNDRkQ5dEE4Y0FQRDlPRDloRDlSSDhjRFFCVEZ0R21FWUlQTGRLZU9uSDhkRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUFlRDl1SGVEeUJqR0JBRUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBcEE4ZERRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQWRBOFpEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4ZkhkQXlBOGNEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4Zkg4WkRRQkZUdEdFbVlJTFBkS09lbkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFkQThaRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSlJFQVlDVEpIWUFNOUpRQk1NQWJDSUpIYkFHOUpRQk1NQUJBVkFHOXNKQUxDVUdKQWNBRzlzLzhjQkJBTEFMQ1VHSkFjQ2FKQUc5c0pBRy84Y0JCTUFjQ0JBS3lBVkpSVkFLUUJNQzkrUktTRk1DQkM5OUFPQUtsQUdDQUFHQ0E5THk2eVJLTUFMQ1UvS0JKOGtVVVVVQkFLTU5CVCtCVVVVQk0rS21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUYvOE1CQUxDODRKaGE4M0VCQUxDOHdKaGE4M0VCQUxDOG9KaGE4M0VCQUxDQUpoYTgzRUJBTENpSmhhODNFQkFMQ1RKaGE4M0VCQUxoYTgzRU5BTGhhODNFQkFFQUlKQzl3SlJjQUVDRkpITkFPSlJNR1hBRjlGUUJDUUNiQVZDRjZ5UlNBQlJFQ0JSVkNCUlFDQlJmQ0JSSUNCUktFWEdYQU1BY3VRQkM5K1JLU0VNR1hHWEFOMkJCSE9DL3ZGOUxRQkFMQ29CSkFPQ0lyQ2E5ekFLSkNiWkNFV0pIYjhvR0lSVEFiOG9HQlJ0R1hBT0NiWkhiQVM5UFFCQUxBT0NhOXpBSUpDYlpDR1dKOG9HQkFWQWJ5Uk9BYjlGUmJHWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQU84N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBT2pHQkFFQ0lKQVRqR0JNQVZBYkpSVkFMQ29CSkFLQ0VXSkhtQU9qR0JBbUFUakdJQUxBSUNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSFRBdGpHQkFUQU9qR0lBSUFiSlJJQUtDRkpSS1NHTUdYR1hBYkNiNlFCQVFBYkpBYkM5ODl6SkNGSlJRU0ZNQU0xQkJIYkNnRlpST0dYR1hBYkNhOU1RQkFNQ0ZKUk1TRk1BTTFCRkhiQ2dCWkNPV0FPQ2dCWnFST0dYQWJDYTlNUUJBTUNHSlJNU0ZNQU0xQkdIYkNnQlpDZldBT3FST0dYQWJDYTlNUUJBTUNFSlJNU0ZNQU0xQkVIYkNnQlpDZFdBT3FST0dYQWJDYTlNUUJBTUNJSlJNU0ZNQU0yQklDOGNXQU9xUk9BTUNMSlJNTUFPQ0ZyQ0JBT0NGWmw5ekFRSlJRTUdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBUTg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFRakdCQUVDSUpBVGpHQk1BTENvQkpBS0NFV0pIT0FRakdCQU9BVGpHSUFMQUlDR1dKQVFqR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhPQXRqR0JBT0FRakdJQUlDRkpSSUFLQ0ZKUktTRk1HWEFPQ0RGOUxRQkFMQUlBY0FPQ2JaSjJCQkhiQ0lySFRsQ2JaQ0dXSjhvR0JBVkNGSkh0QVR5Uk9BTEFJQWJsQ2JaQ0dXSjhvR0JBdEFUOUZIbUpIdEFiQ2JaSFR5UmJBVDlGUlRHWEdYQUdDRzlIUUJBQkFWODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFWakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxBSUNHV0pBVmpHQkFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFWakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQW1KQ2JaSElDR1dKQWJqR0JBTENvQkpBS0NHSkNiWkhLQ0VXSkhPQVZqR0JBT0FiakdJQUtDRkpSS0FJQVRKUklBdEFUSlJWU0ZNQVZDQkFNMkJCSFl5SFRBT0MvK0Y2SFBKUk9BWUNiWlJ0R1hHWEFZQ0lySG1RQkFPQ0ZKUmJTRk1BT1JiQUxBSUFtbENiWkNHV0o4b0dCUk9NR1hHWEF0UUJBYkNGSlJWU0ZNQWJSVkFMQUlBWWxDYlpDR1dKOG9HQlJiTUdYR1hBUDlGUUJBTUNGSlJZU0ZNQU0xQkZIWUNnRlpSVEdYR1hBWUNhOU1RQkFNQ0dKUllTRk1BTTFCR0hZQ2dCWkNPV0FUQ2dCWnFSVEdYQVlDYTlNUUJBTUNFSlJZU0ZNQU0xQkVIWUNnQlpDZldBVHFSVEdYQVlDYTlNUUJBTUNJSlJZU0ZNQU0xQklIWUNnQlpDZFdBVHFSVEdYQVlDYTlNUUJBTUNMSlJZU0ZNQU1DS0pSWUFNMkJMQzhjV0FUcVJUTUFUQ0ZyQ0JBVENGWmw5ekFRSkhRUlRNR1hHWEFtQ2I2UUJBWVJQU0ZNQVkxQkJITUNnRlpST0dYR1hBTUNhOU1RQkFZQ0ZKUlBTRk1BWTFCRkhNQ2dCWkNPV0FPQ2dCWnFST0dYQU1DYTlNUUJBWUNHSlJQU0ZNQVkxQkdITUNnQlpDZldBT3FST0dYQU1DYTlNUUJBWUNFSlJQU0ZNQVkxQkVITUNnQlpDZFdBT3FST0dYQU1DYTlNUUJBWUNJSlJQU0ZNQVlDTEpSUEFZMkJJQzhjV0FPcVJPTUFPQ0ZyQ0JBT0NGWmw5ekFRSkhRUk9NR1hHWEF0Q2I2UUJBUFJNU0ZNQVAxQkJITUNnRlpSYkdYR1hBTUNhOU1RQkFQQ0ZKUk1TRk1BUDFCRkhNQ2dCWkNPV0FiQ2dCWnFSYkdYQU1DYTlNUUJBUENHSlJNU0ZNQVAxQkdITUNnQlpDZldBYnFSYkdYQU1DYTlNUUJBUENFSlJNU0ZNQVAxQkVITUNnQlpDZFdBYnFSYkdYQU1DYTlNUUJBUENJSlJNU0ZNQVBDTEpSTUFQMkJJQzhjV0FicVJiTUFiQ0ZyQ0JBYkNGWmw5ekFRSkhRUmJNR1hHWEFHQ0c5SFFCQUJBVDg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVGpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFUakdJQUxBSUNHV0pBVGpHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDR0pDYlpDRVdKSE9BVGpHQkFPQWJqR0lBTEFJQW05RkFtQ2I2cUpISUNiWkNHV0pBYmpHQkFJQXQ5RkF0Q2I2cUpSSUFLQ0VKUktNQU5DRkpSTkFCQ0tKUkJBRUNTSlJFQUtDYlpSS0FJQ2JaUklBZkNFSkhmQUY5SlFCTU1DQkM5OUFNQWM2eVJLTUFMQ29GSjhrVVVVVUJBS00vdElGR2E4alVVVVVCQ1RsUkxDOStSS0dYQUZDTEpBSTlMUUJDYVJLQUUyQkJDLytGWkMvUUY5SFFCQUxoQjgzRU5BRUNGSlJLQUVBSUpDOThKUkVHWEFGOUZRQkdYQUdDRzZRQkVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFMQ05KQUlDRlpDR1dxSEdBSUNHckNCQUlDRnJDRlpsOXpBRzhvR0JKSElqR0JBQkFJakdCQUJDSUpSQkFGQ2FKSEZRQlNHTU1FWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BQkFJQ0dyQ0JBSUNGckNGWmw5ekFMQ05KQUlDRlpDR1dxSEk4b0dCSkhHODdGQkFJQUdqR0JBQkNHSlJCQUZDYUpIRlFCTU1DQkM5OUFLQUU2eVJLTUFLTS9kTEVLOTdGYUY5N0dYR1hBR0NJOUhRQkFGOUZRRkNCUkdFWEFCQUJEQkJCSEVDaUQrckZDaUQrc0ZELzZGSElBRUNORCtyRkNpRCtzRkQvNkZBSUQvZ0ZBRUNURCtyRkNpRCtzRkQvNkZITEQvZ0ZEL2tGRC9sRkhLQ0JEdEQrMkZIT0FJQ1VVVVU5NER0SE5EOU9EOVJEL2tGSEk5REJCLytoRFlBSUFJRC9tRkFLQUtEL21GQUxBT0FMQU5EOU9EOVJEL2tGSElBSUQvbUZEL2tGRC9rRkQvakZEL25GSExEL21GOURCQlg5TERZSE9EL2tGQ2dGRHREOU9BRUNVVVU5NER0RDlPRDlRQUlBTEQvbUZBT0Qva0ZDTkQrckZDVS8rRUR0RDlPRDlRQUtBTEQvbUZBT0Qva0ZDVEQrckZDVVUvOE9EdEQ5T0Q5UURNQkJBQkNUSlJCQUdDSUpIR0FGOUpRQlNHTU1BRjlGUUJDQlJHRVhBQkNUSkhWQVZEQkJCSEVDQkR0SE9DVVU5OEQ4Y0ZDVVU5OEQ4Y0VITkQ5T0FCREJCQkhLQUVEUUlMS09TUWZiUGRlbjhjOGQ4ZThmQ2dnRkR0RDlPRC82RkFLQUVEUUJGR0VOVmNNVHRtWWk4WnB5SEVDVEQrc0ZELzZGSElEL2dGQUVDVEQrckZDVEQrc0ZELzZGSExEL2dGRC9rRkQvbEZIRTlEQi8rZzZEWUFMQUVBT0QrMkZIT0FMQ1VVVVU5NER0SGNEOU9EOVJEL2tGSExBTEQvbUZBRUFFRC9tRkFJQU9BSUFjRDlPRDlSRC9rRkhFQUVEL21GRC9rRkQva0ZEL2pGRC9uRkhJRC9tRjlEQkJYOUxEWUhPRC9rRkNURCtyRkFMQUlEL21GQU9EL2tGQ2dnRUR0RDlPRDlRSExBRUFJRC9tRkFPRC9rRkNhRGJDQkRuR0NCRG5FQ0JEbktDQkRuT0NCRG5jQ0JEbk1DQkRuZkNCRG5iRDlPSEVEUU5WaThaY01weVNROGM4ZGZiOGU4ZkQ5UURNQkJBQkFLQU5EOU9BTEFFRFFCRlR0R0VtWUlMUGRLT2VuRDlRRE1CQkFCQ0FKUkJBR0NJSkhHQUY5SlFCTU1NL2hFSUdhRjk3RmFMOTc4alVVVVVCQ1RsUkVHWEFGOUZRQkNCUklFWEFFQUJEQkJCSExBQkNUSkhLREJCQkhPRFFJTEtPU1FmYlBkZW44YzhkOGU4ZkhOQ1REK3NGSFZDSUQrckZETUlCQUI5REJCVTgvRFk5RC96STgxOC9EWUFWQ0VEdEQ5UUQvNkZEL25GSFZBTEFPRFFCRkdFTlZjTVR0bVlpOFpweUhMQ1REK3JGQ1REK3NGRC82RkQvbUZIT0FPRC9tRkFWQUxDVEQrc0ZELzZGRC9tRkhjQWNEL21GQVZBTkNURCtyRkNURCtzRkQvNkZEL21GSE5BTkQvbUZEL2tGRC9rRkQvbEZDQkR0RCs0RkQvakY5REIvK2c2RFlIVkQvbUY5REJCWDlMRFlITEQva0ZDZ2dFRHRITUQ5T0FjQVZEL21GQUxEL2tGQ1REK3JGRDlRSGNBTkFWRC9tRkFMRC9rRkNURCtyRkFPQVZEL21GQUxEL2tGQU1EOU9EOVFIVkRRQkZUdEdFbVlJTFBkS09lbkhMRDhkQkFFREJJQkR5Qit0K0o4M0VCQUJDTkpBTEQ4ZEZBRURCSUJEeUYrdCtKODNFQkFLQWNBVkRRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFZEOGRCQUVEQklCRHlHK3QrSjgzRUJBQkNpSkFWRDhkRkFFREJJQkR5RSt0K0o4M0VCQUJDQUpSQkFJQ0lKSElBRjlKUUJNTU05akZGOTdHWEFHQ0dyQUY5c0hHOUZRQkNCUkZFWEFCQUJEQkJCSEVDTkQrckZDTkQrc0ZELzZGQUVDaUQrc0ZDbkQrckZDVVVVLzhFRHREK3VGRC9tRkRNQkJBQkNUSlJCQUZDSUpIRkFHOUpRQk1NTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU1NTUZCQ1VOTUlUOXRCQlwiO1xuICBjb25zdCBkZXRlY3RvciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAwLFxuICAgIDk3LFxuICAgIDExNSxcbiAgICAxMDksXG4gICAgMSxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxLFxuICAgIDQsXG4gICAgMSxcbiAgICA5NixcbiAgICAwLFxuICAgIDAsXG4gICAgMyxcbiAgICAzLFxuICAgIDIsXG4gICAgMCxcbiAgICAwLFxuICAgIDUsXG4gICAgMyxcbiAgICAxLFxuICAgIDAsXG4gICAgMSxcbiAgICAxMixcbiAgICAxLFxuICAgIDAsXG4gICAgMTAsXG4gICAgMjIsXG4gICAgMixcbiAgICAxMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDI1MixcbiAgICAxMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMTEsXG4gICAgNyxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgMjUzLFxuICAgIDE1LFxuICAgIDI2LFxuICAgIDExXG4gIF0pO1xuICBjb25zdCB3YXNtcGFjayA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAzMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDI1MyxcbiAgICAzLFxuICAgIDEsXG4gICAgMixcbiAgICAzNCxcbiAgICA0LFxuICAgIDEwNixcbiAgICA2LFxuICAgIDUsXG4gICAgMTEsXG4gICAgOCxcbiAgICA3LFxuICAgIDIwLFxuICAgIDEzLFxuICAgIDMzLFxuICAgIDEyLFxuICAgIDE2LFxuICAgIDEyOCxcbiAgICA5LFxuICAgIDExNixcbiAgICA2NCxcbiAgICAxOSxcbiAgICAxMTMsXG4gICAgMTI3LFxuICAgIDE1LFxuICAgIDEwLFxuICAgIDIxLFxuICAgIDIyLFxuICAgIDE0LFxuICAgIDI1NSxcbiAgICA2NixcbiAgICAyNCxcbiAgICA1NCxcbiAgICAxMzYsXG4gICAgMTA3LFxuICAgIDE4LFxuICAgIDIzLFxuICAgIDE5MixcbiAgICAyNixcbiAgICAxMTQsXG4gICAgMTE4LFxuICAgIDEzMixcbiAgICAxNyxcbiAgICA3NyxcbiAgICAxMDEsXG4gICAgMTMwLFxuICAgIDE0NCxcbiAgICAyNyxcbiAgICA4NyxcbiAgICAxMzEsXG4gICAgNDQsXG4gICAgNDUsXG4gICAgNzQsXG4gICAgMTU2LFxuICAgIDE1NCxcbiAgICA3MCxcbiAgICAxNjdcbiAgXSk7XG4gIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VwcG9ydGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgbGV0IHdhc20gPSB3YXNtX2Jhc2U7XG4gIGlmIChXZWJBc3NlbWJseS52YWxpZGF0ZShkZXRlY3RvcikpIHtcbiAgICB3YXNtID0gd2FzbV9zaW1kO1xuICB9XG4gIGxldCBpbnN0YW5jZTtcbiAgY29uc3QgcHJvbWlzZSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHVucGFjayh3YXNtKSwge30pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgIGluc3RhbmNlID0gcmVzdWx0Lmluc3RhbmNlO1xuICAgIGluc3RhbmNlLmV4cG9ydHMuX193YXNtX2NhbGxfY3RvcnMoKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHVucGFjayhkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY2ggPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICByZXN1bHRbaV0gPSBjaCA+IDk2ID8gY2ggLSA3MSA6IGNoID4gNjQgPyBjaCAtIDY1IDogY2ggPiA0NyA/IGNoICsgNCA6IGNoID4gNDYgPyA2MyA6IDYyO1xuICAgIH1cbiAgICBsZXQgd3JpdGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0W3dyaXRlKytdID0gcmVzdWx0W2ldIDwgNjAgPyB3YXNtcGFja1tyZXN1bHRbaV1dIDogKHJlc3VsdFtpXSAtIDYwKSAqIDY0ICsgcmVzdWx0WysraV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuYnVmZmVyLnNsaWNlKDAsIHdyaXRlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUoZnVuLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGZpbHRlcikge1xuICAgIGNvbnN0IHNicmsgPSBpbnN0YW5jZS5leHBvcnRzLnNicms7XG4gICAgY29uc3QgY291bnQ0ID0gY291bnQgKyAzICYgfjM7XG4gICAgY29uc3QgdHAgPSBzYnJrKGNvdW50NCAqIHNpemUpO1xuICAgIGNvbnN0IHNwID0gc2Jyayhzb3VyY2UubGVuZ3RoKTtcbiAgICBjb25zdCBoZWFwID0gbmV3IFVpbnQ4QXJyYXkoaW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKTtcbiAgICBoZWFwLnNldChzb3VyY2UsIHNwKTtcbiAgICBjb25zdCByZXMgPSBmdW4odHAsIGNvdW50LCBzaXplLCBzcCwgc291cmNlLmxlbmd0aCk7XG4gICAgaWYgKHJlcyA9PT0gMCAmJiBmaWx0ZXIpIHtcbiAgICAgIGZpbHRlcih0cCwgY291bnQ0LCBzaXplKTtcbiAgICB9XG4gICAgdGFyZ2V0LnNldChoZWFwLnN1YmFycmF5KHRwLCB0cCArIGNvdW50ICogc2l6ZSkpO1xuICAgIHNicmsodHAgLSBzYnJrKDApKTtcbiAgICBpZiAocmVzICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBidWZmZXIgZGF0YTogJHtyZXN9YCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbHRlcnMgPSB7XG4gICAgLy8gbGVnYWN5IGluZGV4LWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgMDogXCJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgMjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICAzOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyRXhwXCIsXG4gICAgLy8gc3RyaW5nLWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgTk9ORTogXCJcIixcbiAgICBPQ1RBSEVEUkFMOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgUVVBVEVSTklPTjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICBFWFBPTkVOVElBTDogXCJtZXNob3B0X2RlY29kZUZpbHRlckV4cFwiXG4gIH07XG4gIGNvbnN0IGRlY29kZXJzID0ge1xuICAgIC8vIGxlZ2FjeSBpbmRleC1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIDA6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXJcIixcbiAgICAyOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZVwiLFxuICAgIC8vIHN0cmluZy1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIEFUVFJJQlVURVM6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICBUUklBTkdMRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlclwiLFxuICAgIElORElDRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlXCJcbiAgfTtcbiAgZ2VuZXJhdGVkID0ge1xuICAgIHJlYWR5OiBwcm9taXNlLFxuICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICBkZWNvZGVWZXJ0ZXhCdWZmZXIodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlLCBmaWx0ZXIpIHtcbiAgICAgIGRlY29kZShcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlcixcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpIHtcbiAgICAgIGRlY29kZShpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXIsIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleFNlcXVlbmNlKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICAgICAgZGVjb2RlKGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpO1xuICAgIH0sXG4gICAgZGVjb2RlR2x0ZkJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIG1vZGUsIGZpbHRlcikge1xuICAgICAgZGVjb2RlKFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2RlY29kZXJzW21vZGVdXSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZ2VuZXJhdGVkO1xufTtcbmV4cG9ydCB7XG4gIE1lc2hvcHREZWNvZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaG9wdERlY29kZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: function() { return /* binding */ DRACOLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((worker) => worker._taskLoad)\n    );\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\n//# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9EUkFDT0xvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0RTtBQUM1RTtBQUNBLDBCQUEwQix5Q0FBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyw2QkFBNkIsZ0RBQWdEO0FBQzdFLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBYztBQUN2QztBQUNBLDRCQUE0QixrREFBZTtBQUMzQztBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0RBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQWlEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQ0FBMEM7QUFDekUsWUFBWTtBQUNaO0FBQ0EsK0JBQStCLHFEQUFxRDtBQUNwRixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0RSQUNPTG9hZGVyLmpzP2VmY2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBGaWxlTG9hZGVyLCBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCBfdGFza0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBEUkFDT0xvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLmRlY29kZXJQYXRoID0gXCJcIjtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSB7fTtcbiAgICB0aGlzLmRlY29kZXJCaW5hcnkgPSBudWxsO1xuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBudWxsO1xuICAgIHRoaXMud29ya2VyTGltaXQgPSA0O1xuICAgIHRoaXMud29ya2VyUG9vbCA9IFtdO1xuICAgIHRoaXMud29ya2VyTmV4dFRhc2tJRCA9IDE7XG4gICAgdGhpcy53b3JrZXJTb3VyY2VVUkwgPSBcIlwiO1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBcIlBPU0lUSU9OXCIsXG4gICAgICBub3JtYWw6IFwiTk9STUFMXCIsXG4gICAgICBjb2xvcjogXCJDT0xPUlwiLFxuICAgICAgdXY6IFwiVEVYX0NPT1JEXCJcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzID0ge1xuICAgICAgcG9zaXRpb246IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBub3JtYWw6IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBjb2xvcjogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIHV2OiBcIkZsb2F0MzJBcnJheVwiXG4gICAgfTtcbiAgfVxuICBzZXREZWNvZGVyUGF0aChwYXRoKSB7XG4gICAgdGhpcy5kZWNvZGVyUGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0RGVjb2RlckNvbmZpZyhjb25maWcpIHtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSBjb25maWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0V29ya2VyTGltaXQod29ya2VyTGltaXQpIHtcbiAgICB0aGlzLndvcmtlckxpbWl0ID0gd29ya2VyTGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIChidWZmZXIpID0+IHtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IHtcbiAgICAgICAgICBhdHRyaWJ1dGVJRHM6IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlczogdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICAgICAgdXNlVW5pcXVlSURzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihvbkxvYWQpLmNhdGNoKG9uRXJyb3IpO1xuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbkVycm9yXG4gICAgKTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgS2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIERSQUNPTG9hZGVyIHZlcnNpb25zLiAqL1xuICBkZWNvZGVEcmFjb0ZpbGUoYnVmZmVyLCBjYWxsYmFjaywgYXR0cmlidXRlSURzLCBhdHRyaWJ1dGVUeXBlcykge1xuICAgIGNvbnN0IHRhc2tDb25maWcgPSB7XG4gICAgICBhdHRyaWJ1dGVJRHM6IGF0dHJpYnV0ZUlEcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMsXG4gICAgICBhdHRyaWJ1dGVUeXBlczogYXR0cmlidXRlVHlwZXMgfHwgdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICB1c2VVbmlxdWVJRHM6ICEhYXR0cmlidXRlSURzXG4gICAgfTtcbiAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcykge1xuICAgICAgY29uc3QgdHlwZSA9IHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlXTtcbiAgICAgIGlmICh0eXBlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVdID0gdHlwZS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXNrS2V5ID0gSlNPTi5zdHJpbmdpZnkodGFza0NvbmZpZyk7XG4gICAgaWYgKF90YXNrQ2FjaGUuaGFzKGJ1ZmZlcikpIHtcbiAgICAgIGNvbnN0IGNhY2hlZFRhc2sgPSBfdGFza0NhY2hlLmdldChidWZmZXIpO1xuICAgICAgaWYgKGNhY2hlZFRhc2sua2V5ID09PSB0YXNrS2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRUYXNrLnByb21pc2U7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmFibGUgdG8gcmUtZGVjb2RlIGEgYnVmZmVyIHdpdGggZGlmZmVyZW50IHNldHRpbmdzLiBCdWZmZXIgaGFzIGFscmVhZHkgYmVlbiB0cmFuc2ZlcnJlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd29ya2VyO1xuICAgIGNvbnN0IHRhc2tJRCA9IHRoaXMud29ya2VyTmV4dFRhc2tJRCsrO1xuICAgIGNvbnN0IHRhc2tDb3N0ID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZ2VvbWV0cnlQZW5kaW5nID0gdGhpcy5fZ2V0V29ya2VyKHRhc2tJRCwgdGFza0Nvc3QpLnRoZW4oKF93b3JrZXIpID0+IHtcbiAgICAgIHdvcmtlciA9IF93b3JrZXI7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJkZWNvZGVcIiwgaWQ6IHRhc2tJRCwgdGFza0NvbmZpZywgYnVmZmVyIH0sIFtidWZmZXJdKTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKG1lc3NhZ2UpID0+IHRoaXMuX2NyZWF0ZUdlb21ldHJ5KG1lc3NhZ2UuZ2VvbWV0cnkpKTtcbiAgICBnZW9tZXRyeVBlbmRpbmcuY2F0Y2goKCkgPT4gdHJ1ZSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAod29ya2VyICYmIHRhc2tJRCkge1xuICAgICAgICB0aGlzLl9yZWxlYXNlVGFzayh3b3JrZXIsIHRhc2tJRCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3Rhc2tDYWNoZS5zZXQoYnVmZmVyLCB7XG4gICAgICBrZXk6IHRhc2tLZXksXG4gICAgICBwcm9taXNlOiBnZW9tZXRyeVBlbmRpbmdcbiAgICB9KTtcbiAgICByZXR1cm4gZ2VvbWV0cnlQZW5kaW5nO1xuICB9XG4gIF9jcmVhdGVHZW9tZXRyeShnZW9tZXRyeURhdGEpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeURhdGEuaW5kZXgpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KG5ldyBCdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnlEYXRhLmluZGV4LmFycmF5LCAxKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgY29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgX2xvYWRMaWJyYXJ5KHVybCwgcmVzcG9uc2VUeXBlKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLmRlY29kZXJQYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKHJlc3BvbnNlVHlwZSk7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgcmVzb2x2ZSwgdm9pZCAwLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHByZWxvYWQoKSB7XG4gICAgdGhpcy5faW5pdERlY29kZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaW5pdERlY29kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGVjb2RlclBlbmRpbmcpXG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVyUGVuZGluZztcbiAgICBjb25zdCB1c2VKUyA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIiB8fCB0aGlzLmRlY29kZXJDb25maWcudHlwZSA9PT0gXCJqc1wiO1xuICAgIGNvbnN0IGxpYnJhcmllc1BlbmRpbmcgPSBbXTtcbiAgICBpZiAodXNlSlMpIHtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIuanNcIiwgXCJ0ZXh0XCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fd2FzbV93cmFwcGVyLmpzXCIsIFwidGV4dFwiKSk7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb19kZWNvZGVyLndhc21cIiwgXCJhcnJheWJ1ZmZlclwiKSk7XG4gICAgfVxuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBQcm9taXNlLmFsbChsaWJyYXJpZXNQZW5kaW5nKS50aGVuKChsaWJyYXJpZXMpID0+IHtcbiAgICAgIGNvbnN0IGpzQ29udGVudCA9IGxpYnJhcmllc1swXTtcbiAgICAgIGlmICghdXNlSlMpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVyQ29uZmlnLndhc21CaW5hcnkgPSBsaWJyYXJpZXNbMV07XG4gICAgICB9XG4gICAgICBjb25zdCBmbiA9IERSQUNPV29ya2VyLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBib2R5ID0gW1xuICAgICAgICBcIi8qIGRyYWNvIGRlY29kZXIgKi9cIixcbiAgICAgICAganNDb250ZW50LFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIi8qIHdvcmtlciAqL1wiLFxuICAgICAgICBmbi5zdWJzdHJpbmcoZm4uaW5kZXhPZihcIntcIikgKyAxLCBmbi5sYXN0SW5kZXhPZihcIn1cIikpXG4gICAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgICB0aGlzLndvcmtlclNvdXJjZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2JvZHldKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlclBlbmRpbmc7XG4gIH1cbiAgX2dldFdvcmtlcih0YXNrSUQsIHRhc2tDb3N0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXREZWNvZGVyKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAodGhpcy53b3JrZXJQb29sLmxlbmd0aCA8IHRoaXMud29ya2VyTGltaXQpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyMiA9IG5ldyBXb3JrZXIodGhpcy53b3JrZXJTb3VyY2VVUkwpO1xuICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgd29ya2VyMi5fdGFza0Nvc3RzID0ge307XG4gICAgICAgIHdvcmtlcjIuX3Rhc2tMb2FkID0gMDtcbiAgICAgICAgd29ya2VyMi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiaW5pdFwiLCBkZWNvZGVyQ29uZmlnOiB0aGlzLmRlY29kZXJDb25maWcgfSk7XG4gICAgICAgIHdvcmtlcjIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG4gICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZWNvZGVcIjpcbiAgICAgICAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzW21lc3NhZ2UuaWRdLnJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrc1ttZXNzYWdlLmlkXS5yZWplY3QobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgbWVzc2FnZSwgXCInICsgbWVzc2FnZS50eXBlICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclBvb2wucHVzaCh3b3JrZXIyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5fdGFza0xvYWQgPiBiLl90YXNrTG9hZCA/IC0xIDogMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlclBvb2xbdGhpcy53b3JrZXJQb29sLmxlbmd0aCAtIDFdO1xuICAgICAgd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXSA9IHRhc2tDb3N0O1xuICAgICAgd29ya2VyLl90YXNrTG9hZCArPSB0YXNrQ29zdDtcbiAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfSk7XG4gIH1cbiAgX3JlbGVhc2VUYXNrKHdvcmtlciwgdGFza0lEKSB7XG4gICAgd29ya2VyLl90YXNrTG9hZCAtPSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICB9XG4gIGRlYnVnKCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJUYXNrIGxvYWQ6IFwiLFxuICAgICAgdGhpcy53b3JrZXJQb29sLm1hcCgod29ya2VyKSA9PiB3b3JrZXIuX3Rhc2tMb2FkKVxuICAgICk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud29ya2VyUG9vbC5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy53b3JrZXJQb29sW2ldLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLndvcmtlclBvb2wubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gRFJBQ09Xb3JrZXIoKSB7XG4gIGxldCBkZWNvZGVyQ29uZmlnO1xuICBsZXQgZGVjb2RlclBlbmRpbmc7XG4gIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhO1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlIFwiaW5pdFwiOlxuICAgICAgICBkZWNvZGVyQ29uZmlnID0gbWVzc2FnZS5kZWNvZGVyQ29uZmlnO1xuICAgICAgICBkZWNvZGVyUGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICBkZWNvZGVyQ29uZmlnLm9uTW9kdWxlTG9hZGVkID0gZnVuY3Rpb24oZHJhY28pIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyBkcmFjbyB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIERyYWNvRGVjb2Rlck1vZHVsZShkZWNvZGVyQ29uZmlnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlY29kZVwiOlxuICAgICAgICBjb25zdCBidWZmZXIgPSBtZXNzYWdlLmJ1ZmZlcjtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IG1lc3NhZ2UudGFza0NvbmZpZztcbiAgICAgICAgZGVjb2RlclBlbmRpbmcudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZHJhY28gPSBtb2R1bGUuZHJhY287XG4gICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBkcmFjby5EZWNvZGVyKCk7XG4gICAgICAgICAgY29uc3QgZGVjb2RlckJ1ZmZlciA9IG5ldyBkcmFjby5EZWNvZGVyQnVmZmVyKCk7XG4gICAgICAgICAgZGVjb2RlckJ1ZmZlci5Jbml0KG5ldyBJbnQ4QXJyYXkoYnVmZmVyKSwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gYXR0ci5hcnJheS5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4KVxuICAgICAgICAgICAgICBidWZmZXJzLnB1c2goZ2VvbWV0cnkuaW5kZXguYXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImRlY29kZVwiLCBpZDogbWVzc2FnZS5pZCwgZ2VvbWV0cnkgfSwgYnVmZmVycyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXJyb3JcIiwgaWQ6IG1lc3NhZ2UuaWQsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkcmFjby5kZXN0cm95KGRlY29kZXJCdWZmZXIpO1xuICAgICAgICAgICAgZHJhY28uZGVzdHJveShkZWNvZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgY29uc3QgYXR0cmlidXRlSURzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVJRHM7XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZXMgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzO1xuICAgIGxldCBkcmFjb0dlb21ldHJ5O1xuICAgIGxldCBkZWNvZGluZ1N0YXR1cztcbiAgICBjb25zdCBnZW9tZXRyeVR5cGUgPSBkZWNvZGVyLkdldEVuY29kZWRHZW9tZXRyeVR5cGUoZGVjb2RlckJ1ZmZlcik7XG4gICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLk1lc2goKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb01lc2goZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlBPSU5UX0NMT1VEKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLlBvaW50Q2xvdWQoKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb1BvaW50Q2xvdWQoZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIGdlb21ldHJ5IHR5cGUuXCIpO1xuICAgIH1cbiAgICBpZiAoIWRlY29kaW5nU3RhdHVzLm9rKCkgfHwgZHJhY29HZW9tZXRyeS5wdHIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBEZWNvZGluZyBmYWlsZWQ6IFwiICsgZGVjb2RpbmdTdGF0dXMuZXJyb3JfbXNnKCkpO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeSA9IHsgaW5kZXg6IG51bGwsIGF0dHJpYnV0ZXM6IFtdIH07XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZUlEcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlVHlwZSA9IHNlbGZbYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgbGV0IGF0dHJpYnV0ZTtcbiAgICAgIGxldCBhdHRyaWJ1dGVJRDtcbiAgICAgIGlmICh0YXNrQ29uZmlnLnVzZVVuaXF1ZUlEcykge1xuICAgICAgICBhdHRyaWJ1dGVJRCA9IGF0dHJpYnV0ZUlEc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZUlEID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVJZChkcmFjb0dlb21ldHJ5LCBkcmFjb1thdHRyaWJ1dGVJRHNbYXR0cmlidXRlTmFtZV1dKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZUlEID09PSAtMSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGUoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSUQpO1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wdXNoKGRlY29kZUF0dHJpYnV0ZShkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlKSk7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlRSSUFOR1VMQVJfTUVTSCkge1xuICAgICAgZ2VvbWV0cnkuaW5kZXggPSBkZWNvZGVJbmRleChkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfVxuICAgIGRyYWNvLmRlc3Ryb3koZHJhY29HZW9tZXRyeSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUluZGV4KGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5KSB7XG4gICAgY29uc3QgbnVtRmFjZXMgPSBkcmFjb0dlb21ldHJ5Lm51bV9mYWNlcygpO1xuICAgIGNvbnN0IG51bUluZGljZXMgPSBudW1GYWNlcyAqIDM7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IG51bUluZGljZXMgKiA0O1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRUcmlhbmdsZXNVSW50MzJBcnJheShkcmFjb0dlb21ldHJ5LCBieXRlTGVuZ3RoLCBwdHIpO1xuICAgIGNvbnN0IGluZGV4ID0gbmV3IFVpbnQzMkFycmF5KGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bUluZGljZXMpLnNsaWNlKCk7XG4gICAgZHJhY28uX2ZyZWUocHRyKTtcbiAgICByZXR1cm4geyBhcnJheTogaW5kZXgsIGl0ZW1TaXplOiAxIH07XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlQXR0cmlidXRlKGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gYXR0cmlidXRlLm51bV9jb21wb25lbnRzKCk7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gZHJhY29HZW9tZXRyeS5udW1fcG9pbnRzKCk7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gbnVtUG9pbnRzICogbnVtQ29tcG9uZW50cztcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gbnVtVmFsdWVzICogYXR0cmlidXRlVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdldERyYWNvRGF0YVR5cGUoZHJhY28sIGF0dHJpYnV0ZVR5cGUpO1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlLCBkYXRhVHlwZSwgYnl0ZUxlbmd0aCwgcHRyKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBhdHRyaWJ1dGVUeXBlKGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bVZhbHVlcykuc2xpY2UoKTtcbiAgICBkcmFjby5fZnJlZShwdHIpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgYXJyYXksXG4gICAgICBpdGVtU2l6ZTogbnVtQ29tcG9uZW50c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJhY29EYXRhVHlwZShkcmFjbywgYXR0cmlidXRlVHlwZSkge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlVHlwZSkge1xuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9GTE9BVDMyO1xuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQ4O1xuICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UMTY7XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQzMjtcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQ4O1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQxNjtcbiAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMzI7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBEUkFDT0xvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURSQUNPTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-stdlib/loaders/DRACOLoader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: function() { return /* binding */ GLTFLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(app-pages-browser)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(app-pages-browser)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\n\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureAVIFExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIridescenceExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshGpuInstancing(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      resourcePath = this.path;\n    } else {\n      resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function(gltf) {\n              onLoad(gltf);\n              scope.manager.itemEnd(url);\n            },\n            _onError\n          );\n        } catch (e) {\n          _onError(e);\n        }\n      },\n      onProgress,\n      _onError\n    );\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let json;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      json = JSON.parse(data);\n    } else if (data instanceof ArrayBuffer) {\n      const magic = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4)));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError)\n            onError(error);\n          return;\n        }\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n      } else {\n        json = JSON.parse(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data)));\n      }\n    } else {\n      json = data;\n    }\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError)\n        onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency)\n      return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n    if (lightDef.color !== void 0)\n      color.fromArray(lightDef.color);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    assignExtrasToUserData(lightNode, lightDef);\n    if (lightDef.intensity !== void 0)\n      lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  getDependency(type, index) {\n    if (type !== \"light\")\n      return;\n    return this._loadLight(index);\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0)\n      return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.iridescenceFactor !== void 0) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n    if (extension.iridescenceTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n    }\n    if (extension.iridescenceIor !== void 0) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n    if (materialParams.iridescenceThicknessRange === void 0) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n    if (extension.iridescenceThicknessMinimum !== void 0) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n    if (extension.iridescenceThicknessMaximum !== void 0) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n    if (extension.iridescenceThicknessTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      materialParams.sheenColor.fromArray(extension.sheenColorFactor);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, 3001));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(colorArray[0], colorArray[1], colorArray[2]);\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(colorArray[0], colorArray[1], colorArray[2]);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, 3001)\n        // sRGBEncoding\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.anisotropyStrength !== void 0) {\n      materialParams.anisotropy = extension.anisotropyStrength;\n    }\n    if (extension.anisotropyRotation !== void 0) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation;\n    }\n    if (extension.anisotropyTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return buffer.then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n            return res2.buffer;\n          });\n        } else {\n          return decoder.ready.then(function() {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter\n            );\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n}\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n    this.parser = parser;\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n      return null;\n    }\n    const meshDef = json.meshes[nodeDef.mesh];\n    for (const primitive of meshDef.primitives) {\n      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n        return null;\n      }\n    }\n    const extensionDef = nodeDef.extensions[this.name];\n    const attributesDef = extensionDef.attributes;\n    const pending = [];\n    const attributes = {};\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor;\n          return attributes[key];\n        })\n      );\n    }\n    if (pending.length < 1) {\n      return null;\n    }\n    pending.push(this.parser.createNodeMesh(nodeIndex));\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop();\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\n      const count = results[0].count;\n      const instancedMeshes = [];\n      for (const mesh of meshes) {\n        const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\n          }\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i);\n          }\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i);\n          }\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n        }\n        for (const attributeName in attributes) {\n          if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n          }\n        }\n        three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n        this.parser.assignFinalMaterial(instancedMesh);\n        instancedMeshes.push(instancedMesh);\n      }\n      if (nodeObject.isGroup) {\n        nodeObject.clear();\n        nodeObject.add(...instancedMeshes);\n        return nodeObject;\n      }\n      return instancedMeshes[0];\n    });\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function(geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName];\n              const normalized = attributeNormalizedMap[attributeName];\n              if (normalized !== void 0)\n                attribute.normalized = normalized;\n            }\n            resolve(geometry);\n          },\n          threeAttributeMap,\n          attributeTypeMap\n        );\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.texCoord !== void 0) {\n      texture.channel = transform.texCoord;\n    }\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p;\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride];\n      const m0 = values[offset0 + i + stride2] * td;\n      const p1 = values[offset1 + i + stride];\n      const m1 = values[offset1 + i] * td;\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  }\n}\nconst _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n  9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n  9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n  9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n  9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n  9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n  33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n  10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__.version >= 152 ? {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\"\n  } : {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv2\"\n  },\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n  STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n  if (cache[\"DefaultMaterial\"] === void 0) {\n    cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n    });\n  }\n  return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0)\n      hasMorphPosition = true;\n    if (target.NORMAL !== void 0)\n      hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0)\n      hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor)\n      break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)\n    return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition)\n      geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal)\n      geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor)\n      geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey;\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  if (primitiveDef.targets !== void 0) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n    }\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0)\n    return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0)\n    return \"image/webp\";\n  return \"image/png\";\n}\nconst _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */ new Map();\n    this.primitiveCache = {};\n    this.nodeCache = {};\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    let isSafari = false;\n    let isFirefox = false;\n    let firefoxVersion = -1;\n    if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n      isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    }\n    if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this.nodeCache = {};\n    this._invokeAll(function(ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(\n      this._invokeAll(function(ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      })\n    ).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      Promise.all(\n        parser._invokeAll(function(ext) {\n          return ext.afterRoot && ext.afterRoot(result);\n        })\n      ).then(function() {\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === void 0)\n      return;\n    if (cache.refs[index] === void 0) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1)\n      return object;\n    const ref = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref);\n    ref.name += \"_instance_\" + cache.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        pending.push(result);\n    }\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadNode && ext.loadNode(index);\n          });\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          dependency = this._invokeOne(function(ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index);\n          });\n          if (!dependency) {\n            throw new Error(\"Unknown type: \" + type);\n          }\n          break;\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(\n        defs.map(function(def, index) {\n          return parser.getDependency(type, index);\n        })\n      );\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const normalized = accessorDef.normalized === true;\n      const array = new TypedArray(accessorDef.count * itemSize);\n      return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          byteOffset % byteStride / elementBytes,\n          normalized\n        );\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices\n        );\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized\n          );\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n      texture.flipY = false;\n      texture.name = textureDef.name || sourceDef.name || \"\";\n      if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n        texture.name = sourceDef.uri;\n      }\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      parser.associations.set(texture, { textures: textureIndex });\n      return texture;\n    }).catch(function() {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function(error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, encoding) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (!texture)\n        return null;\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n        texture = texture.clone();\n        texture.channel = mapDef.texCoord;\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (encoding !== void 0) {\n        if (\"colorSpace\" in texture)\n          texture.colorSpace = encoding === 3001 ? \"srgb\" : \"srgb-linear\";\n        else\n          texture.encoding = encoding;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.map = material.map;\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (useDerivativeTangents)\n        cacheKey += \"derivative-tangents:\";\n      if (useVertexColors)\n        cacheKey += \"vertex-colors:\";\n      if (useFlatShading)\n        cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors)\n          cachedMaterial.vertexColors = true;\n        if (useFlatShading)\n          cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale)\n            cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(\n        Promise.all(\n          this._invokeAll(function(ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n          })\n        )\n      );\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(materialDef.emissiveFactor);\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, 3001));\n    }\n    return Promise.all(pending).then(function() {\n      const material = new materialType(materialParams);\n      if (materialDef.name)\n        material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, { materials: materialIndex });\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0;\n      return sanitizedName;\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n        }\n        cache[cacheKey] = { primitive, promise: geometryPromise };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        if (meshDef.extensions)\n          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n        return meshes[0];\n      }\n      const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      if (meshDef.extensions)\n        addUnknownExtensionsToUserData(extensions, group, meshDef);\n      parser.associations.set(group, { meshes: meshIndex });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(\n        three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6\n      );\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name)\n      camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const pending = [];\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]));\n    }\n    if (skinDef.inverseBindMatrices !== void 0) {\n      pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n    } else {\n      pending.push(null);\n    }\n    return Promise.all(pending).then(function(results) {\n      const inverseBindMatrices = results.pop();\n      const jointNodes = results;\n      const bones = [];\n      const boneInverses = [];\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i];\n        if (jointNode) {\n          bones.push(jointNode);\n          const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16);\n          }\n          boneInverses.push(mat);\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n        }\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const animationDef = json.animations[animationIndex];\n    const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      if (target.node === void 0)\n        continue;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0)\n          continue;\n        node.updateMatrix();\n        let TypedKeyframeTrack;\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n            break;\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n            break;\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n            break;\n        }\n        const targetName = node.name ? node.name : node.uuid;\n        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n        const targetNames = [];\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          node.traverse(function(object) {\n            if (object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n        let outputArray = outputAccessor.array;\n        if (outputAccessor.normalized) {\n          const scale = getNormalizedComponentScale(outputArray.constructor);\n          const scaled = new Float32Array(outputArray.length);\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n          outputArray = scaled;\n        }\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\n          const track = new TypedKeyframeTrack(\n            targetNames[j] + \".\" + PATH_PROPERTIES[target.path],\n            inputAccessor.array,\n            outputArray,\n            interpolation\n          );\n          if (sampler.interpolation === \"CUBICSPLINE\") {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n            };\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n          tracks.push(track);\n        }\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0)\n      return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh)\n            return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodePending = parser._loadNodeShallow(nodeIndex);\n    const childPending = [];\n    const childrenDef = nodeDef.children || [];\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n    }\n    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {\n      const node = results[0];\n      const children = results[1];\n      const skeleton = results[2];\n      if (skeleton !== null) {\n        node.traverse(function(mesh) {\n          if (!mesh.isSkinnedMesh)\n            return;\n          mesh.bind(skeleton, _identityMatrix);\n        });\n      }\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i]);\n      }\n      return node;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    if (this.nodeCache[nodeIndex] !== void 0) {\n      return this.nodeCache[nodeIndex];\n    }\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    const pending = [];\n    const meshPromise = parser._invokeOne(function(ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n    });\n    if (meshPromise) {\n      pending.push(meshPromise);\n    }\n    if (nodeDef.camera !== void 0) {\n      pending.push(\n        parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        })\n      );\n    }\n    parser._invokeAll(function(ext) {\n      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n    }).forEach(function(promise) {\n      pending.push(promise);\n    });\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n      } else if (objects.length > 1) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n    return this.nodeCache[nodeIndex];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    if (sceneDef.name)\n      scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency(\"node\", nodeIds[i]));\n    }\n    return Promise.all(pending).then(function(nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i]);\n      }\n      const reduceAssociations = (node) => {\n        const reducedAssociations = /* @__PURE__ */ new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse((node2) => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes)\n      continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\n\n//# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9HTFRGTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZzhCO0FBQzEzQjtBQUNsQjtBQUNwRCx5QkFBeUIseUNBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQiw4Q0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0NBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0NBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBTztBQUM3QixzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDZDQUFVO0FBQ2hDLHNCQUFzQiwwQ0FBTztBQUM3QixrQ0FBa0MsZ0RBQWE7QUFDL0Msd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQVc7QUFDbEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhDQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQ0FBTyw4QkFBOEIsMENBQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQU87QUFDdkMsdUJBQXVCLDBDQUFPO0FBQzlCLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUNBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcz81MjkxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvYWRlciwgTG9hZGVyVXRpbHMsIEZpbGVMb2FkZXIsIENvbG9yLCBTcG90TGlnaHQsIFBvaW50TGlnaHQsIERpcmVjdGlvbmFsTGlnaHQsIE1lc2hCYXNpY01hdGVyaWFsLCBNZXNoUGh5c2ljYWxNYXRlcmlhbCwgVmVjdG9yMiwgTWF0cml4NCwgVmVjdG9yMywgUXVhdGVybmlvbiwgSW5zdGFuY2VkTWVzaCwgT2JqZWN0M0QsIFRleHR1cmVMb2FkZXIsIEltYWdlQml0bWFwTG9hZGVyLCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIFJlcGVhdFdyYXBwaW5nLCBQb2ludHNNYXRlcmlhbCwgTWF0ZXJpYWwsIExpbmVCYXNpY01hdGVyaWFsLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgRG91YmxlU2lkZSwgUHJvcGVydHlCaW5kaW5nLCBCdWZmZXJHZW9tZXRyeSwgU2tpbm5lZE1lc2gsIE1lc2gsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgTGluZVNlZ21lbnRzLCBMaW5lLCBMaW5lTG9vcCwgUG9pbnRzLCBHcm91cCwgUGVyc3BlY3RpdmVDYW1lcmEsIE1hdGhVdGlscywgT3J0aG9ncmFwaGljQ2FtZXJhLCBTa2VsZXRvbiwgSW50ZXJwb2xhdGVMaW5lYXIsIEFuaW1hdGlvbkNsaXAsIEJvbmUsIE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLCBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLCBJbnRlcnBvbGF0ZURpc2NyZXRlLCBGcm9udFNpZGUsIFRleHR1cmUsIFZlY3RvcktleWZyYW1lVHJhY2ssIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBOdW1iZXJLZXlmcmFtZVRyYWNrLCBCb3gzLCBTcGhlcmUsIEludGVycG9sYW50IH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyB0b1RyaWFuZ2xlc0RyYXdNb2RlIH0gZnJvbSBcIi4uL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3BvbHlmaWxsL2NvbnN0YW50cy5qc1wiO1xuY2xhc3MgR0xURkxvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLmt0eDJMb2FkZXIgPSBudWxsO1xuICAgIHRoaXMubWVzaG9wdERlY29kZXIgPSBudWxsO1xuICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNWb2x1bWVFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZMaWdodHNFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWVzaG9wdENvbXByZXNzaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1lc2hHcHVJbnN0YW5jaW5nKHBhcnNlcik7XG4gICAgfSk7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICBsZXQgcmVzb3VyY2VQYXRoO1xuICAgIGlmICh0aGlzLnJlc291cmNlUGF0aCAhPT0gXCJcIikge1xuICAgICAgcmVzb3VyY2VQYXRoID0gdGhpcy5yZXNvdXJjZVBhdGg7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhdGggIT09IFwiXCIpIHtcbiAgICAgIHJlc291cmNlUGF0aCA9IHRoaXMucGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UodXJsKTtcbiAgICB9XG4gICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgIGNvbnN0IF9vbkVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgfTtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgbG9hZGVyLmxvYWQoXG4gICAgICB1cmwsXG4gICAgICBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2NvcGUucGFyc2UoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVzb3VyY2VQYXRoLFxuICAgICAgICAgICAgZnVuY3Rpb24oZ2x0Zikge1xuICAgICAgICAgICAgICBvbkxvYWQoZ2x0Zik7XG4gICAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF9vbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIF9vbkVycm9yXG4gICAgKTtcbiAgfVxuICBzZXREUkFDT0xvYWRlcihkcmFjb0xvYWRlcikge1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRERFNMb2FkZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5HTFRGTG9hZGVyOiBcIk1TRlRfdGV4dHVyZV9kZHNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIHRvIFwiS0hSX3RleHR1cmVfYmFzaXN1XCIuJyk7XG4gIH1cbiAgc2V0S1RYMkxvYWRlcihrdHgyTG9hZGVyKSB7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0ga3R4MkxvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRNZXNob3B0RGVjb2RlcihtZXNob3B0RGVjb2Rlcikge1xuICAgIHRoaXMubWVzaG9wdERlY29kZXIgPSBtZXNob3B0RGVjb2RlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWdpc3RlcihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1bnJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spICE9PSAtMSkge1xuICAgICAgdGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcGFyc2UoZGF0YSwgcGF0aCwgb25Mb2FkLCBvbkVycm9yKSB7XG4gICAgbGV0IGpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuICAgIGNvbnN0IHBsdWdpbnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBjb25zdCBtYWdpYyA9IExvYWRlclV0aWxzLmRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgaWYgKG1hZ2ljID09PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdID0gbmV3IEdMVEZCaW5hcnlFeHRlbnNpb24oZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UoZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0uY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShMb2FkZXJVdGlscy5kZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGpzb24gPSBkYXRhO1xuICAgIH1cbiAgICBpZiAoanNvbi5hc3NldCA9PT0gdm9pZCAwIHx8IGpzb24uYXNzZXQudmVyc2lvblswXSA8IDIpIHtcbiAgICAgIGlmIChvbkVycm9yKVxuICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGFzc2V0LiBnbFRGIHZlcnNpb25zID49Mi4wIGFyZSBzdXBwb3J0ZWQuXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEdMVEZQYXJzZXIoanNvbiwge1xuICAgICAgcGF0aDogcGF0aCB8fCB0aGlzLnJlc291cmNlUGF0aCB8fCBcIlwiLFxuICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICByZXF1ZXN0SGVhZGVyOiB0aGlzLnJlcXVlc3RIZWFkZXIsXG4gICAgICBtYW5hZ2VyOiB0aGlzLm1hbmFnZXIsXG4gICAgICBrdHgyTG9hZGVyOiB0aGlzLmt0eDJMb2FkZXIsXG4gICAgICBtZXNob3B0RGVjb2RlcjogdGhpcy5tZXNob3B0RGVjb2RlclxuICAgIH0pO1xuICAgIHBhcnNlci5maWxlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbkNhbGxiYWNrc1tpXShwYXJzZXIpO1xuICAgICAgcGx1Z2luc1twbHVnaW4ubmFtZV0gPSBwbHVnaW47XG4gICAgICBleHRlbnNpb25zW3BsdWdpbi5uYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChqc29uLmV4dGVuc2lvbnNVc2VkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24uZXh0ZW5zaW9uc1VzZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZSA9IGpzb24uZXh0ZW5zaW9uc1VzZWRbaV07XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnNSZXF1aXJlZCA9IGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkIHx8IFtdO1xuICAgICAgICBzd2l0Y2ggKGV4dGVuc2lvbk5hbWUpIHtcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVDpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbihqc29uLCB0aGlzLmRyYWNvTG9hZGVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk06XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX01FU0hfUVVBTlRJWkFUSU9OOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihleHRlbnNpb25OYW1lKSA+PSAwICYmIHBsdWdpbnNbZXh0ZW5zaW9uTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkdMVEZMb2FkZXI6IFVua25vd24gZXh0ZW5zaW9uIFwiJyArIGV4dGVuc2lvbk5hbWUgKyAnXCIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VyLnNldEV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgcGFyc2VyLnNldFBsdWdpbnMocGx1Z2lucyk7XG4gICAgcGFyc2VyLnBhcnNlKG9uTG9hZCwgb25FcnJvcik7XG4gIH1cbiAgcGFyc2VBc3luYyhkYXRhLCBwYXRoKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHNjb3BlLnBhcnNlKGRhdGEsIHBhdGgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEdMVEZSZWdpc3RyeSgpIHtcbiAgbGV0IG9iamVjdHMgPSB7fTtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdHNba2V5XTtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24oa2V5LCBvYmplY3QpIHtcbiAgICAgIG9iamVjdHNba2V5XSA9IG9iamVjdDtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICBkZWxldGUgb2JqZWN0c1trZXldO1xuICAgIH0sXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIG9iamVjdHMgPSB7fTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBFWFRFTlNJT05TID0ge1xuICBLSFJfQklOQVJZX0dMVEY6IFwiS0hSX2JpbmFyeV9nbFRGXCIsXG4gIEtIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOiBcIktIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uXCIsXG4gIEtIUl9MSUdIVFNfUFVOQ1RVQUw6IFwiS0hSX2xpZ2h0c19wdW5jdHVhbFwiLFxuICBLSFJfTUFURVJJQUxTX0NMRUFSQ09BVDogXCJLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdFwiLFxuICBLSFJfTUFURVJJQUxTX0lPUjogXCJLSFJfbWF0ZXJpYWxzX2lvclwiLFxuICBLSFJfTUFURVJJQUxTX1NIRUVOOiBcIktIUl9tYXRlcmlhbHNfc2hlZW5cIixcbiAgS0hSX01BVEVSSUFMU19TUEVDVUxBUjogXCJLSFJfbWF0ZXJpYWxzX3NwZWN1bGFyXCIsXG4gIEtIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OOiBcIktIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uXCIsXG4gIEtIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0U6IFwiS0hSX21hdGVyaWFsc19pcmlkZXNjZW5jZVwiLFxuICBLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFk6IFwiS0hSX21hdGVyaWFsc19hbmlzb3Ryb3B5XCIsXG4gIEtIUl9NQVRFUklBTFNfVU5MSVQ6IFwiS0hSX21hdGVyaWFsc191bmxpdFwiLFxuICBLSFJfTUFURVJJQUxTX1ZPTFVNRTogXCJLSFJfbWF0ZXJpYWxzX3ZvbHVtZVwiLFxuICBLSFJfVEVYVFVSRV9CQVNJU1U6IFwiS0hSX3RleHR1cmVfYmFzaXN1XCIsXG4gIEtIUl9URVhUVVJFX1RSQU5TRk9STTogXCJLSFJfdGV4dHVyZV90cmFuc2Zvcm1cIixcbiAgS0hSX01FU0hfUVVBTlRJWkFUSU9OOiBcIktIUl9tZXNoX3F1YW50aXphdGlvblwiLFxuICBLSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIOiBcIktIUl9tYXRlcmlhbHNfZW1pc3NpdmVfc3RyZW5ndGhcIixcbiAgRVhUX1RFWFRVUkVfV0VCUDogXCJFWFRfdGV4dHVyZV93ZWJwXCIsXG4gIEVYVF9URVhUVVJFX0FWSUY6IFwiRVhUX3RleHR1cmVfYXZpZlwiLFxuICBFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjogXCJFWFRfbWVzaG9wdF9jb21wcmVzc2lvblwiLFxuICBFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORzogXCJFWFRfbWVzaF9ncHVfaW5zdGFuY2luZ1wiXG59O1xuY2xhc3MgR0xURkxpZ2h0c0V4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTDtcbiAgICB0aGlzLmNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgfVxuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLnBhcnNlci5qc29uLm5vZGVzIHx8IFtdO1xuICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlRGVmID0gbm9kZURlZnNbbm9kZUluZGV4XTtcbiAgICAgIGlmIChub2RlRGVmLmV4dGVuc2lvbnMgJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQgIT09IHZvaWQgMCkge1xuICAgICAgICBwYXJzZXIuX2FkZE5vZGVSZWYodGhpcy5jYWNoZSwgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfbG9hZExpZ2h0KGxpZ2h0SW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBjYWNoZUtleSA9IFwibGlnaHQ6XCIgKyBsaWdodEluZGV4O1xuICAgIGxldCBkZXBlbmRlbmN5ID0gcGFyc2VyLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGRlcGVuZGVuY3kpXG4gICAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodERlZnMgPSBleHRlbnNpb25zLmxpZ2h0cyB8fCBbXTtcbiAgICBjb25zdCBsaWdodERlZiA9IGxpZ2h0RGVmc1tsaWdodEluZGV4XTtcbiAgICBsZXQgbGlnaHROb2RlO1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKDE2Nzc3MjE1KTtcbiAgICBpZiAobGlnaHREZWYuY29sb3IgIT09IHZvaWQgMClcbiAgICAgIGNvbG9yLmZyb21BcnJheShsaWdodERlZi5jb2xvcik7XG4gICAgY29uc3QgcmFuZ2UgPSBsaWdodERlZi5yYW5nZSAhPT0gdm9pZCAwID8gbGlnaHREZWYucmFuZ2UgOiAwO1xuICAgIHN3aXRjaCAobGlnaHREZWYudHlwZSkge1xuICAgICAgY2FzZSBcImRpcmVjdGlvbmFsXCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoMCwgMCwgLTEpO1xuICAgICAgICBsaWdodE5vZGUuYWRkKGxpZ2h0Tm9kZS50YXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICBsaWdodE5vZGUgPSBuZXcgUG9pbnRMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzcG90XCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBTcG90TGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcbiAgICAgICAgbGlnaHREZWYuc3BvdCA9IGxpZ2h0RGVmLnNwb3QgfHwge307XG4gICAgICAgIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlICE9PSB2b2lkIDAgPyBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlIDogMDtcbiAgICAgICAgbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgOiBNYXRoLlBJIC8gNDtcbiAgICAgICAgbGlnaHROb2RlLmFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcbiAgICAgICAgbGlnaHROb2RlLnBlbnVtYnJhID0gMSAtIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgLyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuICAgICAgICBsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAtMSk7XG4gICAgICAgIGxpZ2h0Tm9kZS5hZGQobGlnaHROb2RlLnRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5leHBlY3RlZCBsaWdodCB0eXBlOiBcIiArIGxpZ2h0RGVmLnR5cGUpO1xuICAgIH1cbiAgICBsaWdodE5vZGUucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIGxpZ2h0Tm9kZS5kZWNheSA9IDI7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShsaWdodE5vZGUsIGxpZ2h0RGVmKTtcbiAgICBpZiAobGlnaHREZWYuaW50ZW5zaXR5ICE9PSB2b2lkIDApXG4gICAgICBsaWdodE5vZGUuaW50ZW5zaXR5ID0gbGlnaHREZWYuaW50ZW5zaXR5O1xuICAgIGxpZ2h0Tm9kZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobGlnaHREZWYubmFtZSB8fCBcImxpZ2h0X1wiICsgbGlnaHRJbmRleCk7XG4gICAgZGVwZW5kZW5jeSA9IFByb21pc2UucmVzb2x2ZShsaWdodE5vZGUpO1xuICAgIHBhcnNlci5jYWNoZS5hZGQoY2FjaGVLZXksIGRlcGVuZGVuY3kpO1xuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG4gIGdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpIHtcbiAgICBpZiAodHlwZSAhPT0gXCJsaWdodFwiKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQoaW5kZXgpO1xuICB9XG4gIGNyZWF0ZU5vZGVBdHRhY2htZW50KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBsaWdodERlZiA9IG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodEluZGV4ID0gbGlnaHREZWYubGlnaHQ7XG4gICAgaWYgKGxpZ2h0SW5kZXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQobGlnaHRJbmRleCkudGhlbihmdW5jdGlvbihsaWdodCkge1xuICAgICAgcmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZihzZWxmMi5jYWNoZSwgbGlnaHRJbmRleCwgbGlnaHQpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKCkge1xuICAgIHJldHVybiBNZXNoQmFzaWNNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRQYXJhbXMobWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDE7XG4gICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcztcbiAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcikpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheShhcnJheSk7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVszXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCAzMDAxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEg7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBlbWlzc2l2ZVN0cmVuZ3RoID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmVtaXNzaXZlU3RyZW5ndGg7XG4gICAgaWYgKGVtaXNzaXZlU3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBlbWlzc2l2ZVN0cmVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfQ0xFQVJDT0FUO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdCA9IGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0TWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdFJvdWdobmVzcyA9IGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0Um91Z2huZXNzTWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiY2xlYXJjb2F0Tm9ybWFsTWFwXCIsIGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlKSk7XG4gICAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKHNjYWxlLCBzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0lyaWRlc2NlbmNlRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2UgPSBleHRlbnNpb24uaXJpZGVzY2VuY2VGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJpcmlkZXNjZW5jZU1hcFwiLCBleHRlbnNpb24uaXJpZGVzY2VuY2VUZXh0dXJlKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VJb3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VJT1IgPSBleHRlbnNpb24uaXJpZGVzY2VuY2VJb3I7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID09PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSBbMTAwLCA0MDBdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWzBdID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVsxXSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiaXJpZGVzY2VuY2VUaGlja25lc3NNYXBcIiwgZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1NIRUVOO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Db2xvciA9IG5ldyBDb2xvcigwLCAwLCAwKTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zaGVlblJvdWdobmVzcyA9IDA7XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW4gPSAxO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Db2xvci5mcm9tQXJyYXkoZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3IpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuUm91Z2huZXNzID0gZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzaGVlbkNvbG9yTWFwXCIsIGV4dGVuc2lvbi5zaGVlbkNvbG9yVGV4dHVyZSwgMzAwMSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic2hlZW5Sb3VnaG5lc3NNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zbWlzc2lvbiA9IGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwidHJhbnNtaXNzaW9uTWFwXCIsIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19WT0xVTUU7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMudGhpY2tuZXNzID0gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciA6IDA7XG4gICAgaWYgKGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJ0aGlja25lc3NNYXBcIiwgZXh0ZW5zaW9uLnRoaWNrbmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkRpc3RhbmNlIHx8IEluZmluaXR5O1xuICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uYXR0ZW51YXRpb25Db2xvciB8fCBbMSwgMSwgMV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25Db2xvciA9IG5ldyBDb2xvcihjb2xvckFycmF5WzBdLCBjb2xvckFycmF5WzFdLCBjb2xvckFycmF5WzJdKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfSU9SO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuaW9yID0gZXh0ZW5zaW9uLmlvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLmlvciA6IDEuNTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TUEVDVUxBUjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhckludGVuc2l0eSA9IGV4dGVuc2lvbi5zcGVjdWxhckZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yIDogMTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic3BlY3VsYXJJbnRlbnNpdHlNYXBcIiwgZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSkpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvckFycmF5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JGYWN0b3IgfHwgWzEsIDEsIDFdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyQ29sb3IgPSBuZXcgQ29sb3IoY29sb3JBcnJheVswXSwgY29sb3JBcnJheVsxXSwgY29sb3JBcnJheVsyXSk7XG4gICAgaWYgKGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNwZWN1bGFyQ29sb3JNYXBcIiwgZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JUZXh0dXJlLCAzMDAxKVxuICAgICAgICAvLyBzUkdCRW5jb2RpbmdcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfQU5JU09UUk9QWTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmFuaXNvdHJvcHlTdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5hbmlzb3Ryb3B5ID0gZXh0ZW5zaW9uLmFuaXNvdHJvcHlTdHJlbmd0aDtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5Um90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuYW5pc290cm9weVJvdGF0aW9uID0gZXh0ZW5zaW9uLmFuaXNvdHJvcHlSb3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5VGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiYW5pc290cm9weU1hcFwiLCBleHRlbnNpb24uYW5pc290cm9weVRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfQkFTSVNVO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGNvbnN0IGxvYWRlciA9IHBhcnNlci5vcHRpb25zLmt0eDJMb2FkZXI7XG4gICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKHRoaXMubmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBzZXRLVFgyTG9hZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIEtUWDIgdGV4dHVyZXNcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfVEVYVFVSRV9XRUJQO1xuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBudWxsO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICBjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1tleHRlbnNpb24uc291cmNlXTtcbiAgICBsZXQgbG9hZGVyID0gcGFyc2VyLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZS51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXIub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0U3VwcG9ydCgpLnRoZW4oZnVuY3Rpb24oaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChpc1N1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogV2ViUCByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpO1xuICAgIH0pO1xuICB9XG4gIGRldGVjdFN1cHBvcnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JpSUFBQUJYUlVKUVZsQTRJQllBQUFBd0FRQ2RBU29CQUFFQURzRCtKYVFBQTNBQUFBQUFcIjtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUoaW1hZ2UuaGVpZ2h0ID09PSAxKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfVEVYVFVSRV9BVklGO1xuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBudWxsO1xuICB9XG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICBjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1tleHRlbnNpb24uc291cmNlXTtcbiAgICBsZXQgbG9hZGVyID0gcGFyc2VyLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZS51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXIub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0U3VwcG9ydCgpLnRoZW4oZnVuY3Rpb24oaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChpc1N1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyKTtcbiAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogQVZJRiByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpO1xuICAgIH0pO1xuICB9XG4gIGRldGVjdFN1cHBvcnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2UvYXZpZjtiYXNlNjQsQUFBQUlHWjBlWEJoZG1sbUFBQUFBR0YyYVdadGFXWXhiV2xoWmsxQk1VSUFBQUR5YldWMFlRQUFBQUFBQUFBb2FHUnNjZ0FBQUFBQUFBQUFjR2xqZEFBQUFBQUFBQUFBQUFBQUFHeHBZbUYyYVdZQUFBQUFEbkJwZEcwQUFBQUFBQUVBQUFBZWFXeHZZd0FBQUFCRUFBQUJBQUVBQUFBQkFBQUJHZ0FBQUJjQUFBQW9hV2x1WmdBQUFBQUFBUUFBQUJwcGJtWmxBZ0FBQUFBQkFBQmhkakF4UTI5c2IzSUFBQUFBYW1sd2NuQUFBQUJMYVhCamJ3QUFBQlJwYzNCbEFBQUFBQUFBQUFFQUFBQUJBQUFBRUhCcGVHa0FBQUFBQXdnSUNBQUFBQXhoZGpGRGdRQU1BQUFBQUJOamIyeHlibU5zZUFBQ0FBSUFCb0FBQUFBWGFYQnRZUUFBQUFBQUFBQUJBQUVFQVFLREJBQUFBQjl0WkdGMEVnQUtDQmdBQm9nUUVEUWdNZ2tRQUFBQUI4ZFNMZkk9XCI7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKGltYWdlLmhlaWdodCA9PT0gMSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG4gIH1cbn1cbmNsYXNzIEdMVEZNZXNob3B0Q29tcHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB9XG4gIGxvYWRCdWZmZXJWaWV3KGluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMucGFyc2VyLmpzb247XG4gICAgY29uc3QgYnVmZmVyVmlldyA9IGpzb24uYnVmZmVyVmlld3NbaW5kZXhdO1xuICAgIGlmIChidWZmZXJWaWV3LmV4dGVuc2lvbnMgJiYgYnVmZmVyVmlldy5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkRlZiA9IGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5wYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclwiLCBleHRlbnNpb25EZWYuYnVmZmVyKTtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSB0aGlzLnBhcnNlci5vcHRpb25zLm1lc2hvcHREZWNvZGVyO1xuICAgICAgaWYgKCFkZWNvZGVyIHx8ICFkZWNvZGVyLnN1cHBvcnRlZCkge1xuICAgICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpID49IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBzZXRNZXNob3B0RGVjb2RlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBjb21wcmVzc2VkIGZpbGVzXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBleHRlbnNpb25EZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gZXh0ZW5zaW9uRGVmLmJ5dGVMZW5ndGggfHwgMDtcbiAgICAgICAgY29uc3QgY291bnQgPSBleHRlbnNpb25EZWYuY291bnQ7XG4gICAgICAgIGNvbnN0IHN0cmlkZSA9IGV4dGVuc2lvbkRlZi5ieXRlU3RyaWRlO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBuZXcgVWludDhBcnJheShyZXMsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICBpZiAoZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyQXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyQXN5bmMoY291bnQsIHN0cmlkZSwgc291cmNlLCBleHRlbnNpb25EZWYubW9kZSwgZXh0ZW5zaW9uRGVmLmZpbHRlcikudGhlbihmdW5jdGlvbihyZXMyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzMi5idWZmZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXIucmVhZHkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlcihjb3VudCAqIHN0cmlkZSk7XG4gICAgICAgICAgICBkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXIoXG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCksXG4gICAgICAgICAgICAgIGNvdW50LFxuICAgICAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uRGVmLm1vZGUsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbkRlZi5maWx0ZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5jbGFzcyBHTFRGTWVzaEdwdUluc3RhbmNpbmcge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NRVNIX0dQVV9JTlNUQU5DSU5HO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB9XG4gIGNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgaWYgKCFub2RlRGVmLmV4dGVuc2lvbnMgfHwgIW5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IG5vZGVEZWYubWVzaCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbWVzaERlZiA9IGpzb24ubWVzaGVzW25vZGVEZWYubWVzaF07XG4gICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgbWVzaERlZi5wcmltaXRpdmVzKSB7XG4gICAgICBpZiAocHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVMgJiYgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCAmJiBwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiAmJiBwcmltaXRpdmUubW9kZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb25EZWYgPSBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzRGVmID0gZXh0ZW5zaW9uRGVmLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzRGVmKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBhdHRyaWJ1dGVzRGVmW2tleV0pLnRoZW4oKGFjY2Vzc29yKSA9PiB7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gYWNjZXNzb3I7XG4gICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwZW5kaW5nLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwZW5kaW5nLnB1c2godGhpcy5wYXJzZXIuY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVPYmplY3QgPSByZXN1bHRzLnBvcCgpO1xuICAgICAgY29uc3QgbWVzaGVzID0gbm9kZU9iamVjdC5pc0dyb3VwID8gbm9kZU9iamVjdC5jaGlsZHJlbiA6IFtub2RlT2JqZWN0XTtcbiAgICAgIGNvbnN0IGNvdW50ID0gcmVzdWx0c1swXS5jb3VudDtcbiAgICAgIGNvbnN0IGluc3RhbmNlZE1lc2hlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBtZXNoIG9mIG1lc2hlcykge1xuICAgICAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgICBjb25zdCBzID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlZE1lc2ggPSBuZXcgSW5zdGFuY2VkTWVzaChtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdGVyaWFsLCBjb3VudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlRSQU5TTEFUSU9OKSB7XG4gICAgICAgICAgICBwLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5UUkFOU0xBVElPTiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlJPVEFUSU9OKSB7XG4gICAgICAgICAgICBxLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5ST1RBVElPTiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlNDQUxFKSB7XG4gICAgICAgICAgICBzLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlcy5TQ0FMRSwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQoaSwgbS5jb21wb3NlKHAsIHEsIHMpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lICE9PSBcIlRSQU5TTEFUSU9OXCIgJiYgYXR0cmlidXRlTmFtZSAhPT0gXCJST1RBVElPTlwiICYmIGF0dHJpYnV0ZU5hbWUgIT09IFwiU0NBTEVcIikge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoaW5zdGFuY2VkTWVzaCwgbWVzaCk7XG4gICAgICAgIHRoaXMucGFyc2VyLmFzc2lnbkZpbmFsTWF0ZXJpYWwoaW5zdGFuY2VkTWVzaCk7XG4gICAgICAgIGluc3RhbmNlZE1lc2hlcy5wdXNoKGluc3RhbmNlZE1lc2gpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGVPYmplY3QuaXNHcm91cCkge1xuICAgICAgICBub2RlT2JqZWN0LmNsZWFyKCk7XG4gICAgICAgIG5vZGVPYmplY3QuYWRkKC4uLmluc3RhbmNlZE1lc2hlcyk7XG4gICAgICAgIHJldHVybiBub2RlT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3RhbmNlZE1lc2hlc1swXTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgPSBcImdsVEZcIjtcbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCA9IDEyO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUyA9IHsgSlNPTjogMTMxMzgyMTUxNCwgQklOOiA1MTMwNTYyIH07XG5jbGFzcyBHTFRGQmluYXJ5RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGO1xuICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICBjb25zdCBoZWFkZXJWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEsIDAsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCk7XG4gICAgdGhpcy5oZWFkZXIgPSB7XG4gICAgICBtYWdpYzogTG9hZGVyVXRpbHMuZGVjb2RlVGV4dChuZXcgVWludDhBcnJheShkYXRhLnNsaWNlKDAsIDQpKSksXG4gICAgICB2ZXJzaW9uOiBoZWFkZXJWaWV3LmdldFVpbnQzMig0LCB0cnVlKSxcbiAgICAgIGxlbmd0aDogaGVhZGVyVmlldy5nZXRVaW50MzIoOCwgdHJ1ZSlcbiAgICB9O1xuICAgIGlmICh0aGlzLmhlYWRlci5tYWdpYyAhPT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGdsVEYtQmluYXJ5IGhlYWRlci5cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhlYWRlci52ZXJzaW9uIDwgMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogTGVnYWN5IGJpbmFyeSBmaWxlIGRldGVjdGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtDb250ZW50c0xlbmd0aCA9IHRoaXMuaGVhZGVyLmxlbmd0aCAtIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSDtcbiAgICBjb25zdCBjaHVua1ZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIKTtcbiAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgd2hpbGUgKGNodW5rSW5kZXggPCBjaHVua0NvbnRlbnRzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaHVua0xlbmd0aCA9IGNodW5rVmlldy5nZXRVaW50MzIoY2h1bmtJbmRleCwgdHJ1ZSk7XG4gICAgICBjaHVua0luZGV4ICs9IDQ7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVua1ZpZXcuZ2V0VWludDMyKGNodW5rSW5kZXgsIHRydWUpO1xuICAgICAgY2h1bmtJbmRleCArPSA0O1xuICAgICAgaWYgKGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5KU09OKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXgsIGNodW5rTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dChjb250ZW50QXJyYXkpO1xuICAgICAgfSBlbHNlIGlmIChjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuQklOKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4O1xuICAgICAgICB0aGlzLmJvZHkgPSBkYXRhLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBjaHVua0xlbmd0aCk7XG4gICAgICB9XG4gICAgICBjaHVua0luZGV4ICs9IGNodW5rTGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBKU09OIGNvbnRlbnQgbm90IGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGpzb24sIGRyYWNvTG9hZGVyKSB7XG4gICAgaWYgKCFkcmFjb0xvYWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogTm8gRFJBQ09Mb2FkZXIgaW5zdGFuY2UgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OO1xuICAgIHRoaXMuanNvbiA9IGpzb247XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuICAgIHRoaXMuZHJhY29Mb2FkZXIucHJlbG9hZCgpO1xuICB9XG4gIGRlY29kZVByaW1pdGl2ZShwcmltaXRpdmUsIHBhcnNlcikge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZHJhY29Mb2FkZXIgPSB0aGlzLmRyYWNvTG9hZGVyO1xuICAgIGNvbnN0IGJ1ZmZlclZpZXdJbmRleCA9IHByaW1pdGl2ZS5leHRlbnNpb25zW3RoaXMubmFtZV0uYnVmZmVyVmlldztcbiAgICBjb25zdCBnbHRmQXR0cmlidXRlTWFwID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTWFwID0ge307XG4gICAgY29uc3QgYXR0cmlidXRlTm9ybWFsaXplZE1hcCA9IHt9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGVNYXAgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2x0ZkF0dHJpYnV0ZU1hcCkge1xuICAgICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1thdHRyaWJ1dGVOYW1lXSB8fCBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aHJlZUF0dHJpYnV0ZU1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gZ2x0ZkF0dHJpYnV0ZU1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIHByaW1pdGl2ZS5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2F0dHJpYnV0ZU5hbWVdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChnbHRmQXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgYWNjZXNzb3JEZWYgPSBqc29uLmFjY2Vzc29yc1twcmltaXRpdmUuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXV07XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFR5cGUgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICAgIGF0dHJpYnV0ZVR5cGVNYXBbdGhyZWVBdHRyaWJ1dGVOYW1lXSA9IGNvbXBvbmVudFR5cGUubmFtZTtcbiAgICAgICAgYXR0cmlidXRlTm9ybWFsaXplZE1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBidWZmZXJWaWV3SW5kZXgpLnRoZW4oZnVuY3Rpb24oYnVmZmVyVmlldykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgZHJhY29Mb2FkZXIuZGVjb2RlRHJhY29GaWxlKFxuICAgICAgICAgIGJ1ZmZlclZpZXcsXG4gICAgICAgICAgZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZCAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZ2VvbWV0cnkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhyZWVBdHRyaWJ1dGVNYXAsXG4gICAgICAgICAgYXR0cmlidXRlVHlwZU1hcFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk07XG4gIH1cbiAgZXh0ZW5kVGV4dHVyZSh0ZXh0dXJlLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoKHRyYW5zZm9ybS50ZXhDb29yZCA9PT0gdm9pZCAwIHx8IHRyYW5zZm9ybS50ZXhDb29yZCA9PT0gdGV4dHVyZS5jaGFubmVsKSAmJiB0cmFuc2Zvcm0ub2Zmc2V0ID09PSB2b2lkIDAgJiYgdHJhbnNmb3JtLnJvdGF0aW9uID09PSB2b2lkIDAgJiYgdHJhbnNmb3JtLnNjYWxlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cbiAgICB0ZXh0dXJlID0gdGV4dHVyZS5jbG9uZSgpO1xuICAgIGlmICh0cmFuc2Zvcm0udGV4Q29vcmQgIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5jaGFubmVsID0gdHJhbnNmb3JtLnRleENvb3JkO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLm9mZnNldCAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkodHJhbnNmb3JtLm9mZnNldCk7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ucm90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5yb3RhdGlvbiA9IHRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkodHJhbnNmb3JtLnNjYWxlKTtcbiAgICB9XG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbn1cbmNsYXNzIEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT047XG4gIH1cbn1cbmNsYXNzIEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKSB7XG4gICAgc3VwZXIocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcik7XG4gIH1cbiAgY29weVNhbXBsZVZhbHVlXyhpbmRleCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLCB2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcywgdmFsdWVTaXplID0gdGhpcy52YWx1ZVNpemUsIG9mZnNldCA9IGluZGV4ICogdmFsdWVTaXplICogMyArIHZhbHVlU2l6ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gdmFsdWVTaXplOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IHZhbHVlc1tvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyO1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzO1xuICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMudmFsdWVTaXplO1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzdHJpZGUgKiAyO1xuICAgIGNvbnN0IHN0cmlkZTMgPSBzdHJpZGUgKiAzO1xuICAgIGNvbnN0IHRkID0gdDEgLSB0MDtcbiAgICBjb25zdCBwID0gKHQgLSB0MCkgLyB0ZDtcbiAgICBjb25zdCBwcCA9IHAgKiBwO1xuICAgIGNvbnN0IHBwcCA9IHBwICogcDtcbiAgICBjb25zdCBvZmZzZXQxID0gaTEgKiBzdHJpZGUzO1xuICAgIGNvbnN0IG9mZnNldDAgPSBvZmZzZXQxIC0gc3RyaWRlMztcbiAgICBjb25zdCBzMiA9IC0yICogcHBwICsgMyAqIHBwO1xuICAgIGNvbnN0IHMzID0gcHBwIC0gcHA7XG4gICAgY29uc3QgczAgPSAxIC0gczI7XG4gICAgY29uc3QgczEgPSBzMyAtIHBwICsgcDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyBpKyspIHtcbiAgICAgIGNvbnN0IHAwID0gdmFsdWVzW29mZnNldDAgKyBpICsgc3RyaWRlXTtcbiAgICAgIGNvbnN0IG0wID0gdmFsdWVzW29mZnNldDAgKyBpICsgc3RyaWRlMl0gKiB0ZDtcbiAgICAgIGNvbnN0IHAxID0gdmFsdWVzW29mZnNldDEgKyBpICsgc3RyaWRlXTtcbiAgICAgIGNvbnN0IG0xID0gdmFsdWVzW29mZnNldDEgKyBpXSAqIHRkO1xuICAgICAgcmVzdWx0W2ldID0gczAgKiBwMCArIHMxICogbTAgKyBzMiAqIHAxICsgczMgKiBtMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuY29uc3QgX3EgPSBuZXcgUXVhdGVybmlvbigpO1xuY2xhc3MgR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50IGV4dGVuZHMgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQge1xuICBpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKTtcbiAgICBfcS5mcm9tQXJyYXkocmVzdWx0KS5ub3JtYWxpemUoKS50b0FycmF5KHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuY29uc3QgV0VCR0xfQ09OU1RBTlRTID0ge1xuICBGTE9BVDogNTEyNixcbiAgLy9GTE9BVF9NQVQyOiAzNTY3NCxcbiAgRkxPQVRfTUFUMzogMzU2NzUsXG4gIEZMT0FUX01BVDQ6IDM1Njc2LFxuICBGTE9BVF9WRUMyOiAzNTY2NCxcbiAgRkxPQVRfVkVDMzogMzU2NjUsXG4gIEZMT0FUX1ZFQzQ6IDM1NjY2LFxuICBMSU5FQVI6IDk3MjksXG4gIFJFUEVBVDogMTA0OTcsXG4gIFNBTVBMRVJfMkQ6IDM1Njc4LFxuICBQT0lOVFM6IDAsXG4gIExJTkVTOiAxLFxuICBMSU5FX0xPT1A6IDIsXG4gIExJTkVfU1RSSVA6IDMsXG4gIFRSSUFOR0xFUzogNCxcbiAgVFJJQU5HTEVfU1RSSVA6IDUsXG4gIFRSSUFOR0xFX0ZBTjogNixcbiAgVU5TSUdORURfQllURTogNTEyMSxcbiAgVU5TSUdORURfU0hPUlQ6IDUxMjNcbn07XG5jb25zdCBXRUJHTF9DT01QT05FTlRfVFlQRVMgPSB7XG4gIDUxMjA6IEludDhBcnJheSxcbiAgNTEyMTogVWludDhBcnJheSxcbiAgNTEyMjogSW50MTZBcnJheSxcbiAgNTEyMzogVWludDE2QXJyYXksXG4gIDUxMjU6IFVpbnQzMkFycmF5LFxuICA1MTI2OiBGbG9hdDMyQXJyYXlcbn07XG5jb25zdCBXRUJHTF9GSUxURVJTID0ge1xuICA5NzI4OiBOZWFyZXN0RmlsdGVyLFxuICA5NzI5OiBMaW5lYXJGaWx0ZXIsXG4gIDk5ODQ6IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuICA5OTg1OiBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuICA5OTg2OiBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLFxuICA5OTg3OiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcbn07XG5jb25zdCBXRUJHTF9XUkFQUElOR1MgPSB7XG4gIDMzMDcxOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuICAzMzY0ODogTWlycm9yZWRSZXBlYXRXcmFwcGluZyxcbiAgMTA0OTc6IFJlcGVhdFdyYXBwaW5nXG59O1xuY29uc3QgV0VCR0xfVFlQRV9TSVpFUyA9IHtcbiAgU0NBTEFSOiAxLFxuICBWRUMyOiAyLFxuICBWRUMzOiAzLFxuICBWRUM0OiA0LFxuICBNQVQyOiA0LFxuICBNQVQzOiA5LFxuICBNQVQ0OiAxNlxufTtcbmNvbnN0IEFUVFJJQlVURVMgPSB7XG4gIFBPU0lUSU9OOiBcInBvc2l0aW9uXCIsXG4gIE5PUk1BTDogXCJub3JtYWxcIixcbiAgVEFOR0VOVDogXCJ0YW5nZW50XCIsXG4gIC8vIHV2ID0+IHV2MSwgNCB1diBjaGFubmVsc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU5NDNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI1Nzg4XG4gIC4uLnZlcnNpb24gPj0gMTUyID8ge1xuICAgIFRFWENPT1JEXzA6IFwidXZcIixcbiAgICBURVhDT09SRF8xOiBcInV2MVwiLFxuICAgIFRFWENPT1JEXzI6IFwidXYyXCIsXG4gICAgVEVYQ09PUkRfMzogXCJ1djNcIlxuICB9IDoge1xuICAgIFRFWENPT1JEXzA6IFwidXZcIixcbiAgICBURVhDT09SRF8xOiBcInV2MlwiXG4gIH0sXG4gIENPTE9SXzA6IFwiY29sb3JcIixcbiAgV0VJR0hUU18wOiBcInNraW5XZWlnaHRcIixcbiAgSk9JTlRTXzA6IFwic2tpbkluZGV4XCJcbn07XG5jb25zdCBQQVRIX1BST1BFUlRJRVMgPSB7XG4gIHNjYWxlOiBcInNjYWxlXCIsXG4gIHRyYW5zbGF0aW9uOiBcInBvc2l0aW9uXCIsXG4gIHJvdGF0aW9uOiBcInF1YXRlcm5pb25cIixcbiAgd2VpZ2h0czogXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIlxufTtcbmNvbnN0IElOVEVSUE9MQVRJT04gPSB7XG4gIENVQklDU1BMSU5FOiB2b2lkIDAsXG4gIC8vIFdlIHVzZSBhIGN1c3RvbSBpbnRlcnBvbGFudCAoR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhdGlvbikgZm9yIENVQklDU1BMSU5FIHRyYWNrcy4gRWFjaFxuICAvLyBrZXlmcmFtZSB0cmFjayB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYSBkZWZhdWx0IGludGVycG9sYXRpb24gdHlwZSwgdGhlbiBtb2RpZmllZC5cbiAgTElORUFSOiBJbnRlcnBvbGF0ZUxpbmVhcixcbiAgU1RFUDogSW50ZXJwb2xhdGVEaXNjcmV0ZVxufTtcbmNvbnN0IEFMUEhBX01PREVTID0ge1xuICBPUEFRVUU6IFwiT1BBUVVFXCIsXG4gIE1BU0s6IFwiTUFTS1wiLFxuICBCTEVORDogXCJCTEVORFwiXG59O1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKGNhY2hlKSB7XG4gIGlmIChjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXSA9PT0gdm9pZCAwKSB7XG4gICAgY2FjaGVbXCJEZWZhdWx0TWF0ZXJpYWxcIl0gPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6IDE2Nzc3MjE1LFxuICAgICAgZW1pc3NpdmU6IDAsXG4gICAgICBtZXRhbG5lc3M6IDEsXG4gICAgICByb3VnaG5lc3M6IDEsXG4gICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IHRydWUsXG4gICAgICBzaWRlOiBGcm9udFNpZGVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2FjaGVbXCJEZWZhdWx0TWF0ZXJpYWxcIl07XG59XG5mdW5jdGlvbiBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoa25vd25FeHRlbnNpb25zLCBvYmplY3QsIG9iamVjdERlZikge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gb2JqZWN0RGVmLmV4dGVuc2lvbnMpIHtcbiAgICBpZiAoa25vd25FeHRlbnNpb25zW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgIG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9ucyA9IG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9ucyB8fCB7fTtcbiAgICAgIG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9uc1tuYW1lXSA9IG9iamVjdERlZi5leHRlbnNpb25zW25hbWVdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShvYmplY3QsIGdsdGZEZWYpIHtcbiAgaWYgKGdsdGZEZWYuZXh0cmFzICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIGdsdGZEZWYuZXh0cmFzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBPYmplY3QuYXNzaWduKG9iamVjdC51c2VyRGF0YSwgZ2x0ZkRlZi5leHRyYXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBJZ25vcmluZyBwcmltaXRpdmUgdHlwZSAuZXh0cmFzLCBcIiArIGdsdGZEZWYuZXh0cmFzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZE1vcnBoVGFyZ2V0cyhnZW9tZXRyeSwgdGFyZ2V0cywgcGFyc2VyKSB7XG4gIGxldCBoYXNNb3JwaFBvc2l0aW9uID0gZmFsc2U7XG4gIGxldCBoYXNNb3JwaE5vcm1hbCA9IGZhbHNlO1xuICBsZXQgaGFzTW9ycGhDb2xvciA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgIGlmICh0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoUG9zaXRpb24gPSB0cnVlO1xuICAgIGlmICh0YXJnZXQuTk9STUFMICE9PSB2b2lkIDApXG4gICAgICBoYXNNb3JwaE5vcm1hbCA9IHRydWU7XG4gICAgaWYgKHRhcmdldC5DT0xPUl8wICE9PSB2b2lkIDApXG4gICAgICBoYXNNb3JwaENvbG9yID0gdHJ1ZTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbiAmJiBoYXNNb3JwaE5vcm1hbCAmJiBoYXNNb3JwaENvbG9yKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKCFoYXNNb3JwaFBvc2l0aW9uICYmICFoYXNNb3JwaE5vcm1hbCAmJiAhaGFzTW9ycGhDb2xvcilcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGdlb21ldHJ5KTtcbiAgY29uc3QgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzID0gW107XG4gIGNvbnN0IHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMgPSBbXTtcbiAgY29uc3QgcGVuZGluZ0NvbG9yQWNjZXNzb3JzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgaWYgKGhhc01vcnBoUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuUE9TSVRJT04pIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgIHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycy5wdXNoKHBlbmRpbmdBY2Nlc3Nvcik7XG4gICAgfVxuICAgIGlmIChoYXNNb3JwaE5vcm1hbCkge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0Lk5PUk1BTCAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuTk9STUFMKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuICAgICAgcGVuZGluZ05vcm1hbEFjY2Vzc29ycy5wdXNoKHBlbmRpbmdBY2Nlc3Nvcik7XG4gICAgfVxuICAgIGlmIChoYXNNb3JwaENvbG9yKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuQ09MT1JfMCAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuQ09MT1JfMCkgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yO1xuICAgICAgcGVuZGluZ0NvbG9yQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICBQcm9taXNlLmFsbChwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMpLFxuICAgIFByb21pc2UuYWxsKHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMpLFxuICAgIFByb21pc2UuYWxsKHBlbmRpbmdDb2xvckFjY2Vzc29ycylcbiAgXSkudGhlbihmdW5jdGlvbihhY2Nlc3NvcnMpIHtcbiAgICBjb25zdCBtb3JwaFBvc2l0aW9ucyA9IGFjY2Vzc29yc1swXTtcbiAgICBjb25zdCBtb3JwaE5vcm1hbHMgPSBhY2Nlc3NvcnNbMV07XG4gICAgY29uc3QgbW9ycGhDb2xvcnMgPSBhY2Nlc3NvcnNbMl07XG4gICAgaWYgKGhhc01vcnBoUG9zaXRpb24pXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPSBtb3JwaFBvc2l0aW9ucztcbiAgICBpZiAoaGFzTW9ycGhOb3JtYWwpXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsID0gbW9ycGhOb3JtYWxzO1xuICAgIGlmIChoYXNNb3JwaENvbG9yKVxuICAgICAgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yID0gbW9ycGhDb2xvcnM7XG4gICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0cnVlO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVNb3JwaFRhcmdldHMobWVzaCwgbWVzaERlZikge1xuICBtZXNoLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuICBpZiAobWVzaERlZi53ZWlnaHRzICE9PSB2b2lkIDApIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbaV0gPSBtZXNoRGVmLndlaWdodHNbaV07XG4gICAgfVxuICB9XG4gIGlmIChtZXNoRGVmLmV4dHJhcyAmJiBBcnJheS5pc0FycmF5KG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzKSkge1xuICAgIGNvbnN0IHRhcmdldE5hbWVzID0gbWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXM7XG4gICAgaWYgKG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aCA9PT0gdGFyZ2V0TmFtZXMubGVuZ3RoKSB7XG4gICAgICBtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVt0YXJnZXROYW1lc1tpXV0gPSBpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBJbnZhbGlkIGV4dHJhcy50YXJnZXROYW1lcyBsZW5ndGguIElnbm9yaW5nIG5hbWVzLlwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZUtleShwcmltaXRpdmVEZWYpIHtcbiAgbGV0IGdlb21ldHJ5S2V5O1xuICBjb25zdCBkcmFjb0V4dGVuc2lvbiA9IHByaW1pdGl2ZURlZi5leHRlbnNpb25zICYmIHByaW1pdGl2ZURlZi5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dO1xuICBpZiAoZHJhY29FeHRlbnNpb24pIHtcbiAgICBnZW9tZXRyeUtleSA9IFwiZHJhY286XCIgKyBkcmFjb0V4dGVuc2lvbi5idWZmZXJWaWV3ICsgXCI6XCIgKyBkcmFjb0V4dGVuc2lvbi5pbmRpY2VzICsgXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KGRyYWNvRXh0ZW5zaW9uLmF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGdlb21ldHJ5S2V5ID0gcHJpbWl0aXZlRGVmLmluZGljZXMgKyBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkocHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXMpICsgXCI6XCIgKyBwcmltaXRpdmVEZWYubW9kZTtcbiAgfVxuICBpZiAocHJpbWl0aXZlRGVmLnRhcmdldHMgIT09IHZvaWQgMCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZURlZi50YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGdlb21ldHJ5S2V5ICs9IFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShwcmltaXRpdmVEZWYudGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW9tZXRyeUtleTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoYXR0cmlidXRlcykge1xuICBsZXQgYXR0cmlidXRlc0tleSA9IFwiXCI7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5zb3J0KCk7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGF0dHJpYnV0ZXNLZXkgKz0ga2V5c1tpXSArIFwiOlwiICsgYXR0cmlidXRlc1trZXlzW2ldXSArIFwiO1wiO1xuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzS2V5O1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKGNvbnN0cnVjdG9yKSB7XG4gIHN3aXRjaCAoY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIEludDhBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMTI3O1xuICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMjU1O1xuICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMzI3Njc7XG4gICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIHJldHVybiAxIC8gNjU1MzU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIG5vcm1hbGl6ZWQgYWNjZXNzb3IgY29tcG9uZW50IHR5cGUuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVVSSU1pbWVUeXBlKHVyaSkge1xuICBpZiAodXJpLnNlYXJjaCgvXFwuanBlP2coJHxcXD8pL2kpID4gMCB8fCB1cmkuc2VhcmNoKC9eZGF0YVxcOmltYWdlXFwvanBlZy8pID09PSAwKVxuICAgIHJldHVybiBcImltYWdlL2pwZWdcIjtcbiAgaWYgKHVyaS5zZWFyY2goL1xcLndlYnAoJHxcXD8pL2kpID4gMCB8fCB1cmkuc2VhcmNoKC9eZGF0YVxcOmltYWdlXFwvd2VicC8pID09PSAwKVxuICAgIHJldHVybiBcImltYWdlL3dlYnBcIjtcbiAgcmV0dXJuIFwiaW1hZ2UvcG5nXCI7XG59XG5jb25zdCBfaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuY2xhc3MgR0xURlBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKGpzb24gPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2FjaGUgPSBuZXcgR0xURlJlZ2lzdHJ5KCk7XG4gICAgdGhpcy5hc3NvY2lhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJpbWl0aXZlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLm5vZGVDYWNoZSA9IHt9O1xuICAgIHRoaXMubWVzaENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLmNhbWVyYUNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLmxpZ2h0Q2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMuc291cmNlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubm9kZU5hbWVzVXNlZCA9IHt9O1xuICAgIGxldCBpc1NhZmFyaSA9IGZhbHNlO1xuICAgIGxldCBpc0ZpcmVmb3ggPSBmYWxzZTtcbiAgICBsZXQgZmlyZWZveFZlcnNpb24gPSAtMTtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpID09PSB0cnVlO1xuICAgICAgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+IC0xO1xuICAgICAgZmlyZWZveFZlcnNpb24gPSBpc0ZpcmVmb3ggPyBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9GaXJlZm94XFwvKFswLTldKylcXC4vKVsxXSA6IC0xO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSBcInVuZGVmaW5lZFwiIHx8IGlzU2FmYXJpIHx8IGlzRmlyZWZveCAmJiBmaXJlZm94VmVyc2lvbiA8IDk4KSB7XG4gICAgICB0aGlzLnRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBJbWFnZUJpdG1hcExvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZUxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgIHRoaXMudGV4dHVyZUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMub3B0aW9ucy5yZXF1ZXN0SGVhZGVyKTtcbiAgICB0aGlzLmZpbGVMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm9wdGlvbnMubWFuYWdlcik7XG4gICAgdGhpcy5maWxlTG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IFwidXNlLWNyZWRlbnRpYWxzXCIpIHtcbiAgICAgIHRoaXMuZmlsZUxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModHJ1ZSk7XG4gICAgfVxuICB9XG4gIHNldEV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gIH1cbiAgc2V0UGx1Z2lucyhwbHVnaW5zKSB7XG4gICAgdGhpcy5wbHVnaW5zID0gcGx1Z2lucztcbiAgfVxuICBwYXJzZShvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICB0aGlzLmNhY2hlLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMubm9kZUNhY2hlID0ge307XG4gICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5fbWFya0RlZnMgJiYgZXh0Ll9tYXJrRGVmcygpO1xuICAgIH0pO1xuICAgIFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICByZXR1cm4gZXh0LmJlZm9yZVJvb3QgJiYgZXh0LmJlZm9yZVJvb3QoKTtcbiAgICAgIH0pXG4gICAgKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY2llcyhcInNjZW5lXCIpLFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwiYW5pbWF0aW9uXCIpLFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwiY2FtZXJhXCIpXG4gICAgICBdKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKGRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzY2VuZTogZGVwZW5kZW5jaWVzWzBdW2pzb24uc2NlbmUgfHwgMF0sXG4gICAgICAgIHNjZW5lczogZGVwZW5kZW5jaWVzWzBdLFxuICAgICAgICBhbmltYXRpb25zOiBkZXBlbmRlbmNpZXNbMV0sXG4gICAgICAgIGNhbWVyYXM6IGRlcGVuZGVuY2llc1syXSxcbiAgICAgICAgYXNzZXQ6IGpzb24uYXNzZXQsXG4gICAgICAgIHBhcnNlcixcbiAgICAgICAgdXNlckRhdGE6IHt9XG4gICAgICB9O1xuICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIHJlc3VsdCwganNvbik7XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKHJlc3VsdCwganNvbik7XG4gICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgcGFyc2VyLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGV4dC5hZnRlclJvb3QgJiYgZXh0LmFmdGVyUm9vdChyZXN1bHQpO1xuICAgICAgICB9KVxuICAgICAgKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBvbkxvYWQocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKG9uRXJyb3IpO1xuICB9XG4gIC8qKlxuICAgKiBNYXJrcyB0aGUgc3BlY2lhbCBub2Rlcy9tZXNoZXMgaW4ganNvbiBmb3IgZWZmaWNpZW50IHBhcnNlLlxuICAgKi9cbiAgX21hcmtEZWZzKCkge1xuICAgIGNvbnN0IG5vZGVEZWZzID0gdGhpcy5qc29uLm5vZGVzIHx8IFtdO1xuICAgIGNvbnN0IHNraW5EZWZzID0gdGhpcy5qc29uLnNraW5zIHx8IFtdO1xuICAgIGNvbnN0IG1lc2hEZWZzID0gdGhpcy5qc29uLm1lc2hlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBza2luSW5kZXggPSAwLCBza2luTGVuZ3RoID0gc2tpbkRlZnMubGVuZ3RoOyBza2luSW5kZXggPCBza2luTGVuZ3RoOyBza2luSW5kZXgrKykge1xuICAgICAgY29uc3Qgam9pbnRzID0gc2tpbkRlZnNbc2tpbkluZGV4XS5qb2ludHM7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBqb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBub2RlRGVmc1tqb2ludHNbaV1dLmlzQm9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlRGVmID0gbm9kZURlZnNbbm9kZUluZGV4XTtcbiAgICAgIGlmIChub2RlRGVmLm1lc2ggIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl9hZGROb2RlUmVmKHRoaXMubWVzaENhY2hlLCBub2RlRGVmLm1lc2gpO1xuICAgICAgICBpZiAobm9kZURlZi5za2luICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBtZXNoRGVmc1tub2RlRGVmLm1lc2hdLmlzU2tpbm5lZE1lc2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZURlZi5jYW1lcmEgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl9hZGROb2RlUmVmKHRoaXMuY2FtZXJhQ2FjaGUsIG5vZGVEZWYuY2FtZXJhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvdW50cyByZWZlcmVuY2VzIHRvIHNoYXJlZCBub2RlIC8gT2JqZWN0M0QgcmVzb3VyY2VzLiBUaGVzZSByZXNvdXJjZXNcbiAgICogY2FuIGJlIHJldXNlZCwgb3IgXCJpbnN0YW50aWF0ZWRcIiwgYXQgbXVsdGlwbGUgbm9kZXMgaW4gdGhlIHNjZW5lXG4gICAqIGhpZXJhcmNoeS4gTWVzaCwgQ2FtZXJhLCBhbmQgTGlnaHQgaW5zdGFuY2VzIGFyZSBpbnN0YW50aWF0ZWQgYW5kIG11c3RcbiAgICogYmUgbWFya2VkLiBOb24tc2NlbmVncmFwaCByZXNvdXJjZXMgKGxpa2UgTWF0ZXJpYWxzLCBHZW9tZXRyaWVzLCBhbmRcbiAgICogVGV4dHVyZXMpIGNhbiBiZSByZXVzZWQgZGlyZWN0bHkgYW5kIGFyZSBub3QgbWFya2VkIGhlcmUuXG4gICAqXG4gICAqIEV4YW1wbGU6IENlc2l1bU1pbGtUcnVjayBzYW1wbGUgbW9kZWwgcmV1c2VzIFwiV2hlZWxcIiBtZXNoZXMuXG4gICAqL1xuICBfYWRkTm9kZVJlZihjYWNoZSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoY2FjaGUucmVmc1tpbmRleF0gPT09IHZvaWQgMCkge1xuICAgICAgY2FjaGUucmVmc1tpbmRleF0gPSBjYWNoZS51c2VzW2luZGV4XSA9IDA7XG4gICAgfVxuICAgIGNhY2hlLnJlZnNbaW5kZXhdKys7XG4gIH1cbiAgLyoqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gYSBzaGFyZWQgcmVzb3VyY2UsIGNsb25pbmcgaXQgaWYgbmVjZXNzYXJ5LiAqL1xuICBfZ2V0Tm9kZVJlZihjYWNoZSwgaW5kZXgsIG9iamVjdCkge1xuICAgIGlmIChjYWNoZS5yZWZzW2luZGV4XSA8PSAxKVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICBjb25zdCByZWYgPSBvYmplY3QuY2xvbmUoKTtcbiAgICBjb25zdCB1cGRhdGVNYXBwaW5ncyA9IChvcmlnaW5hbCwgY2xvbmUpID0+IHtcbiAgICAgIGNvbnN0IG1hcHBpbmdzID0gdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KG9yaWdpbmFsKTtcbiAgICAgIGlmIChtYXBwaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRpb25zLnNldChjbG9uZSwgbWFwcGluZ3MpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbaSwgY2hpbGRdIG9mIG9yaWdpbmFsLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICB1cGRhdGVNYXBwaW5ncyhjaGlsZCwgY2xvbmUuY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlTWFwcGluZ3Mob2JqZWN0LCByZWYpO1xuICAgIHJlZi5uYW1lICs9IFwiX2luc3RhbmNlX1wiICsgY2FjaGUudXNlc1tpbmRleF0rKztcbiAgICByZXR1cm4gcmVmO1xuICB9XG4gIF9pbnZva2VPbmUoZnVuYykge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7XG4gICAgZXh0ZW5zaW9ucy5wdXNoKHRoaXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZnVuYyhleHRlbnNpb25zW2ldKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9pbnZva2VBbGwoZnVuYykge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMucGx1Z2lucyk7XG4gICAgZXh0ZW5zaW9ucy51bnNoaWZ0KHRoaXMpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMoZXh0ZW5zaW9uc1tpXSk7XG4gICAgICBpZiAocmVzdWx0KVxuICAgICAgICBwZW5kaW5nLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSBzcGVjaWZpZWQgZGVwZW5kZW5jeSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRHxNYXRlcmlhbHxUSFJFRS5UZXh0dXJlfEFuaW1hdGlvbkNsaXB8QXJyYXlCdWZmZXJ8T2JqZWN0Pn1cbiAgICovXG4gIGdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IHR5cGUgKyBcIjpcIiArIGluZGV4O1xuICAgIGxldCBkZXBlbmRlbmN5ID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghZGVwZW5kZW5jeSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzY2VuZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTY2VuZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJub2RlXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE5vZGUgJiYgZXh0LmxvYWROb2RlKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc2hcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTWVzaCAmJiBleHQubG9hZE1lc2goaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWNjZXNzb3JcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQWNjZXNzb3IoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYnVmZmVyVmlld1wiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRCdWZmZXJWaWV3ICYmIGV4dC5sb2FkQnVmZmVyVmlldyhpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidWZmZXJcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQnVmZmVyKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1hdGVyaWFsXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE1hdGVyaWFsICYmIGV4dC5sb2FkTWF0ZXJpYWwoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dHVyZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRUZXh0dXJlICYmIGV4dC5sb2FkVGV4dHVyZShpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJza2luXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNraW4oaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYW5pbWF0aW9uXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZEFuaW1hdGlvbiAmJiBleHQubG9hZEFuaW1hdGlvbihpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYW1lcmFcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQ2FtZXJhKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dCAhPSB0aGlzICYmIGV4dC5nZXREZXBlbmRlbmN5ICYmIGV4dC5nZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgZGVwZW5kZW5jeSk7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE9iamVjdD4+fVxuICAgKi9cbiAgZ2V0RGVwZW5kZW5jaWVzKHR5cGUpIHtcbiAgICBsZXQgZGVwZW5kZW5jaWVzID0gdGhpcy5jYWNoZS5nZXQodHlwZSk7XG4gICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgICBjb25zdCBkZWZzID0gdGhpcy5qc29uW3R5cGUgKyAodHlwZSA9PT0gXCJtZXNoXCIgPyBcImVzXCIgOiBcInNcIildIHx8IFtdO1xuICAgICAgZGVwZW5kZW5jaWVzID0gUHJvbWlzZS5hbGwoXG4gICAgICAgIGRlZnMubWFwKGZ1bmN0aW9uKGRlZiwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHRoaXMuY2FjaGUuYWRkKHR5cGUsIGRlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGxvYWRCdWZmZXIoYnVmZmVySW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJEZWYgPSB0aGlzLmpzb24uYnVmZmVyc1tidWZmZXJJbmRleF07XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5maWxlTG9hZGVyO1xuICAgIGlmIChidWZmZXJEZWYudHlwZSAmJiBidWZmZXJEZWYudHlwZSAhPT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBcIiArIGJ1ZmZlckRlZi50eXBlICsgXCIgYnVmZmVyIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGlmIChidWZmZXJEZWYudXJpID09PSB2b2lkIDAgJiYgYnVmZmVySW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGXS5ib2R5KTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBsb2FkZXIubG9hZChMb2FkZXJVdGlscy5yZXNvbHZlVVJMKGJ1ZmZlckRlZi51cmksIG9wdGlvbnMucGF0aCksIHJlc29sdmUsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RIUkVFLkdMVEZMb2FkZXI6IEZhaWxlZCB0byBsb2FkIGJ1ZmZlciBcIicgKyBidWZmZXJEZWYudXJpICsgJ1wiLicpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2J1ZmZlcnMtYW5kLWJ1ZmZlci12aWV3c1xuICAgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyVmlld0luZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgbG9hZEJ1ZmZlclZpZXcoYnVmZmVyVmlld0luZGV4KSB7XG4gICAgY29uc3QgYnVmZmVyVmlld0RlZiA9IHRoaXMuanNvbi5idWZmZXJWaWV3c1tidWZmZXJWaWV3SW5kZXhdO1xuICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJcIiwgYnVmZmVyVmlld0RlZi5idWZmZXIpLnRoZW4oZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICBjb25zdCBieXRlTGVuZ3RoID0gYnVmZmVyVmlld0RlZi5ieXRlTGVuZ3RoIHx8IDA7XG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0gYnVmZmVyVmlld0RlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNhY2Nlc3NvcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFjY2Vzc29ySW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJBdHRyaWJ1dGV8SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU+fVxuICAgKi9cbiAgbG9hZEFjY2Vzc29yKGFjY2Vzc29ySW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgYWNjZXNzb3JEZWYgPSB0aGlzLmpzb24uYWNjZXNzb3JzW2FjY2Vzc29ySW5kZXhdO1xuICAgIGlmIChhY2Nlc3NvckRlZi5idWZmZXJWaWV3ID09PSB2b2lkIDAgJiYgYWNjZXNzb3JEZWYuc3BhcnNlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gV0VCR0xfVFlQRV9TSVpFU1thY2Nlc3NvckRlZi50eXBlXTtcbiAgICAgIGNvbnN0IFR5cGVkQXJyYXkgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcbiAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdCdWZmZXJWaWV3cyA9IFtdO1xuICAgIGlmIChhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuYnVmZmVyVmlldykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaChudWxsKTtcbiAgICB9XG4gICAgaWYgKGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ1ZmZlclZpZXcpKTtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5idWZmZXJWaWV3KSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nQnVmZmVyVmlld3MpLnRoZW4oZnVuY3Rpb24oYnVmZmVyVmlld3MpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBidWZmZXJWaWV3c1swXTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gV0VCR0xfVFlQRV9TSVpFU1thY2Nlc3NvckRlZi50eXBlXTtcbiAgICAgIGNvbnN0IFR5cGVkQXJyYXkgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICBjb25zdCBlbGVtZW50Qnl0ZXMgPSBUeXBlZEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgY29uc3QgaXRlbUJ5dGVzID0gZWxlbWVudEJ5dGVzICogaXRlbVNpemU7XG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0gYWNjZXNzb3JEZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgY29uc3QgYnl0ZVN0cmlkZSA9IGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCA/IGpzb24uYnVmZmVyVmlld3NbYWNjZXNzb3JEZWYuYnVmZmVyVmlld10uYnl0ZVN0cmlkZSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgbGV0IGFycmF5LCBidWZmZXJBdHRyaWJ1dGU7XG4gICAgICBpZiAoYnl0ZVN0cmlkZSAmJiBieXRlU3RyaWRlICE9PSBpdGVtQnl0ZXMpIHtcbiAgICAgICAgY29uc3QgaWJTbGljZSA9IE1hdGguZmxvb3IoYnl0ZU9mZnNldCAvIGJ5dGVTdHJpZGUpO1xuICAgICAgICBjb25zdCBpYkNhY2hlS2V5ID0gXCJJbnRlcmxlYXZlZEJ1ZmZlcjpcIiArIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgKyBcIjpcIiArIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgKyBcIjpcIiArIGliU2xpY2UgKyBcIjpcIiArIGFjY2Vzc29yRGVmLmNvdW50O1xuICAgICAgICBsZXQgaWIgPSBwYXJzZXIuY2FjaGUuZ2V0KGliQ2FjaGVLZXkpO1xuICAgICAgICBpZiAoIWliKSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShidWZmZXJWaWV3LCBpYlNsaWNlICogYnl0ZVN0cmlkZSwgYWNjZXNzb3JEZWYuY291bnQgKiBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzKTtcbiAgICAgICAgICBpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihhcnJheSwgYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyk7XG4gICAgICAgICAgcGFyc2VyLmNhY2hlLmFkZChpYkNhY2hlS2V5LCBpYik7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICAgIGliLFxuICAgICAgICAgIGl0ZW1TaXplLFxuICAgICAgICAgIGJ5dGVPZmZzZXQgJSBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzLFxuICAgICAgICAgIG5vcm1hbGl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChidWZmZXJWaWV3ID09PSBudWxsKSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXcsIGJ5dGVPZmZzZXQsIGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBpdGVtU2l6ZUluZGljZXMgPSBXRUJHTF9UWVBFX1NJWkVTLlNDQUxBUjtcbiAgICAgICAgY29uc3QgVHlwZWRBcnJheUluZGljZXMgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuY29tcG9uZW50VHlwZV07XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXRJbmRpY2VzID0gYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0VmFsdWVzID0gYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IHNwYXJzZUluZGljZXMgPSBuZXcgVHlwZWRBcnJheUluZGljZXMoXG4gICAgICAgICAgYnVmZmVyVmlld3NbMV0sXG4gICAgICAgICAgYnl0ZU9mZnNldEluZGljZXMsXG4gICAgICAgICAgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHNwYXJzZVZhbHVlcyA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXdzWzJdLCBieXRlT2Zmc2V0VmFsdWVzLCBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIGlmIChidWZmZXJWaWV3ICE9PSBudWxsKSB7XG4gICAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5hcnJheS5zbGljZSgpLFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLml0ZW1TaXplLFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHNwYXJzZUluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3BhcnNlSW5kaWNlc1tpXTtcbiAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WChpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZV0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSAyKVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFkoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAxXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDMpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WihpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDJdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gNClcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRXKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgM10pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSA1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgaXRlbVNpemUgaW4gc3BhcnNlIEJ1ZmZlckF0dHJpYnV0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJBdHRyaWJ1dGU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCN0ZXh0dXJlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gdGV4dHVyZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuVGV4dHVyZXxudWxsPn1cbiAgICovXG4gIGxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGNvbnN0IHNvdXJjZUluZGV4ID0gdGV4dHVyZURlZi5zb3VyY2U7XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLnRleHR1cmVMb2FkZXI7XG4gICAgaWYgKHNvdXJjZURlZi51cmkpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBvcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlcihzb3VyY2VEZWYudXJpKTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSBudWxsKVxuICAgICAgICBsb2FkZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgc291cmNlSW5kZXgsIGxvYWRlcik7XG4gIH1cbiAgbG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIHNvdXJjZUluZGV4LCBsb2FkZXIpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgY29uc3QgY2FjaGVLZXkgPSAoc291cmNlRGVmLnVyaSB8fCBzb3VyY2VEZWYuYnVmZmVyVmlldykgKyBcIjpcIiArIHRleHR1cmVEZWYuc2FtcGxlcjtcbiAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5sb2FkSW1hZ2VTb3VyY2Uoc291cmNlSW5kZXgsIGxvYWRlcikudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICB0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG4gICAgICB0ZXh0dXJlLm5hbWUgPSB0ZXh0dXJlRGVmLm5hbWUgfHwgc291cmNlRGVmLm5hbWUgfHwgXCJcIjtcbiAgICAgIGlmICh0ZXh0dXJlLm5hbWUgPT09IFwiXCIgJiYgdHlwZW9mIHNvdXJjZURlZi51cmkgPT09IFwic3RyaW5nXCIgJiYgc291cmNlRGVmLnVyaS5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9cIikgPT09IGZhbHNlKSB7XG4gICAgICAgIHRleHR1cmUubmFtZSA9IHNvdXJjZURlZi51cmk7XG4gICAgICB9XG4gICAgICBjb25zdCBzYW1wbGVycyA9IGpzb24uc2FtcGxlcnMgfHwge307XG4gICAgICBjb25zdCBzYW1wbGVyID0gc2FtcGxlcnNbdGV4dHVyZURlZi5zYW1wbGVyXSB8fCB7fTtcbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gV0VCR0xfRklMVEVSU1tzYW1wbGVyLm1hZ0ZpbHRlcl0gfHwgTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBXRUJHTF9GSUxURVJTW3NhbXBsZXIubWluRmlsdGVyXSB8fCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLndyYXBTID0gV0VCR0xfV1JBUFBJTkdTW3NhbXBsZXIud3JhcFNdIHx8IFJlcGVhdFdyYXBwaW5nO1xuICAgICAgdGV4dHVyZS53cmFwVCA9IFdFQkdMX1dSQVBQSU5HU1tzYW1wbGVyLndyYXBUXSB8fCBSZXBlYXRXcmFwcGluZztcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KHRleHR1cmUsIHsgdGV4dHVyZXM6IHRleHR1cmVJbmRleCB9KTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBsb2FkSW1hZ2VTb3VyY2Uoc291cmNlSW5kZXgsIGxvYWRlcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0udGhlbigodGV4dHVyZSkgPT4gdGV4dHVyZS5jbG9uZSgpKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGNvbnN0IFVSTCA9IHNlbGYuVVJMIHx8IHNlbGYud2Via2l0VVJMO1xuICAgIGxldCBzb3VyY2VVUkkgPSBzb3VyY2VEZWYudXJpIHx8IFwiXCI7XG4gICAgbGV0IGlzT2JqZWN0VVJMID0gZmFsc2U7XG4gICAgaWYgKHNvdXJjZURlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDApIHtcbiAgICAgIHNvdXJjZVVSSSA9IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBzb3VyY2VEZWYuYnVmZmVyVmlldykudGhlbihmdW5jdGlvbihidWZmZXJWaWV3KSB7XG4gICAgICAgIGlzT2JqZWN0VVJMID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJWaWV3XSwgeyB0eXBlOiBzb3VyY2VEZWYubWltZVR5cGUgfSk7XG4gICAgICAgIHNvdXJjZVVSSSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHJldHVybiBzb3VyY2VVUkk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZURlZi51cmkgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogSW1hZ2UgXCIgKyBzb3VyY2VJbmRleCArIFwiIGlzIG1pc3NpbmcgVVJJIGFuZCBidWZmZXJWaWV3XCIpO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHNvdXJjZVVSSSkudGhlbihmdW5jdGlvbihzb3VyY2VVUkkyKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCBvbkxvYWQgPSByZXNvbHZlO1xuICAgICAgICBpZiAobG9hZGVyLmlzSW1hZ2VCaXRtYXBMb2FkZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBvbkxvYWQgPSBmdW5jdGlvbihpbWFnZUJpdG1hcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGltYWdlQml0bWFwKTtcbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh0ZXh0dXJlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlci5sb2FkKExvYWRlclV0aWxzLnJlc29sdmVVUkwoc291cmNlVVJJMiwgb3B0aW9ucy5wYXRoKSwgb25Mb2FkLCB2b2lkIDAsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIGlmIChpc09iamVjdFVSTCA9PT0gdHJ1ZSkge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHNvdXJjZVVSSSk7XG4gICAgICB9XG4gICAgICB0ZXh0dXJlLnVzZXJEYXRhLm1pbWVUeXBlID0gc291cmNlRGVmLm1pbWVUeXBlIHx8IGdldEltYWdlVVJJTWltZVR5cGUoc291cmNlRGVmLnVyaSk7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IENvdWxkbid0IGxvYWQgdGV4dHVyZVwiLCBzb3VyY2VVUkkpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgdGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBhc3NpZ25zIGEgdGV4dHVyZSB0byB0aGUgZ2l2ZW4gbWF0ZXJpYWwgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsUGFyYW1zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEZWZcbiAgICogQHJldHVybiB7UHJvbWlzZTxUZXh0dXJlPn1cbiAgICovXG4gIGFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIG1hcE5hbWUsIG1hcERlZiwgZW5jb2RpbmcpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koXCJ0ZXh0dXJlXCIsIG1hcERlZi5pbmRleCkudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICBpZiAoIXRleHR1cmUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKG1hcERlZi50ZXhDb29yZCAhPT0gdm9pZCAwICYmIG1hcERlZi50ZXhDb29yZCA+IDApIHtcbiAgICAgICAgdGV4dHVyZSA9IHRleHR1cmUuY2xvbmUoKTtcbiAgICAgICAgdGV4dHVyZS5jaGFubmVsID0gbWFwRGVmLnRleENvb3JkO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlci5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXSkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBtYXBEZWYuZXh0ZW5zaW9ucyAhPT0gdm9pZCAwID8gbWFwRGVmLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dIDogdm9pZCAwO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgY29uc3QgZ2x0ZlJlZmVyZW5jZSA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KHRleHR1cmUpO1xuICAgICAgICAgIHRleHR1cmUgPSBwYXJzZXIuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0uZXh0ZW5kVGV4dHVyZSh0ZXh0dXJlLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KHRleHR1cmUsIGdsdGZSZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoXCJjb2xvclNwYWNlXCIgaW4gdGV4dHVyZSlcbiAgICAgICAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBlbmNvZGluZyA9PT0gMzAwMSA/IFwic3JnYlwiIDogXCJzcmdiLWxpbmVhclwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxQYXJhbXNbbWFwTmFtZV0gPSB0ZXh0dXJlO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbnMgZmluYWwgbWF0ZXJpYWwgdG8gYSBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuIFRoZSBpbnN0YW5jZVxuICAgKiBhbHJlYWR5IGhhcyBhIG1hdGVyaWFsIChnZW5lcmF0ZWQgZnJvbSB0aGUgZ2xURiBtYXRlcmlhbCBvcHRpb25zIGFsb25lKVxuICAgKiBidXQgcmV1c2Ugb2YgdGhlIHNhbWUgZ2xURiBtYXRlcmlhbCBtYXkgcmVxdWlyZSBtdWx0aXBsZSB0aHJlZWpzIG1hdGVyaWFsc1xuICAgKiB0byBhY2NvbW1vZGF0ZSBkaWZmZXJlbnQgcHJpbWl0aXZlIHR5cGVzLCBkZWZpbmVzLCBldGMuIE5ldyBtYXRlcmlhbHMgd2lsbFxuICAgKiBiZSBjcmVhdGVkIGlmIG5lY2Vzc2FyeSwgYW5kIHJldXNlZCBmcm9tIGEgY2FjaGUuXG4gICAqIEBwYXJhbSAge09iamVjdDNEfSBtZXNoIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS5cbiAgICovXG4gIGFzc2lnbkZpbmFsTWF0ZXJpYWwobWVzaCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcbiAgICBsZXQgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xuICAgIGNvbnN0IHVzZURlcml2YXRpdmVUYW5nZW50cyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudGFuZ2VudCA9PT0gdm9pZCAwO1xuICAgIGNvbnN0IHVzZVZlcnRleENvbG9ycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgIT09IHZvaWQgMDtcbiAgICBjb25zdCB1c2VGbGF0U2hhZGluZyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsID09PSB2b2lkIDA7XG4gICAgaWYgKG1lc2guaXNQb2ludHMpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJQb2ludHNNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQ7XG4gICAgICBsZXQgcG9pbnRzTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIXBvaW50c01hdGVyaWFsKSB7XG4gICAgICAgIHBvaW50c01hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCk7XG4gICAgICAgIE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwocG9pbnRzTWF0ZXJpYWwsIG1hdGVyaWFsKTtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwuY29sb3IuY29weShtYXRlcmlhbC5jb2xvcik7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLm1hcCA9IG1hdGVyaWFsLm1hcDtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBwb2ludHNNYXRlcmlhbCk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IHBvaW50c01hdGVyaWFsO1xuICAgIH0gZWxzZSBpZiAobWVzaC5pc0xpbmUpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJMaW5lQmFzaWNNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQ7XG4gICAgICBsZXQgbGluZU1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFsaW5lTWF0ZXJpYWwpIHtcbiAgICAgICAgbGluZU1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCk7XG4gICAgICAgIE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwobGluZU1hdGVyaWFsLCBtYXRlcmlhbCk7XG4gICAgICAgIGxpbmVNYXRlcmlhbC5jb2xvci5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICAgICAgbGluZU1hdGVyaWFsLm1hcCA9IG1hdGVyaWFsLm1hcDtcbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGxpbmVNYXRlcmlhbCk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IGxpbmVNYXRlcmlhbDtcbiAgICB9XG4gICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cyB8fCB1c2VWZXJ0ZXhDb2xvcnMgfHwgdXNlRmxhdFNoYWRpbmcpIHtcbiAgICAgIGxldCBjYWNoZUtleSA9IFwiQ2xvbmVkTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkICsgXCI6XCI7XG4gICAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzKVxuICAgICAgICBjYWNoZUtleSArPSBcImRlcml2YXRpdmUtdGFuZ2VudHM6XCI7XG4gICAgICBpZiAodXNlVmVydGV4Q29sb3JzKVxuICAgICAgICBjYWNoZUtleSArPSBcInZlcnRleC1jb2xvcnM6XCI7XG4gICAgICBpZiAodXNlRmxhdFNoYWRpbmcpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwiZmxhdC1zaGFkaW5nOlwiO1xuICAgICAgbGV0IGNhY2hlZE1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFjYWNoZWRNYXRlcmlhbCkge1xuICAgICAgICBjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgIGlmICh1c2VWZXJ0ZXhDb2xvcnMpXG4gICAgICAgICAgY2FjaGVkTWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVzZUZsYXRTaGFkaW5nKVxuICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLmZsYXRTaGFkaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cykge1xuICAgICAgICAgIGlmIChjYWNoZWRNYXRlcmlhbC5ub3JtYWxTY2FsZSlcbiAgICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlLnkgKj0gLTE7XG4gICAgICAgICAgaWYgKGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlKVxuICAgICAgICAgICAgY2FjaGVkTWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUueSAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgY2FjaGVkTWF0ZXJpYWwpO1xuICAgICAgICB0aGlzLmFzc29jaWF0aW9ucy5zZXQoY2FjaGVkTWF0ZXJpYWwsIHRoaXMuYXNzb2NpYXRpb25zLmdldChtYXRlcmlhbCkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBjYWNoZWRNYXRlcmlhbDtcbiAgICB9XG4gICAgbWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZSgpIHtcbiAgICByZXR1cm4gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWF0ZXJpYWxzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXRlcmlhbEluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8TWF0ZXJpYWw+fVxuICAgKi9cbiAgbG9hZE1hdGVyaWFsKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IGpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGxldCBtYXRlcmlhbFR5cGU7XG4gICAgY29uc3QgbWF0ZXJpYWxQYXJhbXMgPSB7fTtcbiAgICBjb25zdCBtYXRlcmlhbEV4dGVuc2lvbnMgPSBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBpZiAobWF0ZXJpYWxFeHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVF0pIHtcbiAgICAgIGNvbnN0IGttdUV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUXTtcbiAgICAgIG1hdGVyaWFsVHlwZSA9IGttdUV4dGVuc2lvbi5nZXRNYXRlcmlhbFR5cGUoKTtcbiAgICAgIHBlbmRpbmcucHVzaChrbXVFeHRlbnNpb24uZXh0ZW5kUGFyYW1zKG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MgfHwge307XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxKTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yKSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IuZnJvbUFycmF5KGFycmF5KTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WzNdO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUsIDMwMDEpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsUGFyYW1zLm1ldGFsbmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yICE9PSB2b2lkIDAgPyBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciA6IDE7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5yb3VnaG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCA/IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA6IDE7XG4gICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1ldGFsbmVzc01hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpKTtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInJvdWdobmVzc01hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsVHlwZSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgcmV0dXJuIGV4dC5nZXRNYXRlcmlhbFR5cGUgJiYgZXh0LmdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zICYmIGV4dC5leHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmRvdWJsZVNpZGVkID09PSB0cnVlKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaWRlID0gRG91YmxlU2lkZTtcbiAgICB9XG4gICAgY29uc3QgYWxwaGFNb2RlID0gbWF0ZXJpYWxEZWYuYWxwaGFNb2RlIHx8IEFMUEhBX01PREVTLk9QQVFVRTtcbiAgICBpZiAoYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5CTEVORCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgaWYgKGFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuTUFTSykge1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5hbHBoYVRlc3QgPSBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiAhPT0gdm9pZCAwID8gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgOiAwLjU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm5vcm1hbE1hcFwiLCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlKSk7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGU7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlLnNldChzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJhb01hcFwiLCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlKSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmFvTWFwSW50ZW5zaXR5ID0gbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkobWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IpO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImVtaXNzaXZlTWFwXCIsIG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSwgMzAwMSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IG1hdGVyaWFsVHlwZShtYXRlcmlhbFBhcmFtcyk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYubmFtZSlcbiAgICAgICAgbWF0ZXJpYWwubmFtZSA9IG1hdGVyaWFsRGVmLm5hbWU7XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG1hdGVyaWFsLCBtYXRlcmlhbERlZik7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChtYXRlcmlhbCwgeyBtYXRlcmlhbHM6IG1hdGVyaWFsSW5kZXggfSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1hdGVyaWFsLCBtYXRlcmlhbERlZik7XG4gICAgICByZXR1cm4gbWF0ZXJpYWw7XG4gICAgfSk7XG4gIH1cbiAgLyoqIFdoZW4gT2JqZWN0M0QgaW5zdGFuY2VzIGFyZSB0YXJnZXRlZCBieSBhbmltYXRpb24sIHRoZXkgbmVlZCB1bmlxdWUgbmFtZXMuICovXG4gIGNyZWF0ZVVuaXF1ZU5hbWUob3JpZ2luYWxOYW1lKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkTmFtZSA9IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKG9yaWdpbmFsTmFtZSB8fCBcIlwiKTtcbiAgICBpZiAoc2FuaXRpemVkTmFtZSBpbiB0aGlzLm5vZGVOYW1lc1VzZWQpIHtcbiAgICAgIHJldHVybiBzYW5pdGl6ZWROYW1lICsgXCJfXCIgKyArK3RoaXMubm9kZU5hbWVzVXNlZFtzYW5pdGl6ZWROYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlTmFtZXNVc2VkW3Nhbml0aXplZE5hbWVdID0gMDtcbiAgICAgIHJldHVybiBzYW5pdGl6ZWROYW1lO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNnZW9tZXRyeVxuICAgKlxuICAgKiBDcmVhdGVzIEJ1ZmZlckdlb21ldHJpZXMgZnJvbSBwcmltaXRpdmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PEdMVEYuUHJpbWl0aXZlPn0gcHJpbWl0aXZlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PEJ1ZmZlckdlb21ldHJ5Pj59XG4gICAqL1xuICBsb2FkR2VvbWV0cmllcyhwcmltaXRpdmVzKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wcmltaXRpdmVDYWNoZTtcbiAgICBmdW5jdGlvbiBjcmVhdGVEcmFjb1ByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgICAgIHJldHVybiBleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dLmRlY29kZVByaW1pdGl2ZShwcmltaXRpdmUsIHBhcnNlcikudGhlbihmdW5jdGlvbihnZW9tZXRyeSkge1xuICAgICAgICByZXR1cm4gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhnZW9tZXRyeSwgcHJpbWl0aXZlLCBwYXJzZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbaV07XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVByaW1pdGl2ZUtleShwcmltaXRpdmUpO1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBwZW5kaW5nLnB1c2goY2FjaGVkLnByb21pc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGdlb21ldHJ5UHJvbWlzZTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5leHRlbnNpb25zICYmIHByaW1pdGl2ZS5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dKSB7XG4gICAgICAgICAgZ2VvbWV0cnlQcm9taXNlID0gY3JlYXRlRHJhY29QcmltaXRpdmUocHJpbWl0aXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW9tZXRyeVByb21pc2UgPSBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBwcmltaXRpdmUsIHBhcnNlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVbY2FjaGVLZXldID0geyBwcmltaXRpdmUsIHByb21pc2U6IGdlb21ldHJ5UHJvbWlzZSB9O1xuICAgICAgICBwZW5kaW5nLnB1c2goZ2VvbWV0cnlQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21lc2hlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWVzaEluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8R3JvdXB8TWVzaHxTa2lubmVkTWVzaD59XG4gICAqL1xuICBsb2FkTWVzaChtZXNoSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBtZXNoRGVmID0ganNvbi5tZXNoZXNbbWVzaEluZGV4XTtcbiAgICBjb25zdCBwcmltaXRpdmVzID0gbWVzaERlZi5wcmltaXRpdmVzO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gcHJpbWl0aXZlc1tpXS5tYXRlcmlhbCA9PT0gdm9pZCAwID8gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKHRoaXMuY2FjaGUpIDogdGhpcy5nZXREZXBlbmRlbmN5KFwibWF0ZXJpYWxcIiwgcHJpbWl0aXZlc1tpXS5tYXRlcmlhbCk7XG4gICAgICBwZW5kaW5nLnB1c2gobWF0ZXJpYWwpO1xuICAgIH1cbiAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmxvYWRHZW9tZXRyaWVzKHByaW1pdGl2ZXMpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbHMgPSByZXN1bHRzLnNsaWNlKDAsIHJlc3VsdHMubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCBnZW9tZXRyaWVzID0gcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgbWVzaGVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgICAgICBjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzW2ldO1xuICAgICAgICBsZXQgbWVzaDtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbaV07XG4gICAgICAgIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyB8fCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQIHx8IHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOIHx8IHByaW1pdGl2ZS5tb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBtZXNoID0gbWVzaERlZi5pc1NraW5uZWRNZXNoID09PSB0cnVlID8gbmV3IFNraW5uZWRNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCkgOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgIGlmIChtZXNoLmlzU2tpbm5lZE1lc2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lc2gubm9ybWFsaXplU2tpbldlaWdodHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVApIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTikge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUobWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVGYW5EcmF3TW9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORVMpIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmVTZWdtZW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9TVFJJUCkge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9MT09QKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lTG9vcChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuUE9JTlRTKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBQb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBQcmltaXRpdmUgbW9kZSB1bnN1cHBvcnRlZDogXCIgKyBwcmltaXRpdmUubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc2guZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdXBkYXRlTW9ycGhUYXJnZXRzKG1lc2gsIG1lc2hEZWYpO1xuICAgICAgICB9XG4gICAgICAgIG1lc2gubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKG1lc2hEZWYubmFtZSB8fCBcIm1lc2hfXCIgKyBtZXNoSW5kZXgpO1xuICAgICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG1lc2gsIG1lc2hEZWYpO1xuICAgICAgICBpZiAocHJpbWl0aXZlLmV4dGVuc2lvbnMpXG4gICAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1lc2gsIHByaW1pdGl2ZSk7XG4gICAgICAgIHBhcnNlci5hc3NpZ25GaW5hbE1hdGVyaWFsKG1lc2gpO1xuICAgICAgICBtZXNoZXMucHVzaChtZXNoKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG1lc2hlc1tpXSwge1xuICAgICAgICAgIG1lc2hlczogbWVzaEluZGV4LFxuICAgICAgICAgIHByaW1pdGl2ZXM6IGlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobWVzaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAobWVzaERlZi5leHRlbnNpb25zKVxuICAgICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtZXNoZXNbMF0sIG1lc2hEZWYpO1xuICAgICAgICByZXR1cm4gbWVzaGVzWzBdO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICAgIGlmIChtZXNoRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBncm91cCwgbWVzaERlZik7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChncm91cCwgeyBtZXNoZXM6IG1lc2hJbmRleCB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwLmFkZChtZXNoZXNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjY2FtZXJhc1xuICAgKiBAcGFyYW0ge251bWJlcn0gY2FtZXJhSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5DYW1lcmE+fVxuICAgKi9cbiAgbG9hZENhbWVyYShjYW1lcmFJbmRleCkge1xuICAgIGxldCBjYW1lcmE7XG4gICAgY29uc3QgY2FtZXJhRGVmID0gdGhpcy5qc29uLmNhbWVyYXNbY2FtZXJhSW5kZXhdO1xuICAgIGNvbnN0IHBhcmFtcyA9IGNhbWVyYURlZltjYW1lcmFEZWYudHlwZV07XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgY2FtZXJhIHBhcmFtZXRlcnMuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FtZXJhRGVmLnR5cGUgPT09IFwicGVyc3BlY3RpdmVcIikge1xuICAgICAgY2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKFxuICAgICAgICBNYXRoVXRpbHMucmFkVG9EZWcocGFyYW1zLnlmb3YpLFxuICAgICAgICBwYXJhbXMuYXNwZWN0UmF0aW8gfHwgMSxcbiAgICAgICAgcGFyYW1zLnpuZWFyIHx8IDEsXG4gICAgICAgIHBhcmFtcy56ZmFyIHx8IDJlNlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNhbWVyYURlZi50eXBlID09PSBcIm9ydGhvZ3JhcGhpY1wiKSB7XG4gICAgICBjYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKC1wYXJhbXMueG1hZywgcGFyYW1zLnhtYWcsIHBhcmFtcy55bWFnLCAtcGFyYW1zLnltYWcsIHBhcmFtcy56bmVhciwgcGFyYW1zLnpmYXIpO1xuICAgIH1cbiAgICBpZiAoY2FtZXJhRGVmLm5hbWUpXG4gICAgICBjYW1lcmEubmFtZSA9IHRoaXMuY3JlYXRlVW5pcXVlTmFtZShjYW1lcmFEZWYubmFtZSk7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShjYW1lcmEsIGNhbWVyYURlZik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2tpbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNraW5JbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFNrZWxldG9uPn1cbiAgICovXG4gIGxvYWRTa2luKHNraW5JbmRleCkge1xuICAgIGNvbnN0IHNraW5EZWYgPSB0aGlzLmpzb24uc2tpbnNbc2tpbkluZGV4XTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc2tpbkRlZi5qb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgcGVuZGluZy5wdXNoKHRoaXMuX2xvYWROb2RlU2hhbGxvdyhza2luRGVmLmpvaW50c1tpXSkpO1xuICAgIH1cbiAgICBpZiAoc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZy5wdXNoKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBpbnZlcnNlQmluZE1hdHJpY2VzID0gcmVzdWx0cy5wb3AoKTtcbiAgICAgIGNvbnN0IGpvaW50Tm9kZXMgPSByZXN1bHRzO1xuICAgICAgY29uc3QgYm9uZXMgPSBbXTtcbiAgICAgIGNvbnN0IGJvbmVJbnZlcnNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gam9pbnROb2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGpvaW50Tm9kZSA9IGpvaW50Tm9kZXNbaV07XG4gICAgICAgIGlmIChqb2ludE5vZGUpIHtcbiAgICAgICAgICBib25lcy5wdXNoKGpvaW50Tm9kZSk7XG4gICAgICAgICAgY29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgICBpZiAoaW52ZXJzZUJpbmRNYXRyaWNlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF0LmZyb21BcnJheShpbnZlcnNlQmluZE1hdHJpY2VzLmFycmF5LCBpICogMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib25lSW52ZXJzZXMucHVzaChtYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogSm9pbnQgXCIlc1wiIGNvdWxkIG5vdCBiZSBmb3VuZC4nLCBza2luRGVmLmpvaW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU2tlbGV0b24oYm9uZXMsIGJvbmVJbnZlcnNlcyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNhbmltYXRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmltYXRpb25JbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFuaW1hdGlvbkNsaXA+fVxuICAgKi9cbiAgbG9hZEFuaW1hdGlvbihhbmltYXRpb25JbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgYW5pbWF0aW9uRGVmID0ganNvbi5hbmltYXRpb25zW2FuaW1hdGlvbkluZGV4XTtcbiAgICBjb25zdCBhbmltYXRpb25OYW1lID0gYW5pbWF0aW9uRGVmLm5hbWUgPyBhbmltYXRpb25EZWYubmFtZSA6IFwiYW5pbWF0aW9uX1wiICsgYW5pbWF0aW9uSW5kZXg7XG4gICAgY29uc3QgcGVuZGluZ05vZGVzID0gW107XG4gICAgY29uc3QgcGVuZGluZ0lucHV0QWNjZXNzb3JzID0gW107XG4gICAgY29uc3QgcGVuZGluZ091dHB1dEFjY2Vzc29ycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdTYW1wbGVycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdUYXJnZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHNbaV07XG4gICAgICBjb25zdCBzYW1wbGVyID0gYW5pbWF0aW9uRGVmLnNhbXBsZXJzW2NoYW5uZWwuc2FtcGxlcl07XG4gICAgICBjb25zdCB0YXJnZXQgPSBjaGFubmVsLnRhcmdldDtcbiAgICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubm9kZTtcbiAgICAgIGNvbnN0IGlucHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHZvaWQgMCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzW3NhbXBsZXIuaW5wdXRdIDogc2FtcGxlci5pbnB1dDtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1tzYW1wbGVyLm91dHB1dF0gOiBzYW1wbGVyLm91dHB1dDtcbiAgICAgIGlmICh0YXJnZXQubm9kZSA9PT0gdm9pZCAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHBlbmRpbmdOb2Rlcy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgbmFtZSkpO1xuICAgICAgcGVuZGluZ0lucHV0QWNjZXNzb3JzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgaW5wdXQpKTtcbiAgICAgIHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBvdXRwdXQpKTtcbiAgICAgIHBlbmRpbmdTYW1wbGVycy5wdXNoKHNhbXBsZXIpO1xuICAgICAgcGVuZGluZ1RhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ05vZGVzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdJbnB1dEFjY2Vzc29ycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nT3V0cHV0QWNjZXNzb3JzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdTYW1wbGVycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nVGFyZ2V0cylcbiAgICBdKS50aGVuKGZ1bmN0aW9uKGRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3Qgbm9kZXMgPSBkZXBlbmRlbmNpZXNbMF07XG4gICAgICBjb25zdCBpbnB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1sxXTtcbiAgICAgIGNvbnN0IG91dHB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1syXTtcbiAgICAgIGNvbnN0IHNhbXBsZXJzID0gZGVwZW5kZW5jaWVzWzNdO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IGRlcGVuZGVuY2llc1s0XTtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3IgPSBpbnB1dEFjY2Vzc29yc1tpXTtcbiAgICAgICAgY29uc3Qgb3V0cHV0QWNjZXNzb3IgPSBvdXRwdXRBY2Nlc3NvcnNbaV07XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1tpXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbm9kZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgbGV0IFR5cGVkS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgc3dpdGNoIChQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdKSB7XG4gICAgICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0czpcbiAgICAgICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5yb3RhdGlvbjpcbiAgICAgICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMucG9zaXRpb246XG4gICAgICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMuc2NhbGU6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXROYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lIDogbm9kZS51dWlkO1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uID0gc2FtcGxlci5pbnRlcnBvbGF0aW9uICE9PSB2b2lkIDAgPyBJTlRFUlBPTEFUSU9OW3NhbXBsZXIuaW50ZXJwb2xhdGlvbl0gOiBJbnRlcnBvbGF0ZUxpbmVhcjtcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0gPT09IFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzKSB7XG4gICAgICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzKSB7XG4gICAgICAgICAgICAgIHRhcmdldE5hbWVzLnB1c2gob2JqZWN0Lm5hbWUgPyBvYmplY3QubmFtZSA6IG9iamVjdC51dWlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXROYW1lcy5wdXNoKHRhcmdldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRwdXRBcnJheSA9IG91dHB1dEFjY2Vzc29yLmFycmF5O1xuICAgICAgICBpZiAob3V0cHV0QWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgICAgIGNvbnN0IHNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKG91dHB1dEFycmF5LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICBjb25zdCBzY2FsZWQgPSBuZXcgRmxvYXQzMkFycmF5KG91dHB1dEFycmF5Lmxlbmd0aCk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gb3V0cHV0QXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgc2NhbGVkW2pdID0gb3V0cHV0QXJyYXlbal0gKiBzY2FsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0QXJyYXkgPSBzY2FsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgIGNvbnN0IHRyYWNrID0gbmV3IFR5cGVkS2V5ZnJhbWVUcmFjayhcbiAgICAgICAgICAgIHRhcmdldE5hbWVzW2pdICsgXCIuXCIgKyBQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdLFxuICAgICAgICAgICAgaW5wdXRBY2Nlc3Nvci5hcnJheSxcbiAgICAgICAgICAgIG91dHB1dEFycmF5LFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHNhbXBsZXIuaW50ZXJwb2xhdGlvbiA9PT0gXCJDVUJJQ1NQTElORVwiKSB7XG4gICAgICAgICAgICB0cmFjay5jcmVhdGVJbnRlcnBvbGFudCA9IGZ1bmN0aW9uIEludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZShyZXN1bHQpIHtcbiAgICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhbnRUeXBlID0gdGhpcyBpbnN0YW5jZW9mIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID8gR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50IDogR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgaW50ZXJwb2xhbnRUeXBlKHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpIC8gMywgcmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKGFuaW1hdGlvbk5hbWUsIHZvaWQgMCwgdHJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAobm9kZURlZi5tZXNoID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJtZXNoXCIsIG5vZGVEZWYubWVzaCkudGhlbihmdW5jdGlvbihtZXNoKSB7XG4gICAgICBjb25zdCBub2RlID0gcGFyc2VyLl9nZXROb2RlUmVmKHBhcnNlci5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCwgbWVzaCk7XG4gICAgICBpZiAobm9kZURlZi53ZWlnaHRzICE9PSB2b2lkIDApIHtcbiAgICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihvKSB7XG4gICAgICAgICAgaWYgKCFvLmlzTWVzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2RlRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgby5tb3JwaFRhcmdldEluZmx1ZW5jZXNbaV0gPSBub2RlRGVmLndlaWdodHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbm9kZXMtYW5kLWhpZXJhcmNoeVxuICAgKiBAcGFyYW0ge251bWJlcn0gbm9kZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0Q+fVxuICAgKi9cbiAgbG9hZE5vZGUobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgY29uc3Qgbm9kZVBlbmRpbmcgPSBwYXJzZXIuX2xvYWROb2RlU2hhbGxvdyhub2RlSW5kZXgpO1xuICAgIGNvbnN0IGNoaWxkUGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGNoaWxkcmVuRGVmID0gbm9kZURlZi5jaGlsZHJlbiB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBjaGlsZHJlbkRlZi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjaGlsZFBlbmRpbmcucHVzaChwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgY2hpbGRyZW5EZWZbaV0pKTtcbiAgICB9XG4gICAgY29uc3Qgc2tlbGV0b25QZW5kaW5nID0gbm9kZURlZi5za2luID09PSB2b2lkIDAgPyBQcm9taXNlLnJlc29sdmUobnVsbCkgOiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcInNraW5cIiwgbm9kZURlZi5za2luKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW25vZGVQZW5kaW5nLCBQcm9taXNlLmFsbChjaGlsZFBlbmRpbmcpLCBza2VsZXRvblBlbmRpbmddKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSByZXN1bHRzWzBdO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSByZXN1bHRzWzFdO1xuICAgICAgY29uc3Qgc2tlbGV0b24gPSByZXN1bHRzWzJdO1xuICAgICAgaWYgKHNrZWxldG9uICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24obWVzaCkge1xuICAgICAgICAgIGlmICghbWVzaC5pc1NraW5uZWRNZXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIG1lc2guYmluZChza2VsZXRvbiwgX2lkZW50aXR5TWF0cml4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG5vZGUuYWRkKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG4gIC8vIC5fbG9hZE5vZGVTaGFsbG93KCkgcGFyc2VzIGEgc2luZ2xlIG5vZGUuXG4gIC8vIHNraW4gYW5kIGNoaWxkIG5vZGVzIGFyZSBjcmVhdGVkIGFuZCBhZGRlZCBpbiAubG9hZE5vZGUoKSAobm8gJ18nIHByZWZpeCkuXG4gIF9sb2FkTm9kZVNoYWxsb3cobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF07XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlRGVmLm5hbWUgPyBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShub2RlRGVmLm5hbWUpIDogXCJcIjtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgbWVzaFByb21pc2UgPSBwYXJzZXIuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuY3JlYXRlTm9kZU1lc2ggJiYgZXh0LmNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCk7XG4gICAgfSk7XG4gICAgaWYgKG1lc2hQcm9taXNlKSB7XG4gICAgICBwZW5kaW5nLnB1c2gobWVzaFByb21pc2UpO1xuICAgIH1cbiAgICBpZiAobm9kZURlZi5jYW1lcmEgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImNhbWVyYVwiLCBub2RlRGVmLmNhbWVyYSkudGhlbihmdW5jdGlvbihjYW1lcmEpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKHBhcnNlci5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEsIGNhbWVyYSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBwYXJzZXIuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQgJiYgZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50KG5vZGVJbmRleCk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocHJvbWlzZSk7XG4gICAgfSk7XG4gICAgdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XSA9IFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ob2JqZWN0cykge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICBpZiAobm9kZURlZi5pc0JvbmUgPT09IHRydWUpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBCb25lKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICBub2RlID0gbmV3IEdyb3VwKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG5vZGUgPSBvYmplY3RzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5ldyBPYmplY3QzRCgpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgIT09IG9iamVjdHNbMF0pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgbm9kZS5hZGQob2JqZWN0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlRGVmLm5hbWUpIHtcbiAgICAgICAgbm9kZS51c2VyRGF0YS5uYW1lID0gbm9kZURlZi5uYW1lO1xuICAgICAgICBub2RlLm5hbWUgPSBub2RlTmFtZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobm9kZSwgbm9kZURlZik7XG4gICAgICBpZiAobm9kZURlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbm9kZSwgbm9kZURlZik7XG4gICAgICBpZiAobm9kZURlZi5tYXRyaXggIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICBtYXRyaXguZnJvbUFycmF5KG5vZGVEZWYubWF0cml4KTtcbiAgICAgICAgbm9kZS5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlRGVmLnRyYW5zbGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnBvc2l0aW9uLmZyb21BcnJheShub2RlRGVmLnRyYW5zbGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZURlZi5yb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5xdWF0ZXJuaW9uLmZyb21BcnJheShub2RlRGVmLnJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZURlZi5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5zY2FsZS5mcm9tQXJyYXkobm9kZURlZi5zY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcGFyc2VyLmFzc29jaWF0aW9ucy5oYXMobm9kZSkpIHtcbiAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobm9kZSwge30pO1xuICAgICAgfVxuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQobm9kZSkubm9kZXMgPSBub2RlSW5kZXg7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NjZW5lc1xuICAgKiBAcGFyYW0ge251bWJlcn0gc2NlbmVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwPn1cbiAgICovXG4gIGxvYWRTY2VuZShzY2VuZUluZGV4KSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBzY2VuZURlZiA9IHRoaXMuanNvbi5zY2VuZXNbc2NlbmVJbmRleF07XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBHcm91cCgpO1xuICAgIGlmIChzY2VuZURlZi5uYW1lKVxuICAgICAgc2NlbmUubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKHNjZW5lRGVmLm5hbWUpO1xuICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoc2NlbmUsIHNjZW5lRGVmKTtcbiAgICBpZiAoc2NlbmVEZWYuZXh0ZW5zaW9ucylcbiAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBzY2VuZSwgc2NlbmVEZWYpO1xuICAgIGNvbnN0IG5vZGVJZHMgPSBzY2VuZURlZi5ub2RlcyB8fCBbXTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZUlkcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmdldERlcGVuZGVuY3koXCJub2RlXCIsIG5vZGVJZHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgc2NlbmUuYWRkKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZHVjZUFzc29jaWF0aW9ucyA9IChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZHVjZWRBc3NvY2lhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBwYXJzZXIuYXNzb2NpYXRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIE1hdGVyaWFsIHx8IGtleSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIHJlZHVjZWRBc3NvY2lhdGlvbnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLnRyYXZlcnNlKChub2RlMikgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hcHBpbmdzID0gcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQobm9kZTIpO1xuICAgICAgICAgIGlmIChtYXBwaW5ncyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZWR1Y2VkQXNzb2NpYXRpb25zLnNldChub2RlMiwgbWFwcGluZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWR1Y2VkQXNzb2NpYXRpb25zO1xuICAgICAgfTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMgPSByZWR1Y2VBc3NvY2lhdGlvbnMoc2NlbmUpO1xuICAgICAgcmV0dXJuIHNjZW5lO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IGJveCA9IG5ldyBCb3gzKCk7XG4gIGlmIChhdHRyaWJ1dGVzLlBPU0lUSU9OICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1thdHRyaWJ1dGVzLlBPU0lUSU9OXTtcbiAgICBjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG4gICAgY29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuICAgIGlmIChtaW4gIT09IHZvaWQgMCAmJiBtYXggIT09IHZvaWQgMCkge1xuICAgICAgYm94LnNldChuZXcgVmVjdG9yMyhtaW5bMF0sIG1pblsxXSwgbWluWzJdKSwgbmV3IFZlY3RvcjMobWF4WzBdLCBtYXhbMV0sIG1heFsyXSkpO1xuICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yLmNvbXBvbmVudFR5cGVdKTtcbiAgICAgICAgYm94Lm1pbi5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICAgIGJveC5tYXgubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0cyA9IHByaW1pdGl2ZURlZi50YXJnZXRzO1xuICBpZiAodGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbWF4RGlzcGxhY2VtZW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGlmICh0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1t0YXJnZXQuUE9TSVRJT05dO1xuICAgICAgICBjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcbiAgICAgICAgaWYgKG1pbiAhPT0gdm9pZCAwICYmIG1heCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmVjdG9yLnNldFgoTWF0aC5tYXgoTWF0aC5hYnMobWluWzBdKSwgTWF0aC5hYnMobWF4WzBdKSkpO1xuICAgICAgICAgIHZlY3Rvci5zZXRZKE1hdGgubWF4KE1hdGguYWJzKG1pblsxXSksIE1hdGguYWJzKG1heFsxXSkpKTtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WihNYXRoLm1heChNYXRoLmFicyhtaW5bMl0pLCBNYXRoLmFicyhtYXhbMl0pKSk7XG4gICAgICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveFNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3Nvci5jb21wb25lbnRUeXBlXSk7XG4gICAgICAgICAgICB2ZWN0b3IubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXhEaXNwbGFjZW1lbnQubWF4KHZlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBib3guZXhwYW5kQnlWZWN0b3IobWF4RGlzcGxhY2VtZW50KTtcbiAgfVxuICBnZW9tZXRyeS5ib3VuZGluZ0JveCA9IGJveDtcbiAgY29uc3Qgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICBib3guZ2V0Q2VudGVyKHNwaGVyZS5jZW50ZXIpO1xuICBzcGhlcmUucmFkaXVzID0gYm94Lm1pbi5kaXN0YW5jZVRvKGJveC5tYXgpIC8gMjtcbiAgZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBzcGhlcmU7XG59XG5mdW5jdGlvbiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgZnVuY3Rpb24gYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoYWNjZXNzb3JJbmRleCwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGFjY2Vzc29ySW5kZXgpLnRoZW4oZnVuY3Rpb24oYWNjZXNzb3IpIHtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhY2Nlc3Nvcik7XG4gICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBnbHRmQXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1tnbHRmQXR0cmlidXRlTmFtZV0gfHwgZ2x0ZkF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGhyZWVBdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpXG4gICAgICBjb250aW51ZTtcbiAgICBwZW5kaW5nLnB1c2goYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoYXR0cmlidXRlc1tnbHRmQXR0cmlidXRlTmFtZV0sIHRocmVlQXR0cmlidXRlTmFtZSkpO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYuaW5kaWNlcyAhPT0gdm9pZCAwICYmICFnZW9tZXRyeS5pbmRleCkge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBwcmltaXRpdmVEZWYuaW5kaWNlcykudGhlbihmdW5jdGlvbihhY2Nlc3NvcjIpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KGFjY2Vzc29yMik7XG4gICAgfSk7XG4gICAgcGVuZGluZy5wdXNoKGFjY2Vzc29yKTtcbiAgfVxuICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYpO1xuICBjb21wdXRlQm91bmRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcik7XG4gIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwID8gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYudGFyZ2V0cywgcGFyc2VyKSA6IGdlb21ldHJ5O1xuICB9KTtcbn1cbmV4cG9ydCB7XG4gIEdMVEZMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTFRGTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-stdlib/loaders/GLTFLoader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: function() { return /* binding */ getWithKey; }\n/* harmony export */ });\nconst getWithKey = (obj, key) => obj[key];\n\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdHlwZXMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdHlwZXMvaGVscGVycy5qcz80OWMxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdldFdpdGhLZXkgPSAob2JqLCBrZXkpID0+IG9ialtrZXldO1xuZXhwb3J0IHtcbiAgZ2V0V2l0aEtleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-stdlib/types/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: function() { return /* binding */ computeMorphedAttributes; },\n/* harmony export */   estimateBytesUsed: function() { return /* binding */ estimateBytesUsed; },\n/* harmony export */   interleaveAttributes: function() { return /* binding */ interleaveAttributes; },\n/* harmony export */   mergeBufferAttributes: function() { return /* binding */ mergeBufferAttributes; },\n/* harmony export */   mergeBufferGeometries: function() { return /* binding */ mergeBufferGeometries; },\n/* harmony export */   mergeVertices: function() { return /* binding */ mergeVertices; },\n/* harmony export */   toCreasedNormals: function() { return /* binding */ toCreasedNormals; },\n/* harmony export */   toTrianglesDrawMode: function() { return /* binding */ toTrianglesDrawMode; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(app-pages-browser)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n        const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()];\n  const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\n\n//# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVNO0FBQ3RKO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlEQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSkFBc0o7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0pBQXdKO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5REFBc0I7QUFDN0QscUNBQXFDLHlEQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTyxRQUFRLDBDQUFPLFFBQVEsMENBQU87QUFDMUQsdUJBQXVCLDBDQUFPO0FBQzlCLHVCQUF1QiwwQ0FBTztBQUM5Qix1QkFBdUIsMENBQU87QUFDOUIsd0JBQXdCLDBDQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQU87QUFDOUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFlO0FBQ3RDLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qcz8xNjNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgVHJpYW5nbGVzRHJhd01vZGUsIFRyaWFuZ2xlRmFuRHJhd01vZGUsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVmVjdG9yMywgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgZ2V0V2l0aEtleSB9IGZyb20gXCIuLi90eXBlcy9oZWxwZXJzLmpzXCI7XG5jb25zdCBtZXJnZUJ1ZmZlckdlb21ldHJpZXMgPSAoZ2VvbWV0cmllcywgdXNlR3JvdXBzKSA9PiB7XG4gIGNvbnN0IGlzSW5kZXhlZCA9IGdlb21ldHJpZXNbMF0uaW5kZXggIT09IG51bGw7XG4gIGNvbnN0IGF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLmF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZ2VvbWV0cmllc1swXS5tb3JwaEF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyaWVzWzBdLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuICBjb25zdCBtZXJnZWRHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tLCBpKSA9PiB7XG4gICAgbGV0IGF0dHJpYnV0ZXNDb3VudCA9IDA7XG4gICAgaWYgKGlzSW5kZXhlZCAhPT0gKGdlb20uaW5kZXggIT09IG51bGwpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gQWxsIGdlb21ldHJpZXMgbXVzdCBoYXZlIGNvbXBhdGlibGUgYXR0cmlidXRlczsgbWFrZSBzdXJlIGluZGV4IGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20uYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFhdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyAnLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgXCInICsgbmFtZSArICdcIiBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20uYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgICBhdHRyaWJ1dGVzQ291bnQrKztcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXNDb3VudCAhPT0gYXR0cmlidXRlc1VzZWQuc2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIE1ha2Ugc3VyZSBhbGwgZ2VvbWV0cmllcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSAhPT0gZ2VvbS5tb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIC5tb3JwaFRhcmdldHNSZWxhdGl2ZSBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20ubW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIW1vcnBoQXR0cmlidXRlc1VzZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuICAubW9ycGhBdHRyaWJ1dGVzIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9PT0gdm9pZCAwKVxuICAgICAgICBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20ubW9ycGhBdHRyaWJ1dGVzW25hbWVdKTtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEgPSBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSB8fCBbXTtcbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YS5wdXNoKGdlb20udXNlckRhdGEpO1xuICAgIGlmICh1c2VHcm91cHMpIHtcbiAgICAgIGxldCBjb3VudDtcbiAgICAgIGlmIChnZW9tLmluZGV4KSB7XG4gICAgICAgIGNvdW50ID0gZ2VvbS5pbmRleC5jb3VudDtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBUaGUgZ2VvbWV0cnkgbXVzdCBoYXZlIGVpdGhlciBhbiBpbmRleCBvciBhIHBvc2l0aW9uIGF0dHJpYnV0ZVwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbWVyZ2VkR2VvbWV0cnkuYWRkR3JvdXAob2Zmc2V0LCBjb3VudCwgaSk7XG4gICAgICBvZmZzZXQgKz0gY291bnQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKGlzSW5kZXhlZCkge1xuICAgIGxldCBpbmRleE9mZnNldCA9IDA7XG4gICAgY29uc3QgbWVyZ2VkSW5kZXggPSBbXTtcbiAgICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20pID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2VvbS5pbmRleDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXguY291bnQ7ICsraikge1xuICAgICAgICBtZXJnZWRJbmRleC5wdXNoKGluZGV4LmdldFgoaikgKyBpbmRleE9mZnNldCk7XG4gICAgICB9XG4gICAgICBpbmRleE9mZnNldCArPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgfSk7XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0SW5kZXgobWVyZ2VkSW5kZXgpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhhdHRyaWJ1dGVzW25hbWVdKTtcbiAgICBpZiAoIW1lcmdlZEF0dHJpYnV0ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgYXR0cmlidXRlLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1lcmdlZEdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBtZXJnZWRBdHRyaWJ1dGUpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhBdHRyaWJ1dGVzW25hbWVdWzBdLmxlbmd0aDtcbiAgICBpZiAobnVtTW9ycGhUYXJnZXRzID09PSAwKVxuICAgICAgYnJlYWs7XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzID0gbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyArK2kpIHtcbiAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UucHVzaChtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal1baV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVyZ2VkTW9ycGhBdHRyaWJ1dGUgPSBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMobW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSk7XG4gICAgICBpZiAoIW1lcmdlZE1vcnBoQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgbW9ycGhBdHRyaWJ1dGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0ucHVzaChtZXJnZWRNb3JwaEF0dHJpYnV0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRHZW9tZXRyeTtcbn07XG5jb25zdCBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGl0ZW1TaXplID0gdm9pZCAwO1xuICBsZXQgbm9ybWFsaXplZCA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgaWYgKFR5cGVkQXJyYXkgPT09IHZvaWQgMCkge1xuICAgICAgVHlwZWRBcnJheSA9IGF0dHIuYXJyYXkuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5hcnJheSBtdXN0IGJlIG9mIGNvbnNpc3RlbnQgYXJyYXkgdHlwZXMgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGl0ZW1TaXplID09PSB2b2lkIDApXG4gICAgICBpdGVtU2l6ZSA9IGF0dHIuaXRlbVNpemU7XG4gICAgaWYgKGl0ZW1TaXplICE9PSBhdHRyLml0ZW1TaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWQgPT09IHZvaWQgMClcbiAgICAgIG5vcm1hbGl6ZWQgPSBhdHRyLm5vcm1hbGl6ZWQ7XG4gICAgaWYgKG5vcm1hbGl6ZWQgIT09IGF0dHIubm9ybWFsaXplZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gIH0pO1xuICBpZiAoVHlwZWRBcnJheSAmJiBpdGVtU2l6ZSkge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYXJyYXlMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgYXJyYXkuc2V0KGF0dHIuYXJyYXksIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgfVxufTtcbmNvbnN0IGludGVybGVhdmVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IFR5cGVkQXJyYXkgPSB2b2lkIDA7XG4gIGxldCBhcnJheUxlbmd0aCA9IDA7XG4gIGxldCBzdHJpZGUgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKVxuICAgICAgVHlwZWRBcnJheSA9IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoVHlwZWRBcnJheSAhPT0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQXR0cmlidXRlQnVmZmVycyBvZiBkaWZmZXJlbnQgdHlwZXMgY2Fubm90IGJlIGludGVybGVhdmVkXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFycmF5TGVuZ3RoICs9IGF0dHJpYnV0ZS5hcnJheS5sZW5ndGg7XG4gICAgc3RyaWRlICs9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgfVxuICBjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCksIHN0cmlkZSk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGNvbnN0IHNldHRlcnMgPSBbXCJzZXRYXCIsIFwic2V0WVwiLCBcInNldFpcIiwgXCJzZXRXXCJdO1xuICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcbiAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICBjb25zdCBjb3VudCA9IGF0dHJpYnV0ZS5jb3VudDtcbiAgICBjb25zdCBpYmEgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXMucHVzaChpYmEpO1xuICAgIG9mZnNldCArPSBpdGVtU2l6ZTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvdW50OyBjKyspIHtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBjb25zdCBzZXQgPSBnZXRXaXRoS2V5KGliYSwgc2V0dGVyc1trXSk7XG4gICAgICAgIGNvbnN0IGdldCA9IGdldFdpdGhLZXkoYXR0cmlidXRlLCBnZXR0ZXJzW2tdKTtcbiAgICAgICAgc2V0KGMsIGdldChjKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gZXN0aW1hdGVCeXRlc1VzZWQoZ2VvbWV0cnkpIHtcbiAgbGV0IG1lbSA9IDA7XG4gIGZvciAobGV0IG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgbWVtICs9IGF0dHIuY291bnQgKiBhdHRyLml0ZW1TaXplICogYXR0ci5hcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgfVxuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgbWVtICs9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50ICogaW5kaWNlcy5pdGVtU2l6ZSAqIGluZGljZXMuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAwO1xuICByZXR1cm4gbWVtO1xufVxuZnVuY3Rpb24gbWVyZ2VWZXJ0aWNlcyhnZW9tZXRyeSwgdG9sZXJhbmNlID0gMWUtNCkge1xuICB0b2xlcmFuY2UgPSBNYXRoLm1heCh0b2xlcmFuY2UsIE51bWJlci5FUFNJTE9OKTtcbiAgY29uc3QgaGFzaFRvSW5kZXggPSB7fTtcbiAgY29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICBjb25zdCB2ZXJ0ZXhDb3VudCA9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50IDogcG9zaXRpb25zLmNvdW50O1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhnZW9tZXRyeS5hdHRyaWJ1dGVzKTtcbiAgY29uc3QgYXR0ckFycmF5cyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJzQXJyYXlzID0ge307XG4gIGNvbnN0IG5ld0luZGljZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGF0dHJBcnJheXNbbmFtZV0gPSBbXTtcbiAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgaWYgKG1vcnBoQXR0cikge1xuICAgICAgbW9ycGhBdHRyc0FycmF5c1tuYW1lXSA9IG5ldyBBcnJheShtb3JwaEF0dHIubGVuZ3RoKS5maWxsKDApLm1hcCgoKSA9PiBbXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxTaGlmdCA9IE1hdGgubG9nMTAoMSAvIHRvbGVyYW5jZSk7XG4gIGNvbnN0IHNoaWZ0TXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBkZWNpbWFsU2hpZnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcbiAgICBjb25zdCBpbmRleCA9IGluZGljZXMgPyBpbmRpY2VzLmdldFgoaSkgOiBpO1xuICAgIGxldCBoYXNoID0gXCJcIjtcbiAgICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgaGFzaCArPSBgJHt+fihhdHRyaWJ1dGVbZ2V0dGVyc1trXV0oaW5kZXgpICogc2hpZnRNdWx0aXBsaWVyKX0sYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc2ggaW4gaGFzaFRvSW5kZXgpIHtcbiAgICAgIG5ld0luZGljZXMucHVzaChoYXNoVG9JbmRleFtoYXNoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tqXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgICBjb25zdCBuZXdhcnJheSA9IGF0dHJBcnJheXNbbmFtZV07XG4gICAgICAgIGNvbnN0IG5ld01vcnBoQXJyYXlzID0gbW9ycGhBdHRyc0FycmF5c1tuYW1lXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgICAgY29uc3QgZ2V0dGVyRnVuYyA9IGdldHRlcnNba107XG4gICAgICAgICAgbmV3YXJyYXkucHVzaChhdHRyaWJ1dGVbZ2V0dGVyRnVuY10oaW5kZXgpKTtcbiAgICAgICAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHIubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuICAgICAgICAgICAgICBuZXdNb3JwaEFycmF5c1ttXS5wdXNoKG1vcnBoQXR0clttXVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFzaFRvSW5kZXhbaGFzaF0gPSBuZXh0SW5kZXg7XG4gICAgICBuZXdJbmRpY2VzLnB1c2gobmV4dEluZGV4KTtcbiAgICAgIG5leHRJbmRleCsrO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICBjb25zdCBvbGRBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IG9sZEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcihhdHRyQXJyYXlzW25hbWVdKTtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlciwgb2xkQXR0cmlidXRlLml0ZW1TaXplLCBvbGRBdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgcmVzdWx0LnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpO1xuICAgIGlmIChuYW1lIGluIG1vcnBoQXR0cnNBcnJheXMpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyc0FycmF5c1tuYW1lXS5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBvbGRNb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXTtcbiAgICAgICAgY29uc3QgYnVmZmVyMiA9IG5ldyBvbGRNb3JwaEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcihtb3JwaEF0dHJzQXJyYXlzW25hbWVdW2pdKTtcbiAgICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcjIsIG9sZE1vcnBoQXR0cmlidXRlLml0ZW1TaXplLCBvbGRNb3JwaEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICAgICAgcmVzdWx0Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXSA9IG1vcnBoQXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXN1bHQuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RyaWFuZ2xlc0RyYXdNb2RlKGdlb21ldHJ5LCBkcmF3TW9kZSkge1xuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlc0RyYXdNb2RlKSB7XG4gICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IEdlb21ldHJ5IGFscmVhZHkgZGVmaW5lZCBhcyB0cmlhbmdsZXMuXCIpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUgfHwgZHJhd01vZGUgPT09IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSkge1xuICAgIGxldCBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICAgICAgaWYgKHBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbi5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGdlb21ldHJ5LnNldEluZGV4KGluZGljZXMpO1xuICAgICAgICBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuZGVmaW5lZCBwb3NpdGlvbiBhdHRyaWJ1dGUuIFByb2Nlc3Npbmcgbm90IHBvc3NpYmxlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZUcmlhbmdsZXMgPSBpbmRleC5jb3VudCAtIDI7XG4gICAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICAgIGlmIChpbmRleCkge1xuICAgICAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG51bWJlck9mVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WCgwKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3SW5kaWNlcy5sZW5ndGggLyAzICE9PSBudW1iZXJPZlRyaWFuZ2xlcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmFibGUgdG8gZ2VuZXJhdGUgY29ycmVjdCBhbW91bnQgb2YgdHJpYW5nbGVzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbmV3R2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICAgIG5ld0dlb21ldHJ5LnNldEluZGV4KG5ld0luZGljZXMpO1xuICAgIG5ld0dlb21ldHJ5LmNsZWFyR3JvdXBzKCk7XG4gICAgcmV0dXJuIG5ld0dlb21ldHJ5O1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5rbm93biBkcmF3IG1vZGU6XCIsIGRyYXdNb2RlKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyhvYmplY3QpIHtcbiAgaWYgKG9iamVjdC5nZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICE9PSB0cnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IEdlb21ldHJ5IGlzIG5vdCBvZiB0eXBlIEJ1ZmZlckdlb21ldHJ5LlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBfdkEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEMgPSBuZXcgVmVjdG9yMygpO1xuICBmdW5jdGlvbiBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEob2JqZWN0MiwgbWF0ZXJpYWwyLCBhdHRyaWJ1dGUsIG1vcnBoQXR0cmlidXRlLCBtb3JwaFRhcmdldHNSZWxhdGl2ZTIsIGEyLCBiMiwgYzIsIG1vZGlmaWVkQXR0cmlidXRlQXJyYXkpIHtcbiAgICBfdkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGEyKTtcbiAgICBfdkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGIyKTtcbiAgICBfdkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGMyKTtcbiAgICBjb25zdCBtb3JwaEluZmx1ZW5jZXMgPSBvYmplY3QyLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcbiAgICBpZiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBtYXRlcmlhbDIubW9ycGhUYXJnZXRzICYmIG1vcnBoQXR0cmlidXRlICYmIG1vcnBoSW5mbHVlbmNlc1xuICAgICkge1xuICAgICAgX21vcnBoQS5zZXQoMCwgMCwgMCk7XG4gICAgICBfbW9ycGhCLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEMuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgaTIgPSAwLCBpbDIgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkyIDwgaWwyOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1tpMl07XG4gICAgICAgIGNvbnN0IG1vcnBoID0gbW9ycGhBdHRyaWJ1dGVbaTJdO1xuICAgICAgICBpZiAoaW5mbHVlbmNlID09PSAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBfdGVtcEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYTIpO1xuICAgICAgICBfdGVtcEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYjIpO1xuICAgICAgICBfdGVtcEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYzIpO1xuICAgICAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUyKSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQiwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMsIGluZmx1ZW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLnN1YihfdkEpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQi5zdWIoX3ZCKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMuc3ViKF92QyksIGluZmx1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF92QS5hZGQoX21vcnBoQSk7XG4gICAgICBfdkIuYWRkKF9tb3JwaEIpO1xuICAgICAgX3ZDLmFkZChfbW9ycGhDKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdDIuaXNTa2lubmVkTWVzaCkge1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGEyLCBfdkEpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGIyLCBfdkIpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGMyLCBfdkMpO1xuICAgIH1cbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDBdID0gX3ZBLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAxXSA9IF92QS55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMl0gPSBfdkEuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDBdID0gX3ZCLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAxXSA9IF92Qi55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMl0gPSBfdkIuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDBdID0gX3ZDLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAxXSA9IF92Qy55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMl0gPSBfdkMuejtcbiAgfVxuICBjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgY29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG4gIGxldCBhLCBiLCBjO1xuICBjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICBjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG5vcm1hbEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuICBjb25zdCBtb3JwaE5vcm1hbCA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICBjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG4gIGxldCBpLCBqLCBpbCwgamw7XG4gIGxldCBncm91cCwgZ3JvdXBNYXRlcmlhbDtcbiAgbGV0IHN0YXJ0LCBlbmQ7XG4gIGNvbnN0IG1vZGlmaWVkUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uQXR0cmlidXRlLmNvdW50ICogcG9zaXRpb25BdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBjb25zdCBtb2RpZmllZE5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsQXR0cmlidXRlLmNvdW50ICogbm9ybWFsQXR0cmlidXRlLml0ZW1TaXplKTtcbiAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcbiAgICAgICAgICBhID0gaW5kZXguZ2V0WChqKTtcbiAgICAgICAgICBiID0gaW5kZXguZ2V0WChqICsgMSk7XG4gICAgICAgICAgYyA9IGluZGV4LmdldFgoaiArIDIpO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgIGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuICAgICAgICBhID0gaW5kZXguZ2V0WChpKTtcbiAgICAgICAgYiA9IGluZGV4LmdldFgoaSArIDEpO1xuICAgICAgICBjID0gaW5kZXguZ2V0WChpICsgMik7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHBvc2l0aW9uQXR0cmlidXRlICE9PSB2b2lkIDApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBqO1xuICAgICAgICAgIGIgPSBqICsgMTtcbiAgICAgICAgICBjID0gaiArIDI7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4ocG9zaXRpb25BdHRyaWJ1dGUuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpO1xuICAgICAgICBiID0gaSArIDE7XG4gICAgICAgIGMgPSBpICsgMjtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobW9kaWZpZWRQb3NpdGlvbiwgMyk7XG4gIGNvbnN0IG1vcnBoZWROb3JtYWxBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZE5vcm1hbCwgMyk7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgbm9ybWFsQXR0cmlidXRlLFxuICAgIG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBtb3JwaGVkTm9ybWFsQXR0cmlidXRlXG4gIH07XG59XG5mdW5jdGlvbiB0b0NyZWFzZWROb3JtYWxzKGdlb21ldHJ5LCBjcmVhc2VBbmdsZSA9IE1hdGguUEkgLyAzKSB7XG4gIGNvbnN0IGNyZWFzZURvdCA9IE1hdGguY29zKGNyZWFzZUFuZ2xlKTtcbiAgY29uc3QgaGFzaE11bHRpcGxpZXIgPSAoMSArIDFlLTEwKSAqIDEwMDtcbiAgY29uc3QgdmVydHMgPSBbbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKV07XG4gIGNvbnN0IHRlbXBWZWMxID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcFZlYzIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wTm9ybSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIGhhc2hWZXJ0ZXgodikge1xuICAgIGNvbnN0IHggPSB+fih2LnggKiBoYXNoTXVsdGlwbGllcik7XG4gICAgY29uc3QgeSA9IH5+KHYueSAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB6ID0gfn4odi56ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIHJldHVybiBgJHt4fSwke3l9LCR7en1gO1xuICB9XG4gIGNvbnN0IHJlc3VsdEdlb21ldHJ5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS50b05vbkluZGV4ZWQoKSA6IGdlb21ldHJ5O1xuICBjb25zdCBwb3NBdHRyID0gcmVzdWx0R2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgdmVydGV4TWFwID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyh0ZW1wVmVjMSwgdGVtcFZlYzIpLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMzsgbisrKSB7XG4gICAgICBjb25zdCB2ZXJ0ID0gdmVydHNbbl07XG4gICAgICBjb25zdCBoYXNoID0gaGFzaFZlcnRleCh2ZXJ0KTtcbiAgICAgIGlmICghKGhhc2ggaW4gdmVydGV4TWFwKSkge1xuICAgICAgICB2ZXJ0ZXhNYXBbaGFzaF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHZlcnRleE1hcFtoYXNoXS5wdXNoKG5vcm1hbCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShwb3NBdHRyLmNvdW50ICogMyk7XG4gIGNvbnN0IG5vcm1BdHRyID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBcnJheSwgMywgZmFsc2UpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaTMgPSAzICogaTtcbiAgICBjb25zdCBhID0gdmVydHNbMF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDApO1xuICAgIGNvbnN0IGIgPSB2ZXJ0c1sxXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMSk7XG4gICAgY29uc3QgYyA9IHZlcnRzWzJdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAyKTtcbiAgICB0ZW1wVmVjMS5zdWJWZWN0b3JzKGMsIGIpO1xuICAgIHRlbXBWZWMyLnN1YlZlY3RvcnMoYSwgYik7XG4gICAgdGVtcE5vcm0uY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgY29uc3Qgb3RoZXJOb3JtYWxzID0gdmVydGV4TWFwW2hhc2hdO1xuICAgICAgdGVtcE5vcm0yLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGsgPSAwLCBsayA9IG90aGVyTm9ybWFscy5sZW5ndGg7IGsgPCBsazsgaysrKSB7XG4gICAgICAgIGNvbnN0IG90aGVyTm9ybSA9IG90aGVyTm9ybWFsc1trXTtcbiAgICAgICAgaWYgKHRlbXBOb3JtLmRvdChvdGhlck5vcm0pID4gY3JlYXNlRG90KSB7XG4gICAgICAgICAgdGVtcE5vcm0yLmFkZChvdGhlck5vcm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wTm9ybTIubm9ybWFsaXplKCk7XG4gICAgICBub3JtQXR0ci5zZXRYWVooaTMgKyBuLCB0ZW1wTm9ybTIueCwgdGVtcE5vcm0yLnksIHRlbXBOb3JtMi56KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0R2VvbWV0cnkuc2V0QXR0cmlidXRlKFwibm9ybWFsXCIsIG5vcm1BdHRyKTtcbiAgcmV0dXJuIHJlc3VsdEdlb21ldHJ5O1xufVxuZXhwb3J0IHtcbiAgY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzLFxuICBlc3RpbWF0ZUJ5dGVzVXNlZCxcbiAgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMsXG4gIG1lcmdlQnVmZmVyQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzLFxuICBtZXJnZVZlcnRpY2VzLFxuICB0b0NyZWFzZWROb3JtYWxzLFxuICB0b1RyaWFuZ2xlc0RyYXdNb2RlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyR2VvbWV0cnlVdGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SDFGenerator; }\n/* harmony export */ });\nfunction SDFGenerator() {\nvar exports = (function (exports) {\n\n  /**\n   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n    pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n  }\n\n  /**\n   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n    pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n  }\n\n  /**\n   * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(\n   *   command: 'L'|'Q'|'C',\n   *   startX: number,\n   *   startY: number,\n   *   endX: number,\n   *   endY: number,\n   *   ctrl1X?: number,\n   *   ctrl1Y?: number,\n   *   ctrl2X?: number,\n   *   ctrl2Y?: number\n   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n   *                      command identifier (only L/Q/C commands) and its numeric arguments.\n   */\n  function forEachPathCommand(pathString, commandCallback) {\n    var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n    var match, firstX, firstY, prevX, prevY;\n    while ((match = segmentRE.exec(pathString))) {\n      var args = match[2]\n        .replace(/^\\s*|\\s*$/g, '')\n        .split(/[,\\s]+/)\n        .map(function (v) { return parseFloat(v); });\n      switch (match[1]) {\n        case 'M':\n          prevX = firstX = args[0];\n          prevY = firstY = args[1];\n          break\n        case 'L':\n          if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands\n            commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));\n          }\n          break\n        case 'Q': {\n          commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);\n          break\n        }\n        case 'C': {\n          commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);\n          break\n        }\n        case 'Z':\n          if (prevX !== firstX || prevY !== firstY) {\n            commandCallback('L', prevX, prevY, firstX, firstY);\n          }\n          break\n      }\n    }\n  }\n\n  /**\n   * Convert a path string to a series of straight line segments\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n   *        function that will be called once for every line segment\n   * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n   *        bezier curve in the path. Defaults to 16.\n   */\n  function pathToLineSegments (pathString, segmentCallback, curvePoints) {\n    if ( curvePoints === void 0 ) curvePoints = 16;\n\n    var tempPoint = { x: 0, y: 0 };\n    forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n      switch (command) {\n        case 'L':\n          segmentCallback(startX, startY, endX, endY);\n          break\n        case 'Q': {\n          var prevCurveX = startX;\n          var prevCurveY = startY;\n          for (var i = 1; i < curvePoints; i++) {\n            pointOnQuadraticBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              endX, endY,\n              i / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n            prevCurveX = tempPoint.x;\n            prevCurveY = tempPoint.y;\n          }\n          break\n        }\n        case 'C': {\n          var prevCurveX$1 = startX;\n          var prevCurveY$1 = startY;\n          for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n            pointOnCubicBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              ctrl2X, ctrl2Y,\n              endX, endY,\n              i$1 / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n            prevCurveX$1 = tempPoint.x;\n            prevCurveY$1 = tempPoint.y;\n          }\n          break\n        }\n      }\n    });\n  }\n\n  var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n\n  var cache = new WeakMap();\n\n  var glContextParams = {\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: true,\n    antialias: false,\n    depth: false,\n  };\n\n  /**\n   * This is a little helper library for WebGL. It assists with state management for a GL context.\n   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n   *\n   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n   */\n  function withWebGLContext (glOrCanvas, callback) {\n    var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n    var wrapper = cache.get(gl);\n    if (!wrapper) {\n      var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n      var extensions = {};\n      var programs = {};\n      var textures = {};\n      var textureUnit = -1;\n      var framebufferStack = [];\n\n      gl.canvas.addEventListener('webglcontextlost', function (e) {\n        handleContextLoss();\n        e.preventDefault();\n      }, false);\n\n      function getExtension (name) {\n        var ext = extensions[name];\n        if (!ext) {\n          ext = extensions[name] = gl.getExtension(name);\n          if (!ext) {\n            throw new Error((name + \" not supported\"))\n          }\n        }\n        return ext\n      }\n\n      function compileShader (src, type) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n        // if (!status && !gl.isContextLost()) {\n        //   throw new Error(gl.getShaderInfoLog(shader).trim())\n        // }\n        return shader\n      }\n\n      function withProgram (name, vert, frag, func) {\n        if (!programs[name]) {\n          var attributes = {};\n          var uniforms = {};\n          var program = gl.createProgram();\n          gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n          gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n          gl.linkProgram(program);\n\n          programs[name] = {\n            program: program,\n            transaction: function transaction (func) {\n              gl.useProgram(program);\n              func({\n                setUniform: function setUniform (type, name) {\n                  var values = [], len = arguments.length - 2;\n                  while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n                  var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                  gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));\n                },\n\n                setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {\n                  var attr = attributes[name];\n                  if (!attr) {\n                    attr = attributes[name] = {\n                      buf: gl.createBuffer(), // TODO should we destroy our buffers?\n                      loc: gl.getAttribLocation(program, name),\n                      data: null\n                    };\n                  }\n                  gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                  gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                  gl.enableVertexAttribArray(attr.loc);\n                  if (isWebGL2) {\n                    gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                  } else {\n                    getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                  }\n                  if (data !== attr.data) {\n                    gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                    attr.data = data;\n                  }\n                }\n              });\n            }\n          };\n        }\n\n        programs[name].transaction(func);\n      }\n\n      function withTexture (name, func) {\n        textureUnit++;\n        try {\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          var texture = textures[name];\n          if (!texture) {\n            texture = textures[name] = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n          }\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          func(texture, textureUnit);\n        } finally {\n          textureUnit--;\n        }\n      }\n\n      function withTextureFramebuffer (texture, textureUnit, func) {\n        var framebuffer = gl.createFramebuffer();\n        framebufferStack.push(framebuffer);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        try {\n          func(framebuffer);\n        } finally {\n          gl.deleteFramebuffer(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n        }\n      }\n\n      function handleContextLoss () {\n        extensions = {};\n        programs = {};\n        textures = {};\n        textureUnit = -1;\n        framebufferStack.length = 0;\n      }\n\n      cache.set(gl, wrapper = {\n        gl: gl,\n        isWebGL2: isWebGL2,\n        getExtension: getExtension,\n        withProgram: withProgram,\n        withTexture: withTexture,\n        withTextureFramebuffer: withTextureFramebuffer,\n        handleContextLoss: handleContextLoss,\n      });\n    }\n    callback(wrapper);\n  }\n\n\n  function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n    if ( channels === void 0 ) channels = 15;\n    if ( framebuffer === void 0 ) framebuffer = null;\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n\n      withTexture('copy', function (tex, texUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n        withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n          var setUniform = ref.setUniform;\n          var setAttribute = ref.setAttribute;\n\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n          setUniform('1i', 'image', texUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n          gl.viewport(x, y, width, height);\n          gl.scissor(x, y, width, height);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n    });\n  }\n\n  /**\n   * Resizing a canvas clears its contents; this utility copies the previous contents over.\n   * @param canvas\n   * @param newWidth\n   * @param newHeight\n   */\n  function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n    var width = canvas.width;\n    var height = canvas.height;\n    withWebGLContext(canvas, function (ref) {\n      var gl = ref.gl;\n\n      var data = new Uint8Array(width * height * 4);\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      renderImageData(gl, data, 0, 0, width, height);\n    });\n  }\n\n  var webglUtils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    withWebGLContext: withWebGLContext,\n    renderImageData: renderImageData,\n    resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n  });\n\n  function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    var textureData = new Uint8Array(sdfWidth * sdfHeight);\n\n    var viewBoxWidth = viewBox[2] - viewBox[0];\n    var viewBoxHeight = viewBox[3] - viewBox[1];\n\n    // Decompose all paths into straight line segments and add them to an index\n    var segments = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      segments.push({\n        x1: x1, y1: y1, x2: x2, y2: y2,\n        minX: Math.min(x1, x2),\n        minY: Math.min(y1, y2),\n        maxX: Math.max(x1, x2),\n        maxY: Math.max(y1, y2)\n      });\n    });\n\n    // Sort segments by maxX, this will let us short-circuit some loops below\n    segments.sort(function (a, b) { return a.maxX - b.maxX; });\n\n    // For each target SDF texel, find the distance from its center to its nearest line segment,\n    // map that distance to an alpha value, and write that alpha to the texel\n    for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n      for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n        var signedDist = findNearestSignedDistance(\n          viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,\n          viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight\n        );\n\n        // Use an exponential scale to ensure the texels very near the glyph path have adequate\n        // precision, while allowing the distance field to cover the entire texture, given that\n        // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n        var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;\n        if (signedDist < 0) {\n          alpha = 1 - alpha;\n        }\n\n        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n        textureData[sdfY * sdfWidth + sdfX] = alpha;\n      }\n    }\n\n    return textureData\n\n    /**\n     * For a given x/y, search the index for the closest line segment and return\n     * its signed distance. Negative = inside, positive = outside, zero = on edge\n     * @param x\n     * @param y\n     * @returns {number}\n     */\n    function findNearestSignedDistance (x, y) {\n      var closestDistSq = Infinity;\n      var closestDist = Infinity;\n\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit\n        if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n          var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n          if (distSq < closestDistSq) {\n            closestDistSq = distSq;\n            closestDist = Math.sqrt(closestDistSq);\n          }\n        }\n      }\n\n      // Flip to negative distance if inside the poly\n      if (isPointInPoly(x, y)) {\n        closestDist = -closestDist;\n      }\n      return closestDist\n    }\n\n    /**\n     * Determine whether the given point lies inside or outside the glyph. Uses a simple\n     * winding-number ray casting algorithm using a ray pointing east from the point.\n     */\n    function isPointInPoly (x, y) {\n      var winding = 0;\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit\n        var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);\n        if (intersects) {\n          winding += seg.y1 < seg.y2 ? 1 : -1;\n        }\n      }\n      return winding !== 0\n    }\n  }\n\n  function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n    // Expand single-channel data to rbga\n    var rgbaData = new Uint8Array(data.length * 4);\n    for (var i = 0; i < data.length; i++) {\n      rgbaData[i * 4 + channel] = data[i];\n    }\n    renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);\n  }\n\n  /**\n   * Find the absolute distance from a point to a line segment at closest approach\n   */\n  function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {\n    var ldx = lineX1 - lineX0;\n    var ldy = lineY1 - lineY0;\n    var lengthSq = ldx * ldx + ldy * ldy;\n    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n    var dx = x - (lineX0 + t * ldx);\n    var dy = y - (lineY0 + t * ldy);\n    return dx * dx + dy * dy\n  }\n\n  var javascript = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$2,\n    generateIntoCanvas: generateIntoCanvas$2,\n    generateIntoFramebuffer: generateIntoFramebuffer$1\n  });\n\n  var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n\n  var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n  // Single triangle covering viewport\n  var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n\n  var implicitContext = null;\n  var isTestingSupport = false;\n  var NULL_OBJECT = {};\n  var supportByCanvas = new WeakMap(); // canvas -> bool\n\n  function validateSupport (glOrCanvas) {\n    if (!isTestingSupport && !isSupported(glOrCanvas)) {\n      throw new Error('WebGL generation not supported')\n    }\n  }\n\n  function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( glOrCanvas === void 0 ) glOrCanvas = null;\n\n    if (!glOrCanvas) {\n      glOrCanvas = implicitContext;\n      if (!glOrCanvas) {\n        var canvas = typeof OffscreenCanvas === 'function'\n          ? new OffscreenCanvas(1, 1)\n          : typeof document !== 'undefined'\n            ? document.createElement('canvas')\n            : null;\n        if (!canvas) {\n          throw new Error('OffscreenCanvas or DOM canvas not supported')\n        }\n        glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });\n      }\n    }\n\n    validateSupport(glOrCanvas);\n\n    var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n    // Render into a background texture framebuffer\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n\n      withTexture('readable', function (texture, textureUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n          generateIntoFramebuffer(\n            sdfWidth,\n            sdfHeight,\n            path,\n            viewBox,\n            maxDistance,\n            sdfExponent,\n            gl,\n            framebuffer,\n            0,\n            0,\n            0 // red channel\n          );\n          gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n        });\n      });\n    });\n\n    // Throw away all but the red channel\n    var data = new Uint8Array(sdfWidth * sdfHeight);\n    for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n      data[j++] = rgbaData[i];\n    }\n\n    return data\n  }\n\n  function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    // Verify support\n    validateSupport(glOrCanvas);\n\n    // Compute path segments\n    var lineSegmentCoords = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      lineSegmentCoords.push(x1, y1, x2, y2);\n    });\n    lineSegmentCoords = new Float32Array(lineSegmentCoords);\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var isWebGL2 = ref.isWebGL2;\n      var getExtension = ref.getExtension;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n      var handleContextLoss = ref.handleContextLoss;\n\n      withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n        if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n          gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA,\n            intermediateTexture._lastWidth = sdfWidth,\n            intermediateTexture._lastHeight = sdfHeight,\n            0, gl.RGBA, gl.UNSIGNED_BYTE, null\n          );\n        }\n\n        // Unsigned distance pass\n        withProgram('main', mainVertex, mainFragment, function (ref) {\n          var setAttribute = ref.setAttribute;\n          var setUniform = ref.setUniform;\n\n          // Init extensions\n          var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n          var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n          // Init/update attributes\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n          // Init/update uniforms\n          setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));\n          setUniform('1f', 'uMaxDistance', maxDistance);\n          setUniform('1f', 'uExponent', sdfExponent);\n\n          // Render initial unsigned distance / winding number info to a texture\n          withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n            gl.enable(gl.BLEND);\n            gl.colorMask(true, true, true, true);\n            gl.viewport(0, 0, sdfWidth, sdfHeight);\n            gl.scissor(0, 0, sdfWidth, sdfHeight);\n            gl.blendFunc(gl.ONE, gl.ONE);\n            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n            // Alpha holds the closest (MAX) unsigned distance.\n            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            if (isWebGL2) {\n              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            } else {\n              instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            }\n            // Debug\n            // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n            // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n            // console.log('intermediate texture data: ', debug)\n          });\n        });\n\n        // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n        withProgram('post', viewportQuadVertex, postFragment, function (program) {\n          program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          program.setUniform('1i', 'tex', intermediateTextureUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n          gl.viewport(x, y, sdfWidth, sdfHeight);\n          gl.scissor(x, y, sdfWidth, sdfHeight);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n\n      // Handle context loss occurring during any of the above calls\n      if (gl.isContextLost()) {\n        handleContextLoss();\n        throw new Error('webgl context lost')\n      }\n    });\n  }\n\n  function isSupported (glOrCanvas) {\n    var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);\n    var supported = supportByCanvas.get(key);\n    if (supported === undefined) {\n      isTestingSupport = true;\n      var failReason = null;\n      try {\n        // Since we can't detect all failure modes up front, let's just do a trial run of a\n        // simple path and compare what we get back to the correct expected result. This will\n        // also serve to prime the shader compilation.\n        var expectedResult = [\n          97, 106, 97, 61,\n          99, 137, 118, 80,\n          80, 118, 137, 99,\n          61, 97, 106, 97\n        ];\n        var testResult = generate$1(\n          4,\n          4,\n          'M8,8L16,8L24,24L16,24Z',\n          [0, 0, 32, 32],\n          24,\n          1,\n          glOrCanvas\n        );\n        supported = testResult && expectedResult.length === testResult.length &&\n          testResult.every(function (val, i) { return val === expectedResult[i]; });\n        if (!supported) {\n          failReason = 'bad trial run results';\n          console.info(expectedResult, testResult);\n        }\n      } catch (err) {\n        // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n        supported = false;\n        failReason = err.message;\n      }\n      if (failReason) {\n        console.warn('WebGL SDF generation not supported:', failReason);\n      }\n      isTestingSupport = false;\n      supportByCanvas.set(key, supported);\n    }\n    return supported\n  }\n\n  var webgl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$1,\n    generateIntoCanvas: generateIntoCanvas$1,\n    generateIntoFramebuffer: generateIntoFramebuffer,\n    isSupported: isSupported\n  });\n\n  /**\n   * Generate an SDF texture image for a 2D path.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @return {Uint8Array}\n   */\n  function generate(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    try {\n      return generate$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generate$2.apply(javascript, arguments)\n    }\n  }\n\n  /**\n   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n   * @param {number} x - the x position at which to render the SDF.\n   * @param {number} y - the y position at which to render the SDF.\n   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n   * @return {Uint8Array}\n   */\n  function generateIntoCanvas(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent,\n    canvas,\n    x,\n    y,\n    channel\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    try {\n      return generateIntoCanvas$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generateIntoCanvas$2.apply(javascript, arguments)\n    }\n  }\n\n  exports.forEachPathCommand = forEachPathCommand;\n  exports.generate = generate;\n  exports.generateIntoCanvas = generateIntoCanvas;\n  exports.javascript = javascript;\n  exports.pathToLineSegments = pathToLineSegments;\n  exports.webgl = webgl;\n  exports.webglUtils = webglUtils;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn exports\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJnbC1zZGYtZ2VuZXJhdG9yL2Rpc3Qvd2ViZ2wtc2RmLWdlbmVyYXRvci5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsK0NBQStDO0FBQ3BFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUSwrQ0FBK0M7QUFDcEUsYUFBYSxzREFBc0Q7QUFDbkU7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0RBQWtELG1CQUFtQixpQkFBaUIs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O0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRLHFEQUFxRDtBQUMxRSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRLDJGQUEyRjtBQUNoSDtBQUNBLGFBQWEsUUFBUSw4RUFBOEU7QUFDbkc7QUFDQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RDs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvd2ViZ2wtc2RmLWdlbmVyYXRvci9kaXN0L3dlYmdsLXNkZi1nZW5lcmF0b3IubWpzPzBmM2UiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gU0RGR2VuZXJhdG9yKCkge1xudmFyIGV4cG9ydHMgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAvKipcbiAgICogRmluZCB0aGUgcG9pbnQgb24gYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIGF0IHQgd2hlcmUgdCBpcyBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAqL1xuICBmdW5jdGlvbiBwb2ludE9uUXVhZHJhdGljQmV6aWVyICh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB0LCBwb2ludE91dCkge1xuICAgIHZhciB0MiA9IDEgLSB0O1xuICAgIHBvaW50T3V0LnggPSB0MiAqIHQyICogeDAgKyAyICogdDIgKiB0ICogeDEgKyB0ICogdCAqIHgyO1xuICAgIHBvaW50T3V0LnkgPSB0MiAqIHQyICogeTAgKyAyICogdDIgKiB0ICogeTEgKyB0ICogdCAqIHkyO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHBvaW50IG9uIGEgY3ViaWMgYmV6aWVyIGN1cnZlIGF0IHQgd2hlcmUgdCBpcyBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAqL1xuICBmdW5jdGlvbiBwb2ludE9uQ3ViaWNCZXppZXIgKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdCwgcG9pbnRPdXQpIHtcbiAgICB2YXIgdDIgPSAxIC0gdDtcbiAgICBwb2ludE91dC54ID0gdDIgKiB0MiAqIHQyICogeDAgKyAzICogdDIgKiB0MiAqIHQgKiB4MSArIDMgKiB0MiAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICBwb2ludE91dC55ID0gdDIgKiB0MiAqIHQyICogeTAgKyAzICogdDIgKiB0MiAqIHQgKiB5MSArIDMgKiB0MiAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHBhdGggc3RyaW5nIGludG8gaXRzIGNvbnN0aXR1ZW50IGxpbmUvY3VydmUgY29tbWFuZHMsIGludm9raW5nIGEgY2FsbGJhY2sgZm9yIGVhY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nIC0gQW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgdG8gcGFyc2U7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFxuICAgKiAgIGNvbW1hbmQ6ICdMJ3wnUSd8J0MnLFxuICAgKiAgIHN0YXJ0WDogbnVtYmVyLFxuICAgKiAgIHN0YXJ0WTogbnVtYmVyLFxuICAgKiAgIGVuZFg6IG51bWJlcixcbiAgICogICBlbmRZOiBudW1iZXIsXG4gICAqICAgY3RybDFYPzogbnVtYmVyLFxuICAgKiAgIGN0cmwxWT86IG51bWJlcixcbiAgICogICBjdHJsMlg/OiBudW1iZXIsXG4gICAqICAgY3RybDJZPzogbnVtYmVyXG4gICAqICl9IGNvbW1hbmRDYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIHBhcnNlZCBwYXRoIGNvbW1hbmQsIHBhc3NpbmcgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgaWRlbnRpZmllciAob25seSBML1EvQyBjb21tYW5kcykgYW5kIGl0cyBudW1lcmljIGFyZ3VtZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIGZvckVhY2hQYXRoQ29tbWFuZChwYXRoU3RyaW5nLCBjb21tYW5kQ2FsbGJhY2spIHtcbiAgICB2YXIgc2VnbWVudFJFID0gLyhbTUxRQ1pdKShbXk1MUUNaXSopL2c7XG4gICAgdmFyIG1hdGNoLCBmaXJzdFgsIGZpcnN0WSwgcHJldlgsIHByZXZZO1xuICAgIHdoaWxlICgobWF0Y2ggPSBzZWdtZW50UkUuZXhlYyhwYXRoU3RyaW5nKSkpIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2hbMl1cbiAgICAgICAgLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKVxuICAgICAgICAuc3BsaXQoL1ssXFxzXSsvKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBwYXJzZUZsb2F0KHYpOyB9KTtcbiAgICAgIHN3aXRjaCAobWF0Y2hbMV0pIHtcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgcHJldlggPSBmaXJzdFggPSBhcmdzWzBdO1xuICAgICAgICAgIHByZXZZID0gZmlyc3RZID0gYXJnc1sxXTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICBpZiAoYXJnc1swXSAhPT0gcHJldlggfHwgYXJnc1sxXSAhPT0gcHJldlkpIHsgLy8geXVwLCBzb21lIGZvbnRzIGhhdmUgemVyby1sZW5ndGggbGluZSBjb21tYW5kc1xuICAgICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdMJywgcHJldlgsIHByZXZZLCAocHJldlggPSBhcmdzWzBdKSwgKHByZXZZID0gYXJnc1sxXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdRJzoge1xuICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnUScsIHByZXZYLCBwcmV2WSwgKHByZXZYID0gYXJnc1syXSksIChwcmV2WSA9IGFyZ3NbM10pLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0MnOiB7XG4gICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdDJywgcHJldlgsIHByZXZZLCAocHJldlggPSBhcmdzWzRdKSwgKHByZXZZID0gYXJnc1s1XSksIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgaWYgKHByZXZYICE9PSBmaXJzdFggfHwgcHJldlkgIT09IGZpcnN0WSkge1xuICAgICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdMJywgcHJldlgsIHByZXZZLCBmaXJzdFgsIGZpcnN0WSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBwYXRoIHN0cmluZyB0byBhIHNlcmllcyBvZiBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nIC0gQW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgdG8gcGFyc2U7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHgxOm51bWJlciwgeTE6bnVtYmVyLCB4MjpudW1iZXIsIHkyOm51bWJlcil9IHNlZ21lbnRDYWxsYmFjayAtIEEgY2FsbGJhY2tcbiAgICogICAgICAgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZXZlcnkgbGluZSBzZWdtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VydmVQb2ludHNdIC0gSG93IG1hbnkgc3RyYWlnaHQgbGluZSBzZWdtZW50cyB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIGFcbiAgICogICAgICAgIGJlemllciBjdXJ2ZSBpbiB0aGUgcGF0aC4gRGVmYXVsdHMgdG8gMTYuXG4gICAqL1xuICBmdW5jdGlvbiBwYXRoVG9MaW5lU2VnbWVudHMgKHBhdGhTdHJpbmcsIHNlZ21lbnRDYWxsYmFjaywgY3VydmVQb2ludHMpIHtcbiAgICBpZiAoIGN1cnZlUG9pbnRzID09PSB2b2lkIDAgKSBjdXJ2ZVBvaW50cyA9IDE2O1xuXG4gICAgdmFyIHRlbXBQb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGZvckVhY2hQYXRoQ29tbWFuZChwYXRoU3RyaW5nLCBmdW5jdGlvbiAoY29tbWFuZCwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGN0cmwxWCwgY3RybDFZLCBjdHJsMlgsIGN0cmwyWSkge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIHNlZ21lbnRDYWxsYmFjayhzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnUSc6IHtcbiAgICAgICAgICB2YXIgcHJldkN1cnZlWCA9IHN0YXJ0WDtcbiAgICAgICAgICB2YXIgcHJldkN1cnZlWSA9IHN0YXJ0WTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGN1cnZlUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50T25RdWFkcmF0aWNCZXppZXIoXG4gICAgICAgICAgICAgIHN0YXJ0WCwgc3RhcnRZLFxuICAgICAgICAgICAgICBjdHJsMVgsIGN0cmwxWSxcbiAgICAgICAgICAgICAgZW5kWCwgZW5kWSxcbiAgICAgICAgICAgICAgaSAvIChjdXJ2ZVBvaW50cyAtIDEpLFxuICAgICAgICAgICAgICB0ZW1wUG9pbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWdtZW50Q2FsbGJhY2socHJldkN1cnZlWCwgcHJldkN1cnZlWSwgdGVtcFBvaW50LngsIHRlbXBQb2ludC55KTtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVggPSB0ZW1wUG9pbnQueDtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVkgPSB0ZW1wUG9pbnQueTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdDJzoge1xuICAgICAgICAgIHZhciBwcmV2Q3VydmVYJDEgPSBzdGFydFg7XG4gICAgICAgICAgdmFyIHByZXZDdXJ2ZVkkMSA9IHN0YXJ0WTtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPCBjdXJ2ZVBvaW50czsgaSQxKyspIHtcbiAgICAgICAgICAgIHBvaW50T25DdWJpY0JlemllcihcbiAgICAgICAgICAgICAgc3RhcnRYLCBzdGFydFksXG4gICAgICAgICAgICAgIGN0cmwxWCwgY3RybDFZLFxuICAgICAgICAgICAgICBjdHJsMlgsIGN0cmwyWSxcbiAgICAgICAgICAgICAgZW5kWCwgZW5kWSxcbiAgICAgICAgICAgICAgaSQxIC8gKGN1cnZlUG9pbnRzIC0gMSksXG4gICAgICAgICAgICAgIHRlbXBQb2ludFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNlZ21lbnRDYWxsYmFjayhwcmV2Q3VydmVYJDEsIHByZXZDdXJ2ZVkkMSwgdGVtcFBvaW50LngsIHRlbXBQb2ludC55KTtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVgkMSA9IHRlbXBQb2ludC54O1xuICAgICAgICAgICAgcHJldkN1cnZlWSQxID0gdGVtcFBvaW50Lnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciB2aWV3cG9ydFF1YWRWZXJ0ZXggPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDthdHRyaWJ1dGUgdmVjMiBhVVY7dmFyeWluZyB2ZWMyIHZVVjt2b2lkIG1haW4oKXt2VVY9YVVWO2dsX1Bvc2l0aW9uPXZlYzQobWl4KHZlYzIoLTEuMCksdmVjMigxLjApLGFVViksMC4wLDEuMCk7fVwiO1xuXG4gIHZhciBjb3B5VGV4RnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDt1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7dmFyeWluZyB2ZWMyIHZVVjt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dGV4dHVyZTJEKHRleCx2VVYpO31cIjtcblxuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIHZhciBnbENvbnRleHRQYXJhbXMgPSB7XG4gICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUsXG4gICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICBkZXB0aDogZmFsc2UsXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBsaXR0bGUgaGVscGVyIGxpYnJhcnkgZm9yIFdlYkdMLiBJdCBhc3Npc3RzIHdpdGggc3RhdGUgbWFuYWdlbWVudCBmb3IgYSBHTCBjb250ZXh0LlxuICAgKiBJdCdzIHByZXR0eSB0aWdodGx5IHdyYXBwZWQgdG8gdGhlIG5lZWRzIG9mIHRoaXMgcGFja2FnZSwgbm90IHZlcnkgZ2VuZXJhbC1wdXJwb3NlLlxuICAgKlxuICAgKiBAcGFyYW0geyBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcyB9IGdsT3JDYW52YXMgLSB0aGUgR0wgY29udGV4dCB0byB3cmFwXG4gICAqIEBwYXJhbSB7ICh7Z2wsIGdldEV4dGVuc2lvbiwgd2l0aFByb2dyYW0sIHdpdGhUZXh0dXJlLCB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyLCBoYW5kbGVDb250ZXh0TG9zc30pID0+IHZvaWQgfSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gd2l0aFdlYkdMQ29udGV4dCAoZ2xPckNhbnZhcywgY2FsbGJhY2spIHtcbiAgICB2YXIgZ2wgPSBnbE9yQ2FudmFzLmdldENvbnRleHQgPyBnbE9yQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgZ2xDb250ZXh0UGFyYW1zKSA6IGdsT3JDYW52YXM7XG4gICAgdmFyIHdyYXBwZXIgPSBjYWNoZS5nZXQoZ2wpO1xuICAgIGlmICghd3JhcHBlcikge1xuICAgICAgdmFyIGlzV2ViR0wyID0gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgIHZhciBleHRlbnNpb25zID0ge307XG4gICAgICB2YXIgcHJvZ3JhbXMgPSB7fTtcbiAgICAgIHZhciB0ZXh0dXJlcyA9IHt9O1xuICAgICAgdmFyIHRleHR1cmVVbml0ID0gLTE7XG4gICAgICB2YXIgZnJhbWVidWZmZXJTdGFjayA9IFtdO1xuXG4gICAgICBnbC5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGhhbmRsZUNvbnRleHRMb3NzKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBleHQgPSBleHRlbnNpb25zW25hbWVdO1xuICAgICAgICBpZiAoIWV4dCkge1xuICAgICAgICAgIGV4dCA9IGV4dGVuc2lvbnNbbmFtZV0gPSBnbC5nZXRFeHRlbnNpb24obmFtZSk7XG4gICAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigobmFtZSArIFwiIG5vdCBzdXBwb3J0ZWRcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcGlsZVNoYWRlciAoc3JjLCB0eXBlKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgLy8gY29uc3Qgc3RhdHVzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpXG4gICAgICAgIC8vIGlmICghc3RhdHVzICYmICFnbC5pc0NvbnRleHRMb3N0KCkpIHtcbiAgICAgICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpLnRyaW0oKSlcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gc2hhZGVyXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdpdGhQcm9ncmFtIChuYW1lLCB2ZXJ0LCBmcmFnLCBmdW5jKSB7XG4gICAgICAgIGlmICghcHJvZ3JhbXNbbmFtZV0pIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHt9O1xuICAgICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBjb21waWxlU2hhZGVyKHZlcnQsIGdsLlZFUlRFWF9TSEFERVIpKTtcbiAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgY29tcGlsZVNoYWRlcihmcmFnLCBnbC5GUkFHTUVOVF9TSEFERVIpKTtcbiAgICAgICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgICAgICAgIHByb2dyYW1zW25hbWVdID0ge1xuICAgICAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBmdW5jdGlvbiB0cmFuc2FjdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICBmdW5jKHtcbiAgICAgICAgICAgICAgICBzZXRVbmlmb3JtOiBmdW5jdGlvbiBzZXRVbmlmb3JtICh0eXBlLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSB2YWx1ZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cbiAgICAgICAgICAgICAgICAgIHZhciB1bmlmb3JtTG9jID0gdW5pZm9ybXNbbmFtZV0gfHwgKHVuaWZvcm1zW25hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpKTtcbiAgICAgICAgICAgICAgICAgIGdsWyhcInVuaWZvcm1cIiArIHR5cGUpXS5hcHBseShnbCwgWyB1bmlmb3JtTG9jIF0uY29uY2F0KCB2YWx1ZXMgKSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlIChuYW1lLCBzaXplLCB1c2FnZSwgaW5zdGFuY2luZ0Rpdmlzb3IsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmICghYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBhdHRyID0gYXR0cmlidXRlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBidWY6IGdsLmNyZWF0ZUJ1ZmZlcigpLCAvLyBUT0RPIHNob3VsZCB3ZSBkZXN0cm95IG91ciBidWZmZXJzP1xuICAgICAgICAgICAgICAgICAgICAgIGxvYzogZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGF0dHIuYnVmKTtcbiAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0ci5sb2MsIHNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyLmxvYyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyLmxvYywgaW5zdGFuY2luZ0Rpdmlzb3IpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJykudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGF0dHIubG9jLCBpbnN0YW5jaW5nRGl2aXNvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gYXR0ci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCB1c2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3JhbXNbbmFtZV0udHJhbnNhY3Rpb24oZnVuYyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdpdGhUZXh0dXJlIChuYW1lLCBmdW5jKSB7XG4gICAgICAgIHRleHR1cmVVbml0Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRleHR1cmVzW25hbWVdO1xuICAgICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgdGV4dHVyZSA9IHRleHR1cmVzW25hbWVdID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICAgIGZ1bmModGV4dHVyZSwgdGV4dHVyZVVuaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRleHR1cmVVbml0LS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd2l0aFRleHR1cmVGcmFtZWJ1ZmZlciAodGV4dHVyZSwgdGV4dHVyZVVuaXQsIGZ1bmMpIHtcbiAgICAgICAgdmFyIGZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgZnJhbWVidWZmZXJTdGFjay5wdXNoKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZ1bmMoZnJhbWVidWZmZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyU3RhY2tbLS1mcmFtZWJ1ZmZlclN0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNvbnRleHRMb3NzICgpIHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHt9O1xuICAgICAgICBwcm9ncmFtcyA9IHt9O1xuICAgICAgICB0ZXh0dXJlcyA9IHt9O1xuICAgICAgICB0ZXh0dXJlVW5pdCA9IC0xO1xuICAgICAgICBmcmFtZWJ1ZmZlclN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnNldChnbCwgd3JhcHBlciA9IHtcbiAgICAgICAgZ2w6IGdsLFxuICAgICAgICBpc1dlYkdMMjogaXNXZWJHTDIsXG4gICAgICAgIGdldEV4dGVuc2lvbjogZ2V0RXh0ZW5zaW9uLFxuICAgICAgICB3aXRoUHJvZ3JhbTogd2l0aFByb2dyYW0sXG4gICAgICAgIHdpdGhUZXh0dXJlOiB3aXRoVGV4dHVyZSxcbiAgICAgICAgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlcjogd2l0aFRleHR1cmVGcmFtZWJ1ZmZlcixcbiAgICAgICAgaGFuZGxlQ29udGV4dExvc3M6IGhhbmRsZUNvbnRleHRMb3NzLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNhbGxiYWNrKHdyYXBwZXIpO1xuICB9XG5cblxuICBmdW5jdGlvbiByZW5kZXJJbWFnZURhdGEoZ2xPckNhbnZhcywgaW1hZ2VEYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZnJhbWVidWZmZXIpIHtcbiAgICBpZiAoIGNoYW5uZWxzID09PSB2b2lkIDAgKSBjaGFubmVscyA9IDE1O1xuICAgIGlmICggZnJhbWVidWZmZXIgPT09IHZvaWQgMCApIGZyYW1lYnVmZmVyID0gbnVsbDtcblxuICAgIHdpdGhXZWJHTENvbnRleHQoZ2xPckNhbnZhcywgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgdmFyIHdpdGhQcm9ncmFtID0gcmVmLndpdGhQcm9ncmFtO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlID0gcmVmLndpdGhUZXh0dXJlO1xuXG4gICAgICB3aXRoVGV4dHVyZSgnY29weScsIGZ1bmN0aW9uICh0ZXgsIHRleFVuaXQpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZURhdGEpO1xuICAgICAgICB3aXRoUHJvZ3JhbSgnY29weScsIHZpZXdwb3J0UXVhZFZlcnRleCwgY29weVRleEZyYWdtZW50LCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgdmFyIHNldFVuaWZvcm0gPSByZWYuc2V0VW5pZm9ybTtcbiAgICAgICAgICB2YXIgc2V0QXR0cmlidXRlID0gcmVmLnNldEF0dHJpYnV0ZTtcblxuICAgICAgICAgIHNldEF0dHJpYnV0ZSgnYVVWJywgMiwgZ2wuU1RBVElDX0RSQVcsIDAsIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDIsIDAsIDAsIDJdKSk7XG4gICAgICAgICAgc2V0VW5pZm9ybSgnMWknLCAnaW1hZ2UnLCB0ZXhVbml0KTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyIHx8IG51bGwpO1xuICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgIGdsLmNvbG9yTWFzayhjaGFubmVscyAmIDgsIGNoYW5uZWxzICYgNCwgY2hhbm5lbHMgJiAyLCBjaGFubmVscyAmIDEpO1xuICAgICAgICAgIGdsLnZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIGdsLnNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6aW5nIGEgY2FudmFzIGNsZWFycyBpdHMgY29udGVudHM7IHRoaXMgdXRpbGl0eSBjb3BpZXMgdGhlIHByZXZpb3VzIGNvbnRlbnRzIG92ZXIuXG4gICAqIEBwYXJhbSBjYW52YXNcbiAgICogQHBhcmFtIG5ld1dpZHRoXG4gICAqIEBwYXJhbSBuZXdIZWlnaHRcbiAgICovXG4gIGZ1bmN0aW9uIHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nKGNhbnZhcywgbmV3V2lkdGgsIG5ld0hlaWdodCkge1xuICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB3aXRoV2ViR0xDb250ZXh0KGNhbnZhcywgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGdsID0gcmVmLmdsO1xuXG4gICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEpO1xuICAgICAgY2FudmFzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgcmVuZGVySW1hZ2VEYXRhKGdsLCBkYXRhLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3ZWJnbFV0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB3aXRoV2ViR0xDb250ZXh0OiB3aXRoV2ViR0xDb250ZXh0LFxuICAgIHJlbmRlckltYWdlRGF0YTogcmVuZGVySW1hZ2VEYXRhLFxuICAgIHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nOiByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZ1xuICB9KTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSQyIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQpIHtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG5cbiAgICB2YXIgdGV4dHVyZURhdGEgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCk7XG5cbiAgICB2YXIgdmlld0JveFdpZHRoID0gdmlld0JveFsyXSAtIHZpZXdCb3hbMF07XG4gICAgdmFyIHZpZXdCb3hIZWlnaHQgPSB2aWV3Qm94WzNdIC0gdmlld0JveFsxXTtcblxuICAgIC8vIERlY29tcG9zZSBhbGwgcGF0aHMgaW50byBzdHJhaWdodCBsaW5lIHNlZ21lbnRzIGFuZCBhZGQgdGhlbSB0byBhbiBpbmRleFxuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgIHBhdGhUb0xpbmVTZWdtZW50cyhwYXRoLCBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICB4MTogeDEsIHkxOiB5MSwgeDI6IHgyLCB5MjogeTIsXG4gICAgICAgIG1pblg6IE1hdGgubWluKHgxLCB4MiksXG4gICAgICAgIG1pblk6IE1hdGgubWluKHkxLCB5MiksXG4gICAgICAgIG1heFg6IE1hdGgubWF4KHgxLCB4MiksXG4gICAgICAgIG1heFk6IE1hdGgubWF4KHkxLCB5MilcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gU29ydCBzZWdtZW50cyBieSBtYXhYLCB0aGlzIHdpbGwgbGV0IHVzIHNob3J0LWNpcmN1aXQgc29tZSBsb29wcyBiZWxvd1xuICAgIHNlZ21lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubWF4WCAtIGIubWF4WDsgfSk7XG5cbiAgICAvLyBGb3IgZWFjaCB0YXJnZXQgU0RGIHRleGVsLCBmaW5kIHRoZSBkaXN0YW5jZSBmcm9tIGl0cyBjZW50ZXIgdG8gaXRzIG5lYXJlc3QgbGluZSBzZWdtZW50LFxuICAgIC8vIG1hcCB0aGF0IGRpc3RhbmNlIHRvIGFuIGFscGhhIHZhbHVlLCBhbmQgd3JpdGUgdGhhdCBhbHBoYSB0byB0aGUgdGV4ZWxcbiAgICBmb3IgKHZhciBzZGZYID0gMDsgc2RmWCA8IHNkZldpZHRoOyBzZGZYKyspIHtcbiAgICAgIGZvciAodmFyIHNkZlkgPSAwOyBzZGZZIDwgc2RmSGVpZ2h0OyBzZGZZKyspIHtcbiAgICAgICAgdmFyIHNpZ25lZERpc3QgPSBmaW5kTmVhcmVzdFNpZ25lZERpc3RhbmNlKFxuICAgICAgICAgIHZpZXdCb3hbMF0gKyB2aWV3Qm94V2lkdGggKiAoc2RmWCArIDAuNSkgLyBzZGZXaWR0aCxcbiAgICAgICAgICB2aWV3Qm94WzFdICsgdmlld0JveEhlaWdodCAqIChzZGZZICsgMC41KSAvIHNkZkhlaWdodFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFVzZSBhbiBleHBvbmVudGlhbCBzY2FsZSB0byBlbnN1cmUgdGhlIHRleGVscyB2ZXJ5IG5lYXIgdGhlIGdseXBoIHBhdGggaGF2ZSBhZGVxdWF0ZVxuICAgICAgICAvLyBwcmVjaXNpb24sIHdoaWxlIGFsbG93aW5nIHRoZSBkaXN0YW5jZSBmaWVsZCB0byBjb3ZlciB0aGUgZW50aXJlIHRleHR1cmUsIGdpdmVuIHRoYXRcbiAgICAgICAgLy8gdGhlcmUgYXJlIG9ubHkgOCBiaXRzIGF2YWlsYWJsZS4gRm9ybXVsYSB2aXN1YWxpemVkOiBodHRwczovL3d3dy5kZXNtb3MuY29tL2NhbGN1bGF0b3IvdWlhcTVhcWlhbVxuICAgICAgICB2YXIgYWxwaGEgPSBNYXRoLnBvdygoMSAtIE1hdGguYWJzKHNpZ25lZERpc3QpIC8gbWF4RGlzdGFuY2UpLCBzZGZFeHBvbmVudCkgLyAyO1xuICAgICAgICBpZiAoc2lnbmVkRGlzdCA8IDApIHtcbiAgICAgICAgICBhbHBoYSA9IDEgLSBhbHBoYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKGFscGhhICogMjU1KSkpOyAvL2NsYW1wXG4gICAgICAgIHRleHR1cmVEYXRhW3NkZlkgKiBzZGZXaWR0aCArIHNkZlhdID0gYWxwaGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmVEYXRhXG5cbiAgICAvKipcbiAgICAgKiBGb3IgYSBnaXZlbiB4L3ksIHNlYXJjaCB0aGUgaW5kZXggZm9yIHRoZSBjbG9zZXN0IGxpbmUgc2VnbWVudCBhbmQgcmV0dXJuXG4gICAgICogaXRzIHNpZ25lZCBkaXN0YW5jZS4gTmVnYXRpdmUgPSBpbnNpZGUsIHBvc2l0aXZlID0gb3V0c2lkZSwgemVybyA9IG9uIGVkZ2VcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTmVhcmVzdFNpZ25lZERpc3RhbmNlICh4LCB5KSB7XG4gICAgICB2YXIgY2xvc2VzdERpc3RTcSA9IEluZmluaXR5O1xuICAgICAgdmFyIGNsb3Nlc3REaXN0ID0gSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBzZWdtZW50cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgICBpZiAoc2VnLm1heFggKyBjbG9zZXN0RGlzdCA8PSB4KSB7IGJyZWFrIH0gLy9zb3J0aW5nIGJ5IG1heFggbWVhbnMgbm8gbW9yZSBjYW4gYmUgY2xvc2VyLCBzbyB3ZSBjYW4gc2hvcnQtY2lyY3VpdFxuICAgICAgICBpZiAoeCArIGNsb3Nlc3REaXN0ID4gc2VnLm1pblggJiYgeSAtIGNsb3Nlc3REaXN0IDwgc2VnLm1heFkgJiYgeSArIGNsb3Nlc3REaXN0ID4gc2VnLm1pblkpIHtcbiAgICAgICAgICB2YXIgZGlzdFNxID0gYWJzU3F1YXJlRGlzdGFuY2VUb0xpbmVTZWdtZW50KHgsIHksIHNlZy54MSwgc2VnLnkxLCBzZWcueDIsIHNlZy55Mik7XG4gICAgICAgICAgaWYgKGRpc3RTcSA8IGNsb3Nlc3REaXN0U3EpIHtcbiAgICAgICAgICAgIGNsb3Nlc3REaXN0U3EgPSBkaXN0U3E7XG4gICAgICAgICAgICBjbG9zZXN0RGlzdCA9IE1hdGguc3FydChjbG9zZXN0RGlzdFNxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmxpcCB0byBuZWdhdGl2ZSBkaXN0YW5jZSBpZiBpbnNpZGUgdGhlIHBvbHlcbiAgICAgIGlmIChpc1BvaW50SW5Qb2x5KHgsIHkpKSB7XG4gICAgICAgIGNsb3Nlc3REaXN0ID0gLWNsb3Nlc3REaXN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb3Nlc3REaXN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGxpZXMgaW5zaWRlIG9yIG91dHNpZGUgdGhlIGdseXBoLiBVc2VzIGEgc2ltcGxlXG4gICAgICogd2luZGluZy1udW1iZXIgcmF5IGNhc3RpbmcgYWxnb3JpdGhtIHVzaW5nIGEgcmF5IHBvaW50aW5nIGVhc3QgZnJvbSB0aGUgcG9pbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQb2ludEluUG9seSAoeCwgeSkge1xuICAgICAgdmFyIHdpbmRpbmcgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IHNlZ21lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgc2VnID0gc2VnbWVudHNbaV07XG4gICAgICAgIGlmIChzZWcubWF4WCA8PSB4KSB7IGJyZWFrIH0gLy9zb3J0aW5nIGJ5IG1heFggbWVhbnMgbm8gbW9yZSBjYW4gY3Jvc3MsIHNvIHdlIGNhbiBzaG9ydC1jaXJjdWl0XG4gICAgICAgIHZhciBpbnRlcnNlY3RzID0gKChzZWcueTEgPiB5KSAhPT0gKHNlZy55MiA+IHkpKSAmJiAoeCA8IChzZWcueDIgLSBzZWcueDEpICogKHkgLSBzZWcueTEpIC8gKHNlZy55MiAtIHNlZy55MSkgKyBzZWcueDEpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0cykge1xuICAgICAgICAgIHdpbmRpbmcgKz0gc2VnLnkxIDwgc2VnLnkyID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZGluZyAhPT0gMFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyQyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIkMShzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGNhbnZhcywgbnVsbCwgeCwgeSwgY2hhbm5lbCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGdsT3JDYW52YXMsIGZyYW1lYnVmZmVyLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgdmFyIGRhdGEgPSBnZW5lcmF0ZSQyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCk7XG4gICAgLy8gRXhwYW5kIHNpbmdsZS1jaGFubmVsIGRhdGEgdG8gcmJnYVxuICAgIHZhciByZ2JhRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICogNCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZ2JhRGF0YVtpICogNCArIGNoYW5uZWxdID0gZGF0YVtpXTtcbiAgICB9XG4gICAgcmVuZGVySW1hZ2VEYXRhKGdsT3JDYW52YXMsIHJnYmFEYXRhLCB4LCB5LCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCAxIDw8ICgzIC0gY2hhbm5lbCksIGZyYW1lYnVmZmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBsaW5lIHNlZ21lbnQgYXQgY2xvc2VzdCBhcHByb2FjaFxuICAgKi9cbiAgZnVuY3Rpb24gYWJzU3F1YXJlRGlzdGFuY2VUb0xpbmVTZWdtZW50ICh4LCB5LCBsaW5lWDAsIGxpbmVZMCwgbGluZVgxLCBsaW5lWTEpIHtcbiAgICB2YXIgbGR4ID0gbGluZVgxIC0gbGluZVgwO1xuICAgIHZhciBsZHkgPSBsaW5lWTEgLSBsaW5lWTA7XG4gICAgdmFyIGxlbmd0aFNxID0gbGR4ICogbGR4ICsgbGR5ICogbGR5O1xuICAgIHZhciB0ID0gbGVuZ3RoU3EgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoKHggLSBsaW5lWDApICogbGR4ICsgKHkgLSBsaW5lWTApICogbGR5KSAvIGxlbmd0aFNxKSkgOiAwO1xuICAgIHZhciBkeCA9IHggLSAobGluZVgwICsgdCAqIGxkeCk7XG4gICAgdmFyIGR5ID0geSAtIChsaW5lWTAgKyB0ICogbGR5KTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHlcbiAgfVxuXG4gIHZhciBqYXZhc2NyaXB0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZW5lcmF0ZTogZ2VuZXJhdGUkMixcbiAgICBnZW5lcmF0ZUludG9DYW52YXM6IGdlbmVyYXRlSW50b0NhbnZhcyQyLFxuICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyOiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxXG4gIH0pO1xuXG4gIHZhciBtYWluVmVydGV4ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSB2ZWM0IHVHbHlwaEJvdW5kczthdHRyaWJ1dGUgdmVjMiBhVVY7YXR0cmlidXRlIHZlYzQgYUxpbmVTZWdtZW50O3ZhcnlpbmcgdmVjNCB2TGluZVNlZ21lbnQ7dmFyeWluZyB2ZWMyIHZHbHlwaFhZO3ZvaWQgbWFpbigpe3ZMaW5lU2VnbWVudD1hTGluZVNlZ21lbnQ7dkdseXBoWFk9bWl4KHVHbHlwaEJvdW5kcy54eSx1R2x5cGhCb3VuZHMuencsYVVWKTtnbF9Qb3NpdGlvbj12ZWM0KG1peCh2ZWMyKC0xLjApLHZlYzIoMS4wKSxhVVYpLDAuMCwxLjApO31cIjtcblxuICB2YXIgbWFpbkZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSB2ZWM0IHVHbHlwaEJvdW5kczt1bmlmb3JtIGZsb2F0IHVNYXhEaXN0YW5jZTt1bmlmb3JtIGZsb2F0IHVFeHBvbmVudDt2YXJ5aW5nIHZlYzQgdkxpbmVTZWdtZW50O3ZhcnlpbmcgdmVjMiB2R2x5cGhYWTtmbG9hdCBhYnNEaXN0VG9TZWdtZW50KHZlYzIgcG9pbnQsdmVjMiBsaW5lQSx2ZWMyIGxpbmVCKXt2ZWMyIGxpbmVEaXI9bGluZUItbGluZUE7ZmxvYXQgbGVuU3E9ZG90KGxpbmVEaXIsbGluZURpcik7ZmxvYXQgdD1sZW5TcT09MC4wID8gMC4wIDogY2xhbXAoZG90KHBvaW50LWxpbmVBLGxpbmVEaXIpL2xlblNxLDAuMCwxLjApO3ZlYzIgbGluZVB0PWxpbmVBK3QqbGluZURpcjtyZXR1cm4gZGlzdGFuY2UocG9pbnQsbGluZVB0KTt9dm9pZCBtYWluKCl7dmVjNCBzZWc9dkxpbmVTZWdtZW50O3ZlYzIgcD12R2x5cGhYWTtmbG9hdCBkaXN0PWFic0Rpc3RUb1NlZ21lbnQocCxzZWcueHksc2VnLnp3KTtmbG9hdCB2YWw9cG93KDEuMC1jbGFtcChkaXN0L3VNYXhEaXN0YW5jZSwwLjAsMS4wKSx1RXhwb25lbnQpKjAuNTtib29sIGNyb3NzaW5nPShzZWcueT5wLnkhPXNlZy53PnAueSkmJihwLng8KHNlZy56LXNlZy54KSoocC55LXNlZy55KS8oc2VnLnctc2VnLnkpK3NlZy54KTtib29sIGNyb3NzaW5nVXA9Y3Jvc3NpbmcmJnZMaW5lU2VnbWVudC55PHZMaW5lU2VnbWVudC53O2dsX0ZyYWdDb2xvcj12ZWM0KGNyb3NzaW5nVXAgPyAxLjAvMjU1LjAgOiAwLjAsY3Jvc3NpbmcmJiFjcm9zc2luZ1VwID8gMS4wLzI1NS4wIDogMC4wLDAuMCx2YWwpO31cIjtcblxuICB2YXIgcG9zdEZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSBzYW1wbGVyMkQgdGV4O3ZhcnlpbmcgdmVjMiB2VVY7dm9pZCBtYWluKCl7dmVjNCBjb2xvcj10ZXh0dXJlMkQodGV4LHZVVik7Ym9vbCBpbnNpZGU9Y29sb3IuciE9Y29sb3IuZztmbG9hdCB2YWw9aW5zaWRlID8gMS4wLWNvbG9yLmEgOiBjb2xvci5hO2dsX0ZyYWdDb2xvcj12ZWM0KHZhbCk7fVwiO1xuXG4gIC8vIFNpbmdsZSB0cmlhbmdsZSBjb3ZlcmluZyB2aWV3cG9ydFxuICB2YXIgdmlld3BvcnRVVnMgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAyLCAwLCAwLCAyXSk7XG5cbiAgdmFyIGltcGxpY2l0Q29udGV4dCA9IG51bGw7XG4gIHZhciBpc1Rlc3RpbmdTdXBwb3J0ID0gZmFsc2U7XG4gIHZhciBOVUxMX09CSkVDVCA9IHt9O1xuICB2YXIgc3VwcG9ydEJ5Q2FudmFzID0gbmV3IFdlYWtNYXAoKTsgLy8gY2FudmFzIC0+IGJvb2xcblxuICBmdW5jdGlvbiB2YWxpZGF0ZVN1cHBvcnQgKGdsT3JDYW52YXMpIHtcbiAgICBpZiAoIWlzVGVzdGluZ1N1cHBvcnQgJiYgIWlzU3VwcG9ydGVkKGdsT3JDYW52YXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCcpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGUkMSAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBnbE9yQ2FudmFzKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggZ2xPckNhbnZhcyA9PT0gdm9pZCAwICkgZ2xPckNhbnZhcyA9IG51bGw7XG5cbiAgICBpZiAoIWdsT3JDYW52YXMpIHtcbiAgICAgIGdsT3JDYW52YXMgPSBpbXBsaWNpdENvbnRleHQ7XG4gICAgICBpZiAoIWdsT3JDYW52YXMpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSlcbiAgICAgICAgICA6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09mZnNjcmVlbkNhbnZhcyBvciBET00gY2FudmFzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICB9XG4gICAgICAgIGdsT3JDYW52YXMgPSBpbXBsaWNpdENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7IGRlcHRoOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVN1cHBvcnQoZ2xPckNhbnZhcyk7XG5cbiAgICB2YXIgcmdiYURhdGEgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCAqIDQpOyAvL25vdCBVaW50OENsYW1wZWRBcnJheSwgY3V6IFNhZmFyaVxuXG4gICAgLy8gUmVuZGVyIGludG8gYSBiYWNrZ3JvdW5kIHRleHR1cmUgZnJhbWVidWZmZXJcbiAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgIHZhciB3aXRoVGV4dHVyZSA9IHJlZi53aXRoVGV4dHVyZTtcbiAgICAgIHZhciB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyID0gcmVmLndpdGhUZXh0dXJlRnJhbWVidWZmZXI7XG5cbiAgICAgIHdpdGhUZXh0dXJlKCdyZWFkYWJsZScsIGZ1bmN0aW9uICh0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNkZldpZHRoLCBzZGZIZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgICAgIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIodGV4dHVyZSwgdGV4dHVyZVVuaXQsIGZ1bmN0aW9uIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyKFxuICAgICAgICAgICAgc2RmV2lkdGgsXG4gICAgICAgICAgICBzZGZIZWlnaHQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgdmlld0JveCxcbiAgICAgICAgICAgIG1heERpc3RhbmNlLFxuICAgICAgICAgICAgc2RmRXhwb25lbnQsXG4gICAgICAgICAgICBnbCxcbiAgICAgICAgICAgIGZyYW1lYnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwIC8vIHJlZCBjaGFubmVsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHJnYmFEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFRocm93IGF3YXkgYWxsIGJ1dCB0aGUgcmVkIGNoYW5uZWxcbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHNkZldpZHRoICogc2RmSGVpZ2h0KTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCByZ2JhRGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgZGF0YVtqKytdID0gcmdiYURhdGFbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyQxKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBjYW52YXMsIG51bGwsIHgsIHksIGNoYW5uZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIgKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgZ2xPckNhbnZhcywgZnJhbWVidWZmZXIsIHgsIHksIGNoYW5uZWwpIHtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgaWYgKCB4ID09PSB2b2lkIDAgKSB4ID0gMDtcbiAgICBpZiAoIHkgPT09IHZvaWQgMCApIHkgPSAwO1xuICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICAvLyBWZXJpZnkgc3VwcG9ydFxuICAgIHZhbGlkYXRlU3VwcG9ydChnbE9yQ2FudmFzKTtcblxuICAgIC8vIENvbXB1dGUgcGF0aCBzZWdtZW50c1xuICAgIHZhciBsaW5lU2VnbWVudENvb3JkcyA9IFtdO1xuICAgIHBhdGhUb0xpbmVTZWdtZW50cyhwYXRoLCBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIGxpbmVTZWdtZW50Q29vcmRzLnB1c2goeDEsIHkxLCB4MiwgeTIpO1xuICAgIH0pO1xuICAgIGxpbmVTZWdtZW50Q29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShsaW5lU2VnbWVudENvb3Jkcyk7XG5cbiAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgIHZhciBpc1dlYkdMMiA9IHJlZi5pc1dlYkdMMjtcbiAgICAgIHZhciBnZXRFeHRlbnNpb24gPSByZWYuZ2V0RXh0ZW5zaW9uO1xuICAgICAgdmFyIHdpdGhQcm9ncmFtID0gcmVmLndpdGhQcm9ncmFtO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlID0gcmVmLndpdGhUZXh0dXJlO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIgPSByZWYud2l0aFRleHR1cmVGcmFtZWJ1ZmZlcjtcbiAgICAgIHZhciBoYW5kbGVDb250ZXh0TG9zcyA9IHJlZi5oYW5kbGVDb250ZXh0TG9zcztcblxuICAgICAgd2l0aFRleHR1cmUoJ3Jhd0Rpc3RhbmNlcycsIGZ1bmN0aW9uIChpbnRlcm1lZGlhdGVUZXh0dXJlLCBpbnRlcm1lZGlhdGVUZXh0dXJlVW5pdCkge1xuICAgICAgICBpZiAoc2RmV2lkdGggIT09IGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RXaWR0aCB8fCBzZGZIZWlnaHQgIT09IGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RIZWlnaHQpIHtcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSxcbiAgICAgICAgICAgIGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RXaWR0aCA9IHNkZldpZHRoLFxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlVGV4dHVyZS5fbGFzdEhlaWdodCA9IHNkZkhlaWdodCxcbiAgICAgICAgICAgIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5zaWduZWQgZGlzdGFuY2UgcGFzc1xuICAgICAgICB3aXRoUHJvZ3JhbSgnbWFpbicsIG1haW5WZXJ0ZXgsIG1haW5GcmFnbWVudCwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgIHZhciBzZXRBdHRyaWJ1dGUgPSByZWYuc2V0QXR0cmlidXRlO1xuICAgICAgICAgIHZhciBzZXRVbmlmb3JtID0gcmVmLnNldFVuaWZvcm07XG5cbiAgICAgICAgICAvLyBJbml0IGV4dGVuc2lvbnNcbiAgICAgICAgICB2YXIgaW5zdGFuY2luZ0V4dGVuc2lvbiA9ICFpc1dlYkdMMiAmJiBnZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgICAgICAgICB2YXIgYmxlbmRNaW5NYXhFeHRlbnNpb24gPSAhaXNXZWJHTDIgJiYgZ2V0RXh0ZW5zaW9uKCdFWFRfYmxlbmRfbWlubWF4Jyk7XG5cbiAgICAgICAgICAvLyBJbml0L3VwZGF0ZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgc2V0QXR0cmlidXRlKCdhVVYnLCAyLCBnbC5TVEFUSUNfRFJBVywgMCwgdmlld3BvcnRVVnMpO1xuICAgICAgICAgIHNldEF0dHJpYnV0ZSgnYUxpbmVTZWdtZW50JywgNCwgZ2wuRFlOQU1JQ19EUkFXLCAxLCBsaW5lU2VnbWVudENvb3Jkcyk7XG5cbiAgICAgICAgICAvLyBJbml0L3VwZGF0ZSB1bmlmb3Jtc1xuICAgICAgICAgIHNldFVuaWZvcm0uYXBwbHkodm9pZCAwLCBbICc0ZicsICd1R2x5cGhCb3VuZHMnIF0uY29uY2F0KCB2aWV3Qm94ICkpO1xuICAgICAgICAgIHNldFVuaWZvcm0oJzFmJywgJ3VNYXhEaXN0YW5jZScsIG1heERpc3RhbmNlKTtcbiAgICAgICAgICBzZXRVbmlmb3JtKCcxZicsICd1RXhwb25lbnQnLCBzZGZFeHBvbmVudCk7XG5cbiAgICAgICAgICAvLyBSZW5kZXIgaW5pdGlhbCB1bnNpZ25lZCBkaXN0YW5jZSAvIHdpbmRpbmcgbnVtYmVyIGluZm8gdG8gYSB0ZXh0dXJlXG4gICAgICAgICAgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlcihpbnRlcm1lZGlhdGVUZXh0dXJlLCBpbnRlcm1lZGlhdGVUZXh0dXJlVW5pdCwgZnVuY3Rpb24gKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgc2RmV2lkdGgsIHNkZkhlaWdodCk7XG4gICAgICAgICAgICBnbC5zY2lzc29yKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FKTtcbiAgICAgICAgICAgIC8vIFJlZCtHcmVlbiBjaGFubmVscyBhcmUgaW5jcmVtZW50ZWQgKEZVTkNfQUREKSBmb3Igc2VnbWVudC1yYXkgY3Jvc3NpbmdzIHRvIGdpdmUgYSBcIndpbmRpbmcgbnVtYmVyXCIuXG4gICAgICAgICAgICAvLyBBbHBoYSBob2xkcyB0aGUgY2xvc2VzdCAoTUFYKSB1bnNpZ25lZCBkaXN0YW5jZS5cbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgaXNXZWJHTDIgPyBnbC5NQVggOiBibGVuZE1pbk1heEV4dGVuc2lvbi5NQVhfRVhUKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQoZ2wuVFJJQU5HTEVTLCAwLCAzLCBsaW5lU2VnbWVudENvb3Jkcy5sZW5ndGggLyA0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluc3RhbmNpbmdFeHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKGdsLlRSSUFOR0xFUywgMCwgMywgbGluZVNlZ21lbnRDb29yZHMubGVuZ3RoIC8gNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWJ1Z1xuICAgICAgICAgICAgLy8gY29uc3QgZGVidWcgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCAqIDQpXG4gICAgICAgICAgICAvLyBnbC5yZWFkUGl4ZWxzKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRlYnVnKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ludGVybWVkaWF0ZSB0ZXh0dXJlIGRhdGE6ICcsIGRlYnVnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVc2UgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSB0ZXh0dXJlIHRvIGFwcGx5IGluc2lkZS9vdXRzaWRlIGFuZCB3cml0ZSB0byB0aGUgb3V0cHV0IGZyYW1lYnVmZmVyIHJlY3QrY2hhbm5lbC5cbiAgICAgICAgd2l0aFByb2dyYW0oJ3Bvc3QnLCB2aWV3cG9ydFF1YWRWZXJ0ZXgsIHBvc3RGcmFnbWVudCwgZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICBwcm9ncmFtLnNldEF0dHJpYnV0ZSgnYVVWJywgMiwgZ2wuU1RBVElDX0RSQVcsIDAsIHZpZXdwb3J0VVZzKTtcbiAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm0oJzFpJywgJ3RleCcsIGludGVybWVkaWF0ZVRleHR1cmVVbml0KTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICBnbC5jb2xvck1hc2soY2hhbm5lbCA9PT0gMCwgY2hhbm5lbCA9PT0gMSwgY2hhbm5lbCA9PT0gMiwgY2hhbm5lbCA9PT0gMyk7XG4gICAgICAgICAgZ2wudmlld3BvcnQoeCwgeSwgc2RmV2lkdGgsIHNkZkhlaWdodCk7XG4gICAgICAgICAgZ2wuc2Npc3Nvcih4LCB5LCBzZGZXaWR0aCwgc2RmSGVpZ2h0KTtcbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgMyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhhbmRsZSBjb250ZXh0IGxvc3Mgb2NjdXJyaW5nIGR1cmluZyBhbnkgb2YgdGhlIGFib3ZlIGNhbGxzXG4gICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgICAgIGhhbmRsZUNvbnRleHRMb3NzKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2ViZ2wgY29udGV4dCBsb3N0JylcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3VwcG9ydGVkIChnbE9yQ2FudmFzKSB7XG4gICAgdmFyIGtleSA9ICghZ2xPckNhbnZhcyB8fCBnbE9yQ2FudmFzID09PSBpbXBsaWNpdENvbnRleHQpID8gTlVMTF9PQkpFQ1QgOiAoZ2xPckNhbnZhcy5jYW52YXMgfHwgZ2xPckNhbnZhcyk7XG4gICAgdmFyIHN1cHBvcnRlZCA9IHN1cHBvcnRCeUNhbnZhcy5nZXQoa2V5KTtcbiAgICBpZiAoc3VwcG9ydGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlzVGVzdGluZ1N1cHBvcnQgPSB0cnVlO1xuICAgICAgdmFyIGZhaWxSZWFzb24gPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU2luY2Ugd2UgY2FuJ3QgZGV0ZWN0IGFsbCBmYWlsdXJlIG1vZGVzIHVwIGZyb250LCBsZXQncyBqdXN0IGRvIGEgdHJpYWwgcnVuIG9mIGFcbiAgICAgICAgLy8gc2ltcGxlIHBhdGggYW5kIGNvbXBhcmUgd2hhdCB3ZSBnZXQgYmFjayB0byB0aGUgY29ycmVjdCBleHBlY3RlZCByZXN1bHQuIFRoaXMgd2lsbFxuICAgICAgICAvLyBhbHNvIHNlcnZlIHRvIHByaW1lIHRoZSBzaGFkZXIgY29tcGlsYXRpb24uXG4gICAgICAgIHZhciBleHBlY3RlZFJlc3VsdCA9IFtcbiAgICAgICAgICA5NywgMTA2LCA5NywgNjEsXG4gICAgICAgICAgOTksIDEzNywgMTE4LCA4MCxcbiAgICAgICAgICA4MCwgMTE4LCAxMzcsIDk5LFxuICAgICAgICAgIDYxLCA5NywgMTA2LCA5N1xuICAgICAgICBdO1xuICAgICAgICB2YXIgdGVzdFJlc3VsdCA9IGdlbmVyYXRlJDEoXG4gICAgICAgICAgNCxcbiAgICAgICAgICA0LFxuICAgICAgICAgICdNOCw4TDE2LDhMMjQsMjRMMTYsMjRaJyxcbiAgICAgICAgICBbMCwgMCwgMzIsIDMyXSxcbiAgICAgICAgICAyNCxcbiAgICAgICAgICAxLFxuICAgICAgICAgIGdsT3JDYW52YXNcbiAgICAgICAgKTtcbiAgICAgICAgc3VwcG9ydGVkID0gdGVzdFJlc3VsdCAmJiBleHBlY3RlZFJlc3VsdC5sZW5ndGggPT09IHRlc3RSZXN1bHQubGVuZ3RoICYmXG4gICAgICAgICAgdGVzdFJlc3VsdC5ldmVyeShmdW5jdGlvbiAodmFsLCBpKSB7IHJldHVybiB2YWwgPT09IGV4cGVjdGVkUmVzdWx0W2ldOyB9KTtcbiAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgICBmYWlsUmVhc29uID0gJ2JhZCB0cmlhbCBydW4gcmVzdWx0cyc7XG4gICAgICAgICAgY29uc29sZS5pbmZvKGV4cGVjdGVkUmVzdWx0LCB0ZXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRPRE8gaWYgaXQgdGhyZXcgZHVlIHRvIHdlYmdsIGNvbnRleHQgbG9zcywgc2hvdWxkIHdlIG1heWJlIGxlYXZlIGlzU3VwcG9ydGVkIGFzIG51bGwgYW5kIHRyeSBhZ2FpbiBsYXRlcj9cbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIGZhaWxSZWFzb24gPSBlcnIubWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWlsUmVhc29uKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV2ViR0wgU0RGIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZDonLCBmYWlsUmVhc29uKTtcbiAgICAgIH1cbiAgICAgIGlzVGVzdGluZ1N1cHBvcnQgPSBmYWxzZTtcbiAgICAgIHN1cHBvcnRCeUNhbnZhcy5zZXQoa2V5LCBzdXBwb3J0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkXG4gIH1cblxuICB2YXIgd2ViZ2wgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdlbmVyYXRlOiBnZW5lcmF0ZSQxLFxuICAgIGdlbmVyYXRlSW50b0NhbnZhczogZ2VuZXJhdGVJbnRvQ2FudmFzJDEsXG4gICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXI6IGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyLFxuICAgIGlzU3VwcG9ydGVkOiBpc1N1cHBvcnRlZFxuICB9KTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgMkQgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNkZldpZHRoIC0gd2lkdGggb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2RmSGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBhbiBTVkctbGlrZSBwYXRoIHN0cmluZyBkZXNjcmliaW5nIHRoZSBnbHlwaDsgc2hvdWxkIG9ubHkgY29udGFpbiBjb21tYW5kczogTS9ML1EvQy9aLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSB2aWV3Qm94IC0gW21pblgsIG1pblksIG1heFgsIG1heFldIGluIGZvbnQgdW5pdHMgYWxpZ25pbmcgd2l0aCB0aGUgdGV4dHVyZSdzIGVkZ2VzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4RGlzdGFuY2UgLSB0aGUgbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBnbHlwaCBwYXRoIGluIGZvbnQgdW5pdHMgdGhhdCB3aWxsIGJlIGVuY29kZWQ7IGRlZmF1bHRzXG4gICAqICAgICAgICB0byBoYWxmIHRoZSBtYXhpbXVtIHZpZXdCb3ggZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NkZkV4cG9uZW50XSAtIHNwZWNpZmllcyBhbiBleHBvbmVudCBmb3IgZW5jb2RpbmcgdGhlIFNERidzIGRpc3RhbmNlIHZhbHVlczsgaGlnaGVyIGV4cG9uZW50c1xuICAgKiAgICAgICAgd2lsbCBnaXZlIGdyZWF0ZXIgcHJlY2lzaW9uIG5lYXJlciB0aGUgZ2x5cGgncyBwYXRoLlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGUoXG4gICAgc2RmV2lkdGgsXG4gICAgc2RmSGVpZ2h0LFxuICAgIHBhdGgsXG4gICAgdmlld0JveCxcbiAgICBtYXhEaXN0YW5jZSxcbiAgICBzZGZFeHBvbmVudFxuICApIHtcbiAgICBpZiAoIG1heERpc3RhbmNlID09PSB2b2lkIDAgKSBtYXhEaXN0YW5jZSA9IE1hdGgubWF4KHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdLCB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgLyAyO1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGUkMS5hcHBseSh3ZWJnbCwgYXJndW1lbnRzKVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5pbmZvKCdXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKUycsIGUpO1xuICAgICAgcmV0dXJuIGdlbmVyYXRlJDIuYXBwbHkoamF2YXNjcmlwdCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBTREYgdGV4dHVyZSBpbWFnZSBmb3IgYSAyRCBwYXRoLCBpbnNlcnRpbmcgdGhlIHJlc3VsdCBpbnRvIGEgV2ViR0wgYGNhbnZhc2AgYXQgYSBnaXZlbiB4L3kgcG9zaXRpb25cbiAgICogYW5kIGNvbG9yIGNoYW5uZWwuIFRoaXMgaXMgZ2VuZXJhbGx5IG11Y2ggZmFzdGVyIHRoYW4gY2FsbGluZyBgZ2VuZXJhdGVgIGJlY2F1c2UgaXQgZG9lcyBub3QgcmVxdWlyZSByZWFkaW5nIHBpeGVsc1xuICAgKiBiYWNrIGZyb20gdGhlIEdQVS0+Q1BVIC0tIHRoZSBgY2FudmFzYCBjYW4gYmUgdXNlZCBkaXJlY3RseSBhcyBhIFdlYkdMIHRleHR1cmUgaW1hZ2UsIHNvIGl0IGFsbCBzdGF5cyBvbiB0aGUgR1BVLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2RmV2lkdGggLSB3aWR0aCBvZiB0aGUgU0RGIG91dHB1dCBpbWFnZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZIZWlnaHQgLSBoZWlnaHQgb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGFuIFNWRy1saWtlIHBhdGggc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGdseXBoOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1ouXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHZpZXdCb3ggLSBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gaW4gZm9udCB1bml0cyBhbGlnbmluZyB3aXRoIHRoZSB0ZXh0dXJlJ3MgZWRnZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEaXN0YW5jZSAtIHRoZSBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGdseXBoIHBhdGggaW4gZm9udCB1bml0cyB0aGF0IHdpbGwgYmUgZW5jb2RlZDsgZGVmYXVsdHNcbiAgICogICAgICAgIHRvIGhhbGYgdGhlIG1heGltdW0gdmlld0JveCBkaW1lbnNpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2RmRXhwb25lbnRdIC0gc3BlY2lmaWVzIGFuIGV4cG9uZW50IGZvciBlbmNvZGluZyB0aGUgU0RGJ3MgZGlzdGFuY2UgdmFsdWVzOyBoaWdoZXIgZXhwb25lbnRzXG4gICAqICAgICAgICB3aWxsIGdpdmUgZ3JlYXRlciBwcmVjaXNpb24gbmVhcmVyIHRoZSBnbHlwaCdzIHBhdGguXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR8T2Zmc2NyZWVuQ2FudmFzfSBjYW52YXMgLSBhIFdlYkdMLWVuYWJsZWQgY2FudmFzIGludG8gd2hpY2ggdGhlIFNERiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiAgICAgICAgT25seSB0aGUgcmVsZXZhbnQgcmVjdC9jaGFubmVsIHdpbGwgYmUgbW9kaWZpZWQsIHRoZSByZXN0IHdpbGwgYmUgcHJlc2VydmVkLiBUbyBhdm9pZCB1bnByZWRpY3RhYmxlIHJlc3VsdHNcbiAgICogICAgICAgIGR1ZSB0byBzaGFyZWQgR0wgY29udGV4dCBzdGF0ZSwgdGhpcyBjYW52YXMgc2hvdWxkIGJlIGRlZGljYXRlZCB0byB1c2UgYnkgdGhpcyBsaWJyYXJ5IGFsb25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IHBvc2l0aW9uIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgU0RGLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IHBvc2l0aW9uIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgU0RGLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbCAtIHRoZSBjb2xvciBjaGFubmVsIGluZGV4ICgwLTQpIGludG8gd2hpY2ggdGhlIFNERiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvQ2FudmFzKFxuICAgIHNkZldpZHRoLFxuICAgIHNkZkhlaWdodCxcbiAgICBwYXRoLFxuICAgIHZpZXdCb3gsXG4gICAgbWF4RGlzdGFuY2UsXG4gICAgc2RmRXhwb25lbnQsXG4gICAgY2FudmFzLFxuICAgIHgsXG4gICAgeSxcbiAgICBjaGFubmVsXG4gICkge1xuICAgIGlmICggbWF4RGlzdGFuY2UgPT09IHZvaWQgMCApIG1heERpc3RhbmNlID0gTWF0aC5tYXgodmlld0JveFsyXSAtIHZpZXdCb3hbMF0sIHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAvIDI7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZUludG9DYW52YXMkMS5hcHBseSh3ZWJnbCwgYXJndW1lbnRzKVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5pbmZvKCdXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKUycsIGUpO1xuICAgICAgcmV0dXJuIGdlbmVyYXRlSW50b0NhbnZhcyQyLmFwcGx5KGphdmFzY3JpcHQsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLmZvckVhY2hQYXRoQ29tbWFuZCA9IGZvckVhY2hQYXRoQ29tbWFuZDtcbiAgZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuICBleHBvcnRzLmdlbmVyYXRlSW50b0NhbnZhcyA9IGdlbmVyYXRlSW50b0NhbnZhcztcbiAgZXhwb3J0cy5qYXZhc2NyaXB0ID0gamF2YXNjcmlwdDtcbiAgZXhwb3J0cy5wYXRoVG9MaW5lU2VnbWVudHMgPSBwYXRoVG9MaW5lU2VnbWVudHM7XG4gIGV4cG9ydHMud2ViZ2wgPSB3ZWJnbDtcbiAgZXhwb3J0cy53ZWJnbFV0aWxzID0gd2ViZ2xVdGlscztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KHt9KSk7XG5yZXR1cm4gZXhwb3J0c1xufVxuXG5leHBvcnQgeyBTREZHZW5lcmF0b3IgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\n"));

/***/ })

});