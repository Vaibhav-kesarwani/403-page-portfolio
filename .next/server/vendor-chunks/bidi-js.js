"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bidi-js";
exports.ids = ["vendor-chunks/bidi-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/bidi-js/dist/bidi.mjs":
/*!********************************************!*\
  !*** ./node_modules/bidi-js/dist/bidi.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction bidiFactory() {\n    var bidi = function(exports) {\n        // Bidi character types data, auto generated\n        var DATA = {\n            \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n            \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n            \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n            \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n            \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n            \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n            \"B\": \"a,3,f+2,2v,690\",\n            \"S\": \"9,2,k\",\n            \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n            \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n            \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n            \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n            \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n            \"LRO\": \"6ct\",\n            \"RLO\": \"6cu\",\n            \"LRE\": \"6cq\",\n            \"RLE\": \"6cr\",\n            \"PDF\": \"6cs\",\n            \"LRI\": \"6ee\",\n            \"RLI\": \"6ef\",\n            \"FSI\": \"6eg\",\n            \"PDI\": \"6eh\"\n        };\n        var TYPES = {};\n        var TYPES_TO_NAMES = {};\n        TYPES.L = 1; //L is the default\n        TYPES_TO_NAMES[1] = \"L\";\n        Object.keys(DATA).forEach(function(type, i) {\n            TYPES[type] = 1 << i + 1;\n            TYPES_TO_NAMES[TYPES[type]] = type;\n        });\n        Object.freeze(TYPES);\n        var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n        var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n        var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n        var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n        var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n        var map = null;\n        function parseData() {\n            if (!map) {\n                //const start = performance.now()\n                map = new Map();\n                var loop = function(type) {\n                    if (DATA.hasOwnProperty(type)) {\n                        var lastCode = 0;\n                        DATA[type].split(\",\").forEach(function(range) {\n                            var ref = range.split(\"+\");\n                            var skip = ref[0];\n                            var step = ref[1];\n                            skip = parseInt(skip, 36);\n                            step = step ? parseInt(step, 36) : 0;\n                            map.set(lastCode += skip, TYPES[type]);\n                            for(var i = 0; i < step; i++){\n                                map.set(++lastCode, TYPES[type]);\n                            }\n                        });\n                    }\n                };\n                for(var type in DATA)loop(type);\n            //console.log(`char types parsed in ${performance.now() - start}ms`)\n            }\n        }\n        /**\n   * @param {string} char\n   * @return {number}\n   */ function getBidiCharType(char) {\n            parseData();\n            return map.get(char.codePointAt(0)) || TYPES.L;\n        }\n        function getBidiCharTypeName(char) {\n            return TYPES_TO_NAMES[getBidiCharType(char)];\n        }\n        // Bidi bracket pairs data, auto generated\n        var data$1 = {\n            \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n            \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n        };\n        /**\n   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n   * @param {string} encodedString\n   * @param {boolean} includeReverse - true if you want reverseMap in the output\n   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n   */ function parseCharacterMap(encodedString, includeReverse) {\n            var radix = 36;\n            var lastCode = 0;\n            var map = new Map();\n            var reverseMap = includeReverse && new Map();\n            var prevPair;\n            encodedString.split(\",\").forEach(function visit(entry) {\n                if (entry.indexOf(\"+\") !== -1) {\n                    for(var i = +entry; i--;){\n                        visit(prevPair);\n                    }\n                } else {\n                    prevPair = entry;\n                    var ref = entry.split(\">\");\n                    var a = ref[0];\n                    var b = ref[1];\n                    a = String.fromCodePoint(lastCode += parseInt(a, radix));\n                    b = String.fromCodePoint(lastCode += parseInt(b, radix));\n                    map.set(a, b);\n                    includeReverse && reverseMap.set(b, a);\n                }\n            });\n            return {\n                map: map,\n                reverseMap: reverseMap\n            };\n        }\n        var openToClose, closeToOpen, canonical;\n        function parse$1() {\n            if (!openToClose) {\n                //const start = performance.now()\n                var ref = parseCharacterMap(data$1.pairs, true);\n                var map = ref.map;\n                var reverseMap = ref.reverseMap;\n                openToClose = map;\n                closeToOpen = reverseMap;\n                canonical = parseCharacterMap(data$1.canonical, false).map;\n            //console.log(`brackets parsed in ${performance.now() - start}ms`)\n            }\n        }\n        function openingToClosingBracket(char) {\n            parse$1();\n            return openToClose.get(char) || null;\n        }\n        function closingToOpeningBracket(char) {\n            parse$1();\n            return closeToOpen.get(char) || null;\n        }\n        function getCanonicalBracket(char) {\n            parse$1();\n            return canonical.get(char) || null;\n        }\n        // Local type aliases\n        var TYPE_L = TYPES.L;\n        var TYPE_R = TYPES.R;\n        var TYPE_EN = TYPES.EN;\n        var TYPE_ES = TYPES.ES;\n        var TYPE_ET = TYPES.ET;\n        var TYPE_AN = TYPES.AN;\n        var TYPE_CS = TYPES.CS;\n        var TYPE_B = TYPES.B;\n        var TYPE_S = TYPES.S;\n        var TYPE_ON = TYPES.ON;\n        var TYPE_BN = TYPES.BN;\n        var TYPE_NSM = TYPES.NSM;\n        var TYPE_AL = TYPES.AL;\n        var TYPE_LRO = TYPES.LRO;\n        var TYPE_RLO = TYPES.RLO;\n        var TYPE_LRE = TYPES.LRE;\n        var TYPE_RLE = TYPES.RLE;\n        var TYPE_PDF = TYPES.PDF;\n        var TYPE_LRI = TYPES.LRI;\n        var TYPE_RLI = TYPES.RLI;\n        var TYPE_FSI = TYPES.FSI;\n        var TYPE_PDI = TYPES.PDI;\n        /**\n   * @typedef {object} GetEmbeddingLevelsResult\n   * @property {{start, end, level}[]} paragraphs\n   * @property {Uint8Array} levels\n   */ /**\n   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n   * base embedding level.\n   *\n   * @param {string} string - The input string\n   * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n   *        otherwise a direction will be chosen automatically from each paragraph's contents.\n   * @return {GetEmbeddingLevelsResult}\n   */ function getEmbeddingLevels(string, baseDirection) {\n            var MAX_DEPTH = 125;\n            // Start by mapping all characters to their unicode type, as a bitmask integer\n            var charTypes = new Uint32Array(string.length);\n            for(var i = 0; i < string.length; i++){\n                charTypes[i] = getBidiCharType(string[i]);\n            }\n            var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n            function changeCharType(i, type) {\n                var oldType = charTypes[i];\n                charTypes[i] = type;\n                charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n                if (oldType & NEUTRAL_ISOLATE_TYPES) {\n                    charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n                }\n                charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n                if (type & NEUTRAL_ISOLATE_TYPES) {\n                    charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n                }\n            }\n            var embedLevels = new Uint8Array(string.length);\n            var isolationPairs = new Map(); //init->pdi and pdi->init\n            // === 3.3.1 The Paragraph Level ===\n            // 3.3.1 P1: Split the text into paragraphs\n            var paragraphs = []; // [{start, end, level}, ...]\n            var paragraph = null;\n            for(var i$1 = 0; i$1 < string.length; i$1++){\n                if (!paragraph) {\n                    paragraphs.push(paragraph = {\n                        start: i$1,\n                        end: string.length - 1,\n                        // 3.3.1 P2-P3: Determine the paragraph level\n                        level: baseDirection === \"rtl\" ? 1 : baseDirection === \"ltr\" ? 0 : determineAutoEmbedLevel(i$1, false)\n                    });\n                }\n                if (charTypes[i$1] & TYPE_B) {\n                    paragraph.end = i$1;\n                    paragraph = null;\n                }\n            }\n            var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n            var nextEven = function(n) {\n                return n + (n & 1 ? 1 : 2);\n            };\n            var nextOdd = function(n) {\n                return n + (n & 1 ? 2 : 1);\n            };\n            // Everything from here on will operate per paragraph.\n            for(var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++){\n                paragraph = paragraphs[paraIdx];\n                var statusStack = [\n                    {\n                        _level: paragraph.level,\n                        _override: 0,\n                        _isolate: 0 //bool\n                    }\n                ];\n                var stackTop = void 0;\n                var overflowIsolateCount = 0;\n                var overflowEmbeddingCount = 0;\n                var validIsolateCount = 0;\n                charTypeCounts.clear();\n                // === 3.3.2 Explicit Levels and Directions ===\n                for(var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++){\n                    var charType = charTypes[i$2];\n                    stackTop = statusStack[statusStack.length - 1];\n                    // Set initial counts\n                    charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n                    if (charType & NEUTRAL_ISOLATE_TYPES) {\n                        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n                    }\n                    // Explicit Embeddings: 3.3.2 X2 - X3\n                    if (charType & FORMATTING_TYPES) {\n                        if (charType & (TYPE_RLE | TYPE_LRE)) {\n                            embedLevels[i$2] = stackTop._level; // 5.2\n                            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n                            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n                                statusStack.push({\n                                    _level: level,\n                                    _override: 0,\n                                    _isolate: 0\n                                });\n                            } else if (!overflowIsolateCount) {\n                                overflowEmbeddingCount++;\n                            }\n                        } else if (charType & (TYPE_RLO | TYPE_LRO)) {\n                            embedLevels[i$2] = stackTop._level; // 5.2\n                            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n                            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n                                statusStack.push({\n                                    _level: level$1,\n                                    _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,\n                                    _isolate: 0\n                                });\n                            } else if (!overflowIsolateCount) {\n                                overflowEmbeddingCount++;\n                            }\n                        } else if (charType & ISOLATE_INIT_TYPES) {\n                            // X5c - FSI becomes either RLI or LRI\n                            if (charType & TYPE_FSI) {\n                                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n                            }\n                            embedLevels[i$2] = stackTop._level;\n                            if (stackTop._override) {\n                                changeCharType(i$2, stackTop._override);\n                            }\n                            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n                            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n                                validIsolateCount++;\n                                statusStack.push({\n                                    _level: level$2,\n                                    _override: 0,\n                                    _isolate: 1,\n                                    _isolInitIndex: i$2\n                                });\n                            } else {\n                                overflowIsolateCount++;\n                            }\n                        } else if (charType & TYPE_PDI) {\n                            if (overflowIsolateCount > 0) {\n                                overflowIsolateCount--;\n                            } else if (validIsolateCount > 0) {\n                                overflowEmbeddingCount = 0;\n                                while(!statusStack[statusStack.length - 1]._isolate){\n                                    statusStack.pop();\n                                }\n                                // Add to isolation pairs bidirectional mapping:\n                                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n                                if (isolInitIndex != null) {\n                                    isolationPairs.set(isolInitIndex, i$2);\n                                    isolationPairs.set(i$2, isolInitIndex);\n                                }\n                                statusStack.pop();\n                                validIsolateCount--;\n                            }\n                            stackTop = statusStack[statusStack.length - 1];\n                            embedLevels[i$2] = stackTop._level;\n                            if (stackTop._override) {\n                                changeCharType(i$2, stackTop._override);\n                            }\n                        } else if (charType & TYPE_PDF) {\n                            if (overflowIsolateCount === 0) {\n                                if (overflowEmbeddingCount > 0) {\n                                    overflowEmbeddingCount--;\n                                } else if (!stackTop._isolate && statusStack.length > 1) {\n                                    statusStack.pop();\n                                    stackTop = statusStack[statusStack.length - 1];\n                                }\n                            }\n                            embedLevels[i$2] = stackTop._level; // 5.2\n                        } else if (charType & TYPE_B) {\n                            embedLevels[i$2] = paragraph.level;\n                        }\n                    } else {\n                        embedLevels[i$2] = stackTop._level;\n                        // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n                        if (stackTop._override && charType !== TYPE_BN) {\n                            changeCharType(i$2, stackTop._override);\n                        }\n                    }\n                }\n                // === 3.3.3 Preparations for Implicit Processing ===\n                // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n                // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n                // easily ignore them all from here on out.\n                // 3.3.3 X10\n                // Compute the set of isolating run sequences as specified by BD13\n                var levelRuns = [];\n                var currentRun = null;\n                for(var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++){\n                    var charType$1 = charTypes[i$3];\n                    if (!(charType$1 & BN_LIKE_TYPES)) {\n                        var lvl = embedLevels[i$3];\n                        var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n                        var isPDI = charType$1 === TYPE_PDI;\n                        if (currentRun && lvl === currentRun._level) {\n                            currentRun._end = i$3;\n                            currentRun._endsWithIsolInit = isIsolInit;\n                        } else {\n                            levelRuns.push(currentRun = {\n                                _start: i$3,\n                                _end: i$3,\n                                _level: lvl,\n                                _startsWithPDI: isPDI,\n                                _endsWithIsolInit: isIsolInit\n                            });\n                        }\n                    }\n                }\n                var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n                for(var runIdx = 0; runIdx < levelRuns.length; runIdx++){\n                    var run = levelRuns[runIdx];\n                    if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {\n                        var seqRuns = [\n                            currentRun = run\n                        ];\n                        for(var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;){\n                            for(var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++){\n                                if (levelRuns[i$4]._start === pdiIndex) {\n                                    seqRuns.push(currentRun = levelRuns[i$4]);\n                                    break;\n                                }\n                            }\n                        }\n                        // build flat list of indices across all runs:\n                        var seqIndices = [];\n                        for(var i$5 = 0; i$5 < seqRuns.length; i$5++){\n                            var run$1 = seqRuns[i$5];\n                            for(var j = run$1._start; j <= run$1._end; j++){\n                                seqIndices.push(j);\n                            }\n                        }\n                        // determine the sos/eos types:\n                        var firstLevel = embedLevels[seqIndices[0]];\n                        var prevLevel = paragraph.level;\n                        for(var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--){\n                            if (!(charTypes[i$6] & BN_LIKE_TYPES)) {\n                                prevLevel = embedLevels[i$6];\n                                break;\n                            }\n                        }\n                        var lastIndex = seqIndices[seqIndices.length - 1];\n                        var lastLevel = embedLevels[lastIndex];\n                        var nextLevel = paragraph.level;\n                        if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n                            for(var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++){\n                                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {\n                                    nextLevel = embedLevels[i$7];\n                                    break;\n                                }\n                            }\n                        }\n                        isolatingRunSeqs.push({\n                            _seqIndices: seqIndices,\n                            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n                            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n                        });\n                    }\n                }\n                // The next steps are done per isolating run sequence\n                for(var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++){\n                    var ref = isolatingRunSeqs[seqIdx];\n                    var seqIndices$1 = ref._seqIndices;\n                    var sosType = ref._sosType;\n                    var eosType = ref._eosType;\n                    /**\n         * All the level runs in an isolating run sequence have the same embedding level.\n         * \n         * DO NOT change any `embedLevels[i]` within the current scope.\n         */ var embedDirection = embedLevels[seqIndices$1[0]] & 1 ? TYPE_R : TYPE_L;\n                    // === 3.3.4 Resolving Weak Types ===\n                    // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n                    // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n                    // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n                    if (charTypeCounts.get(TYPE_NSM)) {\n                        for(var si = 0; si < seqIndices$1.length; si++){\n                            var i$8 = seqIndices$1[si];\n                            if (charTypes[i$8] & TYPE_NSM) {\n                                var prevType = sosType;\n                                for(var sj = si - 1; sj >= 0; sj--){\n                                    if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {\n                                        prevType = charTypes[seqIndices$1[sj]];\n                                        break;\n                                    }\n                                }\n                                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);\n                            }\n                        }\n                    }\n                    // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n                    // is found. If an AL is found, change the type of the European number to Arabic number.\n                    if (charTypeCounts.get(TYPE_EN)) {\n                        for(var si$1 = 0; si$1 < seqIndices$1.length; si$1++){\n                            var i$9 = seqIndices$1[si$1];\n                            if (charTypes[i$9] & TYPE_EN) {\n                                for(var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--){\n                                    var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n                                    if (prevCharType & STRONG_TYPES) {\n                                        if (prevCharType === TYPE_AL) {\n                                            changeCharType(i$9, TYPE_AN);\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    // W3. Change all ALs to R\n                    if (charTypeCounts.get(TYPE_AL)) {\n                        for(var si$2 = 0; si$2 < seqIndices$1.length; si$2++){\n                            var i$10 = seqIndices$1[si$2];\n                            if (charTypes[i$10] & TYPE_AL) {\n                                changeCharType(i$10, TYPE_R);\n                            }\n                        }\n                    }\n                    // W4. A single European separator between two European numbers changes to a European number. A single common\n                    // separator between two numbers of the same type changes to that type.\n                    if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n                        for(var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++){\n                            var i$11 = seqIndices$1[si$3];\n                            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n                                var prevType$1 = 0, nextType = 0;\n                                for(var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--){\n                                    prevType$1 = charTypes[seqIndices$1[sj$2]];\n                                    if (!(prevType$1 & BN_LIKE_TYPES)) {\n                                        break;\n                                    }\n                                }\n                                for(var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++){\n                                    nextType = charTypes[seqIndices$1[sj$3]];\n                                    if (!(nextType & BN_LIKE_TYPES)) {\n                                        break;\n                                    }\n                                }\n                                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {\n                                    changeCharType(i$11, prevType$1);\n                                }\n                            }\n                        }\n                    }\n                    // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n                    if (charTypeCounts.get(TYPE_EN)) {\n                        for(var si$4 = 0; si$4 < seqIndices$1.length; si$4++){\n                            var i$12 = seqIndices$1[si$4];\n                            if (charTypes[i$12] & TYPE_EN) {\n                                for(var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--){\n                                    changeCharType(seqIndices$1[sj$4], TYPE_EN);\n                                }\n                                for(si$4++; si$4 < seqIndices$1.length && charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN); si$4++){\n                                    if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {\n                                        changeCharType(seqIndices$1[si$4], TYPE_EN);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    // W6. Otherwise, separators and terminators change to Other Neutral.\n                    if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n                        for(var si$5 = 0; si$5 < seqIndices$1.length; si$5++){\n                            var i$13 = seqIndices$1[si$5];\n                            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n                                changeCharType(i$13, TYPE_ON);\n                                // 5.2 transform adjacent BNs too:\n                                for(var sj$5 = si$5 - 1; sj$5 >= 0 && charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES; sj$5--){\n                                    changeCharType(seqIndices$1[sj$5], TYPE_ON);\n                                }\n                                for(var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6++){\n                                    changeCharType(seqIndices$1[sj$6], TYPE_ON);\n                                }\n                            }\n                        }\n                    }\n                    // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n                    // is found. If an L is found, then change the type of the European number to L.\n                    // NOTE: implemented in single forward pass for efficiency\n                    if (charTypeCounts.get(TYPE_EN)) {\n                        for(var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++){\n                            var i$14 = seqIndices$1[si$6];\n                            var type = charTypes[i$14];\n                            if (type & TYPE_EN) {\n                                if (prevStrongType === TYPE_L) {\n                                    changeCharType(i$14, TYPE_L);\n                                }\n                            } else if (type & STRONG_TYPES) {\n                                prevStrongType = type;\n                            }\n                        }\n                    }\n                    // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n                    if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n                        // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n                        // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n                        // types EN and AN are treated as R.\n                        var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;\n                        var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n                        // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n                        var bracketPairs = [];\n                        {\n                            var openerStack = [];\n                            for(var si$7 = 0; si$7 < seqIndices$1.length; si$7++){\n                                // NOTE: for any potential bracket character we also test that it still carries a NI\n                                // type, as that may have been changed earlier. This doesn't seem to be explicitly\n                                // called out in the spec, but is required for passage of certain tests.\n                                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                                    var char = string[seqIndices$1[si$7]];\n                                    var oppositeBracket = void 0;\n                                    // Opening bracket\n                                    if (openingToClosingBracket(char) !== null) {\n                                        if (openerStack.length < 63) {\n                                            openerStack.push({\n                                                char: char,\n                                                seqIndex: si$7\n                                            });\n                                        } else {\n                                            break;\n                                        }\n                                    } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                                        for(var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--){\n                                            var stackChar = openerStack[stackIdx].char;\n                                            if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {\n                                                bracketPairs.push([\n                                                    openerStack[stackIdx].seqIndex,\n                                                    si$7\n                                                ]);\n                                                openerStack.length = stackIdx; //pop the matching bracket and all following\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            bracketPairs.sort(function(a, b) {\n                                return a[0] - b[0];\n                            });\n                        }\n                        // * For each bracket-pair element in the list of pairs of text positions\n                        for(var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++){\n                            var ref$1 = bracketPairs[pairIdx];\n                            var openSeqIdx = ref$1[0];\n                            var closeSeqIdx = ref$1[1];\n                            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n                            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n                            // brackets in the pair to match the embedding direction.\n                            var foundStrongType = false;\n                            var useStrongType = 0;\n                            for(var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++){\n                                var i$15 = seqIndices$1[si$8];\n                                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                                    foundStrongType = true;\n                                    var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n                                    if (lr === embedDirection) {\n                                        useStrongType = lr;\n                                        break;\n                                    }\n                                }\n                            }\n                            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n                            // for an established context with a preceding strong type by checking backwards before the opening paired\n                            // bracket until the first strong type (L, R, or sos) is found.\n                            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n                            //    set the type for both brackets in the pair to that direction.\n                            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n                            if (foundStrongType && !useStrongType) {\n                                useStrongType = sosType;\n                                for(var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--){\n                                    var i$16 = seqIndices$1[si$9];\n                                    if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                                        var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n                                        if (lr$1 !== embedDirection) {\n                                            useStrongType = lr$1;\n                                        } else {\n                                            useStrongType = embedDirection;\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                            if (useStrongType) {\n                                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;\n                                // * Any number of characters that had original bidirectional character type NSM prior to the application\n                                // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n                                // the type of their preceding bracket.\n                                if (useStrongType !== embedDirection) {\n                                    for(var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++){\n                                        if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                                            if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                                                charTypes[seqIndices$1[si$10]] = useStrongType;\n                                            }\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (useStrongType !== embedDirection) {\n                                    for(var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++){\n                                        if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                                            if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                                                charTypes[seqIndices$1[si$11]] = useStrongType;\n                                            }\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n                        // same direction.\n                        // N2. Any remaining NIs take the embedding direction.\n                        for(var si$12 = 0; si$12 < seqIndices$1.length; si$12++){\n                            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n                                var niRunStart = si$12, niRunEnd = si$12;\n                                var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n                                for(var si2 = si$12 - 1; si2 >= 0; si2--){\n                                    if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                                        niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                                    } else {\n                                        prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n                                        break;\n                                    }\n                                }\n                                var nextType$1 = eosType;\n                                for(var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++){\n                                    if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                                        niRunEnd = si2$1;\n                                    } else {\n                                        nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n                                        break;\n                                    }\n                                }\n                                for(var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++){\n                                    charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;\n                                }\n                                si$12 = niRunEnd;\n                            }\n                        }\n                    }\n                }\n                // === 3.3.6 Resolving Implicit Levels ===\n                for(var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++){\n                    var level$3 = embedLevels[i$17];\n                    var type$1 = charTypes[i$17];\n                    // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n                    if (level$3 & 1) {\n                        if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n                            embedLevels[i$17]++;\n                        }\n                    } else {\n                        if (type$1 & TYPE_R) {\n                            embedLevels[i$17]++;\n                        } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n                            embedLevels[i$17] += 2;\n                        }\n                    }\n                    // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n                    // and otherwise to the base level.\n                    if (type$1 & BN_LIKE_TYPES) {\n                        embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n                    }\n                    // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n                    // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n                    // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n                    if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n                        for(var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--){\n                            embedLevels[j$1] = paragraph.level;\n                        }\n                    }\n                }\n            }\n            // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n            // according to section 3.4 Reordering Resolved Levels\n            return {\n                levels: embedLevels,\n                paragraphs: paragraphs\n            };\n            function determineAutoEmbedLevel(start, isFSI) {\n                // 3.3.1 P2 - P3\n                for(var i = start; i < string.length; i++){\n                    var charType = charTypes[i];\n                    if (charType & (TYPE_R | TYPE_AL)) {\n                        return 1;\n                    }\n                    if (charType & (TYPE_B | TYPE_L) || isFSI && charType === TYPE_PDI) {\n                        return 0;\n                    }\n                    if (charType & ISOLATE_INIT_TYPES) {\n                        var pdi = indexOfMatchingPDI(i);\n                        i = pdi === -1 ? string.length : pdi;\n                    }\n                }\n                return 0;\n            }\n            function indexOfMatchingPDI(isolateStart) {\n                // 3.1.2 BD9\n                var isolationLevel = 1;\n                for(var i = isolateStart + 1; i < string.length; i++){\n                    var charType = charTypes[i];\n                    if (charType & TYPE_B) {\n                        break;\n                    }\n                    if (charType & TYPE_PDI) {\n                        if (--isolationLevel === 0) {\n                            return i;\n                        }\n                    } else if (charType & ISOLATE_INIT_TYPES) {\n                        isolationLevel++;\n                    }\n                }\n                return -1;\n            }\n        }\n        // Bidi mirrored chars data, auto generated\n        var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n        var mirrorMap;\n        function parse() {\n            if (!mirrorMap) {\n                //const start = performance.now()\n                var ref = parseCharacterMap(data, true);\n                var map = ref.map;\n                var reverseMap = ref.reverseMap;\n                // Combine both maps into one\n                reverseMap.forEach(function(value, key) {\n                    map.set(key, value);\n                });\n                mirrorMap = map;\n            //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n            }\n        }\n        function getMirroredCharacter(char) {\n            parse();\n            return mirrorMap.get(char) || null;\n        }\n        /**\n   * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n   * for any characters in right-to-left segments that have defined mirrored characters.\n   * @param string\n   * @param embeddingLevels\n   * @param [start]\n   * @param [end]\n   * @return {Map<number, string>}\n   */ function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n            var strLen = string.length;\n            start = Math.max(0, start == null ? 0 : +start);\n            end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n            var map = new Map();\n            for(var i = start; i <= end; i++){\n                if (embeddingLevels[i] & 1) {\n                    var mirror = getMirroredCharacter(string[i]);\n                    if (mirror !== null) {\n                        map.set(i, mirror);\n                    }\n                }\n            }\n            return map;\n        }\n        /**\n   * Given a start and end denoting a single line within a string, and a set of precalculated\n   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n   * @param {string} string - the full input string\n   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n   * @param {number} [start] - first character in a subset of the full string\n   * @param {number} [end] - last character in a subset of the full string\n   * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n   */ function getReorderSegments(string, embeddingLevelsResult, start, end) {\n            var strLen = string.length;\n            start = Math.max(0, start == null ? 0 : +start);\n            end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n            var segments = [];\n            embeddingLevelsResult.paragraphs.forEach(function(paragraph) {\n                var lineStart = Math.max(start, paragraph.start);\n                var lineEnd = Math.min(end, paragraph.end);\n                if (lineStart < lineEnd) {\n                    // Local slice for mutation\n                    var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);\n                    // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n                    // end of the line to the paragraph level.\n                    for(var i = lineEnd; i >= lineStart && getBidiCharType(string[i]) & TRAILING_TYPES; i--){\n                        lineLevels[i] = paragraph.level;\n                    }\n                    // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n                    // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n                    var maxLevel = paragraph.level;\n                    var minOddLevel = Infinity;\n                    for(var i$1 = 0; i$1 < lineLevels.length; i$1++){\n                        var level = lineLevels[i$1];\n                        if (level > maxLevel) {\n                            maxLevel = level;\n                        }\n                        if (level < minOddLevel) {\n                            minOddLevel = level | 1;\n                        }\n                    }\n                    for(var lvl = maxLevel; lvl >= minOddLevel; lvl--){\n                        for(var i$2 = 0; i$2 < lineLevels.length; i$2++){\n                            if (lineLevels[i$2] >= lvl) {\n                                var segStart = i$2;\n                                while(i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl){\n                                    i$2++;\n                                }\n                                if (i$2 > segStart) {\n                                    segments.push([\n                                        segStart + lineStart,\n                                        i$2 + lineStart\n                                    ]);\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n            return segments;\n        }\n        /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {string} the new string with bidi segments reordered\n   */ function getReorderedString(string, embedLevelsResult, start, end) {\n            var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n            var chars = [].concat(string);\n            indices.forEach(function(charIndex, i) {\n                chars[i] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];\n            });\n            return chars.join(\"\");\n        }\n        /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {number[]} an array with character indices in their new bidi order\n   */ function getReorderedIndices(string, embedLevelsResult, start, end) {\n            var segments = getReorderSegments(string, embedLevelsResult, start, end);\n            // Fill an array with indices\n            var indices = [];\n            for(var i = 0; i < string.length; i++){\n                indices[i] = i;\n            }\n            // Reverse each segment in order\n            segments.forEach(function(ref) {\n                var start = ref[0];\n                var end = ref[1];\n                var slice = indices.slice(start, end + 1);\n                for(var i = slice.length; i--;){\n                    indices[end - i] = slice[i];\n                }\n            });\n            return indices;\n        }\n        exports.closingToOpeningBracket = closingToOpeningBracket;\n        exports.getBidiCharType = getBidiCharType;\n        exports.getBidiCharTypeName = getBidiCharTypeName;\n        exports.getCanonicalBracket = getCanonicalBracket;\n        exports.getEmbeddingLevels = getEmbeddingLevels;\n        exports.getMirroredCharacter = getMirroredCharacter;\n        exports.getMirroredCharactersMap = getMirroredCharactersMap;\n        exports.getReorderSegments = getReorderSegments;\n        exports.getReorderedIndices = getReorderedIndices;\n        exports.getReorderedString = getReorderedString;\n        exports.openingToClosingBracket = openingToClosingBracket;\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        return exports;\n    }({});\n    return bidi;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bidiFactory);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmlkaS1qcy9kaXN0L2JpZGkubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQTtJQUNULElBQUlDLE9BQVEsU0FBVUMsT0FBTztRQUUzQiw0Q0FBNEM7UUFDNUMsSUFBSUMsT0FBTztZQUNULEtBQUs7WUFDTCxNQUFNO1lBQ04sTUFBTTtZQUNOLE1BQU07WUFDTixNQUFNO1lBQ04sTUFBTTtZQUNOLEtBQUs7WUFDTCxLQUFLO1lBQ0wsTUFBTTtZQUNOLE1BQU07WUFDTixNQUFNO1lBQ04sT0FBTztZQUNQLE1BQU07WUFDTixPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87UUFDVDtRQUVBLElBQUlDLFFBQVEsQ0FBQztRQUNiLElBQUlDLGlCQUFpQixDQUFDO1FBQ3RCRCxNQUFNRSxDQUFDLEdBQUcsR0FBRyxrQkFBa0I7UUFDL0JELGNBQWMsQ0FBQyxFQUFFLEdBQUc7UUFDcEJFLE9BQU9DLElBQUksQ0FBQ0wsTUFBTU0sT0FBTyxDQUFDLFNBQVVDLElBQUksRUFBRUMsQ0FBQztZQUN6Q1AsS0FBSyxDQUFDTSxLQUFLLEdBQUcsS0FBTUMsSUFBSTtZQUN4Qk4sY0FBYyxDQUFDRCxLQUFLLENBQUNNLEtBQUssQ0FBQyxHQUFHQTtRQUNoQztRQUNBSCxPQUFPSyxNQUFNLENBQUNSO1FBRWQsSUFBSVMscUJBQXFCVCxNQUFNVSxHQUFHLEdBQUdWLE1BQU1XLEdBQUcsR0FBR1gsTUFBTVksR0FBRztRQUMxRCxJQUFJQyxlQUFlYixNQUFNRSxDQUFDLEdBQUdGLE1BQU1jLENBQUMsR0FBR2QsTUFBTWUsRUFBRTtRQUMvQyxJQUFJQyx3QkFBd0JoQixNQUFNaUIsQ0FBQyxHQUFHakIsTUFBTWtCLENBQUMsR0FBR2xCLE1BQU1tQixFQUFFLEdBQUduQixNQUFNb0IsRUFBRSxHQUFHcEIsTUFBTVksR0FBRyxHQUFHWixNQUFN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UixtQkFBbUIsR0FBR0E7UUFDOUJsUixRQUFRK1Esa0JBQWtCLEdBQUdBO1FBQzdCL1EsUUFBUXFFLHVCQUF1QixHQUFHQTtRQUVsQ2hFLE9BQU9rUixjQUFjLENBQUN2UixTQUFTLGNBQWM7WUFBRTRQLE9BQU87UUFBSztRQUUzRCxPQUFPNVA7SUFFVCxFQUFFLENBQUM7SUFDSCxPQUFPRDtBQUFJO0FBRVgsaUVBQWVELFdBQVdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmVhdGl2ZS00MDQvLi9ub2RlX21vZHVsZXMvYmlkaS1qcy9kaXN0L2JpZGkubWpzP2VkNjkiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gYmlkaUZhY3RvcnkoKSB7XG52YXIgYmlkaSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIC8vIEJpZGkgY2hhcmFjdGVyIHR5cGVzIGRhdGEsIGF1dG8gZ2VuZXJhdGVkXG4gIHZhciBEQVRBID0ge1xuICAgIFwiUlwiOiBcIjEzaywxYSwyLDMsMywyKzFqLGNoKzE2LGErMSw1KzIsMituLDUsYSw0LDYrMTYsNCszLGgrMWIsNG1vLDE3OXEsMis5LDIrMTEsMmk5Kzd5LDIrNjgsNCwzKzQsNSsxMyw0KzMsMis0aywzKzI5LDgrY2YsMXQrN3osdysxNywzKzNtLDF0KzN6LDE2bzErNXIsOCszMCw4K21jLDI5KzFyLDI5KzR2LDc1KzczXCIsXG4gICAgXCJFTlwiOiBcIjFjKzksM2QrMSw2LDE4Nys5LDUxMyw0KzUsNys5LHNmK2osMTc1aCs5LHF3K3EsMTYxZisxZCw0eHQrYSwyNWkrOVwiLFxuICAgIFwiRVNcIjogXCIxNywyLDZkcCsxLGYrMSxhdiwxNnZyLG14KzEsNG8sMlwiLFxuICAgIFwiRVRcIjogXCJ6KzIsM2grMyxiKzEseW0sM2UrMSwybyxwNCsxLDgsNnUsN2MsZzYsMXdjLDFuOSs0LDMwKzFiLDJuLDZkLHFoeCsxLGgwbSxhKzEsNDkrMiw2MysxLDQrMSw2YmIrMywxMmpqXCIsXG4gICAgXCJBTlwiOiBcIjE2bys1LDJqKzksMisxLDM1LGVkLDFmZjIrOSw4Nyt1XCIsXG4gICAgXCJDU1wiOiBcIjE4LDIrMSxiLDJ1LDEyayw1NXYsbCwxN3YwLDIsMyw1MywyKzEsYlwiLFxuICAgIFwiQlwiOiBcImEsMyxmKzIsMnYsNjkwXCIsXG4gICAgXCJTXCI6IFwiOSwyLGtcIixcbiAgICBcIldTXCI6IFwiYyxrLDRmNCwxdmsrYSx1LDFqLDMzNVwiLFxuICAgIFwiT05cIjogXCJ4KzEsNCs0LGgrNSxyKzUsciszLHosNSszLDIrMSwyKzEsNSwyKzIsMys0LG8sdyxjaSsxLDgrZCwzK2QsNis4LDIrZywzOSsxLDksNisxLDIsMzMsYjgsMysxLDNjKzEsNysxLDVyLGIsN2grMyxzYSs1LDIsM2krNixqZyszLHVyKzksMnYsaWorMSw5Zys5LDcrYSw4bSw0KzEsNDkreCwxNHUsMisyLGMrMixlKzIsZSsyLGUrMSxpK24sZStlLDIrcCx1KzIsZSsyLDM2KzEsMiszLDIrMSxiLDIrMiw2KzUsMiwyLDIsaCsxLDUrNCw2KzMsMytmLDE2KzIsNSszbCwzKzgxLDF5K3AsMis0MCxxK2EsbSsxMywycitjaCwyKzllLDc1K2hmLDMrdiwyKzJ3LDZlKzUsZis2LDc1KzJhLDFhK3AsMisyZyxkKzV4LHIrYiw2KzMsNCtvLGcsNisxLDYrMiwyaysxLDQsMmosNWgreiwxbSsxLDFlK2YsdCsyLDFmK2UsZCszLDRvKzMsMnMrMSx3LDUzNSsxcixoM2wrMWksOTMrMiwycyxiKzEsM2wreCwydiw0ZyszLDIxKzMsa3orMSxnNXYrMSw1YSxqKzksbit2LDIsMywyKzgsMisxLDMrMiwyLDMsNDYrMSw0KzQsaCs1LHIrNSxyK2EsM2grMiw0KzYsYis0LDc4LDFyKzI0LDQrYyw0LDFoYixleSs2LDEwMytqLDE2aitjLDF1eCs3LDUrZyxmc2gsamRxKzF0LDQsNTcrMmUscDEsMW0sMW0sMW0sMW0sNGt0KzEsN2orMTcsNSsycixkK2UsMytlLDIrZSwyKzEwLG0rNCx3LDFuKzUsMXEsNHorNSw0YityYiw5K2MsNCtjLDQrMzcsZCsyZyw4K2IsbCtiLDUrMWosOSs5LDcrMTMsOSt0LDMrMSwyNyszYywyKzI5LDIrM3EsZCtkLDMrNCw0KzIsNis2LGErbyw4KzYsYSsyLGUrNiwxNis0MiwyKzFpXCIsXG4gICAgXCJCTlwiOiBcIjArOCw2K2QsMnMrNSwyK3AsZSw0bTksMWt0KzIsMmIrNSw1KzUsMTdxOSt2LDdrLDZwKzgsNisxLDExOWQrMyw0NDArNyw5NnMrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrNzUsNnArMnJ6LDFiZW4rMSwxZWtmKzEsMWVrZisxXCIsXG4gICAgXCJOU01cIjogXCJsYyszMyw3bys2LDdjKzE4LDIsMisxLDIrMSwyLDIxK2EsMWQrayxoLDJ1KzYsMys1LDMrMSwyKzMsMTAsditxLDJrK2EsMW4rOCxhLHArMywyKzgsMisyLDIrNCwxOCsyLDNjK2UsMit2LDFrLDIsNSs3LDUsNCs2LGIrMSx1LDFuLDUrMyw5LGwrMSxyLDMrMSwxbSw1KzEsNSsxLDMrMiw0LHYrMSw0LGMrMSwxbSw1KzQsMisxLDUsbCsxLG4rNSwyLDFuLDMsMiszLDksOCsxLGMrMSx2LDFxLGQsMWYsNCwxbSsyLDYrMiwyKzMsOCsxLGMrMSx1LDFuLGcrMSxsKzEsdCsxLDFtKzEsNSszLDksbCsxLHUsMjEsOCsyLDIsMmosMys2LGQrNywyciwzKzgsYys1LDIzKzEscywyLDIsMWsrZCwyKzQsMisxLDYrYSwyK3osYSwydiszLDIrNSwyKzEsMysxLHErMSw1KzIsaCszLGUsMysxLDcsZyxqaysyLHFiKzIsdSsyLHUrMSx2KzEsMXQrMSwyKzYsOSwzK2EsYSwxYSsyLDNjKzEseiwzYisyLDUrMSxhLDcrMiw2NCsxLDMsMW4sMis2LDIsMiwzKzcsNys5LDMsMWQrZywxcyszLDFkLDIrNCwyLDYsMTUrOCxkKzEseCszLDMrMSwyKzIsMWwsMisxLDQsMisyLDFuKzcsMysxLDQ5KzIsMitjLDIrNiw1LDcsNCsxLDVqKzFsLDIrNCxrMSt3LDJkYisyLDN5LDJwK3YsZmYrMywzMCsxLG45eCszLDIrOSx4KzEsMjkrMSw3bCw0LDUscSsxLDYsNDgrMSxyK2gsZSwxMys3LHErYSwxYisyLDFkLDMrMywzKzEsMTQsMXcrNSwzKzEsMysxLGQsOSwxYywxZywyKzIsMysxLDYrMSwyLDE3KzEsOSw2biwzLDUsZm41LGtpK2YsaCtmLHIyLDZiLDQ2KzQsMWFmKzIsMisxLDYrMywxNSsyLDUsNG0rMSxmeSszLGFzKzEsNGErYSw0eCwxaitlLDFsKzIsMWUrMywzKzEsMXkrMiwxMSs0LDIrNywxcixkKzEsMWgrOCxiKzMsMywybysyLDMsMisxLDcsNGgsNCs3LG0rMSwxbSsxLDQsMTIrNiw0KzQsNWcrNywzKzIsMixvLDJkKzUsMiw1KzEsMisxLDZuKzMsNysxLDIrMSxzKzEsMmUrNywzLDIrMSwyeiwyLDMrNSwyLDJ1KzIsMyszLDIrNCw3OCs4LDIrMSw3NSsxLDIsNSw0MSszLDMrMSw1LHgrNSwzKzEsMTUrNSwzKzMsOSxhKzUsMysyLDFiK2MsMisxLGJiKzYsMis1LDJkK2wsMys2LDIrMSwyKzEsM2YrNSw0LDIrMSwyKzYsMiwyMSsxLDQsMiw5bysxLGYwYys0LDFvKzYsdDUsMXMrMywyYSxmNWwrMSw0M3QrMixpKzcsMys2LHYrMyw0NSsyLDFqMCsxaSw1KzFkLDksZixuKzQsMitlLDExdCs2LDIrZywzKzYsMisxLDIrNCw3YSs2LGM2KzMsMTV0KzYsMzIrNixnemh5KzZuXCIsXG4gICAgXCJBTFwiOiBcIjE2dywzLDIsZSsxYix6KzIsMisycyxnKzEsOCsxLGIrbSwyK3QscysyaSxjK2UsNGgrZiwxZCsxZSwxYndlK2RwLDMrM3oseCtjLDIrMSwzNSszeSwycm0reiw1KzcsYis1LGR0K2wsYyt1LDE3bmwrMjcsMXQrMjcsNHgrNm4sMytkXCIsXG4gICAgXCJMUk9cIjogXCI2Y3RcIixcbiAgICBcIlJMT1wiOiBcIjZjdVwiLFxuICAgIFwiTFJFXCI6IFwiNmNxXCIsXG4gICAgXCJSTEVcIjogXCI2Y3JcIixcbiAgICBcIlBERlwiOiBcIjZjc1wiLFxuICAgIFwiTFJJXCI6IFwiNmVlXCIsXG4gICAgXCJSTElcIjogXCI2ZWZcIixcbiAgICBcIkZTSVwiOiBcIjZlZ1wiLFxuICAgIFwiUERJXCI6IFwiNmVoXCJcbiAgfTtcblxuICB2YXIgVFlQRVMgPSB7fTtcbiAgdmFyIFRZUEVTX1RPX05BTUVTID0ge307XG4gIFRZUEVTLkwgPSAxOyAvL0wgaXMgdGhlIGRlZmF1bHRcbiAgVFlQRVNfVE9fTkFNRVNbMV0gPSAnTCc7XG4gIE9iamVjdC5rZXlzKERBVEEpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGkpIHtcbiAgICBUWVBFU1t0eXBlXSA9IDEgPDwgKGkgKyAxKTtcbiAgICBUWVBFU19UT19OQU1FU1tUWVBFU1t0eXBlXV0gPSB0eXBlO1xuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShUWVBFUyk7XG5cbiAgdmFyIElTT0xBVEVfSU5JVF9UWVBFUyA9IFRZUEVTLkxSSSB8IFRZUEVTLlJMSSB8IFRZUEVTLkZTSTtcbiAgdmFyIFNUUk9OR19UWVBFUyA9IFRZUEVTLkwgfCBUWVBFUy5SIHwgVFlQRVMuQUw7XG4gIHZhciBORVVUUkFMX0lTT0xBVEVfVFlQRVMgPSBUWVBFUy5CIHwgVFlQRVMuUyB8IFRZUEVTLldTIHwgVFlQRVMuT04gfCBUWVBFUy5GU0kgfCBUWVBFUy5MUkkgfCBUWVBFUy5STEkgfCBUWVBFUy5QREk7XG4gIHZhciBCTl9MSUtFX1RZUEVTID0gVFlQRVMuQk4gfCBUWVBFUy5STEUgfCBUWVBFUy5MUkUgfCBUWVBFUy5STE8gfCBUWVBFUy5MUk8gfCBUWVBFUy5QREY7XG4gIHZhciBUUkFJTElOR19UWVBFUyA9IFRZUEVTLlMgfCBUWVBFUy5XUyB8IFRZUEVTLkIgfCBJU09MQVRFX0lOSVRfVFlQRVMgfCBUWVBFUy5QREkgfCBCTl9MSUtFX1RZUEVTO1xuXG4gIHZhciBtYXAgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHBhcnNlRGF0YSAoKSB7XG4gICAgaWYgKCFtYXApIHtcbiAgICAgIC8vY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIHR5cGUgKSB7XG4gICAgICAgIGlmIChEQVRBLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICAgICAgdmFyIGxhc3RDb2RlID0gMDtcbiAgICAgICAgICBEQVRBW3R5cGVdLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciByZWYgPSByYW5nZS5zcGxpdCgnKycpO1xuICAgICAgICAgICAgdmFyIHNraXAgPSByZWZbMF07XG4gICAgICAgICAgICB2YXIgc3RlcCA9IHJlZlsxXTtcbiAgICAgICAgICAgIHNraXAgPSBwYXJzZUludChza2lwLCAzNik7XG4gICAgICAgICAgICBzdGVwID0gc3RlcCA/IHBhcnNlSW50KHN0ZXAsIDM2KSA6IDA7XG4gICAgICAgICAgICBtYXAuc2V0KGxhc3RDb2RlICs9IHNraXAsIFRZUEVTW3R5cGVdKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgaSsrKSB7XG4gICAgICAgICAgICAgIG1hcC5zZXQoKytsYXN0Q29kZSwgVFlQRVNbdHlwZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciB0eXBlIGluIERBVEEpIGxvb3AoIHR5cGUgKTtcbiAgICAgIC8vY29uc29sZS5sb2coYGNoYXIgdHlwZXMgcGFyc2VkIGluICR7cGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydH1tc2ApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEJpZGlDaGFyVHlwZSAoY2hhcikge1xuICAgIHBhcnNlRGF0YSgpO1xuICAgIHJldHVybiBtYXAuZ2V0KGNoYXIuY29kZVBvaW50QXQoMCkpIHx8IFRZUEVTLkxcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJpZGlDaGFyVHlwZU5hbWUoY2hhcikge1xuICAgIHJldHVybiBUWVBFU19UT19OQU1FU1tnZXRCaWRpQ2hhclR5cGUoY2hhcildXG4gIH1cblxuICAvLyBCaWRpIGJyYWNrZXQgcGFpcnMgZGF0YSwgYXV0byBnZW5lcmF0ZWRcbiAgdmFyIGRhdGEkMSA9IHtcbiAgICBcInBhaXJzXCI6IFwiMTQ+MSwxZT4yLHU+Miwyd3Q+MSwxPjEsMWdlPjEsMXdwPjEsMWo+MSxmPjEsaG0+MSwxPjEsdT4xLHU2PjEsMT4xLCs1LDI4PjEsdz4xLDE+MSwrMyxiOD4xLDE+MSwrMywxPjMsLTE+LTEsMz4xLDE+MSwrMiwxcz4xLDE+MSx4PjEsdGg+MSwxPjEsKzIsZGI+MSwxPjEsKzMsMz4xLDE+MSwrMiwxNHFtPjEsMT4xLCsxLDRxPjEsMWU+Mix1PjIsMj4xLCsxXCIsXG4gICAgXCJjYW5vbmljYWxcIjogXCI2ZjE+LTZkeCw2ZHk+LTZkeCw2ZWM+LTZlZCw2ZWU+LTZlZCw2d3c+MmpqLC0yamk+MmpqLDE0cjQ+LTFlN2wsMWU3bT4tMWU3bCwxZTdtPi0xZTVjLDFlNWQ+LTFlNWIsMWU1Yz4tMTRxeCwxNHF5Pi0xNHF4LDE0dm4+LTFlY2csMWVjaD4tMWVjZywxZWR1Pi0xZWNnLDFlY2k+LTFlY2csMWVkYT4tMWVjZywxZWNpPi0xZWNnLDFlY2k+LTE2OHEsMTY4cj4tMTY4cSwxNjhzPi0xNHllLDE0eWY+LTE0eWVcIlxuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gc3RyaW5nIHRoYXQgaG9sZHMgZW5jb2RlZCBjb2RlcG9pbnQgbWFwcGluZ3MsIGUuZy4gZm9yIGJyYWNrZXQgcGFpcnMgb3JcbiAgICogbWlycm9yaW5nIGNoYXJhY3RlcnMsIGFzIGVuY29kZWQgYnkgc2NyaXB0cy9nZW5lcmF0ZUJpZGlEYXRhLmpzLiBSZXR1cm5zIGFuIG9iamVjdFxuICAgKiBob2xkaW5nIHRoZSBgbWFwYCwgYW5kIG9wdGlvbmFsbHkgYSBgcmV2ZXJzZU1hcGAgaWYgYGluY2x1ZGVSZXZlcnNlOnRydWVgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RlZFN0cmluZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVSZXZlcnNlIC0gdHJ1ZSBpZiB5b3Ugd2FudCByZXZlcnNlTWFwIGluIHRoZSBvdXRwdXRcbiAgICogQHJldHVybiB7e21hcDogTWFwPG51bWJlciwgbnVtYmVyPiwgcmV2ZXJzZU1hcD86IE1hcDxudW1iZXIsIG51bWJlcj59fVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VDaGFyYWN0ZXJNYXAgKGVuY29kZWRTdHJpbmcsIGluY2x1ZGVSZXZlcnNlKSB7XG4gICAgdmFyIHJhZGl4ID0gMzY7XG4gICAgdmFyIGxhc3RDb2RlID0gMDtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIHZhciByZXZlcnNlTWFwID0gaW5jbHVkZVJldmVyc2UgJiYgbmV3IE1hcCgpO1xuICAgIHZhciBwcmV2UGFpcjtcbiAgICBlbmNvZGVkU3RyaW5nLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiB2aXNpdChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5LmluZGV4T2YoJysnKSAhPT0gLTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9ICtlbnRyeTsgaS0tOykge1xuICAgICAgICAgIHZpc2l0KHByZXZQYWlyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlBhaXIgPSBlbnRyeTtcbiAgICAgICAgdmFyIHJlZiA9IGVudHJ5LnNwbGl0KCc+Jyk7XG4gICAgICAgIHZhciBhID0gcmVmWzBdO1xuICAgICAgICB2YXIgYiA9IHJlZlsxXTtcbiAgICAgICAgYSA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGxhc3RDb2RlICs9IHBhcnNlSW50KGEsIHJhZGl4KSk7XG4gICAgICAgIGIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChsYXN0Q29kZSArPSBwYXJzZUludChiLCByYWRpeCkpO1xuICAgICAgICBtYXAuc2V0KGEsIGIpO1xuICAgICAgICBpbmNsdWRlUmV2ZXJzZSAmJiByZXZlcnNlTWFwLnNldChiLCBhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyBtYXA6IG1hcCwgcmV2ZXJzZU1hcDogcmV2ZXJzZU1hcCB9XG4gIH1cblxuICB2YXIgb3BlblRvQ2xvc2UsIGNsb3NlVG9PcGVuLCBjYW5vbmljYWw7XG5cbiAgZnVuY3Rpb24gcGFyc2UkMSAoKSB7XG4gICAgaWYgKCFvcGVuVG9DbG9zZSkge1xuICAgICAgLy9jb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB2YXIgcmVmID0gcGFyc2VDaGFyYWN0ZXJNYXAoZGF0YSQxLnBhaXJzLCB0cnVlKTtcbiAgICAgIHZhciBtYXAgPSByZWYubWFwO1xuICAgICAgdmFyIHJldmVyc2VNYXAgPSByZWYucmV2ZXJzZU1hcDtcbiAgICAgIG9wZW5Ub0Nsb3NlID0gbWFwO1xuICAgICAgY2xvc2VUb09wZW4gPSByZXZlcnNlTWFwO1xuICAgICAgY2Fub25pY2FsID0gcGFyc2VDaGFyYWN0ZXJNYXAoZGF0YSQxLmNhbm9uaWNhbCwgZmFsc2UpLm1hcDtcbiAgICAgIC8vY29uc29sZS5sb2coYGJyYWNrZXRzIHBhcnNlZCBpbiAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnR9bXNgKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0IChjaGFyKSB7XG4gICAgcGFyc2UkMSgpO1xuICAgIHJldHVybiBvcGVuVG9DbG9zZS5nZXQoY2hhcikgfHwgbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQgKGNoYXIpIHtcbiAgICBwYXJzZSQxKCk7XG4gICAgcmV0dXJuIGNsb3NlVG9PcGVuLmdldChjaGFyKSB8fCBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBnZXRDYW5vbmljYWxCcmFja2V0IChjaGFyKSB7XG4gICAgcGFyc2UkMSgpO1xuICAgIHJldHVybiBjYW5vbmljYWwuZ2V0KGNoYXIpIHx8IG51bGxcbiAgfVxuXG4gIC8vIExvY2FsIHR5cGUgYWxpYXNlc1xuICB2YXIgVFlQRV9MID0gVFlQRVMuTDtcbiAgdmFyIFRZUEVfUiA9IFRZUEVTLlI7XG4gIHZhciBUWVBFX0VOID0gVFlQRVMuRU47XG4gIHZhciBUWVBFX0VTID0gVFlQRVMuRVM7XG4gIHZhciBUWVBFX0VUID0gVFlQRVMuRVQ7XG4gIHZhciBUWVBFX0FOID0gVFlQRVMuQU47XG4gIHZhciBUWVBFX0NTID0gVFlQRVMuQ1M7XG4gIHZhciBUWVBFX0IgPSBUWVBFUy5CO1xuICB2YXIgVFlQRV9TID0gVFlQRVMuUztcbiAgdmFyIFRZUEVfT04gPSBUWVBFUy5PTjtcbiAgdmFyIFRZUEVfQk4gPSBUWVBFUy5CTjtcbiAgdmFyIFRZUEVfTlNNID0gVFlQRVMuTlNNO1xuICB2YXIgVFlQRV9BTCA9IFRZUEVTLkFMO1xuICB2YXIgVFlQRV9MUk8gPSBUWVBFUy5MUk87XG4gIHZhciBUWVBFX1JMTyA9IFRZUEVTLlJMTztcbiAgdmFyIFRZUEVfTFJFID0gVFlQRVMuTFJFO1xuICB2YXIgVFlQRV9STEUgPSBUWVBFUy5STEU7XG4gIHZhciBUWVBFX1BERiA9IFRZUEVTLlBERjtcbiAgdmFyIFRZUEVfTFJJID0gVFlQRVMuTFJJO1xuICB2YXIgVFlQRV9STEkgPSBUWVBFUy5STEk7XG4gIHZhciBUWVBFX0ZTSSA9IFRZUEVTLkZTSTtcbiAgdmFyIFRZUEVfUERJID0gVFlQRVMuUERJO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHRcbiAgICogQHByb3BlcnR5IHt7c3RhcnQsIGVuZCwgbGV2ZWx9W119IHBhcmFncmFwaHNcbiAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBsZXZlbHNcbiAgICovXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgQmlkaXJlY3Rpb25hbCBBbGdvcml0aG0gdG8gYSBzdHJpbmcsIHJldHVybmluZyB0aGUgcmVzb2x2ZWQgZW1iZWRkaW5nIGxldmVsc1xuICAgKiBpbiBhIHNpbmdsZSBVaW50OEFycmF5IHBsdXMgYSBsaXN0IG9mIG9iamVjdHMgaG9sZGluZyBlYWNoIHBhcmFncmFwaCdzIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBhbmQgcmVzb2x2ZWRcbiAgICogYmFzZSBlbWJlZGRpbmcgbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgaW5wdXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7XCJsdHJcInxcInJ0bFwifFwiYXV0b1wifSBbYmFzZURpcmVjdGlvbl0gLSBVc2UgXCJsdHJcIiBvciBcInJ0bFwiIHRvIGZvcmNlIGEgYmFzZSBwYXJhZ3JhcGggZGlyZWN0aW9uLFxuICAgKiAgICAgICAgb3RoZXJ3aXNlIGEgZGlyZWN0aW9uIHdpbGwgYmUgY2hvc2VuIGF1dG9tYXRpY2FsbHkgZnJvbSBlYWNoIHBhcmFncmFwaCdzIGNvbnRlbnRzLlxuICAgKiBAcmV0dXJuIHtHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHR9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbWJlZGRpbmdMZXZlbHMgKHN0cmluZywgYmFzZURpcmVjdGlvbikge1xuICAgIHZhciBNQVhfREVQVEggPSAxMjU7XG5cbiAgICAvLyBTdGFydCBieSBtYXBwaW5nIGFsbCBjaGFyYWN0ZXJzIHRvIHRoZWlyIHVuaWNvZGUgdHlwZSwgYXMgYSBiaXRtYXNrIGludGVnZXJcbiAgICB2YXIgY2hhclR5cGVzID0gbmV3IFVpbnQzMkFycmF5KHN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyVHlwZXNbaV0gPSBnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhclR5cGVDb3VudHMgPSBuZXcgTWFwKCk7IC8vd2lsbCBiZSBjbGVhcmVkIGF0IHN0YXJ0IG9mIGVhY2ggcGFyYWdyYXBoXG4gICAgZnVuY3Rpb24gY2hhbmdlQ2hhclR5cGUoaSwgdHlwZSkge1xuICAgICAgdmFyIG9sZFR5cGUgPSBjaGFyVHlwZXNbaV07XG4gICAgICBjaGFyVHlwZXNbaV0gPSB0eXBlO1xuICAgICAgY2hhclR5cGVDb3VudHMuc2V0KG9sZFR5cGUsIGNoYXJUeXBlQ291bnRzLmdldChvbGRUeXBlKSAtIDEpO1xuICAgICAgaWYgKG9sZFR5cGUgJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUywgY2hhclR5cGVDb3VudHMuZ2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUykgLSAxKTtcbiAgICAgIH1cbiAgICAgIGNoYXJUeXBlQ291bnRzLnNldCh0eXBlLCAoY2hhclR5cGVDb3VudHMuZ2V0KHR5cGUpIHx8IDApICsgMSk7XG4gICAgICBpZiAodHlwZSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICBjaGFyVHlwZUNvdW50cy5zZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTLCAoY2hhclR5cGVDb3VudHMuZ2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUykgfHwgMCkgKyAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZW1iZWRMZXZlbHMgPSBuZXcgVWludDhBcnJheShzdHJpbmcubGVuZ3RoKTtcbiAgICB2YXIgaXNvbGF0aW9uUGFpcnMgPSBuZXcgTWFwKCk7IC8vaW5pdC0+cGRpIGFuZCBwZGktPmluaXRcblxuICAgIC8vID09PSAzLjMuMSBUaGUgUGFyYWdyYXBoIExldmVsID09PVxuICAgIC8vIDMuMy4xIFAxOiBTcGxpdCB0aGUgdGV4dCBpbnRvIHBhcmFncmFwaHNcbiAgICB2YXIgcGFyYWdyYXBocyA9IFtdOyAvLyBbe3N0YXJ0LCBlbmQsIGxldmVsfSwgLi4uXVxuICAgIHZhciBwYXJhZ3JhcGggPSBudWxsO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHN0cmluZy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICBpZiAoIXBhcmFncmFwaCkge1xuICAgICAgICBwYXJhZ3JhcGhzLnB1c2gocGFyYWdyYXBoID0ge1xuICAgICAgICAgIHN0YXJ0OiBpJDEsXG4gICAgICAgICAgZW5kOiBzdHJpbmcubGVuZ3RoIC0gMSxcbiAgICAgICAgICAvLyAzLjMuMSBQMi1QMzogRGV0ZXJtaW5lIHRoZSBwYXJhZ3JhcGggbGV2ZWxcbiAgICAgICAgICBsZXZlbDogYmFzZURpcmVjdGlvbiA9PT0gJ3J0bCcgPyAxIDogYmFzZURpcmVjdGlvbiA9PT0gJ2x0cicgPyAwIDogZGV0ZXJtaW5lQXV0b0VtYmVkTGV2ZWwoaSQxLCBmYWxzZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhclR5cGVzW2kkMV0gJiBUWVBFX0IpIHtcbiAgICAgICAgcGFyYWdyYXBoLmVuZCA9IGkkMTtcbiAgICAgICAgcGFyYWdyYXBoID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgRk9STUFUVElOR19UWVBFUyA9IFRZUEVfUkxFIHwgVFlQRV9MUkUgfCBUWVBFX1JMTyB8IFRZUEVfTFJPIHwgSVNPTEFURV9JTklUX1RZUEVTIHwgVFlQRV9QREkgfCBUWVBFX1BERiB8IFRZUEVfQjtcbiAgICB2YXIgbmV4dEV2ZW4gPSBmdW5jdGlvbiAobikgeyByZXR1cm4gbiArICgobiAmIDEpID8gMSA6IDIpOyB9O1xuICAgIHZhciBuZXh0T2RkID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gKyAoKG4gJiAxKSA/IDIgOiAxKTsgfTtcblxuICAgIC8vIEV2ZXJ5dGhpbmcgZnJvbSBoZXJlIG9uIHdpbGwgb3BlcmF0ZSBwZXIgcGFyYWdyYXBoLlxuICAgIGZvciAodmFyIHBhcmFJZHggPSAwOyBwYXJhSWR4IDwgcGFyYWdyYXBocy5sZW5ndGg7IHBhcmFJZHgrKykge1xuICAgICAgcGFyYWdyYXBoID0gcGFyYWdyYXBoc1twYXJhSWR4XTtcbiAgICAgIHZhciBzdGF0dXNTdGFjayA9IFt7XG4gICAgICAgIF9sZXZlbDogcGFyYWdyYXBoLmxldmVsLFxuICAgICAgICBfb3ZlcnJpZGU6IDAsIC8vMD1uZXV0cmFsLCAxPUwsIDI9UlxuICAgICAgICBfaXNvbGF0ZTogMCAvL2Jvb2xcbiAgICAgIH1dO1xuICAgICAgdmFyIHN0YWNrVG9wID0gKHZvaWQgMCk7XG4gICAgICB2YXIgb3ZlcmZsb3dJc29sYXRlQ291bnQgPSAwO1xuICAgICAgdmFyIG92ZXJmbG93RW1iZWRkaW5nQ291bnQgPSAwO1xuICAgICAgdmFyIHZhbGlkSXNvbGF0ZUNvdW50ID0gMDtcbiAgICAgIGNoYXJUeXBlQ291bnRzLmNsZWFyKCk7XG5cbiAgICAgIC8vID09PSAzLjMuMiBFeHBsaWNpdCBMZXZlbHMgYW5kIERpcmVjdGlvbnMgPT09XG4gICAgICBmb3IgKHZhciBpJDIgPSBwYXJhZ3JhcGguc3RhcnQ7IGkkMiA8PSBwYXJhZ3JhcGguZW5kOyBpJDIrKykge1xuICAgICAgICB2YXIgY2hhclR5cGUgPSBjaGFyVHlwZXNbaSQyXTtcbiAgICAgICAgc3RhY2tUb3AgPSBzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBjb3VudHNcbiAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KGNoYXJUeXBlLCAoY2hhclR5cGVDb3VudHMuZ2V0KGNoYXJUeXBlKSB8fCAwKSArIDEpO1xuICAgICAgICBpZiAoY2hhclR5cGUgJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgICBjaGFyVHlwZUNvdW50cy5zZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTLCAoY2hhclR5cGVDb3VudHMuZ2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUykgfHwgMCkgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cGxpY2l0IEVtYmVkZGluZ3M6IDMuMy4yIFgyIC0gWDNcbiAgICAgICAgaWYgKGNoYXJUeXBlICYgRk9STUFUVElOR19UWVBFUykgeyAvL3ByZWZpbHRlciBhbGwgZm9ybWF0dGVyc1xuICAgICAgICAgIGlmIChjaGFyVHlwZSAmIChUWVBFX1JMRSB8IFRZUEVfTFJFKSkge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDsgLy8gNS4yXG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSAoY2hhclR5cGUgPT09IFRZUEVfUkxFID8gbmV4dE9kZCA6IG5leHRFdmVuKShzdGFja1RvcC5fbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGxldmVsIDw9IE1BWF9ERVBUSCAmJiAhb3ZlcmZsb3dJc29sYXRlQ291bnQgJiYgIW92ZXJmbG93RW1iZWRkaW5nQ291bnQpIHtcbiAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgX2xldmVsOiBsZXZlbCxcbiAgICAgICAgICAgICAgICBfb3ZlcnJpZGU6IDAsXG4gICAgICAgICAgICAgICAgX2lzb2xhdGU6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvdmVyZmxvd0lzb2xhdGVDb3VudCkge1xuICAgICAgICAgICAgICBvdmVyZmxvd0VtYmVkZGluZ0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXhwbGljaXQgT3ZlcnJpZGVzOiAzLjMuMiBYNCAtIFg1XG4gICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiAoVFlQRV9STE8gfCBUWVBFX0xSTykpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7IC8vIDUuMlxuICAgICAgICAgICAgdmFyIGxldmVsJDEgPSAoY2hhclR5cGUgPT09IFRZUEVfUkxPID8gbmV4dE9kZCA6IG5leHRFdmVuKShzdGFja1RvcC5fbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGxldmVsJDEgPD0gTUFYX0RFUFRIICYmICFvdmVyZmxvd0lzb2xhdGVDb3VudCAmJiAhb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCkge1xuICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICBfbGV2ZWw6IGxldmVsJDEsXG4gICAgICAgICAgICAgICAgX292ZXJyaWRlOiAoY2hhclR5cGUgJiBUWVBFX1JMTykgPyBUWVBFX1IgOiBUWVBFX0wsXG4gICAgICAgICAgICAgICAgX2lzb2xhdGU6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvdmVyZmxvd0lzb2xhdGVDb3VudCkge1xuICAgICAgICAgICAgICBvdmVyZmxvd0VtYmVkZGluZ0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSXNvbGF0ZXM6IDMuMy4yIFg1YSAtIFg1Y1xuICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgSVNPTEFURV9JTklUX1RZUEVTKSB7XG4gICAgICAgICAgICAvLyBYNWMgLSBGU0kgYmVjb21lcyBlaXRoZXIgUkxJIG9yIExSSVxuICAgICAgICAgICAgaWYgKGNoYXJUeXBlICYgVFlQRV9GU0kpIHtcbiAgICAgICAgICAgICAgY2hhclR5cGUgPSBkZXRlcm1pbmVBdXRvRW1iZWRMZXZlbChpJDIgKyAxLCB0cnVlKSA9PT0gMSA/IFRZUEVfUkxJIDogVFlQRV9MUkk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7XG4gICAgICAgICAgICBpZiAoc3RhY2tUb3AuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMiwgc3RhY2tUb3AuX292ZXJyaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZXZlbCQyID0gKGNoYXJUeXBlID09PSBUWVBFX1JMSSA/IG5leHRPZGQgOiBuZXh0RXZlbikoc3RhY2tUb3AuX2xldmVsKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCQyIDw9IE1BWF9ERVBUSCAmJiBvdmVyZmxvd0lzb2xhdGVDb3VudCA9PT0gMCAmJiBvdmVyZmxvd0VtYmVkZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhbGlkSXNvbGF0ZUNvdW50Kys7XG4gICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIF9sZXZlbDogbGV2ZWwkMixcbiAgICAgICAgICAgICAgICBfb3ZlcnJpZGU6IDAsXG4gICAgICAgICAgICAgICAgX2lzb2xhdGU6IDEsXG4gICAgICAgICAgICAgICAgX2lzb2xJbml0SW5kZXg6IGkkMlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93SXNvbGF0ZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGVybWluYXRpbmcgSXNvbGF0ZXM6IDMuMy4yIFg2YVxuICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgVFlQRV9QREkpIHtcbiAgICAgICAgICAgIGlmIChvdmVyZmxvd0lzb2xhdGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3dJc29sYXRlQ291bnQtLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsaWRJc29sYXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93RW1iZWRkaW5nQ291bnQgPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAoIXN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdLl9pc29sYXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQWRkIHRvIGlzb2xhdGlvbiBwYWlycyBiaWRpcmVjdGlvbmFsIG1hcHBpbmc6XG4gICAgICAgICAgICAgIHZhciBpc29sSW5pdEluZGV4ID0gc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV0uX2lzb2xJbml0SW5kZXg7XG4gICAgICAgICAgICAgIGlmIChpc29sSW5pdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpc29sYXRpb25QYWlycy5zZXQoaXNvbEluaXRJbmRleCwgaSQyKTtcbiAgICAgICAgICAgICAgICBpc29sYXRpb25QYWlycy5zZXQoaSQyLCBpc29sSW5pdEluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgdmFsaWRJc29sYXRlQ291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrVG9wID0gc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsO1xuICAgICAgICAgICAgaWYgKHN0YWNrVG9wLl9vdmVycmlkZSkge1xuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDIsIHN0YWNrVG9wLl9vdmVycmlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICAvLyBUZXJtaW5hdGluZyBFbWJlZGRpbmdzIGFuZCBPdmVycmlkZXM6IDMuMy4yIFg3XG4gICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBUWVBFX1BERikge1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93SXNvbGF0ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChvdmVyZmxvd0VtYmVkZGluZ0NvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93RW1iZWRkaW5nQ291bnQtLTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghc3RhY2tUb3AuX2lzb2xhdGUgJiYgc3RhdHVzU3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHN0YWNrVG9wID0gc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7IC8vIDUuMlxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEVuZCBvZiBQYXJhZ3JhcGg6IDMuMy4yIFg4XG4gICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBUWVBFX0IpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9uLWZvcm1hdHRpbmcgY2hhcmFjdGVyczogMy4zLjIgWDZcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDtcbiAgICAgICAgICAvLyBOT1RFOiBUaGlzIGV4Y2x1c2lvbiBvZiBCTiBzZWVtcyB0byBnbyBhZ2FpbnN0IHdoYXQgc2VjdGlvbiA1LjIgc2F5cywgYnV0IGlzIHJlcXVpcmVkIGZvciB0ZXN0IHBhc3NhZ2VcbiAgICAgICAgICBpZiAoc3RhY2tUb3AuX292ZXJyaWRlICYmIGNoYXJUeXBlICE9PSBUWVBFX0JOKSB7XG4gICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDIsIHN0YWNrVG9wLl9vdmVycmlkZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vID09PSAzLjMuMyBQcmVwYXJhdGlvbnMgZm9yIEltcGxpY2l0IFByb2Nlc3NpbmcgPT09XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgUkxFLCBMUkUsIFJMTywgTFJPLCBQREYsIGFuZCBCTiBjaGFyYWN0ZXJzOiAzLjMuMyBYOVxuICAgICAgLy8gTm90ZTogRHVlIHRvIHNlY3Rpb24gNS4yLCB3ZSB3b24ndCByZW1vdmUgdGhlbSwgYnV0IHdlJ2xsIHVzZSB0aGUgQk5fTElLRV9UWVBFUyBiaXRzZXQgdG9cbiAgICAgIC8vIGVhc2lseSBpZ25vcmUgdGhlbSBhbGwgZnJvbSBoZXJlIG9uIG91dC5cblxuICAgICAgLy8gMy4zLjMgWDEwXG4gICAgICAvLyBDb21wdXRlIHRoZSBzZXQgb2YgaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZXMgYXMgc3BlY2lmaWVkIGJ5IEJEMTNcbiAgICAgIHZhciBsZXZlbFJ1bnMgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UnVuID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkkMyA9IHBhcmFncmFwaC5zdGFydDsgaSQzIDw9IHBhcmFncmFwaC5lbmQ7IGkkMysrKSB7XG4gICAgICAgIHZhciBjaGFyVHlwZSQxID0gY2hhclR5cGVzW2kkM107XG4gICAgICAgIGlmICghKGNoYXJUeXBlJDEgJiBCTl9MSUtFX1RZUEVTKSkge1xuICAgICAgICAgIHZhciBsdmwgPSBlbWJlZExldmVsc1tpJDNdO1xuICAgICAgICAgIHZhciBpc0lzb2xJbml0ID0gY2hhclR5cGUkMSAmIElTT0xBVEVfSU5JVF9UWVBFUztcbiAgICAgICAgICB2YXIgaXNQREkgPSBjaGFyVHlwZSQxID09PSBUWVBFX1BESTtcbiAgICAgICAgICBpZiAoY3VycmVudFJ1biAmJiBsdmwgPT09IGN1cnJlbnRSdW4uX2xldmVsKSB7XG4gICAgICAgICAgICBjdXJyZW50UnVuLl9lbmQgPSBpJDM7XG4gICAgICAgICAgICBjdXJyZW50UnVuLl9lbmRzV2l0aElzb2xJbml0ID0gaXNJc29sSW5pdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV2ZWxSdW5zLnB1c2goY3VycmVudFJ1biA9IHtcbiAgICAgICAgICAgICAgX3N0YXJ0OiBpJDMsXG4gICAgICAgICAgICAgIF9lbmQ6IGkkMyxcbiAgICAgICAgICAgICAgX2xldmVsOiBsdmwsXG4gICAgICAgICAgICAgIF9zdGFydHNXaXRoUERJOiBpc1BESSxcbiAgICAgICAgICAgICAgX2VuZHNXaXRoSXNvbEluaXQ6IGlzSXNvbEluaXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGlzb2xhdGluZ1J1blNlcXMgPSBbXTsgLy8gW3tzZXFJbmRpY2VzOiBbXSwgc29zVHlwZTogTHxSLCBlb3NUeXBlOiBMfFJ9XVxuICAgICAgZm9yICh2YXIgcnVuSWR4ID0gMDsgcnVuSWR4IDwgbGV2ZWxSdW5zLmxlbmd0aDsgcnVuSWR4KyspIHtcbiAgICAgICAgdmFyIHJ1biA9IGxldmVsUnVuc1tydW5JZHhdO1xuICAgICAgICBpZiAoIXJ1bi5fc3RhcnRzV2l0aFBESSB8fCAocnVuLl9zdGFydHNXaXRoUERJICYmICFpc29sYXRpb25QYWlycy5oYXMocnVuLl9zdGFydCkpKSB7XG4gICAgICAgICAgdmFyIHNlcVJ1bnMgPSBbY3VycmVudFJ1biA9IHJ1bl07XG4gICAgICAgICAgZm9yICh2YXIgcGRpSW5kZXggPSAodm9pZCAwKTsgY3VycmVudFJ1biAmJiBjdXJyZW50UnVuLl9lbmRzV2l0aElzb2xJbml0ICYmIChwZGlJbmRleCA9IGlzb2xhdGlvblBhaXJzLmdldChjdXJyZW50UnVuLl9lbmQpKSAhPSBudWxsOykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ0ID0gcnVuSWR4ICsgMTsgaSQ0IDwgbGV2ZWxSdW5zLmxlbmd0aDsgaSQ0KyspIHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsUnVuc1tpJDRdLl9zdGFydCA9PT0gcGRpSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzZXFSdW5zLnB1c2goY3VycmVudFJ1biA9IGxldmVsUnVuc1tpJDRdKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGJ1aWxkIGZsYXQgbGlzdCBvZiBpbmRpY2VzIGFjcm9zcyBhbGwgcnVuczpcbiAgICAgICAgICB2YXIgc2VxSW5kaWNlcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkkNSA9IDA7IGkkNSA8IHNlcVJ1bnMubGVuZ3RoOyBpJDUrKykge1xuICAgICAgICAgICAgdmFyIHJ1biQxID0gc2VxUnVuc1tpJDVdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJ1biQxLl9zdGFydDsgaiA8PSBydW4kMS5fZW5kOyBqKyspIHtcbiAgICAgICAgICAgICAgc2VxSW5kaWNlcy5wdXNoKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHNvcy9lb3MgdHlwZXM6XG4gICAgICAgICAgdmFyIGZpcnN0TGV2ZWwgPSBlbWJlZExldmVsc1tzZXFJbmRpY2VzWzBdXTtcbiAgICAgICAgICB2YXIgcHJldkxldmVsID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICAgIGZvciAodmFyIGkkNiA9IHNlcUluZGljZXNbMF0gLSAxOyBpJDYgPj0gMDsgaSQ2LS0pIHtcbiAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tpJDZdICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjJcbiAgICAgICAgICAgICAgcHJldkxldmVsID0gZW1iZWRMZXZlbHNbaSQ2XTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxhc3RJbmRleCA9IHNlcUluZGljZXNbc2VxSW5kaWNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgbGFzdExldmVsID0gZW1iZWRMZXZlbHNbbGFzdEluZGV4XTtcbiAgICAgICAgICB2YXIgbmV4dExldmVsID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tsYXN0SW5kZXhdICYgSVNPTEFURV9JTklUX1RZUEVTKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ3ID0gbGFzdEluZGV4ICsgMTsgaSQ3IDw9IHBhcmFncmFwaC5lbmQ7IGkkNysrKSB7XG4gICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tpJDddICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjJcbiAgICAgICAgICAgICAgICBuZXh0TGV2ZWwgPSBlbWJlZExldmVsc1tpJDddO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNvbGF0aW5nUnVuU2Vxcy5wdXNoKHtcbiAgICAgICAgICAgIF9zZXFJbmRpY2VzOiBzZXFJbmRpY2VzLFxuICAgICAgICAgICAgX3Nvc1R5cGU6IE1hdGgubWF4KHByZXZMZXZlbCwgZmlyc3RMZXZlbCkgJSAyID8gVFlQRV9SIDogVFlQRV9MLFxuICAgICAgICAgICAgX2Vvc1R5cGU6IE1hdGgubWF4KG5leHRMZXZlbCwgbGFzdExldmVsKSAlIDIgPyBUWVBFX1IgOiBUWVBFX0xcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbmV4dCBzdGVwcyBhcmUgZG9uZSBwZXIgaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZVxuICAgICAgZm9yICh2YXIgc2VxSWR4ID0gMDsgc2VxSWR4IDwgaXNvbGF0aW5nUnVuU2Vxcy5sZW5ndGg7IHNlcUlkeCsrKSB7XG4gICAgICAgIHZhciByZWYgPSBpc29sYXRpbmdSdW5TZXFzW3NlcUlkeF07XG4gICAgICAgIHZhciBzZXFJbmRpY2VzJDEgPSByZWYuX3NlcUluZGljZXM7XG4gICAgICAgIHZhciBzb3NUeXBlID0gcmVmLl9zb3NUeXBlO1xuICAgICAgICB2YXIgZW9zVHlwZSA9IHJlZi5fZW9zVHlwZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCB0aGUgbGV2ZWwgcnVucyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlIGhhdmUgdGhlIHNhbWUgZW1iZWRkaW5nIGxldmVsLlxuICAgICAgICAgKiBcbiAgICAgICAgICogRE8gTk9UIGNoYW5nZSBhbnkgYGVtYmVkTGV2ZWxzW2ldYCB3aXRoaW4gdGhlIGN1cnJlbnQgc2NvcGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZW1iZWREaXJlY3Rpb24gPSAoKGVtYmVkTGV2ZWxzW3NlcUluZGljZXMkMVswXV0pICYgMSkgPyBUWVBFX1IgOiBUWVBFX0w7XG5cbiAgICAgICAgLy8gPT09IDMuMy40IFJlc29sdmluZyBXZWFrIFR5cGVzID09PVxuXG4gICAgICAgIC8vIFcxICsgNS4yLiBTZWFyY2ggYmFja3dhcmQgZnJvbSBlYWNoIE5TTSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBpc29sYXRpbmcgcnVuIHNlcXVlbmNlIHdob3NlXG4gICAgICAgIC8vIGJpZGlyZWN0aW9uYWwgdHlwZSBpcyBub3QgQk4sIGFuZCBzZXQgdGhlIE5TTSB0byBPTiBpZiBpdCBpcyBhbiBpc29sYXRlIGluaXRpYXRvciBvciBQREksIGFuZCB0byBpdHNcbiAgICAgICAgLy8gdHlwZSBvdGhlcndpc2UuIElmIHRoZSBOU00gaXMgdGhlIGZpcnN0IG5vbi1CTiBjaGFyYWN0ZXIsIGNoYW5nZSB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHNvcy5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX05TTSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2krKykge1xuICAgICAgICAgICAgdmFyIGkkOCA9IHNlcUluZGljZXMkMVtzaV07XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkOF0gJiBUWVBFX05TTSkge1xuICAgICAgICAgICAgICB2YXIgcHJldlR5cGUgPSBzb3NUeXBlO1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaiA9IHNpIC0gMTsgc2ogPj0gMDsgc2otLSkge1xuICAgICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2pdXSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yIHNjYW4gYmFjayB0byBmaXJzdCBub24tQk5cbiAgICAgICAgICAgICAgICAgIHByZXZUeXBlID0gY2hhclR5cGVzW3NlcUluZGljZXMkMVtzal1dO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQ4LCAocHJldlR5cGUgJiAoSVNPTEFURV9JTklUX1RZUEVTIHwgVFlQRV9QREkpKSA/IFRZUEVfT04gOiBwcmV2VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzIuIFNlYXJjaCBiYWNrd2FyZCBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXIgdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29zKVxuICAgICAgICAvLyBpcyBmb3VuZC4gSWYgYW4gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpYyBudW1iZXIuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FTikpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQxID0gMDsgc2kkMSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDErKykge1xuICAgICAgICAgICAgdmFyIGkkOSA9IHNlcUluZGljZXMkMVtzaSQxXTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQ5XSAmIFRZUEVfRU4pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okMSA9IHNpJDEgLSAxOyBzaiQxID49IC0xOyBzaiQxLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldkNoYXJUeXBlID0gc2okMSA9PT0gLTEgPyBzb3NUeXBlIDogY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQxXV07XG4gICAgICAgICAgICAgICAgaWYgKHByZXZDaGFyVHlwZSAmIFNUUk9OR19UWVBFUykge1xuICAgICAgICAgICAgICAgICAgaWYgKHByZXZDaGFyVHlwZSA9PT0gVFlQRV9BTCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDksIFRZUEVfQU4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfQUwpKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkMiA9IDA7IHNpJDIgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQyKyspIHtcbiAgICAgICAgICAgIHZhciBpJDEwID0gc2VxSW5kaWNlcyQxW3NpJDJdO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDEwXSAmIFRZUEVfQUwpIHtcbiAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQxMCwgVFlQRV9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXNC4gQSBzaW5nbGUgRXVyb3BlYW4gc2VwYXJhdG9yIGJldHdlZW4gdHdvIEV1cm9wZWFuIG51bWJlcnMgY2hhbmdlcyB0byBhIEV1cm9wZWFuIG51bWJlci4gQSBzaW5nbGUgY29tbW9uXG4gICAgICAgIC8vIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBudW1iZXJzIG9mIHRoZSBzYW1lIHR5cGUgY2hhbmdlcyB0byB0aGF0IHR5cGUuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FUykgfHwgY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfQ1MpKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkMyA9IDE7IHNpJDMgPCBzZXFJbmRpY2VzJDEubGVuZ3RoIC0gMTsgc2kkMysrKSB7XG4gICAgICAgICAgICB2YXIgaSQxMSA9IHNlcUluZGljZXMkMVtzaSQzXTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxMV0gJiAoVFlQRV9FUyB8IFRZUEVfQ1MpKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2VHlwZSQxID0gMCwgbmV4dFR5cGUgPSAwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQyID0gc2kkMyAtIDE7IHNqJDIgPj0gMDsgc2okMi0tKSB7XG4gICAgICAgICAgICAgICAgcHJldlR5cGUkMSA9IGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okMl1dO1xuICAgICAgICAgICAgICAgIGlmICghKHByZXZUeXBlJDEgJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMlxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okMyA9IHNpJDMgKyAxOyBzaiQzIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2okMysrKSB7XG4gICAgICAgICAgICAgICAgbmV4dFR5cGUgPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDNdXTtcbiAgICAgICAgICAgICAgICBpZiAoIShuZXh0VHlwZSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocHJldlR5cGUkMSA9PT0gbmV4dFR5cGUgJiYgKGNoYXJUeXBlc1tpJDExXSA9PT0gVFlQRV9FUyA/IHByZXZUeXBlJDEgPT09IFRZUEVfRU4gOiAocHJldlR5cGUkMSAmIChUWVBFX0VOIHwgVFlQRV9BTikpKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMTEsIHByZXZUeXBlJDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW4gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRU4pKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkNCA9IDA7IHNpJDQgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQ0KyspIHtcbiAgICAgICAgICAgIHZhciBpJDEyID0gc2VxSW5kaWNlcyQxW3NpJDRdO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDEyXSAmIFRZUEVfRU4pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okNCA9IHNpJDQgLSAxOyBzaiQ0ID49IDAgJiYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okNF1dICYgKFRZUEVfRVQgfCBCTl9MSUtFX1RZUEVTKSk7IHNqJDQtLSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKHNlcUluZGljZXMkMVtzaiQ0XSwgVFlQRV9FTik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChzaSQ0Kys7IHNpJDQgPCBzZXFJbmRpY2VzJDEubGVuZ3RoICYmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDRdXSAmIChUWVBFX0VUIHwgQk5fTElLRV9UWVBFUyB8IFRZUEVfRU4pKTsgc2kkNCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkNF1dICE9PSBUWVBFX0VOKSB7XG4gICAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShzZXFJbmRpY2VzJDFbc2kkNF0sIFRZUEVfRU4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlciBOZXV0cmFsLlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRVQpIHx8IGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VTKSB8fCBjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9DUykpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQ1ID0gMDsgc2kkNSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDUrKykge1xuICAgICAgICAgICAgdmFyIGkkMTMgPSBzZXFJbmRpY2VzJDFbc2kkNV07XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTNdICYgKFRZUEVfRVQgfCBUWVBFX0VTIHwgVFlQRV9DUykpIHtcbiAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQxMywgVFlQRV9PTik7XG4gICAgICAgICAgICAgIC8vIDUuMiB0cmFuc2Zvcm0gYWRqYWNlbnQgQk5zIHRvbzpcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okNSA9IHNpJDUgLSAxOyBzaiQ1ID49IDAgJiYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okNV1dICYgQk5fTElLRV9UWVBFUyk7IHNqJDUtLSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKHNlcUluZGljZXMkMVtzaiQ1XSwgVFlQRV9PTik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okNiA9IHNpJDUgKyAxOyBzaiQ2IDwgc2VxSW5kaWNlcyQxLmxlbmd0aCAmJiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQ2XV0gJiBCTl9MSUtFX1RZUEVTKTsgc2okNisrKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NqJDZdLCBUWVBFX09OKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmQgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29zKVxuICAgICAgICAvLyBpcyBmb3VuZC4gSWYgYW4gTCBpcyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgICAvLyBOT1RFOiBpbXBsZW1lbnRlZCBpbiBzaW5nbGUgZm9yd2FyZCBwYXNzIGZvciBlZmZpY2llbmN5XG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FTikpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQ2ID0gMCwgcHJldlN0cm9uZ1R5cGUgPSBzb3NUeXBlOyBzaSQ2IDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkNisrKSB7XG4gICAgICAgICAgICB2YXIgaSQxNCA9IHNlcUluZGljZXMkMVtzaSQ2XTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gY2hhclR5cGVzW2kkMTRdO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiBUWVBFX0VOKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2U3Ryb25nVHlwZSA9PT0gVFlQRV9MKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQxNCwgVFlQRV9MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlICYgU1RST05HX1RZUEVTKSB7XG4gICAgICAgICAgICAgIHByZXZTdHJvbmdUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA9PT0gMy4zLjUgUmVzb2x2aW5nIE5ldXRyYWwgYW5kIElzb2xhdGUgRm9ybWF0dGluZyBUeXBlcyA9PT1cblxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUykpIHtcbiAgICAgICAgICAvLyBOMC4gUHJvY2VzcyBicmFja2V0IHBhaXJzIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2Ugc2VxdWVudGlhbGx5IGluIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSB0ZXh0XG4gICAgICAgICAgLy8gcG9zaXRpb25zIG9mIHRoZSBvcGVuaW5nIHBhaXJlZCBicmFja2V0cyB1c2luZyB0aGUgbG9naWMgZ2l2ZW4gYmVsb3cuIFdpdGhpbiB0aGlzIHNjb3BlLCBiaWRpcmVjdGlvbmFsXG4gICAgICAgICAgLy8gdHlwZXMgRU4gYW5kIEFOIGFyZSB0cmVhdGVkIGFzIFIuXG4gICAgICAgICAgdmFyIFJfVFlQRVNfRk9SX05fU1RFUFMgPSAoVFlQRV9SIHwgVFlQRV9FTiB8IFRZUEVfQU4pO1xuICAgICAgICAgIHZhciBTVFJPTkdfVFlQRVNfRk9SX05fU1RFUFMgPSBSX1RZUEVTX0ZPUl9OX1NURVBTIHwgVFlQRV9MO1xuXG4gICAgICAgICAgLy8gKiBJZGVudGlmeSB0aGUgYnJhY2tldCBwYWlycyBpbiB0aGUgY3VycmVudCBpc29sYXRpbmcgcnVuIHNlcXVlbmNlIGFjY29yZGluZyB0byBCRDE2LlxuICAgICAgICAgIHZhciBicmFja2V0UGFpcnMgPSBbXTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb3BlbmVyU3RhY2sgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHNpJDcgPSAwOyBzaSQ3IDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkNysrKSB7XG4gICAgICAgICAgICAgIC8vIE5PVEU6IGZvciBhbnkgcG90ZW50aWFsIGJyYWNrZXQgY2hhcmFjdGVyIHdlIGFsc28gdGVzdCB0aGF0IGl0IHN0aWxsIGNhcnJpZXMgYSBOSVxuICAgICAgICAgICAgICAvLyB0eXBlLCBhcyB0aGF0IG1heSBoYXZlIGJlZW4gY2hhbmdlZCBlYXJsaWVyLiBUaGlzIGRvZXNuJ3Qgc2VlbSB0byBiZSBleHBsaWNpdGx5XG4gICAgICAgICAgICAgIC8vIGNhbGxlZCBvdXQgaW4gdGhlIHNwZWMsIGJ1dCBpcyByZXF1aXJlZCBmb3IgcGFzc2FnZSBvZiBjZXJ0YWluIHRlc3RzLlxuICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQ3XV0gJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhciA9IHN0cmluZ1tzZXFJbmRpY2VzJDFbc2kkN11dO1xuICAgICAgICAgICAgICAgIHZhciBvcHBvc2l0ZUJyYWNrZXQgPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAvLyBPcGVuaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICBpZiAob3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQoY2hhcikgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXJTdGFjay5sZW5ndGggPCA2Mykge1xuICAgICAgICAgICAgICAgICAgICBvcGVuZXJTdGFjay5wdXNoKHsgY2hhcjogY2hhciwgc2VxSW5kZXg6IHNpJDcgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgob3Bwb3NpdGVCcmFja2V0ID0gY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQoY2hhcikpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBzdGFja0lkeCA9IG9wZW5lclN0YWNrLmxlbmd0aCAtIDE7IHN0YWNrSWR4ID49IDA7IHN0YWNrSWR4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrQ2hhciA9IG9wZW5lclN0YWNrW3N0YWNrSWR4XS5jaGFyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2tDaGFyID09PSBvcHBvc2l0ZUJyYWNrZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFja0NoYXIgPT09IGNsb3NpbmdUb09wZW5pbmdCcmFja2V0KGdldENhbm9uaWNhbEJyYWNrZXQoY2hhcikpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgb3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQoZ2V0Q2Fub25pY2FsQnJhY2tldChzdGFja0NoYXIpKSA9PT0gY2hhclxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmFja2V0UGFpcnMucHVzaChbb3BlbmVyU3RhY2tbc3RhY2tJZHhdLnNlcUluZGV4LCBzaSQ3XSk7XG4gICAgICAgICAgICAgICAgICAgICAgb3BlbmVyU3RhY2subGVuZ3RoID0gc3RhY2tJZHg7IC8vcG9wIHRoZSBtYXRjaGluZyBicmFja2V0IGFuZCBhbGwgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJhY2tldFBhaXJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gKiBGb3IgZWFjaCBicmFja2V0LXBhaXIgZWxlbWVudCBpbiB0aGUgbGlzdCBvZiBwYWlycyBvZiB0ZXh0IHBvc2l0aW9uc1xuICAgICAgICAgIGZvciAodmFyIHBhaXJJZHggPSAwOyBwYWlySWR4IDwgYnJhY2tldFBhaXJzLmxlbmd0aDsgcGFpcklkeCsrKSB7XG4gICAgICAgICAgICB2YXIgcmVmJDEgPSBicmFja2V0UGFpcnNbcGFpcklkeF07XG4gICAgICAgICAgICB2YXIgb3BlblNlcUlkeCA9IHJlZiQxWzBdO1xuICAgICAgICAgICAgdmFyIGNsb3NlU2VxSWR4ID0gcmVmJDFbMV07XG4gICAgICAgICAgICAvLyBhLiBJbnNwZWN0IHRoZSBiaWRpcmVjdGlvbmFsIHR5cGVzIG9mIHRoZSBjaGFyYWN0ZXJzIGVuY2xvc2VkIHdpdGhpbiB0aGUgYnJhY2tldCBwYWlyLlxuICAgICAgICAgICAgLy8gYi4gSWYgYW55IHN0cm9uZyB0eXBlIChlaXRoZXIgTCBvciBSKSBtYXRjaGluZyB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbiBpcyBmb3VuZCwgc2V0IHRoZSB0eXBlIGZvciBib3RoXG4gICAgICAgICAgICAvLyBicmFja2V0cyBpbiB0aGUgcGFpciB0byBtYXRjaCB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgICAgIHZhciBmb3VuZFN0cm9uZ1R5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB1c2VTdHJvbmdUeXBlID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHNpJDggPSBvcGVuU2VxSWR4ICsgMTsgc2kkOCA8IGNsb3NlU2VxSWR4OyBzaSQ4KyspIHtcbiAgICAgICAgICAgICAgdmFyIGkkMTUgPSBzZXFJbmRpY2VzJDFbc2kkOF07XG4gICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxNV0gJiBTVFJPTkdfVFlQRVNfRk9SX05fU1RFUFMpIHtcbiAgICAgICAgICAgICAgICBmb3VuZFN0cm9uZ1R5cGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBsciA9IChjaGFyVHlwZXNbaSQxNV0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTDtcbiAgICAgICAgICAgICAgICBpZiAobHIgPT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB1c2VTdHJvbmdUeXBlID0gbHI7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYy4gT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBhIHN0cm9uZyB0eXBlIGl0IG11c3QgYmUgb3Bwb3NpdGUgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uIFRoZXJlZm9yZSwgdGVzdFxuICAgICAgICAgICAgLy8gZm9yIGFuIGVzdGFibGlzaGVkIGNvbnRleHQgd2l0aCBhIHByZWNlZGluZyBzdHJvbmcgdHlwZSBieSBjaGVja2luZyBiYWNrd2FyZHMgYmVmb3JlIHRoZSBvcGVuaW5nIHBhaXJlZFxuICAgICAgICAgICAgLy8gYnJhY2tldCB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKEwsIFIsIG9yIHNvcykgaXMgZm91bmQuXG4gICAgICAgICAgICAvLyAgICAxLiBJZiB0aGUgcHJlY2VkaW5nIHN0cm9uZyB0eXBlIGlzIGFsc28gb3Bwb3NpdGUgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24sIGNvbnRleHQgaXMgZXN0YWJsaXNoZWQsIHNvXG4gICAgICAgICAgICAvLyAgICBzZXQgdGhlIHR5cGUgZm9yIGJvdGggYnJhY2tldHMgaW4gdGhlIHBhaXIgdG8gdGhhdCBkaXJlY3Rpb24uXG4gICAgICAgICAgICAvLyAgICAyLiBPdGhlcndpc2Ugc2V0IHRoZSB0eXBlIGZvciBib3RoIGJyYWNrZXRzIGluIHRoZSBwYWlyIHRvIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGZvdW5kU3Ryb25nVHlwZSAmJiAhdXNlU3Ryb25nVHlwZSkge1xuICAgICAgICAgICAgICB1c2VTdHJvbmdUeXBlID0gc29zVHlwZTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2kkOSA9IG9wZW5TZXFJZHggLSAxOyBzaSQ5ID49IDA7IHNpJDktLSkge1xuICAgICAgICAgICAgICAgIHZhciBpJDE2ID0gc2VxSW5kaWNlcyQxW3NpJDldO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxNl0gJiBTVFJPTkdfVFlQRVNfRk9SX05fU1RFUFMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBsciQxID0gKGNoYXJUeXBlc1tpJDE2XSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MO1xuICAgICAgICAgICAgICAgICAgaWYgKGxyJDEgIT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZVN0cm9uZ1R5cGUgPSBsciQxO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlU3Ryb25nVHlwZSA9IGVtYmVkRGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VTdHJvbmdUeXBlKSB7XG4gICAgICAgICAgICAgIGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbb3BlblNlcUlkeF1dID0gY2hhclR5cGVzW3NlcUluZGljZXMkMVtjbG9zZVNlcUlkeF1dID0gdXNlU3Ryb25nVHlwZTtcbiAgICAgICAgICAgICAgLy8gKiBBbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBoYWQgb3JpZ2luYWwgYmlkaXJlY3Rpb25hbCBjaGFyYWN0ZXIgdHlwZSBOU00gcHJpb3IgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgICAgICAgIC8vIG9mIFcxIHRoYXQgaW1tZWRpYXRlbHkgZm9sbG93IGEgcGFpcmVkIGJyYWNrZXQgd2hpY2ggY2hhbmdlZCB0byBMIG9yIFIgdW5kZXIgTjAgc2hvdWxkIGNoYW5nZSB0byBtYXRjaFxuICAgICAgICAgICAgICAvLyB0aGUgdHlwZSBvZiB0aGVpciBwcmVjZWRpbmcgYnJhY2tldC5cbiAgICAgICAgICAgICAgaWYgKHVzZVN0cm9uZ1R5cGUgIT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kkMTAgPSBvcGVuU2VxSWR4ICsgMTsgc2kkMTAgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxMCsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDEwXV0gJiBCTl9MSUtFX1RZUEVTKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tzZXFJbmRpY2VzJDFbc2kkMTBdXSkgJiBUWVBFX05TTSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTBdXSA9IHVzZVN0cm9uZ1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHVzZVN0cm9uZ1R5cGUgIT09IGVtYmVkRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kkMTEgPSBjbG9zZVNlcUlkeCArIDE7IHNpJDExIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMTErKykge1xuICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQxMV1dICYgQk5fTElLRV9UWVBFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEJpZGlDaGFyVHlwZShzdHJpbmdbc2VxSW5kaWNlcyQxW3NpJDExXV0pICYgVFlQRV9OU00pIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDExXV0gPSB1c2VTdHJvbmdUeXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgTklzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHN1cnJvdW5kaW5nIHN0cm9uZyB0ZXh0IGlmIHRoZSB0ZXh0IG9uIGJvdGggc2lkZXMgaGFzIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZGlyZWN0aW9uLlxuICAgICAgICAgIC8vIE4yLiBBbnkgcmVtYWluaW5nIE5JcyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgIGZvciAodmFyIHNpJDEyID0gMDsgc2kkMTIgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxMisrKSB7XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQxMl1dICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgICAgICAgIHZhciBuaVJ1blN0YXJ0ID0gc2kkMTIsIG5pUnVuRW5kID0gc2kkMTI7XG4gICAgICAgICAgICAgIHZhciBwcmV2VHlwZSQyID0gc29zVHlwZTsgLy9zaSA9PT0gMCA/IHNvc1R5cGUgOiAoY2hhclR5cGVzW3NlcUluZGljZXNbc2kgLSAxXV0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTFxuICAgICAgICAgICAgICBmb3IgKHZhciBzaTIgPSBzaSQxMiAtIDE7IHNpMiA+PSAwOyBzaTItLSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpMl1dICYgQk5fTElLRV9UWVBFUykge1xuICAgICAgICAgICAgICAgICAgbmlSdW5TdGFydCA9IHNpMjsgLy81LjIgdHJlYXQgQk5zIGFkamFjZW50IHRvIE5JcyBhcyBOSXNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJldlR5cGUkMiA9IChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpMl1dICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0w7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmV4dFR5cGUkMSA9IGVvc1R5cGU7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNpMiQxID0gc2kkMTIgKyAxOyBzaTIkMSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpMiQxKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaTIkMV1dICYgKE5FVVRSQUxfSVNPTEFURV9UWVBFUyB8IEJOX0xJS0VfVFlQRVMpKSB7XG4gICAgICAgICAgICAgICAgICBuaVJ1bkVuZCA9IHNpMiQxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXh0VHlwZSQxID0gKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kyJDFdXSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okNyA9IG5pUnVuU3RhcnQ7IHNqJDcgPD0gbmlSdW5FbmQ7IHNqJDcrKykge1xuICAgICAgICAgICAgICAgIGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okN11dID0gcHJldlR5cGUkMiA9PT0gbmV4dFR5cGUkMSA/IHByZXZUeXBlJDIgOiBlbWJlZERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzaSQxMiA9IG5pUnVuRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA9PT0gMy4zLjYgUmVzb2x2aW5nIEltcGxpY2l0IExldmVscyA9PT1cblxuICAgICAgZm9yICh2YXIgaSQxNyA9IHBhcmFncmFwaC5zdGFydDsgaSQxNyA8PSBwYXJhZ3JhcGguZW5kOyBpJDE3KyspIHtcbiAgICAgICAgdmFyIGxldmVsJDMgPSBlbWJlZExldmVsc1tpJDE3XTtcbiAgICAgICAgdmFyIHR5cGUkMSA9IGNoYXJUeXBlc1tpJDE3XTtcbiAgICAgICAgLy8gSTIuIEZvciBhbGwgY2hhcmFjdGVycyB3aXRoIGFuIG9kZCAocmlnaHQtdG8tbGVmdCkgZW1iZWRkaW5nIGxldmVsLCB0aG9zZSBvZiB0eXBlIEwsIEVOIG9yIEFOIGdvIHVwIG9uZSBsZXZlbC5cbiAgICAgICAgaWYgKGxldmVsJDMgJiAxKSB7XG4gICAgICAgICAgaWYgKHR5cGUkMSAmIChUWVBFX0wgfCBUWVBFX0VOIHwgVFlQRV9BTikpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICAgLy8gSTEuIEZvciBhbGwgY2hhcmFjdGVycyB3aXRoIGFuIGV2ZW4gKGxlZnQtdG8tcmlnaHQpIGVtYmVkZGluZyBsZXZlbCwgdGhvc2Ugb2YgdHlwZSBSIGdvIHVwIG9uZSBsZXZlbFxuICAgICAgICAvLyBhbmQgdGhvc2Ugb2YgdHlwZSBBTiBvciBFTiBnbyB1cCB0d28gbGV2ZWxzLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZSQxICYgVFlQRV9SKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDE3XSsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSQxICYgKFRZUEVfQU4gfCBUWVBFX0VOKSkge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQxN10gKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LjI6IFJlc29sdmUgYW55IExSRSwgUkxFLCBMUk8sIFJMTywgUERGLCBvciBCTiB0byB0aGUgbGV2ZWwgb2YgdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIgaWYgdGhlcmUgaXMgb25lLFxuICAgICAgICAvLyBhbmQgb3RoZXJ3aXNlIHRvIHRoZSBiYXNlIGxldmVsLlxuICAgICAgICBpZiAodHlwZSQxICYgQk5fTElLRV9UWVBFUykge1xuICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddID0gaSQxNyA9PT0gMCA/IHBhcmFncmFwaC5sZXZlbCA6IGVtYmVkTGV2ZWxzW2kkMTcgLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuNCBMMS4xLTQ6IFJlc2V0IHRoZSBlbWJlZGRpbmcgbGV2ZWwgb2Ygc2VnbWVudC9wYXJhZ3JhcGggc2VwYXJhdG9ycywgYW5kIGFueSBzZXF1ZW5jZSBvZiB3aGl0ZXNwYWNlIG9yXG4gICAgICAgIC8vIGlzb2xhdGUgZm9ybWF0dGluZyBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGVtIG9yIHRoZSBlbmQgb2YgdGhlIHBhcmFncmFwaCwgdG8gdGhlIHBhcmFncmFwaCBsZXZlbC5cbiAgICAgICAgLy8gTk9URTogdGhpcyB3aWxsIGFsc28gbmVlZCB0byBiZSBhcHBsaWVkIHRvIGVhY2ggaW5kaXZpZHVhbCBsaW5lIGVuZGluZyBhZnRlciBsaW5lIHdyYXBwaW5nIG9jY3Vycy5cbiAgICAgICAgaWYgKGkkMTcgPT09IHBhcmFncmFwaC5lbmQgfHwgZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tpJDE3XSkgJiAoVFlQRV9TIHwgVFlQRV9CKSkge1xuICAgICAgICAgIGZvciAodmFyIGokMSA9IGkkMTc7IGokMSA+PSAwICYmIChnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW2okMV0pICYgVFJBSUxJTkdfVFlQRVMpOyBqJDEtLSkge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaiQxXSA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBET05FISBUaGUgcmVzb2x2ZWQgbGV2ZWxzIGNhbiB0aGVuIGJlIHVzZWQsIGFmdGVyIGxpbmUgd3JhcHBpbmcsIHRvIGZsaXAgcnVucyBvZiBjaGFyYWN0ZXJzXG4gICAgLy8gYWNjb3JkaW5nIHRvIHNlY3Rpb24gMy40IFJlb3JkZXJpbmcgUmVzb2x2ZWQgTGV2ZWxzXG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsczogZW1iZWRMZXZlbHMsXG4gICAgICBwYXJhZ3JhcGhzOiBwYXJhZ3JhcGhzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lQXV0b0VtYmVkTGV2ZWwgKHN0YXJ0LCBpc0ZTSSkge1xuICAgICAgLy8gMy4zLjEgUDIgLSBQM1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyVHlwZSA9IGNoYXJUeXBlc1tpXTtcbiAgICAgICAgaWYgKGNoYXJUeXBlICYgKFRZUEVfUiB8IFRZUEVfQUwpKSB7XG4gICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGNoYXJUeXBlICYgKFRZUEVfQiB8IFRZUEVfTCkpIHx8IChpc0ZTSSAmJiBjaGFyVHlwZSA9PT0gVFlQRV9QREkpKSB7XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhclR5cGUgJiBJU09MQVRFX0lOSVRfVFlQRVMpIHtcbiAgICAgICAgICB2YXIgcGRpID0gaW5kZXhPZk1hdGNoaW5nUERJKGkpO1xuICAgICAgICAgIGkgPSBwZGkgPT09IC0xID8gc3RyaW5nLmxlbmd0aCA6IHBkaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRleE9mTWF0Y2hpbmdQREkgKGlzb2xhdGVTdGFydCkge1xuICAgICAgLy8gMy4xLjIgQkQ5XG4gICAgICB2YXIgaXNvbGF0aW9uTGV2ZWwgPSAxO1xuICAgICAgZm9yICh2YXIgaSA9IGlzb2xhdGVTdGFydCArIDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJUeXBlID0gY2hhclR5cGVzW2ldO1xuICAgICAgICBpZiAoY2hhclR5cGUgJiBUWVBFX0IpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyVHlwZSAmIFRZUEVfUERJKSB7XG4gICAgICAgICAgaWYgKC0taXNvbGF0aW9uTGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJUeXBlICYgSVNPTEFURV9JTklUX1RZUEVTKSB7XG4gICAgICAgICAgaXNvbGF0aW9uTGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICB9XG5cbiAgLy8gQmlkaSBtaXJyb3JlZCBjaGFycyBkYXRhLCBhdXRvIGdlbmVyYXRlZFxuICB2YXIgZGF0YSA9IFwiMTQ+MSxqPjIsdD4yLHU+MiwxYT5nLDJ2Mz4xLDE+MSwxZ2U+MSwxd2Q+MSxiPjEsMWo+MSxmPjEsYWk+MywtMj4zLCsxLDg+MWswLC0xanE+MXk3LC0xeTY+MWhmLC0xaGU+MWg2LC0xaDU+MWhhLC0xaDg+MXFpLC0xcHU+MSw2PjN1LC0zcz43LDY+MSwxPjEsZj4xLDE+MSwrMiwzPjEsMT4xLCsxMyw0PjEsMT4xLDY+MWVvLC0xZWU+MSwzPjFtZywtMW1lPjFtaywtMW1qPjFtaSwtMW1nPjFtaSwtMW1kPjEsMT4xLCsyLDE+MTBrLC0xMDM+MSwxPjEsND4xLDU+MSwxPjEsKzEwLDM+MSwxPjgsLTc+OCwrMSwtNj43LCsxLGE+MSwxPjEsdT4xLHU2PjEsMT4xLCs1LDI2PjEsMT4xLDI+MSwyPjIsOD4xLDc+MSw0PjEsMT4xLCs1LGI4PjEsMT4xLCszLDE+MywtMj4xLDI+MSwxPjEsKzIsYz4xLDM+MSwxPjEsKzIsaD4xLDM+MSxhPjEsMT4xLDI+MSwzPjEsMT4xLGQ+MSxmPjEsMz4xLDFhPjEsMT4xLDY+MSw3PjEsMTM+MSxrPjEsMT4xLCsxOSw0PjEsMT4xLCsyLDI+MSwxPjEsKzE4LG0+MSxhPjEsMT4xLGxrPjEsMT4xLDQ+MSwyPjEsZj4xLDM+MSwxPjEsKzMsZGI+MSwxPjEsKzMsMz4xLDE+MSwrMiwxNHFtPjEsMT4xLCsxLDY+MSw0aj4xLGo+Mix0PjIsdT4yLDI+MSwrMVwiO1xuXG4gIHZhciBtaXJyb3JNYXA7XG5cbiAgZnVuY3Rpb24gcGFyc2UgKCkge1xuICAgIGlmICghbWlycm9yTWFwKSB7XG4gICAgICAvL2NvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIHZhciByZWYgPSBwYXJzZUNoYXJhY3Rlck1hcChkYXRhLCB0cnVlKTtcbiAgICAgIHZhciBtYXAgPSByZWYubWFwO1xuICAgICAgdmFyIHJldmVyc2VNYXAgPSByZWYucmV2ZXJzZU1hcDtcbiAgICAgIC8vIENvbWJpbmUgYm90aCBtYXBzIGludG8gb25lXG4gICAgICByZXZlcnNlTWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgbWlycm9yTWFwID0gbWFwO1xuICAgICAgLy9jb25zb2xlLmxvZyhgbWlycm9yZWQgY2hhcnMgcGFyc2VkIGluICR7cGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydH1tc2ApXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWlycm9yZWRDaGFyYWN0ZXIgKGNoYXIpIHtcbiAgICBwYXJzZSgpO1xuICAgIHJldHVybiBtaXJyb3JNYXAuZ2V0KGNoYXIpIHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHN0cmluZyBhbmQgaXRzIHJlc29sdmVkIGVtYmVkZGluZyBsZXZlbHMsIGJ1aWxkIGEgbWFwIG9mIGluZGljZXMgdG8gcmVwbGFjZW1lbnQgY2hhcnNcbiAgICogZm9yIGFueSBjaGFyYWN0ZXJzIGluIHJpZ2h0LXRvLWxlZnQgc2VnbWVudHMgdGhhdCBoYXZlIGRlZmluZWQgbWlycm9yZWQgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIHN0cmluZ1xuICAgKiBAcGFyYW0gZW1iZWRkaW5nTGV2ZWxzXG4gICAqIEBwYXJhbSBbc3RhcnRdXG4gICAqIEBwYXJhbSBbZW5kXVxuICAgKiBAcmV0dXJuIHtNYXA8bnVtYmVyLCBzdHJpbmc+fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TWlycm9yZWRDaGFyYWN0ZXJzTWFwKHN0cmluZywgZW1iZWRkaW5nTGV2ZWxzLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCA9PSBudWxsID8gMCA6ICtzdGFydCk7XG4gICAgZW5kID0gTWF0aC5taW4oc3RyTGVuIC0gMSwgZW5kID09IG51bGwgPyBzdHJMZW4gLSAxIDogK2VuZCk7XG5cbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgaWYgKGVtYmVkZGluZ0xldmVsc1tpXSAmIDEpIHsgLy9vbmx5IG9kZCAocnRsKSBsZXZlbHNcbiAgICAgICAgdmFyIG1pcnJvciA9IGdldE1pcnJvcmVkQ2hhcmFjdGVyKHN0cmluZ1tpXSk7XG4gICAgICAgIGlmIChtaXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICBtYXAuc2V0KGksIG1pcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgc3RhcnQgYW5kIGVuZCBkZW5vdGluZyBhIHNpbmdsZSBsaW5lIHdpdGhpbiBhIHN0cmluZywgYW5kIGEgc2V0IG9mIHByZWNhbGN1bGF0ZWRcbiAgICogYmlkaSBlbWJlZGRpbmcgbGV2ZWxzLCBwcm9kdWNlIGEgbGlzdCBvZiBzZWdtZW50cyB3aG9zZSBvcmRlcmluZyBzaG91bGQgYmUgZmxpcHBlZCwgaW4gc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSB0aGUgZnVsbCBpbnB1dCBzdHJpbmdcbiAgICogQHBhcmFtIHtHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHR9IGVtYmVkZGluZ0xldmVsc1Jlc3VsdCAtIHRoZSByZXN1bHQgb2JqZWN0IGZyb20gZ2V0RW1iZWRkaW5nTGV2ZWxzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdIC0gZmlyc3QgY2hhcmFjdGVyIGluIGEgc3Vic2V0IG9mIHRoZSBmdWxsIHN0cmluZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gLSBsYXN0IGNoYXJhY3RlciBpbiBhIHN1YnNldCBvZiB0aGUgZnVsbCBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyW11bXX0gLSB0aGUgbGlzdCBvZiBzdGFydC9lbmQgc2VnbWVudHMgdGhhdCBzaG91bGQgYmUgZmxpcHBlZCwgaW4gb3JkZXIuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSZW9yZGVyU2VnbWVudHMoc3RyaW5nLCBlbWJlZGRpbmdMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0ID09IG51bGwgPyAwIDogK3N0YXJ0KTtcbiAgICBlbmQgPSBNYXRoLm1pbihzdHJMZW4gLSAxLCBlbmQgPT0gbnVsbCA/IHN0ckxlbiAtIDEgOiArZW5kKTtcblxuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgIGVtYmVkZGluZ0xldmVsc1Jlc3VsdC5wYXJhZ3JhcGhzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFncmFwaCkge1xuICAgICAgdmFyIGxpbmVTdGFydCA9IE1hdGgubWF4KHN0YXJ0LCBwYXJhZ3JhcGguc3RhcnQpO1xuICAgICAgdmFyIGxpbmVFbmQgPSBNYXRoLm1pbihlbmQsIHBhcmFncmFwaC5lbmQpO1xuICAgICAgaWYgKGxpbmVTdGFydCA8IGxpbmVFbmQpIHtcbiAgICAgICAgLy8gTG9jYWwgc2xpY2UgZm9yIG11dGF0aW9uXG4gICAgICAgIHZhciBsaW5lTGV2ZWxzID0gZW1iZWRkaW5nTGV2ZWxzUmVzdWx0LmxldmVscy5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcblxuICAgICAgICAvLyAzLjQgTDEuNDogUmVzZXQgYW55IHNlcXVlbmNlIG9mIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBhbmQvb3IgaXNvbGF0ZSBmb3JtYXR0aW5nIGNoYXJhY3RlcnMgYXQgdGhlXG4gICAgICAgIC8vIGVuZCBvZiB0aGUgbGluZSB0byB0aGUgcGFyYWdyYXBoIGxldmVsLlxuICAgICAgICBmb3IgKHZhciBpID0gbGluZUVuZDsgaSA+PSBsaW5lU3RhcnQgJiYgKGdldEJpZGlDaGFyVHlwZShzdHJpbmdbaV0pICYgVFJBSUxJTkdfVFlQRVMpOyBpLS0pIHtcbiAgICAgICAgICBsaW5lTGV2ZWxzW2ldID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTDIuIEZyb20gdGhlIGhpZ2hlc3QgbGV2ZWwgZm91bmQgaW4gdGhlIHRleHQgdG8gdGhlIGxvd2VzdCBvZGQgbGV2ZWwgb24gZWFjaCBsaW5lLCBpbmNsdWRpbmcgaW50ZXJtZWRpYXRlIGxldmVsc1xuICAgICAgICAvLyBub3QgYWN0dWFsbHkgcHJlc2VudCBpbiB0aGUgdGV4dCwgcmV2ZXJzZSBhbnkgY29udGlndW91cyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHRoYXQgYXJlIGF0IHRoYXQgbGV2ZWwgb3IgaGlnaGVyLlxuICAgICAgICB2YXIgbWF4TGV2ZWwgPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgIHZhciBtaW5PZGRMZXZlbCA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsaW5lTGV2ZWxzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBsaW5lTGV2ZWxzW2kkMV07XG4gICAgICAgICAgaWYgKGxldmVsID4gbWF4TGV2ZWwpIHsgbWF4TGV2ZWwgPSBsZXZlbDsgfVxuICAgICAgICAgIGlmIChsZXZlbCA8IG1pbk9kZExldmVsKSB7IG1pbk9kZExldmVsID0gbGV2ZWwgfCAxOyB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgbHZsID0gbWF4TGV2ZWw7IGx2bCA+PSBtaW5PZGRMZXZlbDsgbHZsLS0pIHtcbiAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBsaW5lTGV2ZWxzLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lTGV2ZWxzW2kkMl0gPj0gbHZsKSB7XG4gICAgICAgICAgICAgIHZhciBzZWdTdGFydCA9IGkkMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGkkMiArIDEgPCBsaW5lTGV2ZWxzLmxlbmd0aCAmJiBsaW5lTGV2ZWxzW2kkMiArIDFdID49IGx2bCkge1xuICAgICAgICAgICAgICAgIGkkMisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpJDIgPiBzZWdTdGFydCkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goW3NlZ1N0YXJ0ICsgbGluZVN0YXJ0LCBpJDIgKyBsaW5lU3RhcnRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWdtZW50c1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHR9IGVtYmVkTGV2ZWxzUmVzdWx0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBuZXcgc3RyaW5nIHdpdGggYmlkaSBzZWdtZW50cyByZW9yZGVyZWRcbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlb3JkZXJlZFN0cmluZyhzdHJpbmcsIGVtYmVkTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGluZGljZXMgPSBnZXRSZW9yZGVyZWRJbmRpY2VzKHN0cmluZywgZW1iZWRMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpO1xuICAgIHZhciBjaGFycyA9IFtdLmNvbmNhdCggc3RyaW5nICk7XG4gICAgaW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFySW5kZXgsIGkpIHtcbiAgICAgIGNoYXJzW2ldID0gKFxuICAgICAgICAoZW1iZWRMZXZlbHNSZXN1bHQubGV2ZWxzW2NoYXJJbmRleF0gJiAxKSA/IGdldE1pcnJvcmVkQ2hhcmFjdGVyKHN0cmluZ1tjaGFySW5kZXhdKSA6IG51bGxcbiAgICAgICkgfHwgc3RyaW5nW2NoYXJJbmRleF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcGFyYW0ge0dldEVtYmVkZGluZ0xldmVsc1Jlc3VsdH0gZW1iZWRMZXZlbHNSZXN1bHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge251bWJlcltdfSBhbiBhcnJheSB3aXRoIGNoYXJhY3RlciBpbmRpY2VzIGluIHRoZWlyIG5ldyBiaWRpIG9yZGVyXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSZW9yZGVyZWRJbmRpY2VzKHN0cmluZywgZW1iZWRMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBnZXRSZW9yZGVyU2VnbWVudHMoc3RyaW5nLCBlbWJlZExldmVsc1Jlc3VsdCwgc3RhcnQsIGVuZCk7XG4gICAgLy8gRmlsbCBhbiBhcnJheSB3aXRoIGluZGljZXNcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbmRpY2VzW2ldID0gaTtcbiAgICB9XG4gICAgLy8gUmV2ZXJzZSBlYWNoIHNlZ21lbnQgaW4gb3JkZXJcbiAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBzdGFydCA9IHJlZlswXTtcbiAgICAgIHZhciBlbmQgPSByZWZbMV07XG5cbiAgICAgIHZhciBzbGljZSA9IGluZGljZXMuc2xpY2Uoc3RhcnQsIGVuZCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IHNsaWNlLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBpbmRpY2VzW2VuZCAtIGldID0gc2xpY2VbaV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGluZGljZXNcbiAgfVxuXG4gIGV4cG9ydHMuY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQgPSBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldDtcbiAgZXhwb3J0cy5nZXRCaWRpQ2hhclR5cGUgPSBnZXRCaWRpQ2hhclR5cGU7XG4gIGV4cG9ydHMuZ2V0QmlkaUNoYXJUeXBlTmFtZSA9IGdldEJpZGlDaGFyVHlwZU5hbWU7XG4gIGV4cG9ydHMuZ2V0Q2Fub25pY2FsQnJhY2tldCA9IGdldENhbm9uaWNhbEJyYWNrZXQ7XG4gIGV4cG9ydHMuZ2V0RW1iZWRkaW5nTGV2ZWxzID0gZ2V0RW1iZWRkaW5nTGV2ZWxzO1xuICBleHBvcnRzLmdldE1pcnJvcmVkQ2hhcmFjdGVyID0gZ2V0TWlycm9yZWRDaGFyYWN0ZXI7XG4gIGV4cG9ydHMuZ2V0TWlycm9yZWRDaGFyYWN0ZXJzTWFwID0gZ2V0TWlycm9yZWRDaGFyYWN0ZXJzTWFwO1xuICBleHBvcnRzLmdldFJlb3JkZXJTZWdtZW50cyA9IGdldFJlb3JkZXJTZWdtZW50cztcbiAgZXhwb3J0cy5nZXRSZW9yZGVyZWRJbmRpY2VzID0gZ2V0UmVvcmRlcmVkSW5kaWNlcztcbiAgZXhwb3J0cy5nZXRSZW9yZGVyZWRTdHJpbmcgPSBnZXRSZW9yZGVyZWRTdHJpbmc7XG4gIGV4cG9ydHMub3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQgPSBvcGVuaW5nVG9DbG9zaW5nQnJhY2tldDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KHt9KSk7XG5yZXR1cm4gYmlkaX1cblxuZXhwb3J0IGRlZmF1bHQgYmlkaUZhY3Rvcnk7XG4iXSwibmFtZXMiOlsiYmlkaUZhY3RvcnkiLCJiaWRpIiwiZXhwb3J0cyIsIkRBVEEiLCJUWVBFUyIsIlRZUEVTX1RPX05BTUVTIiwiTCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwidHlwZSIsImkiLCJmcmVlemUiLCJJU09MQVRFX0lOSVRfVFlQRVMiLCJMUkkiLCJSTEkiLCJGU0kiLCJTVFJPTkdfVFlQRVMiLCJSIiwiQUwiLCJORVVUUkFMX0lTT0xBVEVfVFlQRVMiLCJCIiwiUyIsIldTIiwiT04iLCJQREkiLCJCTl9MSUtFX1RZUEVTIiwiQk4iLCJSTEUiLCJMUkUiLCJSTE8iLCJMUk8iLCJQREYiLCJUUkFJTElOR19UWVBFUyIsIm1hcCIsInBhcnNlRGF0YSIsIk1hcCIsImxvb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImxhc3RDb2RlIiwic3BsaXQiLCJyYW5nZSIsInJlZiIsInNraXAiLCJzdGVwIiwicGFyc2VJbnQiLCJzZXQiLCJnZXRCaWRpQ2hhclR5cGUiLCJjaGFyIiwiZ2V0IiwiY29kZVBvaW50QXQiLCJnZXRCaWRpQ2hhclR5cGVOYW1lIiwiZGF0YSQxIiwicGFyc2VDaGFyYWN0ZXJNYXAiLCJlbmNvZGVkU3RyaW5nIiwiaW5jbHVkZVJldmVyc2UiLCJyYWRpeCIsInJldmVyc2VNYXAiLCJwcmV2UGFpciIsInZpc2l0IiwiZW50cnkiLCJpbmRleE9mIiwiYSIsImIiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50Iiwib3BlblRvQ2xvc2UiLCJjbG9zZVRvT3BlbiIsImNhbm9uaWNhbCIsInBhcnNlJDEiLCJwYWlycyIsIm9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0IiwiY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQiLCJnZXRDYW5vbmljYWxCcmFja2V0IiwiVFlQRV9MIiwiVFlQRV9SIiwiVFlQRV9FTiIsIkVOIiwiVFlQRV9FUyIsIkVTIiwiVFlQRV9FVCIsIkVUIiwiVFlQRV9BTiIsIkFOIiwiVFlQRV9DUyIsIkNTIiwiVFlQRV9CIiwiVFlQRV9TIiwiVFlQRV9PTiIsIlRZUEVfQk4iLCJUWVBFX05TTSIsIk5TTSIsIlRZUEVfQUwiLCJUWVBFX0xSTyIsIlRZUEVfUkxPIiwiVFlQRV9MUkUiLCJUWVBFX1JMRSIsIlRZUEVfUERGIiwiVFlQRV9MUkkiLCJUWVBFX1JMSSIsIlRZUEVfRlNJIiwiVFlQRV9QREkiLCJnZXRFbWJlZGRpbmdMZXZlbHMiLCJzdHJpbmciLCJiYXNlRGlyZWN0aW9uIiwiTUFYX0RFUFRIIiwiY2hhclR5cGVzIiwiVWludDMyQXJyYXkiLCJsZW5ndGgiLCJjaGFyVHlwZUNvdW50cyIsImNoYW5nZUNoYXJUeXBlIiwib2xkVHlwZSIsImVtYmVkTGV2ZWxzIiwiVWludDhBcnJheSIsImlzb2xhdGlvblBhaXJzIiwicGFyYWdyYXBocyIsInBhcmFncmFwaCIsImkkMSIsInB1c2giLCJzdGFydCIsImVuZCIsImxldmVsIiwiZGV0ZXJtaW5lQXV0b0VtYmVkTGV2ZWwiLCJGT1JNQVRUSU5HX1RZUEVTIiwibmV4dEV2ZW4iLCJuIiwibmV4dE9kZCIsInBhcmFJZHgiLCJzdGF0dXNTdGFjayIsIl9sZXZlbCIsIl9vdmVycmlkZSIsIl9pc29sYXRlIiwic3RhY2tUb3AiLCJvdmVyZmxvd0lzb2xhdGVDb3VudCIsIm92ZXJmbG93RW1iZWRkaW5nQ291bnQiLCJ2YWxpZElzb2xhdGVDb3VudCIsImNsZWFyIiwiaSQyIiwiY2hhclR5cGUiLCJsZXZlbCQxIiwibGV2ZWwkMiIsIl9pc29sSW5pdEluZGV4IiwicG9wIiwiaXNvbEluaXRJbmRleCIsImxldmVsUnVucyIsImN1cnJlbnRSdW4iLCJpJDMiLCJjaGFyVHlwZSQxIiwibHZsIiwiaXNJc29sSW5pdCIsImlzUERJIiwiX2VuZCIsIl9lbmRzV2l0aElzb2xJbml0IiwiX3N0YXJ0IiwiX3N0YXJ0c1dpdGhQREkiLCJpc29sYXRpbmdSdW5TZXFzIiwicnVuSWR4IiwicnVuIiwiaGFzIiwic2VxUnVucyIsInBkaUluZGV4IiwiaSQ0Iiwic2VxSW5kaWNlcyIsImkkNSIsInJ1biQxIiwiaiIsImZpcnN0TGV2ZWwiLCJwcmV2TGV2ZWwiLCJpJDYiLCJsYXN0SW5kZXgiLCJsYXN0TGV2ZWwiLCJuZXh0TGV2ZWwiLCJpJDciLCJfc2VxSW5kaWNlcyIsIl9zb3NUeXBlIiwiTWF0aCIsIm1heCIsIl9lb3NUeXBlIiwic2VxSWR4Iiwic2VxSW5kaWNlcyQxIiwic29zVHlwZSIsImVvc1R5cGUiLCJlbWJlZERpcmVjdGlvbiIsInNpIiwiaSQ4IiwicHJldlR5cGUiLCJzaiIsInNpJDEiLCJpJDkiLCJzaiQxIiwicHJldkNoYXJUeXBlIiwic2kkMiIsImkkMTAiLCJzaSQzIiwiaSQxMSIsInByZXZUeXBlJDEiLCJuZXh0VHlwZSIsInNqJDIiLCJzaiQzIiwic2kkNCIsImkkMTIiLCJzaiQ0Iiwic2kkNSIsImkkMTMiLCJzaiQ1Iiwic2okNiIsInNpJDYiLCJwcmV2U3Ryb25nVHlwZSIsImkkMTQiLCJSX1RZUEVTX0ZPUl9OX1NURVBTIiwiU1RST05HX1RZUEVTX0ZPUl9OX1NURVBTIiwiYnJhY2tldFBhaXJzIiwib3BlbmVyU3RhY2siLCJzaSQ3Iiwib3Bwb3NpdGVCcmFja2V0Iiwic2VxSW5kZXgiLCJzdGFja0lkeCIsInN0YWNrQ2hhciIsInNvcnQiLCJwYWlySWR4IiwicmVmJDEiLCJvcGVuU2VxSWR4IiwiY2xvc2VTZXFJZHgiLCJmb3VuZFN0cm9uZ1R5cGUiLCJ1c2VTdHJvbmdUeXBlIiwic2kkOCIsImkkMTUiLCJsciIsInNpJDkiLCJpJDE2IiwibHIkMSIsInNpJDEwIiwic2kkMTEiLCJzaSQxMiIsIm5pUnVuU3RhcnQiLCJuaVJ1bkVuZCIsInByZXZUeXBlJDIiLCJzaTIiLCJuZXh0VHlwZSQxIiwic2kyJDEiLCJzaiQ3IiwiaSQxNyIsImxldmVsJDMiLCJ0eXBlJDEiLCJqJDEiLCJsZXZlbHMiLCJpc0ZTSSIsInBkaSIsImluZGV4T2ZNYXRjaGluZ1BESSIsImlzb2xhdGVTdGFydCIsImlzb2xhdGlvbkxldmVsIiwiZGF0YSIsIm1pcnJvck1hcCIsInBhcnNlIiwidmFsdWUiLCJrZXkiLCJnZXRNaXJyb3JlZENoYXJhY3RlciIsImdldE1pcnJvcmVkQ2hhcmFjdGVyc01hcCIsImVtYmVkZGluZ0xldmVscyIsInN0ckxlbiIsIm1pbiIsIm1pcnJvciIsImdldFJlb3JkZXJTZWdtZW50cyIsImVtYmVkZGluZ0xldmVsc1Jlc3VsdCIsInNlZ21lbnRzIiwibGluZVN0YXJ0IiwibGluZUVuZCIsImxpbmVMZXZlbHMiLCJzbGljZSIsIm1heExldmVsIiwibWluT2RkTGV2ZWwiLCJJbmZpbml0eSIsInNlZ1N0YXJ0IiwiZ2V0UmVvcmRlcmVkU3RyaW5nIiwiZW1iZWRMZXZlbHNSZXN1bHQiLCJpbmRpY2VzIiwiZ2V0UmVvcmRlcmVkSW5kaWNlcyIsImNoYXJzIiwiY29uY2F0IiwiY2hhckluZGV4Iiwiam9pbiIsImRlZmluZVByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bidi-js/dist/bidi.mjs\n");

/***/ })

};
;