"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst version = parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakMsTUFBTUMsVUFBVUMsU0FBU0YsMkNBQVFBLENBQUNHLE9BQU8sQ0FBQyxRQUFRO0FBR2hELENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JlYXRpdmUtNDA0Ly4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9fcG9seWZpbGwvY29uc3RhbnRzLmpzP2YxN2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUkVWSVNJT04gfSBmcm9tIFwidGhyZWVcIjtcbmNvbnN0IHZlcnNpb24gPSBwYXJzZUludChSRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csIFwiXCIpKTtcbmV4cG9ydCB7XG4gIHZlcnNpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwXG4iXSwibmFtZXMiOlsiUkVWSVNJT04iLCJ2ZXJzaW9uIiwicGFyc2VJbnQiLCJyZXBsYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: () => (/* binding */ MeshoptDecoder)\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = ()=>{\n    if (generated) return generated;\n    const wasm_base = \"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\";\n    const wasm_simd = \"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\";\n    const detector = new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        4,\n        1,\n        96,\n        0,\n        0,\n        3,\n        3,\n        2,\n        0,\n        0,\n        5,\n        3,\n        1,\n        0,\n        1,\n        12,\n        1,\n        0,\n        10,\n        22,\n        2,\n        12,\n        0,\n        65,\n        0,\n        65,\n        0,\n        65,\n        0,\n        252,\n        10,\n        0,\n        0,\n        11,\n        7,\n        0,\n        65,\n        0,\n        253,\n        15,\n        26,\n        11\n    ]);\n    const wasmpack = new Uint8Array([\n        32,\n        0,\n        65,\n        253,\n        3,\n        1,\n        2,\n        34,\n        4,\n        106,\n        6,\n        5,\n        11,\n        8,\n        7,\n        20,\n        13,\n        33,\n        12,\n        16,\n        128,\n        9,\n        116,\n        64,\n        19,\n        113,\n        127,\n        15,\n        10,\n        21,\n        22,\n        14,\n        255,\n        66,\n        24,\n        54,\n        136,\n        107,\n        18,\n        23,\n        192,\n        26,\n        114,\n        118,\n        132,\n        17,\n        77,\n        101,\n        130,\n        144,\n        27,\n        87,\n        131,\n        44,\n        45,\n        74,\n        156,\n        154,\n        70,\n        167\n    ]);\n    if (typeof WebAssembly !== \"object\") {\n        return {\n            supported: false\n        };\n    }\n    let wasm = wasm_base;\n    if (WebAssembly.validate(detector)) {\n        wasm = wasm_simd;\n    }\n    let instance;\n    const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result)=>{\n        instance = result.instance;\n        instance.exports.__wasm_call_ctors();\n    });\n    function unpack(data) {\n        const result = new Uint8Array(data.length);\n        for(let i = 0; i < data.length; ++i){\n            const ch = data.charCodeAt(i);\n            result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n        }\n        let write = 0;\n        for(let i = 0; i < data.length; ++i){\n            result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n        }\n        return result.buffer.slice(0, write);\n    }\n    function decode(fun, target, count, size, source, filter) {\n        const sbrk = instance.exports.sbrk;\n        const count4 = count + 3 & ~3;\n        const tp = sbrk(count4 * size);\n        const sp = sbrk(source.length);\n        const heap = new Uint8Array(instance.exports.memory.buffer);\n        heap.set(source, sp);\n        const res = fun(tp, count, size, sp, source.length);\n        if (res === 0 && filter) {\n            filter(tp, count4, size);\n        }\n        target.set(heap.subarray(tp, tp + count * size));\n        sbrk(tp - sbrk(0));\n        if (res !== 0) {\n            throw new Error(`Malformed buffer data: ${res}`);\n        }\n    }\n    const filters = {\n        // legacy index-based enums for glTF\n        0: \"\",\n        1: \"meshopt_decodeFilterOct\",\n        2: \"meshopt_decodeFilterQuat\",\n        3: \"meshopt_decodeFilterExp\",\n        // string-based enums for glTF\n        NONE: \"\",\n        OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n        QUATERNION: \"meshopt_decodeFilterQuat\",\n        EXPONENTIAL: \"meshopt_decodeFilterExp\"\n    };\n    const decoders = {\n        // legacy index-based enums for glTF\n        0: \"meshopt_decodeVertexBuffer\",\n        1: \"meshopt_decodeIndexBuffer\",\n        2: \"meshopt_decodeIndexSequence\",\n        // string-based enums for glTF\n        ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n        TRIANGLES: \"meshopt_decodeIndexBuffer\",\n        INDICES: \"meshopt_decodeIndexSequence\"\n    };\n    generated = {\n        ready: promise,\n        supported: true,\n        decodeVertexBuffer (target, count, size, source, filter) {\n            decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);\n        },\n        decodeIndexBuffer (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n        },\n        decodeIndexSequence (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n        },\n        decodeGltfBuffer (target, count, size, source, mode, filter) {\n            decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);\n        }\n    };\n    return generated;\n};\n //# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBO0FBQ0osTUFBTUMsaUJBQWlCO0lBQ3JCLElBQUlELFdBQ0YsT0FBT0E7SUFDVCxNQUFNRSxZQUFZO0lBQ2xCLE1BQU1DLFlBQVk7SUFDbEIsTUFBTUMsV0FBVyxJQUFJQyxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsTUFBTUMsV0FBVyxJQUFJRCxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsSUFBSSxPQUFPRSxnQkFBZ0IsVUFBVTtRQUNuQyxPQUFPO1lBQ0xDLFdBQVc7UUFDYjtJQUNGO0lBQ0EsSUFBSUMsT0FBT1A7SUFDWCxJQUFJSyxZQUFZRyxRQUFR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QUFrQjNCLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLE1BQU07WUFDM0NMLE9BQU9oQixTQUFTTSxPQUFPLENBQUN3Qyx5QkFBeUIsRUFBRTVCLFFBQVFDLE9BQU9DLE1BQU1DO1FBQzFFO1FBQ0EwQixxQkFBb0I3QixNQUFNLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxNQUFNO1lBQzdDTCxPQUFPaEIsU0FBU00sT0FBTyxDQUFDMEMsMkJBQTJCLEVBQUU5QixRQUFRQyxPQUFPQyxNQUFNQztRQUM1RTtRQUNBNEIsa0JBQWlCL0IsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFNkIsSUFBSSxFQUFFNUIsTUFBTTtZQUN4RE4sT0FDRWhCLFNBQVNNLE9BQU8sQ0FBQ2dDLFFBQVEsQ0FBQ1ksS0FBSyxDQUFDLEVBQ2hDaEMsUUFDQUMsT0FDQUMsTUFDQUMsUUFDQXJCLFNBQVNNLE9BQU8sQ0FBQzJCLE9BQU8sQ0FBQ1gsT0FBTyxDQUFDO1FBRXJDO0lBQ0Y7SUFDQSxPQUFPakM7QUFDVDtBQUdFLENBQ0YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JlYXRpdmUtNDA0Ly4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9saWJzL01lc2hvcHREZWNvZGVyLmpzP2E3ZjQiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGdlbmVyYXRlZDtcbmNvbnN0IE1lc2hvcHREZWNvZGVyID0gKCkgPT4ge1xuICBpZiAoZ2VuZXJhdGVkKVxuICAgIHJldHVybiBnZW5lcmF0ZWQ7XG4gIGNvbnN0IHdhc21fYmFzZSA9IFwiQjloOXo5dEZCQkJGOGZMOWdCQjlnTGFhYWFhRmE5Z0VhYWFCOWdGYUZhOWdFYWFhRmFFTWNCRkZGR0dHRUlJSUxGOXdGRkZMRUZCRktORmFGQ3gvSUZNTy9MRlZLOXR2OXQ5dnE5NUdCdDlmOWY5MzloOXo5dDlmOWo5aDlzOXM5ZjlqVzl2cTl6QkJwOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OVd2cVd2OTRoOTE5bTltdnFCRjhaOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0aDkxOW05bXZxQkd5OXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0OVR2Wjkxdjl1OWp2QkVuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UDlqV0JJaTl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVI5MTloV0JMbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOUY5NDl3QktJOXo5aXFsQk9jK3g4eWNHQk0vcVFGVGE4alVVVVVCQ1UvRUJsSEw4a1VVVVVCQzkrUktHWEFHQ0ZKQUk5TFFCQ2FSS0FFMkJCQytnRjlIUUJBTEFFQUlKSE9BR2xBR1RrVVVVQlJOQ1VvQkFHOXVDL3dnQlpIS0NVR0FLQ1VHOUp5UlZBRUNGSlJJQ0JSY0dYRVhBY0FGOVBRRkFWQUZBY2xBY0FWSkFGOUp5Uk1HWEdYQUc5RlFCQU1DYkpIS0M5d1pSU0FLQ0lyQ0VKQ0dyUlFBTkNVR0pSZkNCUmJBSVJURVhHWEFPQVRsQVE5UFFCQ0JSSVNFTUFUQVFKUklHWEFTOUZRQkNCUnRDQlJFRVhHWEFPQUlsQ2k5UFFCQ0JSSVNMTUFOQ1UvQ0JKQUVKUktHWEdYR1hHWEdYQVRBRUNLckoyQkJBdENLWnJDRVpmSUJGR0VCTUFLaEI4M0VCQUtDTkpoQjgzRUJTRU1BS0FJMkJJQUkyQkJIbUNLckhZQVlDRTZIWXk4NkJCQUtDRkpBSUNJSkFZSkhZMkJCQW1DSXJDRVpIUEFQQ0U2SFB5ODZCQkFLQ0dKQVlBUEpIWTJCQkFtQ0dyQ0VaSFBBUENFNkhQeTg2QkJBS0NFSkFZQVBKSFkyQkJBbUNFWkhtQW1DRTZIbXk4NkJCQUtDSUpBWUFtSkhZMkJCQUkyQkZIbUNLckhQQVBDRTZIUHk4NkJCQUtDTEpBWUFQSkhZMkJCQW1DSXJDRVpIUEFQQ0U2SFB5ODZCQkFLQ0tKQVlBUEpIWTJCQkFtQ0dyQ0VaSFBBUENFNkhQeTg2QkJBS0NPSkFZQVBKSFkyQkJBbUNFWkhtQW1DRTZIbXk4NkJCQUtDTkpBWUFtSkhZMkJCQUkyQkdIbUNLckhQQVBDRTZIUHk4NkJCQUtDVkpBWUFQSkhZMkJCQW1DSXJDRVpIUEFQQ0U2SFB5ODZCQkFLQ2NKQVlBUEpIWTJCQkFtQ0dyQ0VaSFBBUENFNkhQeTg2QkJBS0NNSkFZQVBKSFkyQkJBbUNFWkhtQW1DRTZIbXk4NkJCQUtDU0pBWUFtSkhtMkJCQUkyQkVISUNLckhZQVlDRTZIWXk4NkJCQUtDUUpBbUFZSkhtMkJCQUlDSXJDRVpIWUFZQ0U2SFl5ODZCQkFLQ2ZKQW1BWUpIbTJCQkFJQ0dyQ0VaSFlBWUNFNkhZeTg2QkJBS0NiSkFtQVlKSEsyQkJBSUNFWkhJQUlDRTZISXk4NkJCQUtBSUpSSVNHTUFLQUkyQk5BSTJCQkhtQ0lySFlBWUNiNkhZeTg2QkJBS0NGSkFJQ05KQVlKSFkyQkJBbUNiWkhtQW1DYjZIbXk4NkJCQUtDR0pBWUFtSkhtMkJCQUkyQkZIWUNJckhQQVBDYjZIUHk4NkJCQUtDRUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ0lKQW1BWUpIbTJCQkFJMkJHSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ0xKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NLSkFtQVlKSG0yQkJBSTJCRUhZQ0lySFBBUENiNkhQeTg2QkJBS0NPSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDTkpBbUFZSkhtMkJCQUkyQklIWUNJckhQQVBDYjZIUHk4NkJCQUtDVkpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ2NKQW1BWUpIbTJCQkFJMkJMSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ01KQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NTSkFtQVlKSG0yQkJBSTJCS0hZQ0lySFBBUENiNkhQeTg2QkJBS0NRSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDZkpBbUFZSkhtMkJCQUkyQk9ISUNJckhZQVlDYjZIWXk4NkJCQUtDYkpBbUFZSkhLMkJCQUlDYlpISUFJQ2I2SEl5ODZCQkFLQUlKUklTRk1BS0FJOHBCQjgzQkJBS0NOSkFJQ05KOHBCQjgzQkJBSUNUSlJJTUF0Q0dKUnRBRUNUSkhFQVM5SlFCTU1HWEFJUUJDQlJJU0VNR1hBTTlGUUJBTkFiSjJCQlJ0Q0JSS0FmUkVFWEFFQU5DVS9DQkpBS0oyQkJIVENGckNCQVRDRlpsOXpBdEpIdDg2QkJBRUFHSlJFQUtDRkpIS0FNOUhRQk1NQWZDRkpSZkFJUlRBYkNGSkhiQUc5SFFCTU1BQkFjQUc5c0pBTkNVR0pBTUFHOXNUa1VVVUJwQU5BTkNVR0pBTUNhSkFHOXNKQUdUa1VVVUJwTUFNQ0JBSXlBY0pSY0FJUUJNQzkrUktTRk1DQkM5OUFPQUlsQUdDQUFHQ0E5THk2eVJLTUFMQ1UvRUJKOGtVVVVVQkFLTStPbUZUYThqVVVVVUJDb0ZsSEw4a1VVVVVCQzkrUktHWEFGQ0U5dUhPQ3RKQUk5TFFCQ2FSS0FFMkJCSE5DL3dGWkMvZ0Y5SFFCQU5DYlpIVkNGOUxRQkFMQ29CSkNnRkNVRlQrSlVVVUJwQUxDODRKaGE4M0VCQUxDOHdKaGE4M0VCQUxDOG9KaGE4M0VCQUxDQUpoYTgzRUJBTENpSmhhODNFQkFMQ1RKaGE4M0VCQUxoYTgzRU5BTGhhODNFQkFFQUlKQzl3SlJjQUVDRkpITkFPSlJNR1hBRjlGUUJDUUNiQVZDRjZ5UlNBQlJFQ0JSVkNCUlFDQlJmQ0JSSUNCUktFWEdYQU1BY3VRQkM5K1JLU0VNR1hHWEFOMkJCSE9DL3ZGOUxRQkFMQ29CSkFPQ0lyQ2E5ekFLSkNiWkNFV0pIYjhvR0lSVEFiOG9HQlJ0R1hBT0NiWkhiQVM5UFFCQUxBT0NhOXpBSUpDYlpDR1dKOG9HQkFWQWJ5Uk9BYjlGUmJHWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQU84N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBT2pHQkFFQ0lKQVRqR0JNQVZBYkpSVkFMQ29CSkFLQ0VXSkhtQU9qR0JBbUFUakdJQUxBSUNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSFRBdGpHQkFUQU9qR0lBSUFiSlJJQUtDRkpSS1NHTUdYR1hBYkNiNlFCQVFBYkpBYkM5ODl6SkNGSlJRU0ZNQU0xQkJIYkNnRlpST0dYR1hBYkNhOU1RQkFNQ0ZKUk1TRk1BTTFCRkhiQ2dCWkNPV0FPQ2dCWnFST0dYQWJDYTlNUUJBTUNHSlJNU0ZNQU0xQkdIYkNnQlpDZldBT3FST0dYQWJDYTlNUUJBTUNFSlJNU0ZNQU0xQkVIYkNnQlpDZFdBT3FST0dYQWJDYTlNUUJBTUNJSlJNU0ZNQU0yQklDOGNXQU9xUk9BTUNMSlJNTUFPQ0ZyQ0JBT0NGWmw5ekFRSlJRTUdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBUTg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFRakdCQUVDSUpBVGpHQk1BTENvQkpBS0NFV0pIT0FRakdCQU9BVGpHSUFMQUlDR1dKQVFqR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhPQXRqR0JBT0FRakdJQUlDRkpSSUFLQ0ZKUktTRk1HWEFPQ0RGOUxRQkFMQUlBY0FPQ2JaSjJCQkhiQ0lySFRsQ2JaQ0dXSjhvR0JBVkNGSkh0QVR5Uk9BTEFJQWJsQ2JaQ0dXSjhvR0JBdEFUOUZIbUpIdEFiQ2JaSFR5UmJBVDlGUlRHWEdYQUdDRzlIUUJBQkFWODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFWakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxBSUNHV0pBVmpHQkFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFWakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQW1KQ2JaSElDR1dKQWJqR0JBTENvQkpBS0NHSkNiWkhLQ0VXSkhPQVZqR0JBT0FiakdJQUtDRkpSS0FJQVRKUklBdEFUSlJWU0ZNQVZDQkFNMkJCSFl5SFRBT0MvK0Y2SFBKUk9BWUNiWlJ0R1hHWEFZQ0lySG1RQkFPQ0ZKUmJTRk1BT1JiQUxBSUFtbENiWkNHV0o4b0dCUk9NR1hHWEF0UUJBYkNGSlJWU0ZNQWJSVkFMQUlBWWxDYlpDR1dKOG9HQlJiTUdYR1hBUDlGUUJBTUNGSlJZU0ZNQU0xQkZIWUNnRlpSVEdYR1hBWUNhOU1RQkFNQ0dKUllTRk1BTTFCR0hZQ2dCWkNPV0FUQ2dCWnFSVEdYQVlDYTlNUUJBTUNFSlJZU0ZNQU0xQkVIWUNnQlpDZldBVHFSVEdYQVlDYTlNUUJBTUNJSlJZU0ZNQU0xQklIWUNnQlpDZFdBVHFSVEdYQVlDYTlNUUJBTUNMSlJZU0ZNQU1DS0pSWUFNMkJMQzhjV0FUcVJUTUFUQ0ZyQ0JBVENGWmw5ekFRSkhRUlRNR1hHWEFtQ2I2UUJBWVJQU0ZNQVkxQkJITUNnRlpST0dYR1hBTUNhOU1RQkFZQ0ZKUlBTRk1BWTFCRkhNQ2dCWkNPV0FPQ2dCWnFST0dYQU1DYTlNUUJBWUNHSlJQU0ZNQVkxQkdITUNnQlpDZldBT3FST0dYQU1DYTlNUUJBWUNFSlJQU0ZNQVkxQkVITUNnQlpDZFdBT3FST0dYQU1DYTlNUUJBWUNJSlJQU0ZNQVlDTEpSUEFZMkJJQzhjV0FPcVJPTUFPQ0ZyQ0JBT0NGWmw5ekFRSkhRUk9NR1hHWEF0Q2I2UUJBUFJNU0ZNQVAxQkJITUNnRlpSYkdYR1hBTUNhOU1RQkFQQ0ZKUk1TRk1BUDFCRkhNQ2dCWkNPV0FiQ2dCWnFSYkdYQU1DYTlNUUJBUENHSlJNU0ZNQVAxQkdITUNnQlpDZldBYnFSYkdYQU1DYTlNUUJBUENFSlJNU0ZNQVAxQkVITUNnQlpDZFdBYnFSYkdYQU1DYTlNUUJBUENJSlJNU0ZNQVBDTEpSTUFQMkJJQzhjV0FicVJiTUFiQ0ZyQ0JBYkNGWmw5ekFRSkhRUmJNR1hHWEFHQ0c5SFFCQUJBVDg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVGpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFUakdJQUxBSUNHV0pBVGpHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDR0pDYlpDRVdKSE9BVGpHQkFPQWJqR0lBTEFJQW05RkFtQ2I2cUpISUNiWkNHV0pBYmpHQkFJQXQ5RkF0Q2I2cUpSSUFLQ0VKUktNQU5DRkpSTkFCQ0tKUkJBRUNTSlJFQUtDYlpSS0FJQ2JaUklBZkNFSkhmQUY5SlFCTU1DQkM5OUFNQWM2eVJLTUFMQ29GSjhrVVVVVUJBS00vdElGR2E4alVVVVVCQ1RsUkxDOStSS0dYQUZDTEpBSTlMUUJDYVJLQUUyQkJDLytGWkMvUUY5SFFCQUxoQjgzRU5BRUNGSlJLQUVBSUpDOThKUkVHWEFGOUZRQkdYQUdDRzZRQkVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFMQ05KQUlDRlpDR1dxSEdBSUNHckNCQUlDRnJDRlpsOXpBRzhvR0JKSElqR0JBQkFJakdCQUJDSUpSQkFGQ2FKSEZRQlNHTU1FWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BQkFJQ0dyQ0JBSUNGckNGWmw5ekFMQ05KQUlDRlpDR1dxSEk4b0dCSkhHODdGQkFJQUdqR0JBQkNHSlJCQUZDYUpIRlFCTU1DQkM5OUFLQUU2eVJLTUFLTStsTEtGYUY5OUdhRzk5RmFHOTlHWEdYQUdDSTlIUUJBRjlGUUZFWEdYR1g5REJCQjgvOURCQkIrL0FCQ0dKSEcxQkIreUFCMUJCSEUreUhJK0wrVEFCQ0ZKSEwxQkJISyt5SE8rTCtUSE45REJCQkI5Z0hWeUFOOURCQi8raEFOQU4rVTlEQkJCQkFOQVZ5SGNBYytNSE1BRUNhM3lBSStTSElBSStVQWNBTUFLQ2EzeUFPK1NIY0FjK1UrUytTK1IrVkhPK1UrU0hOK0w5REJCQjlQOWQ5RlFCQU4rb1JFU0ZNQ1VVVVU5NFJFTUFHQUU4NkJCR1hHWDlEQkJCOC85REJCQisvQWM5REJCQkI5Z3lBY0FPK1UrU0hOK0w5REJCQjlQOWQ5RlFCQU4rb1JHU0ZNQ1VVVVU5NFJHTUFMQUc4NkJCR1hHWDlEQkJCOC85REJCQisvQUk5REJCQkI5Z3lBSUFPK1UrU0hOK0w5REJCQjlQOWQ5RlFCQU4rb1JHU0ZNQ1VVVVU5NFJHTUFCQUc4NkJCQUJDSUpSQkFGQ2FKSEZRQlNHTU1BRjlGUUJFWEdYR1g5REJCQjgvOURCQkIrL0FCQ0lKSEc4dUZCK3lBQjh1RkJIRSt5SEkrTCtUQUJDR0pITDh1RkJISyt5SE8rTCtUSE45REJCQkI5Z0hWeUFOOURCLytnNkFOQU4rVTlEQkJCQkFOQVZ5SGNBYytNSE1BRUNhM3lBSStTSElBSStVQWNBTUFLQ2EzeUFPK1NIY0FjK1UrUytTK1IrVkhPK1UrU0hOK0w5REJCQjlQOWQ5RlFCQU4rb1JFU0ZNQ1VVVVU5NFJFTUFHQUU4N0ZCR1hHWDlEQkJCOC85REJCQisvQWM5REJCQkI5Z3lBY0FPK1UrU0hOK0w5REJCQjlQOWQ5RlFCQU4rb1JHU0ZNQ1VVVVU5NFJHTUFMQUc4N0ZCR1hHWDlEQkJCOC85REJCQisvQUk5REJCQkI5Z3lBSUFPK1UrU0hOK0w5REJCQjlQOWQ5RlFCQU4rb1JHU0ZNQ1VVVVU5NFJHTUFCQUc4N0ZCQUJDTkpSQkFGQ2FKSEZRQk1NTS9TRUlFYUU5OUVhRjk5R1hBRjlGUUJDQlJFQUJSSUVYR1hHWDlEL3pJODE4L0FJQ0tKOHVGQkhMQ0VxK3krVkhLQUk4dUZCK3krVUhPOURCLytnNitVOURCQkI4LzlEQkJCKy9BTzlEQkJCQjlneStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUlZTRk1DVVVVVTk0UlZNQUlDSUo4dUZCUmNBSUNHSjh1RkJSTUFCQUxDRkpDRVpBRXFDRldKQVY4N0ZCR1hHWEFLQU0reStVSE45REIvK2c2K1U5REJCQjgvOURCQkIrL0FOOURCQkJCOWd5K1NIUytMOURCQkI5UDlkOUZRQkFTK29STVNGTUNVVVVVOTRSTU1BQkFMQ0dKQ0VaQUVxQ0ZXSkFNODdGQkdYR1hBS0FjK3krVUhLOURCLytnNitVOURCQkI4LzlEQkJCKy9BSzlEQkJCQjlneStTSFMrTDlEQkJCOVA5ZDlGUUJBUytvUmNTRk1DVVVVVTk0UmNNQUJBTENhSkNFWkFFcUNGV0pBYzg3RkJHWEdYOURCQlU4L0FPQU8rVStUQU5BTitVK1RBS0FLK1UrVEhPOURCQkJCQU85REJCQkI5Z3krUjlEQi8rZzYrVTlEQkJCOC8rU0hPK0w5REJCQjlQOWQ5RlFCQU8rb1JjU0ZNQ1VVVVU5NFJjTUFCQUxDRVpBRXFDRldKQWM4N0ZCQUlDTkpSSUFFQ0lKUkVBRkNhSkhGUUJNTU05SkJHWEFHQ0dyQUY5c0hGOUZRQkVYQUJBQjhvR0JIR0NOV0NOOTEreUFHQ2k5MUNuV0NVVVUvOEVKKysrVTg0R0JBQkNJSlJCQUZDYUpIRlFCTU1NOVRGRWFDQkNCOG9HVWtVVUJIRkFCQ0VKQzk4WkpIQmpHVWtVVUJHWEdYQUI4L0JDVFdIR3VRQkNhUkVBQkFHbENnZ0VKQ1RyWEJDYTZRRk1BRlJFTUFFTS9sRkZGYUdYR1hBRkFCcUNFWjlGUUJBQlJFU0ZNR1hHWEFHQ1Q5UFFCQUJSRVNGTUFCUkVFWEFFQUY4b0dCakdCQUVDSUpBRkNJSjhvR0JqR0JBRUNOSkFGQ05KOG9HQmpHQkFFQ1NKQUZDU0o4b0dCakdCQUVDVEpSRUFGQ1RKUkZBR0M5d0pIR0NiOUxRQk1NQUdDSTlKUUJFWEFFQUY4b0dCakdCQUZDSUpSRkFFQ0lKUkVBR0M5OEpIR0NFOUxRQk1NR1hBRzlGUUJFWEFFQUYyQkI4NkJCQUVDRkpSRUFGQ0ZKUkZBR0NhSkhHUUJNTUFCTW9GRkdhR1hHWEFCQ0VaOUZRQkFCUkVTRk1BRkNnRlpDK0J3c045c1JJR1hHWEFHQ1Q5UFFCQUJSRVNGTUFCUkVFWEFFQUlqR0JBRUNTSkFJakdCQUVDTkpBSWpHQkFFQ0lKQUlqR0JBRUNUSlJFQUdDOXdKSEdDYjlMUUJNTUFHQ0k5SlFCRVhBRUFJakdCQUVDSUpSRUFHQzk4SkhHQ0U5TFFCTU1HWEFHOUZRQkVYQUVBRjg2QkJBRUNGSlJFQUdDYUpIR1FCTU1BQk1NTUZCQ1VOTUlUOWtCQlwiO1xuICBjb25zdCB3YXNtX3NpbWQgPSBcIkI5aDl6OXRGQkJCRmlJOWdCQjlnTGFhYWFhRmE5Z0VhYWFCOWdGYUZhRU1jQkJGQkZGR0dHRUlMRjl3RkZGTEVGQkZLTkZhRkN4L2FGTU8vTEZWSzl0djl0OXZxOTVHQnQ5ZjlmOTM5aDl6OXQ5ZjlqOWg5czlzOWY5alc5dnE5ekJCcDl0djl6OW85djl3VzlmOWt2OWo5djlrdjlXdnFXdjk0aDkxOW05bXZxQkc4Wjl0djl6OW85djl3VzlmOWt2OWo5djlrdjlKOXU5a3Y5NGg5MTltOW12cUJJeTl0djl6OW85djl3VzlmOWt2OWo5djlrdjlKOXU5a3Y5NDlUdlo5MXY5dTlqdkJMbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVA5aldCS2k5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlSOTE5aFdCT245dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlGOTQ5d0JOSTl6OWlxbEJWYytOOUljSUJURU05K0ZMYThqVVVVVUJDVGxSQkNCUkZFWENCUkdDQlJFRVhBQkNOSkFHSkFFQ1VhQUZBR3JDRlpISXk4NkJCQUVBSUpSRUFHQ0ZKSEdDTjlIUUJNQUZDeCtZVVVCSkFFODZCQkFGQ0VXQ3hrVVVCSkFCOHBFTjgzRUJBRkNGSkhGQ1VHOUhRQk1NazhsTGJhRTk3RjkrRmFMOTc4alVVVVVCQ1UvS0JsSEw4a1VVVVVCQzkrUktHWEFHQ0ZKQUk5TFFCQ2FSS0FFMkJCQytnRjlIUUJBTEFFQUlKSE9BR2xBRy84Y0JCQ1VvQkFHOXVDL3dnQlpIS0NVR0FLQ1VHOUp5Uk5BRUNGSlJLQ0JSVkdYRVhBVkFGOVBRRkFOQUZBVmxBVkFOSkFGOUp5UmNHWEdYQUc5RlFCQWNDYkpISUM5d1pITUNFOXNSU0FNQ0ZXUlFBSUNJckNFSkNHclJmQ0JSYkVYQUtSVENCUnRHWEVYR1hBT0FUbEFmOVBRQkNCUktTTE1BTENVL0NCSkF0QU05c0pSbUFUQWZKUktDQlJFR1hBTUNvQjlKUUJBT0FLbEMvZ0I5SlFCQ0JSSUVYQW1BSUpSRUdYR1hHWEdYR1hBVEFJQ0tySjJCQkhZQ0VaZklCRkdFQk1BRUNCRHRETUlCU0VNQUVBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ0lKQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NHTUFFQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ05KQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NGTUFFQUtEQkJCRE1JQkFLQ1RKUktNR1hHWEdYR1hHWEFZQ0dyQ0VaZklCRkdFQk1BRUNCRHRETUlUU0VNQUVBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JVEFLQ0lKQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NHTUFFQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JVEFLQ05KQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NGTUFFQUtEQkJCRE1JVEFLQ1RKUktNR1hHWEdYR1hHWEFZQ0lyQ0VaZklCRkdFQk1BRUNCRHRETUlBU0VNQUVBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQUFLQ0lKQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NHTUFFQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQUFLQ05KQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NGTUFFQUtEQkJCRE1JQUFLQ1RKUktNR1hHWEdYR1hHWEFZQ0tyZklCRkdFQk1BRUNCRHRETUk4d1NFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJBWUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSFlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSTh3QUtDSUpBZURlQkpBWUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIWUNFV0N4a1VVQkpEQkVCQVlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUk4d0FLQ05KQWVEZUJKQVlDeCtZVVVCSjJCQkpSS1NGTUFFQUtEQkJCRE1JOHdBS0NUSlJLTUFJQ29CSlJFQUlDVUZKQU05TFFGQUVSSUFPQUtsQy9mQjlMUUJNTUdYQUVBTTlQUUJBRUNFclJJRVhHWEFPQUtsQ2k5UFFCQ0JSS1NPTUFtQUVKUllHWEdYR1hHWEdYQVRBRUNLckoyQkJBSUNLWnJDRVpmSUJGR0VCTUFZQ0JEdERNSUJTRU1BWUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQVlBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQVlBS0RCQkJETUlCQUtDVEpSS01BSUNHSlJJQUVDVEpIRUFNOUpRQk1NR1hBSzlGUUJBS1JUQXRDRkpIdENJNlFHU0ZNTUNCUktTRU1HWEFNOUZRQkFMQ1VHSkFiSlJFQUxBYkpEQkdCUmVDQlJZRVhBRUFMQ1UvQ0JKQVlKSElEQklCSGRDRkQ5dEFkQ0ZEYkhQRDlPRDloRDlSSGRBSUFNSkRCSUJIOFpDRkQ5dEE4WkFQRDlPRDloRDlSSDhaRFFCVEZ0R21FWUlQTGRLZU9uSHBBSUFRSkRCSUJIeUNGRDl0QXlBUEQ5T0Q5aEQ5Ukh5QUlBU0pEQklCSDhjQ0ZEOXRBOGNBUEQ5T0Q5aEQ5Ukg4Y0RRQlRGdEdtRVlJUExkS2VPbkg4ZERRQkZUdEdFbVlJTFBkS09lbkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VBZUQ5dUhlRHlCakdCQUVBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQXBBOGREUU5WaThaY01weVNROGM4ZGZiOGU4ZkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFkQThaRFFOaVY4WmNwTXlTOGNROGRmOGViOGZIZEF5QThjRFFOaVY4WmNwTXlTOGNROGRmOGViOGZIOFpEUUJGVHRHRW1ZSUxQZEtPZW5IUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBZEE4WkRRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pSRUFZQ1RKSFlBTTlKUUJNTUFiQ0lKSGJBRzlKUUJNTUFCQVZBRzlzSkFMQ1VHSkFjQUc5cy84Y0JCQUxBTENVR0pBY0NhSkFHOXNKQUcvOGNCQk1BY0NCQUt5QVZKUlZBS1FCTUM5K1JLU0ZNQ0JDOTlBT0FLbEFHQ0FBR0NBOUx5NnlSS01BTENVL0tCSjhrVVVVVUJBS01OQlQrQlVVVUJNK0ttRlRhOGpVVVVVQkNvRmxITDhrVVVVVUJDOStSS0dYQUZDRTl1SE9DdEpBSTlMUUJDYVJLQUUyQkJITkMvd0ZaQy9nRjlIUUJBTkNiWkhWQ0Y5TFFCQUxDb0JKQ2dGQ1VGLzhNQkFMQzg0SmhhODNFQkFMQzh3SmhhODNFQkFMQzhvSmhhODNFQkFMQ0FKaGE4M0VCQUxDaUpoYTgzRUJBTENUSmhhODNFQkFMaGE4M0VOQUxoYTgzRUJBRUFJSkM5d0pSY0FFQ0ZKSE5BT0pSTUdYQUY5RlFCQ1FDYkFWQ0Y2eVJTQUJSRUNCUlZDQlJRQ0JSZkNCUklDQlJLRVhHWEFNQWN1UUJDOStSS1NFTUdYR1hBTjJCQkhPQy92RjlMUUJBTENvQkpBT0NJckNhOXpBS0pDYlpDRVdKSGI4b0dJUlRBYjhvR0JSdEdYQU9DYlpIYkFTOVBRQkFMQU9DYTl6QUlKQ2JaQ0dXSjhvR0JBVkFieVJPQWI5RlJiR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFPODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQU9qR0JBRUNJSkFUakdCTUFWQWJKUlZBTENvQkpBS0NFV0pIbUFPakdCQW1BVGpHSUFMQUlDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhUQXRqR0JBVEFPakdJQUlBYkpSSUFLQ0ZKUktTR01HWEdYQWJDYjZRQkFRQWJKQWJDOTg5ekpDRkpSUVNGTUFNMUJCSGJDZ0ZaUk9HWEdYQWJDYTlNUUJBTUNGSlJNU0ZNQU0xQkZIYkNnQlpDT1dBT0NnQlpxUk9HWEFiQ2E5TVFCQU1DR0pSTVNGTUFNMUJHSGJDZ0JaQ2ZXQU9xUk9HWEFiQ2E5TVFCQU1DRUpSTVNGTUFNMUJFSGJDZ0JaQ2RXQU9xUk9HWEFiQ2E5TVFCQU1DSUpSTVNGTUFNMkJJQzhjV0FPcVJPQU1DTEpSTU1BT0NGckNCQU9DRlpsOXpBUUpSUU1HWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQVE4N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBUWpHQkFFQ0lKQVRqR0JNQUxDb0JKQUtDRVdKSE9BUWpHQkFPQVRqR0lBTEFJQ0dXSkFRakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIT0F0akdCQU9BUWpHSUFJQ0ZKUklBS0NGSlJLU0ZNR1hBT0NERjlMUUJBTEFJQWNBT0NiWkoyQkJIYkNJckhUbENiWkNHV0o4b0dCQVZDRkpIdEFUeVJPQUxBSUFibENiWkNHV0o4b0dCQXRBVDlGSG1KSHRBYkNiWkhUeVJiQVQ5RlJUR1hHWEFHQ0c5SFFCQUJBVjg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVmpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQUlDR1dKQVZqR0JBTENvQkpBS0NFV0pIWUFPakdCQVlBVmpHSUFMQUlDRkpISUNiWkNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUFtSkNiWkhJQ0dXSkFiakdCQUxDb0JKQUtDR0pDYlpIS0NFV0pIT0FWakdCQU9BYmpHSUFLQ0ZKUktBSUFUSlJJQXRBVEpSVlNGTUFWQ0JBTTJCQkhZeUhUQU9DLytGNkhQSlJPQVlDYlpSdEdYR1hBWUNJckhtUUJBT0NGSlJiU0ZNQU9SYkFMQUlBbWxDYlpDR1dKOG9HQlJPTUdYR1hBdFFCQWJDRkpSVlNGTUFiUlZBTEFJQVlsQ2JaQ0dXSjhvR0JSYk1HWEdYQVA5RlFCQU1DRkpSWVNGTUFNMUJGSFlDZ0ZaUlRHWEdYQVlDYTlNUUJBTUNHSlJZU0ZNQU0xQkdIWUNnQlpDT1dBVENnQlpxUlRHWEFZQ2E5TVFCQU1DRUpSWVNGTUFNMUJFSFlDZ0JaQ2ZXQVRxUlRHWEFZQ2E5TVFCQU1DSUpSWVNGTUFNMUJJSFlDZ0JaQ2RXQVRxUlRHWEFZQ2E5TVFCQU1DTEpSWVNGTUFNQ0tKUllBTTJCTEM4Y1dBVHFSVE1BVENGckNCQVRDRlpsOXpBUUpIUVJUTUdYR1hBbUNiNlFCQVlSUFNGTUFZMUJCSE1DZ0ZaUk9HWEdYQU1DYTlNUUJBWUNGSlJQU0ZNQVkxQkZITUNnQlpDT1dBT0NnQlpxUk9HWEFNQ2E5TVFCQVlDR0pSUFNGTUFZMUJHSE1DZ0JaQ2ZXQU9xUk9HWEFNQ2E5TVFCQVlDRUpSUFNGTUFZMUJFSE1DZ0JaQ2RXQU9xUk9HWEFNQ2E5TVFCQVlDSUpSUFNGTUFZQ0xKUlBBWTJCSUM4Y1dBT3FST01BT0NGckNCQU9DRlpsOXpBUUpIUVJPTUdYR1hBdENiNlFCQVBSTVNGTUFQMUJCSE1DZ0ZaUmJHWEdYQU1DYTlNUUJBUENGSlJNU0ZNQVAxQkZITUNnQlpDT1dBYkNnQlpxUmJHWEFNQ2E5TVFCQVBDR0pSTVNGTUFQMUJHSE1DZ0JaQ2ZXQWJxUmJHWEFNQ2E5TVFCQVBDRUpSTVNGTUFQMUJFSE1DZ0JaQ2RXQWJxUmJHWEFNQ2E5TVFCQVBDSUpSTVNGTUFQQ0xKUk1BUDJCSUM4Y1dBYnFSYk1BYkNGckNCQWJDRlpsOXpBUUpIUVJiTUdYR1hBR0NHOUhRQkFCQVQ4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVRqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTENvQkpBS0NFV0pIWUFPakdCQVlBVGpHSUFMQUlDR1dKQVRqR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlDRkpISUNiWkNHV0pBT2pHQkFMQ29CSkFLQ0dKQ2JaQ0VXSkhPQVRqR0JBT0FiakdJQUxBSUFtOUZBbUNiNnFKSElDYlpDR1dKQWJqR0JBSUF0OUZBdENiNnFKUklBS0NFSlJLTUFOQ0ZKUk5BQkNLSlJCQUVDU0pSRUFLQ2JaUktBSUNiWlJJQWZDRUpIZkFGOUpRQk1NQ0JDOTlBTUFjNnlSS01BTENvRko4a1VVVVVCQUtNL3RJRkdhOGpVVVVVQkNUbFJMQzkrUktHWEFGQ0xKQUk5TFFCQ2FSS0FFMkJCQy8rRlpDL1FGOUhRQkFMaEI4M0VOQUVDRkpSS0FFQUlKQzk4SlJFR1hBRjlGUUJHWEFHQ0c2UUJFWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BTENOSkFJQ0ZaQ0dXcUhHQUlDR3JDQkFJQ0ZyQ0ZabDl6QUc4b0dCSkhJakdCQUJBSWpHQkFCQ0lKUkJBRkNhSkhGUUJTR01NRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUJBSUNHckNCQUlDRnJDRlpsOXpBTENOSkFJQ0ZaQ0dXcUhJOG9HQkpIRzg3RkJBSUFHakdCQUJDR0pSQkFGQ2FKSEZRQk1NQ0JDOTlBS0FFNnlSS01BS00vZExFSzk3RmFGOTdHWEdYQUdDSTlIUUJBRjlGUUZDQlJHRVhBQkFCREJCQkhFQ2lEK3JGQ2lEK3NGRC82RkhJQUVDTkQrckZDaUQrc0ZELzZGQUlEL2dGQUVDVEQrckZDaUQrc0ZELzZGSExEL2dGRC9rRkQvbEZIS0NCRHREKzJGSE9BSUNVVVVVOTREdEhORDlPRDlSRC9rRkhJOURCQi8raERZQUlBSUQvbUZBS0FLRC9tRkFMQU9BTEFORDlPRDlSRC9rRkhJQUlEL21GRC9rRkQva0ZEL2pGRC9uRkhMRC9tRjlEQkJYOUxEWUhPRC9rRkNnRkR0RDlPQUVDVVVVOTREdEQ5T0Q5UUFJQUxEL21GQU9EL2tGQ05EK3JGQ1UvK0VEdEQ5T0Q5UUFLQUxEL21GQU9EL2tGQ1REK3JGQ1VVLzhPRHREOU9EOVFETUJCQUJDVEpSQkFHQ0lKSEdBRjlKUUJTR01NQUY5RlFCQ0JSR0VYQUJDVEpIVkFWREJCQkhFQ0JEdEhPQ1VVOThEOGNGQ1VVOThEOGNFSE5EOU9BQkRCQkJIS0FFRFFJTEtPU1FmYlBkZW44YzhkOGU4ZkNnZ0ZEdEQ5T0QvNkZBS0FFRFFCRkdFTlZjTVR0bVlpOFpweUhFQ1REK3NGRC82RkhJRC9nRkFFQ1REK3JGQ1REK3NGRC82RkhMRC9nRkQva0ZEL2xGSEU5REIvK2c2RFlBTEFFQU9EKzJGSE9BTENVVVVVOTREdEhjRDlPRDlSRC9rRkhMQUxEL21GQUVBRUQvbUZBSUFPQUlBY0Q5T0Q5UkQva0ZIRUFFRC9tRkQva0ZEL2tGRC9qRkQvbkZISUQvbUY5REJCWDlMRFlIT0Qva0ZDVEQrckZBTEFJRC9tRkFPRC9rRkNnZ0VEdEQ5T0Q5UUhMQUVBSUQvbUZBT0Qva0ZDYURiQ0JEbkdDQkRuRUNCRG5LQ0JEbk9DQkRuY0NCRG5NQ0JEbmZDQkRuYkQ5T0hFRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZEOVFETUJCQUJBS0FORDlPQUxBRURRQkZUdEdFbVlJTFBkS09lbkQ5UURNQkJBQkNBSlJCQUdDSUpIR0FGOUpRQk1NTS9oRUlHYUY5N0ZhTDk3OGpVVVVVQkNUbFJFR1hBRjlGUUJDQlJJRVhBRUFCREJCQkhMQUJDVEpIS0RCQkJIT0RRSUxLT1NRZmJQZGVuOGM4ZDhlOGZITkNURCtzRkhWQ0lEK3JGRE1JQkFCOURCQlU4L0RZOUQvekk4MTgvRFlBVkNFRHREOVFELzZGRC9uRkhWQUxBT0RRQkZHRU5WY01UdG1ZaThacHlITENURCtyRkNURCtzRkQvNkZEL21GSE9BT0QvbUZBVkFMQ1REK3NGRC82RkQvbUZIY0FjRC9tRkFWQU5DVEQrckZDVEQrc0ZELzZGRC9tRkhOQU5EL21GRC9rRkQva0ZEL2xGQ0JEdEQrNEZEL2pGOURCLytnNkRZSFZEL21GOURCQlg5TERZSExEL2tGQ2dnRUR0SE1EOU9BY0FWRC9tRkFMRC9rRkNURCtyRkQ5UUhjQU5BVkQvbUZBTEQva0ZDVEQrckZBT0FWRC9tRkFMRC9rRkFNRDlPRDlRSFZEUUJGVHRHRW1ZSUxQZEtPZW5ITEQ4ZEJBRURCSUJEeUIrdCtKODNFQkFCQ05KQUxEOGRGQUVEQklCRHlGK3QrSjgzRUJBS0FjQVZEUU5WaThaY01weVNROGM4ZGZiOGU4ZkhWRDhkQkFFREJJQkR5Ryt0K0o4M0VCQUJDaUpBVkQ4ZEZBRURCSUJEeUUrdCtKODNFQkFCQ0FKUkJBSUNJSkhJQUY5SlFCTU1NOWpGRjk3R1hBR0NHckFGOXNIRzlGUUJDQlJGRVhBQkFCREJCQkhFQ05EK3JGQ05EK3NGRC82RkFFQ2lEK3NGQ25EK3JGQ1VVVS84RUR0RCt1RkQvbUZETUJCQUJDVEpSQkFGQ0lKSEZBRzlKUUJNTU05VEZFYUNCQ0I4b0dVa1VVQkhGQUJDRUpDOThaSkhCakdVa1VVQkdYR1hBQjgvQkNUV0hHdVFCQ2FSRUFCQUdsQ2dnRUpDVHJYQkNhNlFGTUFGUkVNQUVNTU1GQkNVTk1JVDl0QkJcIjtcbiAgY29uc3QgZGV0ZWN0b3IgPSBuZXcgVWludDhBcnJheShbXG4gICAgMCxcbiAgICA5NyxcbiAgICAxMTUsXG4gICAgMTA5LFxuICAgIDEsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMSxcbiAgICA0LFxuICAgIDEsXG4gICAgOTYsXG4gICAgMCxcbiAgICAwLFxuICAgIDMsXG4gICAgMyxcbiAgICAyLFxuICAgIDAsXG4gICAgMCxcbiAgICA1LFxuICAgIDMsXG4gICAgMSxcbiAgICAwLFxuICAgIDEsXG4gICAgMTIsXG4gICAgMSxcbiAgICAwLFxuICAgIDEwLFxuICAgIDIyLFxuICAgIDIsXG4gICAgMTIsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICAyNTIsXG4gICAgMTAsXG4gICAgMCxcbiAgICAwLFxuICAgIDExLFxuICAgIDcsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDI1MyxcbiAgICAxNSxcbiAgICAyNixcbiAgICAxMVxuICBdKTtcbiAgY29uc3Qgd2FzbXBhY2sgPSBuZXcgVWludDhBcnJheShbXG4gICAgMzIsXG4gICAgMCxcbiAgICA2NSxcbiAgICAyNTMsXG4gICAgMyxcbiAgICAxLFxuICAgIDIsXG4gICAgMzQsXG4gICAgNCxcbiAgICAxMDYsXG4gICAgNixcbiAgICA1LFxuICAgIDExLFxuICAgIDgsXG4gICAgNyxcbiAgICAyMCxcbiAgICAxMyxcbiAgICAzMyxcbiAgICAxMixcbiAgICAxNixcbiAgICAxMjgsXG4gICAgOSxcbiAgICAxMTYsXG4gICAgNjQsXG4gICAgMTksXG4gICAgMTEzLFxuICAgIDEyNyxcbiAgICAxNSxcbiAgICAxMCxcbiAgICAyMSxcbiAgICAyMixcbiAgICAxNCxcbiAgICAyNTUsXG4gICAgNjYsXG4gICAgMjQsXG4gICAgNTQsXG4gICAgMTM2LFxuICAgIDEwNyxcbiAgICAxOCxcbiAgICAyMyxcbiAgICAxOTIsXG4gICAgMjYsXG4gICAgMTE0LFxuICAgIDExOCxcbiAgICAxMzIsXG4gICAgMTcsXG4gICAgNzcsXG4gICAgMTAxLFxuICAgIDEzMCxcbiAgICAxNDQsXG4gICAgMjcsXG4gICAgODcsXG4gICAgMTMxLFxuICAgIDQ0LFxuICAgIDQ1LFxuICAgIDc0LFxuICAgIDE1NixcbiAgICAxNTQsXG4gICAgNzAsXG4gICAgMTY3XG4gIF0pO1xuICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1cHBvcnRlZDogZmFsc2VcbiAgICB9O1xuICB9XG4gIGxldCB3YXNtID0gd2FzbV9iYXNlO1xuICBpZiAoV2ViQXNzZW1ibHkudmFsaWRhdGUoZGV0ZWN0b3IpKSB7XG4gICAgd2FzbSA9IHdhc21fc2ltZDtcbiAgfVxuICBsZXQgaW5zdGFuY2U7XG4gIGNvbnN0IHByb21pc2UgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh1bnBhY2sod2FzbSksIHt9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICBpbnN0YW5jZSA9IHJlc3VsdC5pbnN0YW5jZTtcbiAgICBpbnN0YW5jZS5leHBvcnRzLl9fd2FzbV9jYWxsX2N0b3JzKCk7XG4gIH0pO1xuICBmdW5jdGlvbiB1bnBhY2soZGF0YSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgcmVzdWx0W2ldID0gY2ggPiA5NiA/IGNoIC0gNzEgOiBjaCA+IDY0ID8gY2ggLSA2NSA6IGNoID4gNDcgPyBjaCArIDQgOiBjaCA+IDQ2ID8gNjMgOiA2MjtcbiAgICB9XG4gICAgbGV0IHdyaXRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlc3VsdFt3cml0ZSsrXSA9IHJlc3VsdFtpXSA8IDYwID8gd2FzbXBhY2tbcmVzdWx0W2ldXSA6IChyZXN1bHRbaV0gLSA2MCkgKiA2NCArIHJlc3VsdFsrK2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmJ1ZmZlci5zbGljZSgwLCB3cml0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlKGZ1biwgdGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBzYnJrID0gaW5zdGFuY2UuZXhwb3J0cy5zYnJrO1xuICAgIGNvbnN0IGNvdW50NCA9IGNvdW50ICsgMyAmIH4zO1xuICAgIGNvbnN0IHRwID0gc2Jyayhjb3VudDQgKiBzaXplKTtcbiAgICBjb25zdCBzcCA9IHNicmsoc291cmNlLmxlbmd0aCk7XG4gICAgY29uc3QgaGVhcCA9IG5ldyBVaW50OEFycmF5KGluc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcik7XG4gICAgaGVhcC5zZXQoc291cmNlLCBzcCk7XG4gICAgY29uc3QgcmVzID0gZnVuKHRwLCBjb3VudCwgc2l6ZSwgc3AsIHNvdXJjZS5sZW5ndGgpO1xuICAgIGlmIChyZXMgPT09IDAgJiYgZmlsdGVyKSB7XG4gICAgICBmaWx0ZXIodHAsIGNvdW50NCwgc2l6ZSk7XG4gICAgfVxuICAgIHRhcmdldC5zZXQoaGVhcC5zdWJhcnJheSh0cCwgdHAgKyBjb3VudCAqIHNpemUpKTtcbiAgICBzYnJrKHRwIC0gc2JyaygwKSk7XG4gICAgaWYgKHJlcyAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYWxmb3JtZWQgYnVmZmVyIGRhdGE6ICR7cmVzfWApO1xuICAgIH1cbiAgfVxuICBjb25zdCBmaWx0ZXJzID0ge1xuICAgIC8vIGxlZ2FjeSBpbmRleC1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIDA6IFwiXCIsXG4gICAgMTogXCJtZXNob3B0X2RlY29kZUZpbHRlck9jdFwiLFxuICAgIDI6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJRdWF0XCIsXG4gICAgMzogXCJtZXNob3B0X2RlY29kZUZpbHRlckV4cFwiLFxuICAgIC8vIHN0cmluZy1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIE5PTkU6IFwiXCIsXG4gICAgT0NUQUhFRFJBTDogXCJtZXNob3B0X2RlY29kZUZpbHRlck9jdFwiLFxuICAgIFFVQVRFUk5JT046IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJRdWF0XCIsXG4gICAgRVhQT05FTlRJQUw6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJFeHBcIlxuICB9O1xuICBjb25zdCBkZWNvZGVycyA9IHtcbiAgICAvLyBsZWdhY3kgaW5kZXgtYmFzZWQgZW51bXMgZm9yIGdsVEZcbiAgICAwOiBcIm1lc2hvcHRfZGVjb2RlVmVydGV4QnVmZmVyXCIsXG4gICAgMTogXCJtZXNob3B0X2RlY29kZUluZGV4QnVmZmVyXCIsXG4gICAgMjogXCJtZXNob3B0X2RlY29kZUluZGV4U2VxdWVuY2VcIixcbiAgICAvLyBzdHJpbmctYmFzZWQgZW51bXMgZm9yIGdsVEZcbiAgICBBVFRSSUJVVEVTOiBcIm1lc2hvcHRfZGVjb2RlVmVydGV4QnVmZmVyXCIsXG4gICAgVFJJQU5HTEVTOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXJcIixcbiAgICBJTkRJQ0VTOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZVwiXG4gIH07XG4gIGdlbmVyYXRlZCA9IHtcbiAgICByZWFkeTogcHJvbWlzZSxcbiAgICBzdXBwb3J0ZWQ6IHRydWUsXG4gICAgZGVjb2RlVmVydGV4QnVmZmVyKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSwgZmlsdGVyKSB7XG4gICAgICBkZWNvZGUoXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXIsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY291bnQsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0c1tmaWx0ZXJzW2ZpbHRlcl1dXG4gICAgICApO1xuICAgIH0sXG4gICAgZGVjb2RlSW5kZXhCdWZmZXIodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKSB7XG4gICAgICBkZWNvZGUoaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZUluZGV4QnVmZmVyLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpO1xuICAgIH0sXG4gICAgZGVjb2RlSW5kZXhTZXF1ZW5jZSh0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpIHtcbiAgICAgIGRlY29kZShpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZSwgdGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKTtcbiAgICB9LFxuICAgIGRlY29kZUdsdGZCdWZmZXIodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlLCBtb2RlLCBmaWx0ZXIpIHtcbiAgICAgIGRlY29kZShcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0c1tkZWNvZGVyc1ttb2RlXV0sXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY291bnQsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0c1tmaWx0ZXJzW2ZpbHRlcl1dXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGdlbmVyYXRlZDtcbn07XG5leHBvcnQge1xuICBNZXNob3B0RGVjb2RlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hvcHREZWNvZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdlbmVyYXRlZCIsIk1lc2hvcHREZWNvZGVyIiwid2FzbV9iYXNlIiwid2FzbV9zaW1kIiwiZGV0ZWN0b3IiLCJVaW50OEFycmF5Iiwid2FzbXBhY2siLCJXZWJBc3NlbWJseSIsInN1cHBvcnRlZCIsIndhc20iLCJ2YWxpZGF0ZSIsImluc3RhbmNlIiwicHJvbWlzZSIsImluc3RhbnRpYXRlIiwidW5wYWNrIiwidGhlbiIsInJlc3VsdCIsImV4cG9ydHMiLCJfX3dhc21fY2FsbF9jdG9ycyIsImRhdGEiLCJsZW5ndGgiLCJpIiwiY2giLCJjaGFyQ29kZUF0Iiwid3JpdGUiLCJidWZmZXIiLCJzbGljZSIsImRlY29kZSIsImZ1biIsInRhcmdldCIsImNvdW50Iiwic2l6ZSIsInNvdXJjZSIsImZpbHRlciIsInNicmsiLCJjb3VudDQiLCJ0cCIsInNwIiwiaGVhcCIsIm1lbW9yeSIsInNldCIsInJlcyIsInN1YmFycmF5IiwiRXJyb3IiLCJmaWx0ZXJzIiwiTk9ORSIsIk9DVEFIRURSQUwiLCJRVUFURVJOSU9OIiwiRVhQT05FTlRJQUwiLCJkZWNvZGVycyIsIkFUVFJJQlVURVMiLCJUUklBTkdMRVMiLCJJTkRJQ0VTIiwicmVhZHkiLCJkZWNvZGVWZXJ0ZXhCdWZmZXIiLCJtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlciIsImRlY29kZUluZGV4QnVmZmVyIiwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlciIsImRlY29kZUluZGV4U2VxdWVuY2UiLCJtZXNob3B0X2RlY29kZUluZGV4U2VxdWVuY2UiLCJkZWNvZGVHbHRmQnVmZmVyIiwibW9kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.decoderPath = \"\";\n        this.decoderConfig = {};\n        this.decoderBinary = null;\n        this.decoderPending = null;\n        this.workerLimit = 4;\n        this.workerPool = [];\n        this.workerNextTaskID = 1;\n        this.workerSourceURL = \"\";\n        this.defaultAttributeIDs = {\n            position: \"POSITION\",\n            normal: \"NORMAL\",\n            color: \"COLOR\",\n            uv: \"TEX_COORD\"\n        };\n        this.defaultAttributeTypes = {\n            position: \"Float32Array\",\n            normal: \"Float32Array\",\n            color: \"Float32Array\",\n            uv: \"Float32Array\"\n        };\n    }\n    setDecoderPath(path) {\n        this.decoderPath = path;\n        return this;\n    }\n    setDecoderConfig(config) {\n        this.decoderConfig = config;\n        return this;\n    }\n    setWorkerLimit(workerLimit) {\n        this.workerLimit = workerLimit;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, (buffer)=>{\n            const taskConfig = {\n                attributeIDs: this.defaultAttributeIDs,\n                attributeTypes: this.defaultAttributeTypes,\n                useUniqueIDs: false\n            };\n            this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n        }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */ decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n        const taskConfig = {\n            attributeIDs: attributeIDs || this.defaultAttributeIDs,\n            attributeTypes: attributeTypes || this.defaultAttributeTypes,\n            useUniqueIDs: !!attributeIDs\n        };\n        this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n    decodeGeometry(buffer, taskConfig) {\n        for(const attribute in taskConfig.attributeTypes){\n            const type = taskConfig.attributeTypes[attribute];\n            if (type.BYTES_PER_ELEMENT !== void 0) {\n                taskConfig.attributeTypes[attribute] = type.name;\n            }\n        }\n        const taskKey = JSON.stringify(taskConfig);\n        if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer);\n            if (cachedTask.key === taskKey) {\n                return cachedTask.promise;\n            } else if (buffer.byteLength === 0) {\n                throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n            }\n        }\n        let worker;\n        const taskID = this.workerNextTaskID++;\n        const taskCost = buffer.byteLength;\n        const geometryPending = this._getWorker(taskID, taskCost).then((_worker)=>{\n            worker = _worker;\n            return new Promise((resolve, reject)=>{\n                worker._callbacks[taskID] = {\n                    resolve,\n                    reject\n                };\n                worker.postMessage({\n                    type: \"decode\",\n                    id: taskID,\n                    taskConfig,\n                    buffer\n                }, [\n                    buffer\n                ]);\n            });\n        }).then((message)=>this._createGeometry(message.geometry));\n        geometryPending.catch(()=>true).then(()=>{\n            if (worker && taskID) {\n                this._releaseTask(worker, taskID);\n            }\n        });\n        _taskCache.set(buffer, {\n            key: taskKey,\n            promise: geometryPending\n        });\n        return geometryPending;\n    }\n    _createGeometry(geometryData) {\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        if (geometryData.index) {\n            geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n        }\n        for(let i = 0; i < geometryData.attributes.length; i++){\n            const attribute = geometryData.attributes[i];\n            const name = attribute.name;\n            const array = attribute.array;\n            const itemSize = attribute.itemSize;\n            geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n        }\n        return geometry;\n    }\n    _loadLibrary(url, responseType) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.decoderPath);\n        loader.setResponseType(responseType);\n        loader.setWithCredentials(this.withCredentials);\n        return new Promise((resolve, reject)=>{\n            loader.load(url, resolve, void 0, reject);\n        });\n    }\n    preload() {\n        this._initDecoder();\n        return this;\n    }\n    _initDecoder() {\n        if (this.decoderPending) return this.decoderPending;\n        const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n        const librariesPending = [];\n        if (useJS) {\n            librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n        } else {\n            librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n            librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n        }\n        this.decoderPending = Promise.all(librariesPending).then((libraries)=>{\n            const jsContent = libraries[0];\n            if (!useJS) {\n                this.decoderConfig.wasmBinary = libraries[1];\n            }\n            const fn = DRACOWorker.toString();\n            const body = [\n                \"/* draco decoder */\",\n                jsContent,\n                \"\",\n                \"/* worker */\",\n                fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n            ].join(\"\\n\");\n            this.workerSourceURL = URL.createObjectURL(new Blob([\n                body\n            ]));\n        });\n        return this.decoderPending;\n    }\n    _getWorker(taskID, taskCost) {\n        return this._initDecoder().then(()=>{\n            if (this.workerPool.length < this.workerLimit) {\n                const worker2 = new Worker(this.workerSourceURL);\n                worker2._callbacks = {};\n                worker2._taskCosts = {};\n                worker2._taskLoad = 0;\n                worker2.postMessage({\n                    type: \"init\",\n                    decoderConfig: this.decoderConfig\n                });\n                worker2.onmessage = function(e) {\n                    const message = e.data;\n                    switch(message.type){\n                        case \"decode\":\n                            worker2._callbacks[message.id].resolve(message);\n                            break;\n                        case \"error\":\n                            worker2._callbacks[message.id].reject(message);\n                            break;\n                        default:\n                            console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n                    }\n                };\n                this.workerPool.push(worker2);\n            } else {\n                this.workerPool.sort(function(a, b) {\n                    return a._taskLoad > b._taskLoad ? -1 : 1;\n                });\n            }\n            const worker = this.workerPool[this.workerPool.length - 1];\n            worker._taskCosts[taskID] = taskCost;\n            worker._taskLoad += taskCost;\n            return worker;\n        });\n    }\n    _releaseTask(worker, taskID) {\n        worker._taskLoad -= worker._taskCosts[taskID];\n        delete worker._callbacks[taskID];\n        delete worker._taskCosts[taskID];\n    }\n    debug() {\n        console.log(\"Task load: \", this.workerPool.map((worker)=>worker._taskLoad));\n    }\n    dispose() {\n        for(let i = 0; i < this.workerPool.length; ++i){\n            this.workerPool[i].terminate();\n        }\n        this.workerPool.length = 0;\n        return this;\n    }\n}\nfunction DRACOWorker() {\n    let decoderConfig;\n    let decoderPending;\n    onmessage = function(e) {\n        const message = e.data;\n        switch(message.type){\n            case \"init\":\n                decoderConfig = message.decoderConfig;\n                decoderPending = new Promise(function(resolve) {\n                    decoderConfig.onModuleLoaded = function(draco) {\n                        resolve({\n                            draco\n                        });\n                    };\n                    DracoDecoderModule(decoderConfig);\n                });\n                break;\n            case \"decode\":\n                const buffer = message.buffer;\n                const taskConfig = message.taskConfig;\n                decoderPending.then((module)=>{\n                    const draco = module.draco;\n                    const decoder = new draco.Decoder();\n                    const decoderBuffer = new draco.DecoderBuffer();\n                    decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n                    try {\n                        const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n                        const buffers = geometry.attributes.map((attr)=>attr.array.buffer);\n                        if (geometry.index) buffers.push(geometry.index.array.buffer);\n                        self.postMessage({\n                            type: \"decode\",\n                            id: message.id,\n                            geometry\n                        }, buffers);\n                    } catch (error) {\n                        console.error(error);\n                        self.postMessage({\n                            type: \"error\",\n                            id: message.id,\n                            error: error.message\n                        });\n                    } finally{\n                        draco.destroy(decoderBuffer);\n                        draco.destroy(decoder);\n                    }\n                });\n                break;\n        }\n    };\n    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n        const attributeIDs = taskConfig.attributeIDs;\n        const attributeTypes = taskConfig.attributeTypes;\n        let dracoGeometry;\n        let decodingStatus;\n        const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            dracoGeometry = new draco.Mesh();\n            decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n        } else if (geometryType === draco.POINT_CLOUD) {\n            dracoGeometry = new draco.PointCloud();\n            decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n        } else {\n            throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n        }\n        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n            throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n        }\n        const geometry = {\n            index: null,\n            attributes: []\n        };\n        for(const attributeName in attributeIDs){\n            const attributeType = self[attributeTypes[attributeName]];\n            let attribute;\n            let attributeID;\n            if (taskConfig.useUniqueIDs) {\n                attributeID = attributeIDs[attributeName];\n                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n            } else {\n                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n                if (attributeID === -1) continue;\n                attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n            }\n            geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n        }\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n        }\n        draco.destroy(dracoGeometry);\n        return geometry;\n    }\n    function decodeIndex(draco, decoder, dracoGeometry) {\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * 4;\n        const ptr = draco._malloc(byteLength);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        return {\n            array: index,\n            itemSize: 1\n        };\n    }\n    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n        const numComponents = attribute.num_components();\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(draco, attributeType);\n        const ptr = draco._malloc(byteLength);\n        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n        draco._free(ptr);\n        return {\n            name: attributeName,\n            array,\n            itemSize: numComponents\n        };\n    }\n    function getDracoDataType(draco, attributeType) {\n        switch(attributeType){\n            case Float32Array:\n                return draco.DT_FLOAT32;\n            case Int8Array:\n                return draco.DT_INT8;\n            case Int16Array:\n                return draco.DT_INT16;\n            case Int32Array:\n                return draco.DT_INT32;\n            case Uint8Array:\n                return draco.DT_UINT8;\n            case Uint16Array:\n                return draco.DT_UINT16;\n            case Uint32Array:\n                return draco.DT_UINT32;\n        }\n    }\n}\n //# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEU7QUFDNUUsTUFBTUksYUFBYSxhQUFhLEdBQUcsSUFBSUM7QUFDdkMsTUFBTUMsb0JBQW9CTix5Q0FBTUE7SUFDOUJPLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQztRQUN0QixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztZQUN6QkMsVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO1FBQ0EsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRztZQUMzQkosVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO0lBQ0Y7SUFDQUUsZUFBZUMsSUFBSSxFQUFFO1FBQ25CLElBQUksQ0FBQ2YsV0FBVyxHQUFHZTtRQUNuQixPQUFPLElBQUk7SUFDYjtJQUNBQyxpQkFBaUJDLE1BQU0sRUFBRTtRQUN2QixJQUFJLENBQUNoQixhQUFhLEdBQUdnQjtRQUNyQixPQUFPLElBQUk7SUFDYjtJQUNBQyxlQUFlZCxXQUFXLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO1FBQ25CLE9BQU8sSUFBSTtJQUNiO0lBQ0FlLEtBQUtDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxNQUFNQyxTQUFTLElBQUloQyw2Q0FBVUEsQ0FBQyxJ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QUtDO2dCQUNILE9BQU94RCxNQUFNeUQsUUFBUTtZQUN2QixLQUFLQztnQkFDSCxPQUFPMUQsTUFBTTJELFFBQVE7WUFDdkIsS0FBS0M7Z0JBQ0gsT0FBTzVELE1BQU02RCxTQUFTO1lBQ3hCLEtBQUt0QjtnQkFDSCxPQUFPdkMsTUFBTThELFNBQVM7UUFDMUI7SUFDRjtBQUNGO0FBR0UsQ0FDRix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmVhdGl2ZS00MDQvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanM/NzRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2FkZXIsIEZpbGVMb2FkZXIsIEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tIFwidGhyZWVcIjtcbmNvbnN0IF90YXNrQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIERSQUNPTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMuZGVjb2RlclBhdGggPSBcIlwiO1xuICAgIHRoaXMuZGVjb2RlckNvbmZpZyA9IHt9O1xuICAgIHRoaXMuZGVjb2RlckJpbmFyeSA9IG51bGw7XG4gICAgdGhpcy5kZWNvZGVyUGVuZGluZyA9IG51bGw7XG4gICAgdGhpcy53b3JrZXJMaW1pdCA9IDQ7XG4gICAgdGhpcy53b3JrZXJQb29sID0gW107XG4gICAgdGhpcy53b3JrZXJOZXh0VGFza0lEID0gMTtcbiAgICB0aGlzLndvcmtlclNvdXJjZVVSTCA9IFwiXCI7XG4gICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzID0ge1xuICAgICAgcG9zaXRpb246IFwiUE9TSVRJT05cIixcbiAgICAgIG5vcm1hbDogXCJOT1JNQUxcIixcbiAgICAgIGNvbG9yOiBcIkNPTE9SXCIsXG4gICAgICB1djogXCJURVhfQ09PUkRcIlxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMgPSB7XG4gICAgICBwb3NpdGlvbjogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIG5vcm1hbDogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIGNvbG9yOiBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgdXY6IFwiRmxvYXQzMkFycmF5XCJcbiAgICB9O1xuICB9XG4gIHNldERlY29kZXJQYXRoKHBhdGgpIHtcbiAgICB0aGlzLmRlY29kZXJQYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXREZWNvZGVyQ29uZmlnKGNvbmZpZykge1xuICAgIHRoaXMuZGVjb2RlckNvbmZpZyA9IGNvbmZpZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRXb3JrZXJMaW1pdCh3b3JrZXJMaW1pdCkge1xuICAgIHRoaXMud29ya2VyTGltaXQgPSB3b3JrZXJMaW1pdDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcbiAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgIGxvYWRlci5sb2FkKFxuICAgICAgdXJsLFxuICAgICAgKGJ1ZmZlcikgPT4ge1xuICAgICAgICBjb25zdCB0YXNrQ29uZmlnID0ge1xuICAgICAgICAgIGF0dHJpYnV0ZUlEczogdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzLFxuICAgICAgICAgIGF0dHJpYnV0ZVR5cGVzOiB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyxcbiAgICAgICAgICB1c2VVbmlxdWVJRHM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKS50aGVuKG9uTG9hZCkuY2F0Y2gob25FcnJvcik7XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIG9uRXJyb3JcbiAgICApO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBLZXB0IGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgRFJBQ09Mb2FkZXIgdmVyc2lvbnMuICovXG4gIGRlY29kZURyYWNvRmlsZShidWZmZXIsIGNhbGxiYWNrLCBhdHRyaWJ1dGVJRHMsIGF0dHJpYnV0ZVR5cGVzKSB7XG4gICAgY29uc3QgdGFza0NvbmZpZyA9IHtcbiAgICAgIGF0dHJpYnV0ZUlEczogYXR0cmlidXRlSURzIHx8IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxcbiAgICAgIGF0dHJpYnV0ZVR5cGVzOiBhdHRyaWJ1dGVUeXBlcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyxcbiAgICAgIHVzZVVuaXF1ZUlEczogISFhdHRyaWJ1dGVJRHNcbiAgICB9O1xuICAgIHRoaXMuZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKS50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICBkZWNvZGVHZW9tZXRyeShidWZmZXIsIHRhc2tDb25maWcpIHtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBpbiB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVdO1xuICAgICAgaWYgKHR5cGUuQllURVNfUEVSX0VMRU1FTlQgIT09IHZvaWQgMCkge1xuICAgICAgICB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzW2F0dHJpYnV0ZV0gPSB0eXBlLm5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRhc2tLZXkgPSBKU09OLnN0cmluZ2lmeSh0YXNrQ29uZmlnKTtcbiAgICBpZiAoX3Rhc2tDYWNoZS5oYXMoYnVmZmVyKSkge1xuICAgICAgY29uc3QgY2FjaGVkVGFzayA9IF90YXNrQ2FjaGUuZ2V0KGJ1ZmZlcik7XG4gICAgICBpZiAoY2FjaGVkVGFzay5rZXkgPT09IHRhc2tLZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFRhc2sucHJvbWlzZTtcbiAgICAgIH0gZWxzZSBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuRFJBQ09Mb2FkZXI6IFVuYWJsZSB0byByZS1kZWNvZGUgYSBidWZmZXIgd2l0aCBkaWZmZXJlbnQgc2V0dGluZ3MuIEJ1ZmZlciBoYXMgYWxyZWFkeSBiZWVuIHRyYW5zZmVycmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB3b3JrZXI7XG4gICAgY29uc3QgdGFza0lEID0gdGhpcy53b3JrZXJOZXh0VGFza0lEKys7XG4gICAgY29uc3QgdGFza0Nvc3QgPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBnZW9tZXRyeVBlbmRpbmcgPSB0aGlzLl9nZXRXb3JrZXIodGFza0lELCB0YXNrQ29zdCkudGhlbigoX3dvcmtlcikgPT4ge1xuICAgICAgd29ya2VyID0gX3dvcmtlcjtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHdvcmtlci5fY2FsbGJhY2tzW3Rhc2tJRF0gPSB7IHJlc29sdmUsIHJlamVjdCB9O1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImRlY29kZVwiLCBpZDogdGFza0lELCB0YXNrQ29uZmlnLCBidWZmZXIgfSwgW2J1ZmZlcl0pO1xuICAgICAgfSk7XG4gICAgfSkudGhlbigobWVzc2FnZSkgPT4gdGhpcy5fY3JlYXRlR2VvbWV0cnkobWVzc2FnZS5nZW9tZXRyeSkpO1xuICAgIGdlb21ldHJ5UGVuZGluZy5jYXRjaCgoKSA9PiB0cnVlKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICh3b3JrZXIgJiYgdGFza0lEKSB7XG4gICAgICAgIHRoaXMuX3JlbGVhc2VUYXNrKHdvcmtlciwgdGFza0lEKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGFza0NhY2hlLnNldChidWZmZXIsIHtcbiAgICAgIGtleTogdGFza0tleSxcbiAgICAgIHByb21pc2U6IGdlb21ldHJ5UGVuZGluZ1xuICAgIH0pO1xuICAgIHJldHVybiBnZW9tZXRyeVBlbmRpbmc7XG4gIH1cbiAgX2NyZWF0ZUdlb21ldHJ5KGdlb21ldHJ5RGF0YSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5RGF0YS5pbmRleCkge1xuICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgobmV3IEJ1ZmZlckF0dHJpYnV0ZShnZW9tZXRyeURhdGEuaW5kZXguYXJyYXksIDEpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeURhdGEuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXNbaV07XG4gICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlLm5hbWU7XG4gICAgICBjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKSk7XG4gICAgfVxuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBfbG9hZExpYnJhcnkodXJsLCByZXNwb25zZVR5cGUpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMuZGVjb2RlclBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUocmVzcG9uc2VUeXBlKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbG9hZGVyLmxvYWQodXJsLCByZXNvbHZlLCB2b2lkIDAsIHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgcHJlbG9hZCgpIHtcbiAgICB0aGlzLl9pbml0RGVjb2RlcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9pbml0RGVjb2RlcigpIHtcbiAgICBpZiAodGhpcy5kZWNvZGVyUGVuZGluZylcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZXJQZW5kaW5nO1xuICAgIGNvbnN0IHVzZUpTID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSBcIm9iamVjdFwiIHx8IHRoaXMuZGVjb2RlckNvbmZpZy50eXBlID09PSBcImpzXCI7XG4gICAgY29uc3QgbGlicmFyaWVzUGVuZGluZyA9IFtdO1xuICAgIGlmICh1c2VKUykge1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fZGVjb2Rlci5qc1wiLCBcInRleHRcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb193YXNtX3dyYXBwZXIuanNcIiwgXCJ0ZXh0XCIpKTtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIud2FzbVwiLCBcImFycmF5YnVmZmVyXCIpKTtcbiAgICB9XG4gICAgdGhpcy5kZWNvZGVyUGVuZGluZyA9IFByb21pc2UuYWxsKGxpYnJhcmllc1BlbmRpbmcpLnRoZW4oKGxpYnJhcmllcykgPT4ge1xuICAgICAgY29uc3QganNDb250ZW50ID0gbGlicmFyaWVzWzBdO1xuICAgICAgaWYgKCF1c2VKUykge1xuICAgICAgICB0aGlzLmRlY29kZXJDb25maWcud2FzbUJpbmFyeSA9IGxpYnJhcmllc1sxXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZuID0gRFJBQ09Xb3JrZXIudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IGJvZHkgPSBbXG4gICAgICAgIFwiLyogZHJhY28gZGVjb2RlciAqL1wiLFxuICAgICAgICBqc0NvbnRlbnQsXG4gICAgICAgIFwiXCIsXG4gICAgICAgIFwiLyogd29ya2VyICovXCIsXG4gICAgICAgIGZuLnN1YnN0cmluZyhmbi5pbmRleE9mKFwie1wiKSArIDEsIGZuLmxhc3RJbmRleE9mKFwifVwiKSlcbiAgICAgIF0uam9pbihcIlxcblwiKTtcbiAgICAgIHRoaXMud29ya2VyU291cmNlVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbYm9keV0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyUGVuZGluZztcbiAgfVxuICBfZ2V0V29ya2VyKHRhc2tJRCwgdGFza0Nvc3QpIHtcbiAgICByZXR1cm4gdGhpcy5faW5pdERlY29kZXIoKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLndvcmtlclBvb2wubGVuZ3RoIDwgdGhpcy53b3JrZXJMaW1pdCkge1xuICAgICAgICBjb25zdCB3b3JrZXIyID0gbmV3IFdvcmtlcih0aGlzLndvcmtlclNvdXJjZVVSTCk7XG4gICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICB3b3JrZXIyLl90YXNrQ29zdHMgPSB7fTtcbiAgICAgICAgd29ya2VyMi5fdGFza0xvYWQgPSAwO1xuICAgICAgICB3b3JrZXIyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJpbml0XCIsIGRlY29kZXJDb25maWc6IHRoaXMuZGVjb2RlckNvbmZpZyB9KTtcbiAgICAgICAgd29ya2VyMi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGUuZGF0YTtcbiAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRlY29kZVwiOlxuICAgICAgICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3NbbWVzc2FnZS5pZF0ucmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzW21lc3NhZ2UuaWRdLnJlamVjdChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5EUkFDT0xvYWRlcjogVW5leHBlY3RlZCBtZXNzYWdlLCBcIicgKyBtZXNzYWdlLnR5cGUgKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2VyUG9vbC5wdXNoKHdvcmtlcjIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3JrZXJQb29sLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLl90YXNrTG9hZCA+IGIuX3Rhc2tMb2FkID8gLTEgOiAxO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2VyUG9vbFt0aGlzLndvcmtlclBvb2wubGVuZ3RoIC0gMV07XG4gICAgICB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdID0gdGFza0Nvc3Q7XG4gICAgICB3b3JrZXIuX3Rhc2tMb2FkICs9IHRhc2tDb3N0O1xuICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9KTtcbiAgfVxuICBfcmVsZWFzZVRhc2sod29ya2VyLCB0YXNrSUQpIHtcbiAgICB3b3JrZXIuX3Rhc2tMb2FkIC09IHdvcmtlci5fdGFza0Nvc3RzW3Rhc2tJRF07XG4gICAgZGVsZXRlIHdvcmtlci5fY2FsbGJhY2tzW3Rhc2tJRF07XG4gICAgZGVsZXRlIHdvcmtlci5fdGFza0Nvc3RzW3Rhc2tJRF07XG4gIH1cbiAgZGVidWcoKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIlRhc2sgbG9hZDogXCIsXG4gICAgICB0aGlzLndvcmtlclBvb2wubWFwKCh3b3JrZXIpID0+IHdvcmtlci5fdGFza0xvYWQpXG4gICAgKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53b3JrZXJQb29sLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLndvcmtlclBvb2xbaV0udGVybWluYXRlKCk7XG4gICAgfVxuICAgIHRoaXMud29ya2VyUG9vbC5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBEUkFDT1dvcmtlcigpIHtcbiAgbGV0IGRlY29kZXJDb25maWc7XG4gIGxldCBkZWNvZGVyUGVuZGluZztcbiAgb25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG4gICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbml0XCI6XG4gICAgICAgIGRlY29kZXJDb25maWcgPSBtZXNzYWdlLmRlY29kZXJDb25maWc7XG4gICAgICAgIGRlY29kZXJQZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIGRlY29kZXJDb25maWcub25Nb2R1bGVMb2FkZWQgPSBmdW5jdGlvbihkcmFjbykge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IGRyYWNvIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgRHJhY29EZWNvZGVyTW9kdWxlKGRlY29kZXJDb25maWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVjb2RlXCI6XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG1lc3NhZ2UuYnVmZmVyO1xuICAgICAgICBjb25zdCB0YXNrQ29uZmlnID0gbWVzc2FnZS50YXNrQ29uZmlnO1xuICAgICAgICBkZWNvZGVyUGVuZGluZy50aGVuKChtb2R1bGUpID0+IHtcbiAgICAgICAgICBjb25zdCBkcmFjbyA9IG1vZHVsZS5kcmFjbztcbiAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IGRyYWNvLkRlY29kZXIoKTtcbiAgICAgICAgICBjb25zdCBkZWNvZGVyQnVmZmVyID0gbmV3IGRyYWNvLkRlY29kZXJCdWZmZXIoKTtcbiAgICAgICAgICBkZWNvZGVyQnVmZmVyLkluaXQobmV3IEludDhBcnJheShidWZmZXIpLCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZGVjb2RlR2VvbWV0cnkoZHJhY28sIGRlY29kZXIsIGRlY29kZXJCdWZmZXIsIHRhc2tDb25maWcpO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiBhdHRyLmFycmF5LmJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkuaW5kZXgpXG4gICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChnZW9tZXRyeS5pbmRleC5hcnJheS5idWZmZXIpO1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZGVjb2RlXCIsIGlkOiBtZXNzYWdlLmlkLCBnZW9tZXRyeSB9LCBidWZmZXJzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJlcnJvclwiLCBpZDogbWVzc2FnZS5pZCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGRyYWNvLmRlc3Ryb3koZGVjb2RlckJ1ZmZlcik7XG4gICAgICAgICAgICBkcmFjby5kZXN0cm95KGRlY29kZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZGVjb2RlR2VvbWV0cnkoZHJhY28sIGRlY29kZXIsIGRlY29kZXJCdWZmZXIsIHRhc2tDb25maWcpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVJRHMgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZUlEcztcbiAgICBjb25zdCBhdHRyaWJ1dGVUeXBlcyA9IHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXM7XG4gICAgbGV0IGRyYWNvR2VvbWV0cnk7XG4gICAgbGV0IGRlY29kaW5nU3RhdHVzO1xuICAgIGNvbnN0IGdlb21ldHJ5VHlwZSA9IGRlY29kZXIuR2V0RW5jb2RlZEdlb21ldHJ5VHlwZShkZWNvZGVyQnVmZmVyKTtcbiAgICBpZiAoZ2VvbWV0cnlUeXBlID09PSBkcmFjby5UUklBTkdVTEFSX01FU0gpIHtcbiAgICAgIGRyYWNvR2VvbWV0cnkgPSBuZXcgZHJhY28uTWVzaCgpO1xuICAgICAgZGVjb2RpbmdTdGF0dXMgPSBkZWNvZGVyLkRlY29kZUJ1ZmZlclRvTWVzaChkZWNvZGVyQnVmZmVyLCBkcmFjb0dlb21ldHJ5KTtcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uUE9JTlRfQ0xPVUQpIHtcbiAgICAgIGRyYWNvR2VvbWV0cnkgPSBuZXcgZHJhY28uUG9pbnRDbG91ZCgpO1xuICAgICAgZGVjb2RpbmdTdGF0dXMgPSBkZWNvZGVyLkRlY29kZUJ1ZmZlclRvUG9pbnRDbG91ZChkZWNvZGVyQnVmZmVyLCBkcmFjb0dlb21ldHJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgZ2VvbWV0cnkgdHlwZS5cIik7XG4gICAgfVxuICAgIGlmICghZGVjb2RpbmdTdGF0dXMub2soKSB8fCBkcmFjb0dlb21ldHJ5LnB0ciA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuRFJBQ09Mb2FkZXI6IERlY29kaW5nIGZhaWxlZDogXCIgKyBkZWNvZGluZ1N0YXR1cy5lcnJvcl9tc2coKSk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0geyBpbmRleDogbnVsbCwgYXR0cmlidXRlczogW10gfTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlSURzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVUeXBlID0gc2VsZlthdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVOYW1lXV07XG4gICAgICBsZXQgYXR0cmlidXRlO1xuICAgICAgbGV0IGF0dHJpYnV0ZUlEO1xuICAgICAgaWYgKHRhc2tDb25maWcudXNlVW5pcXVlSURzKSB7XG4gICAgICAgIGF0dHJpYnV0ZUlEID0gYXR0cmlidXRlSURzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBhdHRyaWJ1dGUgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZUJ5VW5pcXVlSWQoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSUQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlSUQgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZUlkKGRyYWNvR2VvbWV0cnksIGRyYWNvW2F0dHJpYnV0ZUlEc1thdHRyaWJ1dGVOYW1lXV0pO1xuICAgICAgICBpZiAoYXR0cmlidXRlSUQgPT09IC0xKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhdHRyaWJ1dGUgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZShkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVJRCk7XG4gICAgICB9XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnB1c2goZGVjb2RlQXR0cmlidXRlKGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUpKTtcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIKSB7XG4gICAgICBnZW9tZXRyeS5pbmRleCA9IGRlY29kZUluZGV4KGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5KTtcbiAgICB9XG4gICAgZHJhY28uZGVzdHJveShkcmFjb0dlb21ldHJ5KTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlSW5kZXgoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnkpIHtcbiAgICBjb25zdCBudW1GYWNlcyA9IGRyYWNvR2VvbWV0cnkubnVtX2ZhY2VzKCk7XG4gICAgY29uc3QgbnVtSW5kaWNlcyA9IG51bUZhY2VzICogMztcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gbnVtSW5kaWNlcyAqIDQ7XG4gICAgY29uc3QgcHRyID0gZHJhY28uX21hbGxvYyhieXRlTGVuZ3RoKTtcbiAgICBkZWNvZGVyLkdldFRyaWFuZ2xlc1VJbnQzMkFycmF5KGRyYWNvR2VvbWV0cnksIGJ5dGVMZW5ndGgsIHB0cik7XG4gICAgY29uc3QgaW5kZXggPSBuZXcgVWludDMyQXJyYXkoZHJhY28uSEVBUEYzMi5idWZmZXIsIHB0ciwgbnVtSW5kaWNlcykuc2xpY2UoKTtcbiAgICBkcmFjby5fZnJlZShwdHIpO1xuICAgIHJldHVybiB7IGFycmF5OiBpbmRleCwgaXRlbVNpemU6IDEgfTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVBdHRyaWJ1dGUoZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IG51bUNvbXBvbmVudHMgPSBhdHRyaWJ1dGUubnVtX2NvbXBvbmVudHMoKTtcbiAgICBjb25zdCBudW1Qb2ludHMgPSBkcmFjb0dlb21ldHJ5Lm51bV9wb2ludHMoKTtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSBudW1Qb2ludHMgKiBudW1Db21wb25lbnRzO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBudW1WYWx1ZXMgKiBhdHRyaWJ1dGVUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2V0RHJhY29EYXRhVHlwZShkcmFjbywgYXR0cmlidXRlVHlwZSk7XG4gICAgY29uc3QgcHRyID0gZHJhY28uX21hbGxvYyhieXRlTGVuZ3RoKTtcbiAgICBkZWNvZGVyLkdldEF0dHJpYnV0ZURhdGFBcnJheUZvckFsbFBvaW50cyhkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGUsIGRhdGFUeXBlLCBieXRlTGVuZ3RoLCBwdHIpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IGF0dHJpYnV0ZVR5cGUoZHJhY28uSEVBUEYzMi5idWZmZXIsIHB0ciwgbnVtVmFsdWVzKS5zbGljZSgpO1xuICAgIGRyYWNvLl9mcmVlKHB0cik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGF0dHJpYnV0ZU5hbWUsXG4gICAgICBhcnJheSxcbiAgICAgIGl0ZW1TaXplOiBudW1Db21wb25lbnRzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXREcmFjb0RhdGFUeXBlKGRyYWNvLCBhdHRyaWJ1dGVUeXBlKSB7XG4gICAgc3dpdGNoIChhdHRyaWJ1dGVUeXBlKSB7XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0ZMT0FUMzI7XG4gICAgICBjYXNlIEludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDg7XG4gICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQxNjtcbiAgICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDMyO1xuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfVUlOVDg7XG4gICAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfVUlOVDE2O1xuICAgICAgY2FzZSBVaW50MzJBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQzMjtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCB7XG4gIERSQUNPTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RFJBQ09Mb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOlsiTG9hZGVyIiwiRmlsZUxvYWRlciIsIkJ1ZmZlckdlb21ldHJ5IiwiQnVmZmVyQXR0cmlidXRlIiwiX3Rhc2tDYWNoZSIsIldlYWtNYXAiLCJEUkFDT0xvYWRlciIsImNvbnN0cnVjdG9yIiwibWFuYWdlciIsImRlY29kZXJQYXRoIiwiZGVjb2RlckNvbmZpZyIsImRlY29kZXJCaW5hcnkiLCJkZWNvZGVyUGVuZGluZyIsIndvcmtlckxpbWl0Iiwid29ya2VyUG9vbCIsIndvcmtlck5leHRUYXNrSUQiLCJ3b3JrZXJTb3VyY2VVUkwiLCJkZWZhdWx0QXR0cmlidXRlSURzIiwicG9zaXRpb24iLCJub3JtYWwiLCJjb2xvciIsInV2IiwiZGVmYXVsdEF0dHJpYnV0ZVR5cGVzIiwic2V0RGVjb2RlclBhdGgiLCJwYXRoIiwic2V0RGVjb2RlckNvbmZpZyIsImNvbmZpZyIsInNldFdvcmtlckxpbWl0IiwibG9hZCIsInVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwibG9hZGVyIiwic2V0UGF0aCIsInNldFJlc3BvbnNlVHlwZSIsInNldFJlcXVlc3RIZWFkZXIiLCJyZXF1ZXN0SGVhZGVyIiwic2V0V2l0aENyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiYnVmZmVyIiwidGFza0NvbmZpZyIsImF0dHJpYnV0ZUlEcyIsImF0dHJpYnV0ZVR5cGVzIiwidXNlVW5pcXVlSURzIiwiZGVjb2RlR2VvbWV0cnkiLCJ0aGVuIiwiY2F0Y2giLCJkZWNvZGVEcmFjb0ZpbGUiLCJjYWxsYmFjayIsImF0dHJpYnV0ZSIsInR5cGUiLCJCWVRFU19QRVJfRUxFTUVOVCIsIm5hbWUiLCJ0YXNrS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImhhcyIsImNhY2hlZFRhc2siLCJnZXQiLCJrZXkiLCJwcm9taXNlIiwiYnl0ZUxlbmd0aCIsIkVycm9yIiwid29ya2VyIiwidGFza0lEIiwidGFza0Nvc3QiLCJnZW9tZXRyeVBlbmRpbmciLCJfZ2V0V29ya2VyIiwiX3dvcmtlciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiX2NhbGxiYWNrcyIsInBvc3RNZXNzYWdlIiwiaWQiLCJtZXNzYWdlIiwiX2NyZWF0ZUdlb21ldHJ5IiwiZ2VvbWV0cnkiLCJfcmVsZWFzZVRhc2siLCJzZXQiLCJnZW9tZXRyeURhdGEiLCJpbmRleCIsInNldEluZGV4IiwiYXJyYXkiLCJpIiwiYXR0cmlidXRlcyIsImxlbmd0aCIsIml0ZW1TaXplIiwic2V0QXR0cmlidXRlIiwiX2xvYWRMaWJyYXJ5IiwicmVzcG9uc2VUeXBlIiwicHJlbG9hZCIsIl9pbml0RGVjb2RlciIsInVzZUpTIiwiV2ViQXNzZW1ibHkiLCJsaWJyYXJpZXNQZW5kaW5nIiwicHVzaCIsImFsbCIsImxpYnJhcmllcyIsImpzQ29udGVudCIsIndhc21CaW5hcnkiLCJmbiIsIkRSQUNPV29ya2VyIiwidG9TdHJpbmciLCJib2R5Iiwic3Vic3RyaW5nIiwiaW5kZXhPZiIsImxhc3RJbmRleE9mIiwiam9pbiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsIkJsb2IiLCJ3b3JrZXIyIiwiV29ya2VyIiwiX3Rhc2tDb3N0cyIsIl90YXNrTG9hZCIsIm9ubWVzc2FnZSIsImUiLCJkYXRhIiwiY29uc29sZSIsImVycm9yIiwic29ydCIsImEiLCJiIiwiZGVidWciLCJsb2ciLCJtYXAiLCJkaXNwb3NlIiwidGVybWluYXRlIiwib25Nb2R1bGVMb2FkZWQiLCJkcmFjbyIsIkRyYWNvRGVjb2Rlck1vZHVsZSIsIm1vZHVsZSIsImRlY29kZXIiLCJEZWNvZGVyIiwiZGVjb2RlckJ1ZmZlciIsIkRlY29kZXJCdWZmZXIiLCJJbml0IiwiSW50OEFycmF5IiwiYnVmZmVycyIsImF0dHIiLCJzZWxmIiwiZGVzdHJveSIsImRyYWNvR2VvbWV0cnkiLCJkZWNvZGluZ1N0YXR1cyIsImdlb21ldHJ5VHlwZSIsIkdldEVuY29kZWRHZW9tZXRyeVR5cGUiLCJUUklBTkdVTEFSX01FU0giLCJNZXNoIiwiRGVjb2RlQnVmZmVyVG9NZXNoIiwiUE9JTlRfQ0xPVUQiLCJQb2ludENsb3VkIiwiRGVjb2RlQnVmZmVyVG9Qb2ludENsb3VkIiwib2siLCJwdHIiLCJlcnJvcl9tc2ciLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlVHlwZSIsImF0dHJpYnV0ZUlEIiwiR2V0QXR0cmlidXRlQnlVbmlxdWVJZCIsIkdldEF0dHJpYnV0ZUlkIiwiR2V0QXR0cmlidXRlIiwiZGVjb2RlQXR0cmlidXRlIiwiZGVjb2RlSW5kZXgiLCJudW1GYWNlcyIsIm51bV9mYWNlcyIsIm51bUluZGljZXMiLCJfbWFsbG9jIiwiR2V0VHJpYW5nbGVzVUludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsIkhFQVBGMzIiLCJzbGljZSIsIl9mcmVlIiwibnVtQ29tcG9uZW50cyIsIm51bV9jb21wb25lbnRzIiwibnVtUG9pbnRzIiwibnVtX3BvaW50cyIsIm51bVZhbHVlcyIsImRhdGFUeXBlIiwiZ2V0RHJhY29EYXRhVHlwZSIsIkdldEF0dHJpYnV0ZURhdGFBcnJheUZvckFsbFBvaW50cyIsIkZsb2F0MzJBcnJheSIsIkRUX0ZMT0FUMzIiLCJEVF9JTlQ4IiwiSW50MTZBcnJheSIsIkRUX0lOVDE2IiwiSW50MzJBcnJheSIsIkRUX0lOVDMyIiwiVWludDhBcnJheSIsIkRUX1VJTlQ4IiwiVWludDE2QXJyYXkiLCJEVF9VSU5UMTYiLCJEVF9VSU5UMzIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/EXRLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXRLoader: () => (/* binding */ EXRLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ \"(ssr)/./node_modules/fflate/esm/index.mjs\");\n\n\nconst hasColorSpace = \"colorSpace\" in new three__WEBPACK_IMPORTED_MODULE_0__.Texture();\nclass EXRLoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    parse(buffer) {\n        const USHORT_RANGE = 1 << 16;\n        const BITMAP_SIZE = USHORT_RANGE >> 3;\n        const HUF_ENCBITS = 16;\n        const HUF_DECBITS = 14;\n        const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n        const HUF_DECSIZE = 1 << HUF_DECBITS;\n        const HUF_DECMASK = HUF_DECSIZE - 1;\n        const NBITS = 16;\n        const A_OFFSET = 1 << NBITS - 1;\n        const MOD_MASK = (1 << NBITS) - 1;\n        const SHORT_ZEROCODE_RUN = 59;\n        const LONG_ZEROCODE_RUN = 63;\n        const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n        const ULONG_SIZE = 8;\n        const FLOAT32_SIZE = 4;\n        const INT32_SIZE = 4;\n        const INT16_SIZE = 2;\n        const INT8_SIZE = 1;\n        const STATIC_HUFFMAN = 0;\n        const DEFLATE = 1;\n        const UNKNOWN = 0;\n        const LOSSY_DCT = 1;\n        const RLE = 2;\n        const logBase = Math.pow(2.7182818, 2.2);\n        function reverseLutFromBitmap(bitmap, lut) {\n            var k = 0;\n            for(var i = 0; i < USHORT_RANGE; ++i){\n                if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n                    lut[k++] = i;\n                }\n            }\n            var n = k - 1;\n            while(k < USHORT_RANGE)lut[k++] = 0;\n            return n;\n        }\n        function hufClearDecTable(hdec) {\n            for(var i = 0; i < HUF_DECSIZE; i++){\n                hdec[i] = {};\n                hdec[i].len = 0;\n                hdec[i].lit = 0;\n                hdec[i].p = null;\n            }\n        }\n        const getBitsReturn = {\n            l: 0,\n            c: 0,\n            lc: 0\n        };\n        function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n            while(lc < nBits){\n                c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n                lc += 8;\n            }\n            lc -= nBits;\n            getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n            getBitsReturn.c = c;\n            getBitsReturn.lc = lc;\n        }\n        const hufTableBuffer = new Array(59);\n        function hufCanonicalCodeTable(hcode) {\n            for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;\n            for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;\n            var c = 0;\n            for(var i = 58; i > 0; --i){\n                var nc = c + hufTableBuffer[i] >> 1;\n                hufTableBuffer[i] = c;\n                c = nc;\n            }\n            for(var i = 0; i < HUF_ENCSIZE; ++i){\n                var l = hcode[i];\n                if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n            }\n        }\n        function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n            var p = inOffset;\n            var c = 0;\n            var lc = 0;\n            for(; im <= iM; im++){\n                if (p.value - inOffset.value > ni) return false;\n                getBits(6, c, lc, uInt8Array2, p);\n                var l = getBitsReturn.l;\n                c = getBitsReturn.c;\n                lc = getBitsReturn.lc;\n                hcode[im] = l;\n                if (l == LONG_ZEROCODE_RUN) {\n                    if (p.value - inOffset.value > ni) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    getBits(8, c, lc, uInt8Array2, p);\n                    var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n                    c = getBitsReturn.c;\n                    lc = getBitsReturn.lc;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                } else if (l >= SHORT_ZEROCODE_RUN) {\n                    var zerun = l - SHORT_ZEROCODE_RUN + 2;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                }\n            }\n            hufCanonicalCodeTable(hcode);\n        }\n        function hufLength(code) {\n            return code & 63;\n        }\n        function hufCode(code) {\n            return code >> 6;\n        }\n        function hufBuildDecTable(hcode, im, iM, hdecod) {\n            for(; im <= iM; im++){\n                var c = hufCode(hcode[im]);\n                var l = hufLength(hcode[im]);\n                if (c >> l) {\n                    throw \"Invalid table entry\";\n                }\n                if (l > HUF_DECBITS) {\n                    var pl = hdecod[c >> l - HUF_DECBITS];\n                    if (pl.len) {\n                        throw \"Invalid table entry\";\n                    }\n                    pl.lit++;\n                    if (pl.p) {\n                        var p = pl.p;\n                        pl.p = new Array(pl.lit);\n                        for(var i = 0; i < pl.lit - 1; ++i){\n                            pl.p[i] = p[i];\n                        }\n                    } else {\n                        pl.p = new Array(1);\n                    }\n                    pl.p[pl.lit - 1] = im;\n                } else if (l) {\n                    var plOffset = 0;\n                    for(var i = 1 << HUF_DECBITS - l; i > 0; i--){\n                        var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n                        if (pl.len || pl.p) {\n                            throw \"Invalid table entry\";\n                        }\n                        pl.len = l;\n                        pl.lit = im;\n                        plOffset++;\n                    }\n                }\n            }\n            return true;\n        }\n        const getCharReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getChar(c, lc, uInt8Array2, inOffset) {\n            c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n            lc += 8;\n            getCharReturn.c = c;\n            getCharReturn.lc = lc;\n        }\n        const getCodeReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n            if (po == rlc) {\n                if (lc < 8) {\n                    getChar(c, lc, uInt8Array2, inOffset);\n                    c = getCharReturn.c;\n                    lc = getCharReturn.lc;\n                }\n                lc -= 8;\n                var cs = c >> lc;\n                var cs = new Uint8Array([\n                    cs\n                ])[0];\n                if (outBufferOffset.value + cs > outBufferEndOffset) {\n                    return false;\n                }\n                var s = outBuffer[outBufferOffset.value - 1];\n                while(cs-- > 0){\n                    outBuffer[outBufferOffset.value++] = s;\n                }\n            } else if (outBufferOffset.value < outBufferEndOffset) {\n                outBuffer[outBufferOffset.value++] = po;\n            } else {\n                return false;\n            }\n            getCodeReturn.c = c;\n            getCodeReturn.lc = lc;\n        }\n        function UInt16(value) {\n            return value & 65535;\n        }\n        function Int16(value) {\n            var ref = UInt16(value);\n            return ref > 32767 ? ref - 65536 : ref;\n        }\n        const wdec14Return = {\n            a: 0,\n            b: 0\n        };\n        function wdec14(l, h) {\n            var ls = Int16(l);\n            var hs = Int16(h);\n            var hi = hs;\n            var ai = ls + (hi & 1) + (hi >> 1);\n            var as = ai;\n            var bs = ai - hi;\n            wdec14Return.a = as;\n            wdec14Return.b = bs;\n        }\n        function wdec16(l, h) {\n            var m = UInt16(l);\n            var d = UInt16(h);\n            var bb = m - (d >> 1) & MOD_MASK;\n            var aa = d + bb - A_OFFSET & MOD_MASK;\n            wdec14Return.a = aa;\n            wdec14Return.b = bb;\n        }\n        function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n            var w14 = mx < 1 << 14;\n            var n = nx > ny ? ny : nx;\n            var p = 1;\n            var p2;\n            while(p <= n)p <<= 1;\n            p >>= 1;\n            p2 = p;\n            p >>= 1;\n            while(p >= 1){\n                var py = 0;\n                var ey = py + oy * (ny - p2);\n                var oy1 = oy * p;\n                var oy2 = oy * p2;\n                var ox1 = ox * p;\n                var ox2 = ox * p2;\n                var i00, i01, i10, i11;\n                for(; py <= ey; py += oy2){\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        var p10 = px + oy1;\n                        var p11 = p10 + ox1;\n                        if (w14) {\n                            wdec14(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec14(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec14(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        } else {\n                            wdec16(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec16(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec16(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        }\n                    }\n                    if (nx & p) {\n                        var p10 = px + oy1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p10 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p10 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                if (ny & p) {\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p01 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p01 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                p2 = p;\n                p >>= 1;\n            }\n            return py;\n        }\n        function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n            var c = 0;\n            var lc = 0;\n            var outBufferEndOffset = no;\n            var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n            while(inOffset.value < inOffsetEnd){\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n                while(lc >= HUF_DECBITS){\n                    var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n                    var pl = decodingTable[index];\n                    if (pl.len) {\n                        lc -= pl.len;\n                        getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                        c = getCodeReturn.c;\n                        lc = getCodeReturn.lc;\n                    } else {\n                        if (!pl.p) {\n                            throw \"hufDecode issues\";\n                        }\n                        var j;\n                        for(j = 0; j < pl.lit; j++){\n                            var l = hufLength(encodingTable[pl.p[j]]);\n                            while(lc < l && inOffset.value < inOffsetEnd){\n                                getChar(c, lc, uInt8Array2, inOffset);\n                                c = getCharReturn.c;\n                                lc = getCharReturn.lc;\n                            }\n                            if (lc >= l) {\n                                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                                    lc -= l;\n                                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                                    c = getCodeReturn.c;\n                                    lc = getCodeReturn.lc;\n                                    break;\n                                }\n                            }\n                        }\n                        if (j == pl.lit) {\n                            throw \"hufDecode issues\";\n                        }\n                    }\n                }\n            }\n            var i = 8 - ni & 7;\n            c >>= i;\n            lc -= i;\n            while(lc > 0){\n                var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n                if (pl.len) {\n                    lc -= pl.len;\n                    getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                } else {\n                    throw \"hufDecode issues\";\n                }\n            }\n            return true;\n        }\n        function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n            var outOffset = {\n                value: 0\n            };\n            var initialInOffset = inOffset.value;\n            var im = parseUint32(inDataView, inOffset);\n            var iM = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            var nBits = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n                throw \"Something wrong with HUF_ENCSIZE\";\n            }\n            var freq = new Array(HUF_ENCSIZE);\n            var hdec = new Array(HUF_DECSIZE);\n            hufClearDecTable(hdec);\n            var ni = nCompressed - (inOffset.value - initialInOffset);\n            hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n            if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n                throw \"Something wrong with hufUncompress\";\n            }\n            hufBuildDecTable(freq, im, iM, hdec);\n            hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n        }\n        function applyLut(lut, data, nData) {\n            for(var i = 0; i < nData; ++i){\n                data[i] = lut[data[i]];\n            }\n        }\n        function predictor(source) {\n            for(var t = 1; t < source.length; t++){\n                var d = source[t - 1] + source[t] - 128;\n                source[t] = d;\n            }\n        }\n        function interleaveScalar(source, out) {\n            var t1 = 0;\n            var t2 = Math.floor((source.length + 1) / 2);\n            var s = 0;\n            var stop = source.length - 1;\n            while(true){\n                if (s > stop) break;\n                out[s++] = source[t1++];\n                if (s > stop) break;\n                out[s++] = source[t2++];\n            }\n        }\n        function decodeRunLength(source) {\n            var size = source.byteLength;\n            var out = new Array();\n            var p = 0;\n            var reader = new DataView(source);\n            while(size > 0){\n                var l = reader.getInt8(p++);\n                if (l < 0) {\n                    var count = -l;\n                    size -= count + 1;\n                    for(var i = 0; i < count; i++){\n                        out.push(reader.getUint8(p++));\n                    }\n                } else {\n                    var count = l;\n                    size -= 2;\n                    var value = reader.getUint8(p++);\n                    for(var i = 0; i < count + 1; i++){\n                        out.push(value);\n                    }\n                }\n            }\n            return out;\n        }\n        function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n            var dataView = new DataView(outBuffer.buffer);\n            var width = channelData[cscSet.idx[0]].width;\n            var height = channelData[cscSet.idx[0]].height;\n            var numComp = 3;\n            var numFullBlocksX = Math.floor(width / 8);\n            var numBlocksX = Math.ceil(width / 8);\n            var numBlocksY = Math.ceil(height / 8);\n            var leftoverX = width - (numBlocksX - 1) * 8;\n            var leftoverY = height - (numBlocksY - 1) * 8;\n            var currAcComp = {\n                value: 0\n            };\n            var currDcComp = new Array(numComp);\n            var dctData = new Array(numComp);\n            var halfZigBlock = new Array(numComp);\n            var rowBlock = new Array(numComp);\n            var rowOffsets = new Array(numComp);\n            for(let comp2 = 0; comp2 < numComp; ++comp2){\n                rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n                currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n                dctData[comp2] = new Float32Array(64);\n                halfZigBlock[comp2] = new Uint16Array(64);\n                rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n            }\n            for(let blocky = 0; blocky < numBlocksY; ++blocky){\n                var maxY = 8;\n                if (blocky == numBlocksY - 1) maxY = leftoverY;\n                var maxX = 8;\n                for(let blockx = 0; blockx < numBlocksX; ++blockx){\n                    if (blockx == numBlocksX - 1) maxX = leftoverX;\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        halfZigBlock[comp2].fill(0);\n                        halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n                        unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n                        unZigZag(halfZigBlock[comp2], dctData[comp2]);\n                        dctInverse(dctData[comp2]);\n                    }\n                    {\n                        csc709Inverse(dctData);\n                    }\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n                    }\n                }\n                let offset2 = 0;\n                for(let comp2 = 0; comp2 < numComp; ++comp2){\n                    const type2 = channelData[cscSet.idx[comp2]].type;\n                    for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                        offset2 = rowOffsets[comp2][y2];\n                        for(let blockx = 0; blockx < numFullBlocksX; ++blockx){\n                            const src = blockx * 64 + (y2 & 7) * 8;\n                            dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n                            dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n                            dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n                            dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n                            dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n                            dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n                            dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n                            dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n                            offset2 += 8 * INT16_SIZE * type2;\n                        }\n                    }\n                    if (numFullBlocksX != numBlocksX) {\n                        for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                            const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n                            const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n                            for(let x2 = 0; x2 < maxX; ++x2){\n                                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n                            }\n                        }\n                    }\n                }\n            }\n            var halfRow = new Uint16Array(width);\n            var dataView = new DataView(outBuffer.buffer);\n            for(var comp = 0; comp < numComp; ++comp){\n                channelData[cscSet.idx[comp]].decoded = true;\n                var type = channelData[cscSet.idx[comp]].type;\n                if (channelData[comp].type != 2) continue;\n                for(var y = 0; y < height; ++y){\n                    const offset2 = rowOffsets[comp][y];\n                    for(var x = 0; x < width; ++x){\n                        halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n                    }\n                    for(var x = 0; x < width; ++x){\n                        dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n                    }\n                }\n            }\n        }\n        function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n            var acValue;\n            var dctComp = 1;\n            while(dctComp < 64){\n                acValue = acBuffer[currAcComp.value];\n                if (acValue == 65280) {\n                    dctComp = 64;\n                } else if (acValue >> 8 == 255) {\n                    dctComp += acValue & 255;\n                } else {\n                    halfZigBlock[dctComp] = acValue;\n                    dctComp++;\n                }\n                currAcComp.value++;\n            }\n        }\n        function unZigZag(src, dst) {\n            dst[0] = decodeFloat16(src[0]);\n            dst[1] = decodeFloat16(src[1]);\n            dst[2] = decodeFloat16(src[5]);\n            dst[3] = decodeFloat16(src[6]);\n            dst[4] = decodeFloat16(src[14]);\n            dst[5] = decodeFloat16(src[15]);\n            dst[6] = decodeFloat16(src[27]);\n            dst[7] = decodeFloat16(src[28]);\n            dst[8] = decodeFloat16(src[2]);\n            dst[9] = decodeFloat16(src[4]);\n            dst[10] = decodeFloat16(src[7]);\n            dst[11] = decodeFloat16(src[13]);\n            dst[12] = decodeFloat16(src[16]);\n            dst[13] = decodeFloat16(src[26]);\n            dst[14] = decodeFloat16(src[29]);\n            dst[15] = decodeFloat16(src[42]);\n            dst[16] = decodeFloat16(src[3]);\n            dst[17] = decodeFloat16(src[8]);\n            dst[18] = decodeFloat16(src[12]);\n            dst[19] = decodeFloat16(src[17]);\n            dst[20] = decodeFloat16(src[25]);\n            dst[21] = decodeFloat16(src[30]);\n            dst[22] = decodeFloat16(src[41]);\n            dst[23] = decodeFloat16(src[43]);\n            dst[24] = decodeFloat16(src[9]);\n            dst[25] = decodeFloat16(src[11]);\n            dst[26] = decodeFloat16(src[18]);\n            dst[27] = decodeFloat16(src[24]);\n            dst[28] = decodeFloat16(src[31]);\n            dst[29] = decodeFloat16(src[40]);\n            dst[30] = decodeFloat16(src[44]);\n            dst[31] = decodeFloat16(src[53]);\n            dst[32] = decodeFloat16(src[10]);\n            dst[33] = decodeFloat16(src[19]);\n            dst[34] = decodeFloat16(src[23]);\n            dst[35] = decodeFloat16(src[32]);\n            dst[36] = decodeFloat16(src[39]);\n            dst[37] = decodeFloat16(src[45]);\n            dst[38] = decodeFloat16(src[52]);\n            dst[39] = decodeFloat16(src[54]);\n            dst[40] = decodeFloat16(src[20]);\n            dst[41] = decodeFloat16(src[22]);\n            dst[42] = decodeFloat16(src[33]);\n            dst[43] = decodeFloat16(src[38]);\n            dst[44] = decodeFloat16(src[46]);\n            dst[45] = decodeFloat16(src[51]);\n            dst[46] = decodeFloat16(src[55]);\n            dst[47] = decodeFloat16(src[60]);\n            dst[48] = decodeFloat16(src[21]);\n            dst[49] = decodeFloat16(src[34]);\n            dst[50] = decodeFloat16(src[37]);\n            dst[51] = decodeFloat16(src[47]);\n            dst[52] = decodeFloat16(src[50]);\n            dst[53] = decodeFloat16(src[56]);\n            dst[54] = decodeFloat16(src[59]);\n            dst[55] = decodeFloat16(src[61]);\n            dst[56] = decodeFloat16(src[35]);\n            dst[57] = decodeFloat16(src[36]);\n            dst[58] = decodeFloat16(src[48]);\n            dst[59] = decodeFloat16(src[49]);\n            dst[60] = decodeFloat16(src[57]);\n            dst[61] = decodeFloat16(src[58]);\n            dst[62] = decodeFloat16(src[62]);\n            dst[63] = decodeFloat16(src[63]);\n        }\n        function dctInverse(data) {\n            const a = 0.5 * Math.cos(3.14159 / 4);\n            const b = 0.5 * Math.cos(3.14159 / 16);\n            const c = 0.5 * Math.cos(3.14159 / 8);\n            const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n            const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n            const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n            const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n            var alpha = new Array(4);\n            var beta = new Array(4);\n            var theta = new Array(4);\n            var gamma = new Array(4);\n            for(var row = 0; row < 8; ++row){\n                var rowPtr = row * 8;\n                alpha[0] = c * data[rowPtr + 2];\n                alpha[1] = f * data[rowPtr + 2];\n                alpha[2] = c * data[rowPtr + 6];\n                alpha[3] = f * data[rowPtr + 6];\n                beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n                beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n                beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n                beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n                theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n                theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[rowPtr + 0] = gamma[0] + beta[0];\n                data[rowPtr + 1] = gamma[1] + beta[1];\n                data[rowPtr + 2] = gamma[2] + beta[2];\n                data[rowPtr + 3] = gamma[3] + beta[3];\n                data[rowPtr + 4] = gamma[3] - beta[3];\n                data[rowPtr + 5] = gamma[2] - beta[2];\n                data[rowPtr + 6] = gamma[1] - beta[1];\n                data[rowPtr + 7] = gamma[0] - beta[0];\n            }\n            for(var column = 0; column < 8; ++column){\n                alpha[0] = c * data[16 + column];\n                alpha[1] = f * data[16 + column];\n                alpha[2] = c * data[48 + column];\n                alpha[3] = f * data[48 + column];\n                beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n                beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n                beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n                beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n                theta[0] = a * (data[column] + data[32 + column]);\n                theta[3] = a * (data[column] - data[32 + column]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[0 + column] = gamma[0] + beta[0];\n                data[8 + column] = gamma[1] + beta[1];\n                data[16 + column] = gamma[2] + beta[2];\n                data[24 + column] = gamma[3] + beta[3];\n                data[32 + column] = gamma[3] - beta[3];\n                data[40 + column] = gamma[2] - beta[2];\n                data[48 + column] = gamma[1] - beta[1];\n                data[56 + column] = gamma[0] - beta[0];\n            }\n        }\n        function csc709Inverse(data) {\n            for(var i = 0; i < 64; ++i){\n                var y = data[0][i];\n                var cb = data[1][i];\n                var cr = data[2][i];\n                data[0][i] = y + 1.5747 * cr;\n                data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n                data[2][i] = y + 1.8556 * cb;\n            }\n        }\n        function convertToHalf(src, dst, idx) {\n            for(var i = 0; i < 64; ++i){\n                dst[idx + i] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(toLinear(src[i]));\n            }\n        }\n        function toLinear(float) {\n            if (float <= 1) {\n                return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n            } else {\n                return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n            }\n        }\n        function uncompressRAW(info) {\n            return new DataView(info.array.buffer, info.offset.value, info.size);\n        }\n        function uncompressRLE(info) {\n            var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressZIP(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPIZ(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n            var bitmap = new Uint8Array(BITMAP_SIZE);\n            var outBufferEnd = 0;\n            var pizChannelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; i++){\n                pizChannelData[i] = {};\n                pizChannelData[i][\"start\"] = outBufferEnd;\n                pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n                pizChannelData[i][\"nx\"] = info.width;\n                pizChannelData[i][\"ny\"] = info.lines;\n                pizChannelData[i][\"size\"] = info.type;\n                outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n            }\n            var minNonZero = parseUint16(inDataView, inOffset);\n            var maxNonZero = parseUint16(inDataView, inOffset);\n            if (maxNonZero >= BITMAP_SIZE) {\n                throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n            }\n            if (minNonZero <= maxNonZero) {\n                for(var i = 0; i < maxNonZero - minNonZero + 1; i++){\n                    bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n                }\n            }\n            var lut = new Uint16Array(USHORT_RANGE);\n            var maxValue = reverseLutFromBitmap(bitmap, lut);\n            var length = parseUint32(inDataView, inOffset);\n            hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = pizChannelData[i];\n                for(var j = 0; j < pizChannelData[i].size; ++j){\n                    wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n                }\n            }\n            applyLut(lut, outBuffer, outBufferEnd);\n            var tmpOffset2 = 0;\n            var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n            for(var y = 0; y < info.lines; y++){\n                for(var c = 0; c < info.channels; c++){\n                    var cd = pizChannelData[c];\n                    var n = cd.nx * cd.size;\n                    var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n                    tmpBuffer.set(cp, tmpOffset2);\n                    tmpOffset2 += n * INT16_SIZE;\n                    cd.end += n;\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPXR(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n            const sz = info.lines * info.channels * info.width;\n            const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n            let tmpBufferEnd = 0;\n            let writePtr = 0;\n            const ptr = new Array(4);\n            for(let y = 0; y < info.lines; y++){\n                for(let c = 0; c < info.channels; c++){\n                    let pixel = 0;\n                    switch(info.type){\n                        case 1:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            tmpBufferEnd = ptr[1] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                        case 2:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            ptr[2] = ptr[1] + info.width;\n                            tmpBufferEnd = ptr[2] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                    }\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressDWA(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n            var dwaHeader = {\n                version: parseInt64(inDataView, inOffset),\n                unknownUncompressedSize: parseInt64(inDataView, inOffset),\n                unknownCompressedSize: parseInt64(inDataView, inOffset),\n                acCompressedSize: parseInt64(inDataView, inOffset),\n                dcCompressedSize: parseInt64(inDataView, inOffset),\n                rleCompressedSize: parseInt64(inDataView, inOffset),\n                rleUncompressedSize: parseInt64(inDataView, inOffset),\n                rleRawSize: parseInt64(inDataView, inOffset),\n                totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n                totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n                acCompression: parseInt64(inDataView, inOffset)\n            };\n            if (dwaHeader.version < 2) {\n                throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n            }\n            var channelRules = new Array();\n            var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n            while(ruleSize > 0){\n                var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n                var value = parseUint8(inDataView, inOffset);\n                var compression = value >> 2 & 3;\n                var csc = (value >> 4) - 1;\n                var index = new Int8Array([\n                    csc\n                ])[0];\n                var type = parseUint8(inDataView, inOffset);\n                channelRules.push({\n                    name,\n                    index,\n                    type,\n                    compression\n                });\n                ruleSize -= name.length + 3;\n            }\n            var channels = EXRHeader.channels;\n            var channelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = channelData[i] = {};\n                var channel = channels[i];\n                cd.name = channel.name;\n                cd.compression = UNKNOWN;\n                cd.decoded = false;\n                cd.type = channel.pixelType;\n                cd.pLinear = channel.pLinear;\n                cd.width = info.width;\n                cd.height = info.lines;\n            }\n            var cscSet = {\n                idx: new Array(3)\n            };\n            for(var offset2 = 0; offset2 < info.channels; ++offset2){\n                var cd = channelData[offset2];\n                for(var i = 0; i < channelRules.length; ++i){\n                    var rule = channelRules[i];\n                    if (cd.name == rule.name) {\n                        cd.compression = rule.compression;\n                        if (rule.index >= 0) {\n                            cscSet.idx[rule.index] = offset2;\n                        }\n                        cd.offset = offset2;\n                    }\n                }\n            }\n            if (dwaHeader.acCompressedSize > 0) {\n                switch(dwaHeader.acCompression){\n                    case STATIC_HUFFMAN:\n                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n                        break;\n                    case DEFLATE:\n                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n                        var data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n                        var acBuffer = new Uint16Array(data.buffer);\n                        inOffset.value += dwaHeader.totalAcUncompressedCount;\n                        break;\n                }\n            }\n            if (dwaHeader.dcCompressedSize > 0) {\n                var zlibInfo = {\n                    array: info.array,\n                    offset: inOffset,\n                    size: dwaHeader.dcCompressedSize\n                };\n                var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n                inOffset.value += dwaHeader.dcCompressedSize;\n            }\n            if (dwaHeader.rleRawSize > 0) {\n                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n                var data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n                var rleBuffer = decodeRunLength(data.buffer);\n                inOffset.value += dwaHeader.rleCompressedSize;\n            }\n            var outBufferEnd = 0;\n            var rowOffsets = new Array(channelData.length);\n            for(var i = 0; i < rowOffsets.length; ++i){\n                rowOffsets[i] = new Array();\n            }\n            for(var y = 0; y < info.lines; ++y){\n                for(var chan = 0; chan < channelData.length; ++chan){\n                    rowOffsets[chan].push(outBufferEnd);\n                    outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n                }\n            }\n            lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n            for(var i = 0; i < channelData.length; ++i){\n                var cd = channelData[i];\n                if (cd.decoded) continue;\n                switch(cd.compression){\n                    case RLE:\n                        var row = 0;\n                        var rleOffset = 0;\n                        for(var y = 0; y < info.lines; ++y){\n                            var rowOffsetBytes = rowOffsets[i][row];\n                            for(var x = 0; x < cd.width; ++x){\n                                for(var byte = 0; byte < INT16_SIZE * cd.type; ++byte){\n                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                                }\n                                rleOffset++;\n                            }\n                            row++;\n                        }\n                        break;\n                    case LOSSY_DCT:\n                    default:\n                        throw \"EXRLoader.parse: unsupported channel compression\";\n                }\n            }\n            return new DataView(outBuffer.buffer);\n        }\n        function parseNullTerminatedString(buffer2, offset2) {\n            var uintBuffer = new Uint8Array(buffer2);\n            var endOffset = 0;\n            while(uintBuffer[offset2.value + endOffset] != 0){\n                endOffset += 1;\n            }\n            var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n            offset2.value = offset2.value + endOffset + 1;\n            return stringValue;\n        }\n        function parseFixedLengthString(buffer2, offset2, size) {\n            var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n            offset2.value = offset2.value + size;\n            return stringValue;\n        }\n        function parseRational(dataView, offset2) {\n            var x = parseInt32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseTimecode(dataView, offset2) {\n            var x = parseUint32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseInt32(dataView, offset2) {\n            var Int32 = dataView.getInt32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Int32;\n        }\n        function parseUint32(dataView, offset2) {\n            var Uint32 = dataView.getUint32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Uint32;\n        }\n        function parseUint8Array(uInt8Array2, offset2) {\n            var Uint8 = uInt8Array2[offset2.value];\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        function parseUint8(dataView, offset2) {\n            var Uint8 = dataView.getUint8(offset2.value);\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        const parseInt64 = function(dataView, offset2) {\n            let int;\n            if (\"getBigInt64\" in DataView.prototype) {\n                int = Number(dataView.getBigInt64(offset2.value, true));\n            } else {\n                int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n            }\n            offset2.value += ULONG_SIZE;\n            return int;\n        };\n        function parseFloat32(dataView, offset2) {\n            var float = dataView.getFloat32(offset2.value, true);\n            offset2.value += FLOAT32_SIZE;\n            return float;\n        }\n        function decodeFloat32(dataView, offset2) {\n            return three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n        }\n        function decodeFloat16(binary) {\n            var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n            return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n        }\n        function parseUint16(dataView, offset2) {\n            var Uint16 = dataView.getUint16(offset2.value, true);\n            offset2.value += INT16_SIZE;\n            return Uint16;\n        }\n        function parseFloat16(buffer2, offset2) {\n            return decodeFloat16(parseUint16(buffer2, offset2));\n        }\n        function parseChlist(dataView, buffer2, offset2, size) {\n            var startOffset = offset2.value;\n            var channels = [];\n            while(offset2.value < startOffset + size - 1){\n                var name = parseNullTerminatedString(buffer2, offset2);\n                var pixelType = parseInt32(dataView, offset2);\n                var pLinear = parseUint8(dataView, offset2);\n                offset2.value += 3;\n                var xSampling = parseInt32(dataView, offset2);\n                var ySampling = parseInt32(dataView, offset2);\n                channels.push({\n                    name,\n                    pixelType,\n                    pLinear,\n                    xSampling,\n                    ySampling\n                });\n            }\n            offset2.value += 1;\n            return channels;\n        }\n        function parseChromaticities(dataView, offset2) {\n            var redX = parseFloat32(dataView, offset2);\n            var redY = parseFloat32(dataView, offset2);\n            var greenX = parseFloat32(dataView, offset2);\n            var greenY = parseFloat32(dataView, offset2);\n            var blueX = parseFloat32(dataView, offset2);\n            var blueY = parseFloat32(dataView, offset2);\n            var whiteX = parseFloat32(dataView, offset2);\n            var whiteY = parseFloat32(dataView, offset2);\n            return {\n                redX,\n                redY,\n                greenX,\n                greenY,\n                blueX,\n                blueY,\n                whiteX,\n                whiteY\n            };\n        }\n        function parseCompression(dataView, offset2) {\n            var compressionCodes = [\n                \"NO_COMPRESSION\",\n                \"RLE_COMPRESSION\",\n                \"ZIPS_COMPRESSION\",\n                \"ZIP_COMPRESSION\",\n                \"PIZ_COMPRESSION\",\n                \"PXR24_COMPRESSION\",\n                \"B44_COMPRESSION\",\n                \"B44A_COMPRESSION\",\n                \"DWAA_COMPRESSION\",\n                \"DWAB_COMPRESSION\"\n            ];\n            var compression = parseUint8(dataView, offset2);\n            return compressionCodes[compression];\n        }\n        function parseBox2i(dataView, offset2) {\n            var xMin = parseUint32(dataView, offset2);\n            var yMin = parseUint32(dataView, offset2);\n            var xMax = parseUint32(dataView, offset2);\n            var yMax = parseUint32(dataView, offset2);\n            return {\n                xMin,\n                yMin,\n                xMax,\n                yMax\n            };\n        }\n        function parseLineOrder(dataView, offset2) {\n            var lineOrders = [\n                \"INCREASING_Y\"\n            ];\n            var lineOrder = parseUint8(dataView, offset2);\n            return lineOrders[lineOrder];\n        }\n        function parseV2f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseV3f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            var z = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y,\n                z\n            ];\n        }\n        function parseValue(dataView, buffer2, offset2, type, size) {\n            if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n                return parseFixedLengthString(buffer2, offset2, size);\n            } else if (type === \"chlist\") {\n                return parseChlist(dataView, buffer2, offset2, size);\n            } else if (type === \"chromaticities\") {\n                return parseChromaticities(dataView, offset2);\n            } else if (type === \"compression\") {\n                return parseCompression(dataView, offset2);\n            } else if (type === \"box2i\") {\n                return parseBox2i(dataView, offset2);\n            } else if (type === \"lineOrder\") {\n                return parseLineOrder(dataView, offset2);\n            } else if (type === \"float\") {\n                return parseFloat32(dataView, offset2);\n            } else if (type === \"v2f\") {\n                return parseV2f(dataView, offset2);\n            } else if (type === \"v3f\") {\n                return parseV3f(dataView, offset2);\n            } else if (type === \"int\") {\n                return parseInt32(dataView, offset2);\n            } else if (type === \"rational\") {\n                return parseRational(dataView, offset2);\n            } else if (type === \"timecode\") {\n                return parseTimecode(dataView, offset2);\n            } else if (type === \"preview\") {\n                offset2.value += size;\n                return \"skipped\";\n            } else {\n                offset2.value += size;\n                return void 0;\n            }\n        }\n        function parseHeader(dataView, buffer2, offset2) {\n            const EXRHeader2 = {};\n            if (dataView.getUint32(0, true) != 20000630) {\n                throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n            }\n            EXRHeader2.version = dataView.getUint8(4);\n            const spec = dataView.getUint8(5);\n            EXRHeader2.spec = {\n                singleTile: !!(spec & 2),\n                longName: !!(spec & 4),\n                deepFormat: !!(spec & 8),\n                multiPart: !!(spec & 16)\n            };\n            offset2.value = 8;\n            var keepReading = true;\n            while(keepReading){\n                var attributeName = parseNullTerminatedString(buffer2, offset2);\n                if (attributeName == 0) {\n                    keepReading = false;\n                } else {\n                    var attributeType = parseNullTerminatedString(buffer2, offset2);\n                    var attributeSize = parseUint32(dataView, offset2);\n                    var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n                    if (attributeValue === void 0) {\n                        console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n                    } else {\n                        EXRHeader2[attributeName] = attributeValue;\n                    }\n                }\n            }\n            if ((spec & ~4) != 0) {\n                console.error(\"EXRHeader:\", EXRHeader2);\n                throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n            }\n            return EXRHeader2;\n        }\n        function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n            const EXRDecoder2 = {\n                size: 0,\n                viewer: dataView,\n                array: uInt8Array2,\n                offset: offset2,\n                width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n                height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n                channels: EXRHeader2.channels.length,\n                bytesPerLine: null,\n                lines: null,\n                inputSize: null,\n                type: EXRHeader2.channels[0].pixelType,\n                uncompress: null,\n                getter: null,\n                format: null,\n                [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n            };\n            switch(EXRHeader2.compression){\n                case \"NO_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRAW;\n                    break;\n                case \"RLE_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRLE;\n                    break;\n                case \"ZIPS_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"ZIP_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"PIZ_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressPIZ;\n                    break;\n                case \"PXR24_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressPXR;\n                    break;\n                case \"DWAA_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                case \"DWAB_COMPRESSION\":\n                    EXRDecoder2.lines = 256;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                default:\n                    throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n            }\n            EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n            if (EXRDecoder2.type == 1) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        EXRDecoder2.getter = parseFloat16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        EXRDecoder2.getter = parseUint16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                }\n            } else if (EXRDecoder2.type == 2) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        EXRDecoder2.getter = parseFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        EXRDecoder2.getter = decodeFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                }\n            } else {\n                throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n            }\n            EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n            for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);\n            EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n            const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n            switch(outputType){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                    EXRDecoder2.byteArray = new Float32Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    EXRDecoder2.byteArray = new Uint16Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n                    break;\n                default:\n                    console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n                    break;\n            }\n            EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n            if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n            else EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_0__.RedFormat;\n            if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";\n            else EXRDecoder2.encoding = 3e3;\n            return EXRDecoder2;\n        }\n        const bufferDataView = new DataView(buffer);\n        const uInt8Array = new Uint8Array(buffer);\n        const offset = {\n            value: 0\n        };\n        const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n        const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n        const tmpOffset = {\n            value: 0\n        };\n        const channelOffsets = {\n            R: 0,\n            G: 1,\n            B: 2,\n            A: 3,\n            Y: 0\n        };\n        for(let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){\n            const line = parseUint32(bufferDataView, offset);\n            EXRDecoder.size = parseUint32(bufferDataView, offset);\n            EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n            const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n            const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n            offset.value += EXRDecoder.size;\n            for(let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){\n                const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n                if (true_y >= EXRDecoder.height) break;\n                for(let channelID = 0; channelID < EXRDecoder.channels; channelID++){\n                    const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n                    for(let x = 0; x < EXRDecoder.width; x++){\n                        tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n                        const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n                        EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n                    }\n                }\n            }\n        }\n        return {\n            header: EXRHeader,\n            width: EXRDecoder.width,\n            height: EXRDecoder.height,\n            data: EXRDecoder.byteArray,\n            format: EXRDecoder.format,\n            [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n            type: this.type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            if (hasColorSpace) texture.colorSpace = texData.colorSpace;\n            else texture.encoding = texData.encoding;\n            texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = false;\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=EXRLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRVhSTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2SDtBQUN6RjtBQUNwQyxNQUFNUyxnQkFBZ0IsZ0JBQWdCLElBQUlULDBDQUFPQTtBQUNqRCxNQUFNVSxrQkFBa0JULG9EQUFpQkE7SUFDdkNVLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdYLGdEQUFhQTtJQUMzQjtJQUNBWSxNQUFNQyxNQUFNLEVBQUU7UUFDWixNQUFNQyxlQUFlLEtBQUs7UUFDMUIsTUFBTUMsY0FBY0QsZ0JBQWdCO1FBQ3BDLE1BQU1FLGNBQWM7UUFDcEIsTUFBTUMsY0FBYztRQUNwQixNQUFNQyxjQUFjLENBQUMsS0FBS0YsV0FBVSxJQUFLO1FBQ3pDLE1BQU1HLGNBQWMsS0FBS0Y7UUFDekIsTUFBTUcsY0FBY0QsY0FBYztRQUNsQyxNQUFNRSxRQUFRO1FBQ2QsTUFBTUMsV0FBVyxLQUFLRCxRQUFRO1FBQzlCLE1BQU1FLFdBQVcsQ0FBQyxLQUFLRixLQUFJLElBQUs7UUFDaEMsTUFBTUcscUJBQXFCO1FBQzNCLE1BQU1DLG9CQUFvQjtRQUMxQixNQUFNQyxvQkFBb0IsSUFBSUQsb0JBQW9CRDtRQUNsRCxNQUFNRyxhQUFhO1FBQ25CLE1BQU1DLGVBQWU7UUFDckIsTUFBTUMsYUFBYTtRQUNuQixNQUFNQyxhQUFhO1FBQ25CLE1BQU1DLFlBQVk7UUFDbEIsTUFBTUMsaUJBQWlCO1FBQ3ZCLE1BQU1DLFVBQVU7UUFDaEIsTUFBTUMsVUFBVTtRQUNoQixNQUFNQyxZQUFZO1FBQ2xCLE1BQU1DLE1BQU07UUFDWixNQUFNQyxVQUFVQyxLQUFLQyxHQUFHLENBQUMsV0FBVztRQUNwQyxTQUFTQyxxQkFBcUJDLE1BQU0sRUFBRUMsR0FBRztZQUN2QyxJQUFJQyxJQUFJO1lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUk5QixjQUFjLEVBQUU4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R0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsRUFBRTtZQUM5QmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEVBQUU7WUFDOUJjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxFQUFFO1lBQzlCYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1FBQ2pDO1FBQ0EsU0FBU04sV0FBV3RELElBQUk7WUFDdEIsTUFBTXZELElBQUksTUFBTXpELEtBQUsyTCxHQUFHLENBQUMsVUFBVTtZQUNuQyxNQUFNakksSUFBSSxNQUFNMUQsS0FBSzJMLEdBQUcsQ0FBQyxVQUFVO1lBQ25DLE1BQU01SyxJQUFJLE1BQU1mLEtBQUsyTCxHQUFHLENBQUMsVUFBVTtZQUNuQyxNQUFNdEgsSUFBSSxNQUFNckUsS0FBSzJMLEdBQUcsQ0FBQyxJQUFJLFVBQVU7WUFDdkMsTUFBTUMsSUFBSSxNQUFNNUwsS0FBSzJMLEdBQUcsQ0FBQyxJQUFJLFVBQVU7WUFDdkMsTUFBTUUsSUFBSSxNQUFNN0wsS0FBSzJMLEdBQUcsQ0FBQyxJQUFJLFVBQVU7WUFDdkMsTUFBTUcsSUFBSSxNQUFNOUwsS0FBSzJMLEdBQUcsQ0FBQyxJQUFJLFVBQVU7WUFDdkMsSUFBSUksUUFBUSxJQUFJeEssTUFBTTtZQUN0QixJQUFJeUssT0FBTyxJQUFJekssTUFBTTtZQUNyQixJQUFJMEssUUFBUSxJQUFJMUssTUFBTTtZQUN0QixJQUFJMkssUUFBUSxJQUFJM0ssTUFBTTtZQUN0QixJQUFLLElBQUk0SyxNQUFNLEdBQUdBLE1BQU0sR0FBRyxFQUFFQSxJQUFLO2dCQUNoQyxJQUFJQyxTQUFTRCxNQUFNO2dCQUNuQkosS0FBSyxDQUFDLEVBQUUsR0FBR2hMLElBQUlpRyxJQUFJLENBQUNvRixTQUFTLEVBQUU7Z0JBQy9CTCxLQUFLLENBQUMsRUFBRSxHQUFHRixJQUFJN0UsSUFBSSxDQUFDb0YsU0FBUyxFQUFFO2dCQUMvQkwsS0FBSyxDQUFDLEVBQUUsR0FBR2hMLElBQUlpRyxJQUFJLENBQUNvRixTQUFTLEVBQUU7Z0JBQy9CTCxLQUFLLENBQUMsRUFBRSxHQUFHRixJQUFJN0UsSUFBSSxDQUFDb0YsU0FBUyxFQUFFO2dCQUMvQkosSUFBSSxDQUFDLEVBQUUsR0FBR3RJLElBQUlzRCxJQUFJLENBQUNvRixTQUFTLEVBQUUsR0FBRy9ILElBQUkyQyxJQUFJLENBQUNvRixTQUFTLEVBQUUsR0FBR1IsSUFBSTVFLElBQUksQ0FBQ29GLFNBQVMsRUFBRSxHQUFHTixJQUFJOUUsSUFBSSxDQUFDb0YsU0FBUyxFQUFFO2dCQUNuR0osSUFBSSxDQUFDLEVBQUUsR0FBRzNILElBQUkyQyxJQUFJLENBQUNvRixTQUFTLEVBQUUsR0FBR04sSUFBSTlFLElBQUksQ0FBQ29GLFNBQVMsRUFBRSxHQUFHMUksSUFBSXNELElBQUksQ0FBQ29GLFNBQVMsRUFBRSxHQUFHUixJQUFJNUUsSUFBSSxDQUFDb0YsU0FBUyxFQUFFO2dCQUNuR0osSUFBSSxDQUFDLEVBQUUsR0FBR0osSUFBSTVFLElBQUksQ0FBQ29GLFNBQVMsRUFBRSxHQUFHMUksSUFBSXNELElBQUksQ0FBQ29GLFNBQVMsRUFBRSxHQUFHTixJQUFJOUUsSUFBSSxDQUFDb0YsU0FBUyxFQUFFLEdBQUcvSCxJQUFJMkMsSUFBSSxDQUFDb0YsU0FBUyxFQUFFO2dCQUNuR0osSUFBSSxDQUFDLEVBQUUsR0FBR0YsSUFBSTlFLElBQUksQ0FBQ29GLFNBQVMsRUFBRSxHQUFHUixJQUFJNUUsSUFBSSxDQUFDb0YsU0FBUyxFQUFFLEdBQUcvSCxJQUFJMkMsSUFBSSxDQUFDb0YsU0FBUyxFQUFFLEdBQUcxSSxJQUFJc0QsSUFBSSxDQUFDb0YsU0FBUyxFQUFFO2dCQUNuR0gsS0FBSyxDQUFDLEVBQUUsR0FBR3hJLElBQUt1RCxDQUFBQSxJQUFJLENBQUNvRixTQUFTLEVBQUUsR0FBR3BGLElBQUksQ0FBQ29GLFNBQVMsRUFBRTtnQkFDbkRILEtBQUssQ0FBQyxFQUFFLEdBQUd4SSxJQUFLdUQsQ0FBQUEsSUFBSSxDQUFDb0YsU0FBUyxFQUFFLEdBQUdwRixJQUFJLENBQUNvRixTQUFTLEVBQUU7Z0JBQ25ESCxLQUFLLENBQUMsRUFBRSxHQUFHRixLQUFLLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRTtnQkFDOUJFLEtBQUssQ0FBQyxFQUFFLEdBQUdGLEtBQUssQ0FBQyxFQUFFLEdBQUdBLEtBQUssQ0FBQyxFQUFFO2dCQUM5QkcsS0FBSyxDQUFDLEVBQUUsR0FBR0QsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUU7Z0JBQzlCQyxLQUFLLENBQUMsRUFBRSxHQUFHRCxLQUFLLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRTtnQkFDOUJDLEtBQUssQ0FBQyxFQUFFLEdBQUdELEtBQUssQ0FBQyxFQUFFLEdBQUdBLEtBQUssQ0FBQyxFQUFFO2dCQUM5QkMsS0FBSyxDQUFDLEVBQUUsR0FBR0QsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUU7Z0JBQzlCakYsSUFBSSxDQUFDb0YsU0FBUyxFQUFFLEdBQUdGLEtBQUssQ0FBQyxFQUFFLEdBQUdGLElBQUksQ0FBQyxFQUFFO2dCQUNyQ2hGLElBQUksQ0FBQ29GLFNBQVMsRUFBRSxHQUFHRixLQUFLLENBQUMsRUFBRSxHQUFHRixJQUFJLENBQUMsRUFBRTtnQkFDckNoRixJQUFJLENBQUNvRixTQUFTLEVBQUUsR0FBR0YsS0FBSyxDQUFDLEVBQUUsR0FBR0YsSUFBSSxDQUFDLEVBQUU7Z0JBQ3JDaEYsSUFBSSxDQUFDb0YsU0FBUyxFQUFFLEdBQUdGLEtBQUssQ0FBQyxFQUFFLEdBQUdGLElBQUksQ0FBQyxFQUFFO2dCQUNyQ2hGLElBQUksQ0FBQ29GLFNBQVMsRUFBRSxHQUFHRixLQUFLLENBQUMsRUFBRSxHQUFHRixJQUFJLENBQUMsRUFBRTtnQkFDckNoRixJQUFJLENBQUNvRixTQUFTLEVBQUUsR0FBR0YsS0FBSyxDQUFDLEVBQUUsR0FBR0YsSUFBSSxDQUFDLEVBQUU7Z0JBQ3JDaEYsSUFBSSxDQUFDb0YsU0FBUyxFQUFFLEdBQUdGLEtBQUssQ0FBQyxFQUFFLEdBQUdGLElBQUksQ0FBQyxFQUFFO2dCQUNyQ2hGLElBQUksQ0FBQ29GLFNBQVMsRUFBRSxHQUFHRixLQUFLLENBQUMsRUFBRSxHQUFHRixJQUFJLENBQUMsRUFBRTtZQUN2QztZQUNBLElBQUssSUFBSUssU0FBUyxHQUFHQSxTQUFTLEdBQUcsRUFBRUEsT0FBUTtnQkFDekNOLEtBQUssQ0FBQyxFQUFFLEdBQUdoTCxJQUFJaUcsSUFBSSxDQUFDLEtBQUtxRixPQUFPO2dCQUNoQ04sS0FBSyxDQUFDLEVBQUUsR0FBR0YsSUFBSTdFLElBQUksQ0FBQyxLQUFLcUYsT0FBTztnQkFDaENOLEtBQUssQ0FBQyxFQUFFLEdBQUdoTCxJQUFJaUcsSUFBSSxDQUFDLEtBQUtxRixPQUFPO2dCQUNoQ04sS0FBSyxDQUFDLEVBQUUsR0FBR0YsSUFBSTdFLElBQUksQ0FBQyxLQUFLcUYsT0FBTztnQkFDaENMLElBQUksQ0FBQyxFQUFFLEdBQUd0SSxJQUFJc0QsSUFBSSxDQUFDLElBQUlxRixPQUFPLEdBQUdoSSxJQUFJMkMsSUFBSSxDQUFDLEtBQUtxRixPQUFPLEdBQUdULElBQUk1RSxJQUFJLENBQUMsS0FBS3FGLE9BQU8sR0FBR1AsSUFBSTlFLElBQUksQ0FBQyxLQUFLcUYsT0FBTztnQkFDdEdMLElBQUksQ0FBQyxFQUFFLEdBQUczSCxJQUFJMkMsSUFBSSxDQUFDLElBQUlxRixPQUFPLEdBQUdQLElBQUk5RSxJQUFJLENBQUMsS0FBS3FGLE9BQU8sR0FBRzNJLElBQUlzRCxJQUFJLENBQUMsS0FBS3FGLE9BQU8sR0FBR1QsSUFBSTVFLElBQUksQ0FBQyxLQUFLcUYsT0FBTztnQkFDdEdMLElBQUksQ0FBQyxFQUFFLEdBQUdKLElBQUk1RSxJQUFJLENBQUMsSUFBSXFGLE9BQU8sR0FBRzNJLElBQUlzRCxJQUFJLENBQUMsS0FBS3FGLE9BQU8sR0FBR1AsSUFBSTlFLElBQUksQ0FBQyxLQUFLcUYsT0FBTyxHQUFHaEksSUFBSTJDLElBQUksQ0FBQyxLQUFLcUYsT0FBTztnQkFDdEdMLElBQUksQ0FBQyxFQUFFLEdBQUdGLElBQUk5RSxJQUFJLENBQUMsSUFBSXFGLE9BQU8sR0FBR1QsSUFBSTVFLElBQUksQ0FBQyxLQUFLcUYsT0FBTyxHQUFHaEksSUFBSTJDLElBQUksQ0FBQyxLQUFLcUYsT0FBTyxHQUFHM0ksSUFBSXNELElBQUksQ0FBQyxLQUFLcUYsT0FBTztnQkFDdEdKLEtBQUssQ0FBQyxFQUFFLEdBQUd4SSxJQUFLdUQsQ0FBQUEsSUFBSSxDQUFDcUYsT0FBTyxHQUFHckYsSUFBSSxDQUFDLEtBQUtxRixPQUFPO2dCQUNoREosS0FBSyxDQUFDLEVBQUUsR0FBR3hJLElBQUt1RCxDQUFBQSxJQUFJLENBQUNxRixPQUFPLEdBQUdyRixJQUFJLENBQUMsS0FBS3FGLE9BQU87Z0JBQ2hESixLQUFLLENBQUMsRUFBRSxHQUFHRixLQUFLLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRTtnQkFDOUJFLEtBQUssQ0FBQyxFQUFFLEdBQUdGLEtBQUssQ0FBQyxFQUFFLEdBQUdBLEtBQUssQ0FBQyxFQUFFO2dCQUM5QkcsS0FBSyxDQUFDLEVBQUUsR0FBR0QsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUU7Z0JBQzlCQyxLQUFLLENBQUMsRUFBRSxHQUFHRCxLQUFLLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRTtnQkFDOUJDLEtBQUssQ0FBQyxFQUFFLEdBQUdELEtBQUssQ0FBQyxFQUFFLEdBQUdBLEtBQUssQ0FBQyxFQUFFO2dCQUM5QkMsS0FBSyxDQUFDLEVBQUUsR0FBR0QsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUU7Z0JBQzlCakYsSUFBSSxDQUFDLElBQUlxRixPQUFPLEdBQUdILEtBQUssQ0FBQyxFQUFFLEdBQUdGLElBQUksQ0FBQyxFQUFFO2dCQUNyQ2hGLElBQUksQ0FBQyxJQUFJcUYsT0FBTyxHQUFHSCxLQUFLLENBQUMsRUFBRSxHQUFHRixJQUFJLENBQUMsRUFBRTtnQkFDckNoRixJQUFJLENBQUMsS0FBS3FGLE9BQU8sR0FBR0gsS0FBSyxDQUFDLEVBQUUsR0FBR0YsSUFBSSxDQUFDLEVBQUU7Z0JBQ3RDaEYsSUFBSSxDQUFDLEtBQUtxRixPQUFPLEdBQUdILEtBQUssQ0FBQyxFQUFFLEdBQUdGLElBQUksQ0FBQyxFQUFFO2dCQUN0Q2hGLElBQUksQ0FBQyxLQUFLcUYsT0FBTyxHQUFHSCxLQUFLLENBQUMsRUFBRSxHQUFHRixJQUFJLENBQUMsRUFBRTtnQkFDdENoRixJQUFJLENBQUMsS0FBS3FGLE9BQU8sR0FBR0gsS0FBSyxDQUFDLEVBQUUsR0FBR0YsSUFBSSxDQUFDLEVBQUU7Z0JBQ3RDaEYsSUFBSSxDQUFDLEtBQUtxRixPQUFPLEdBQUdILEtBQUssQ0FBQyxFQUFFLEdBQUdGLElBQUksQ0FBQyxFQUFFO2dCQUN0Q2hGLElBQUksQ0FBQyxLQUFLcUYsT0FBTyxHQUFHSCxLQUFLLENBQUMsRUFBRSxHQUFHRixJQUFJLENBQUMsRUFBRTtZQUN4QztRQUNGO1FBQ0EsU0FBU3pCLGNBQWN2RCxJQUFJO1lBQ3pCLElBQUssSUFBSTFHLElBQUksR0FBR0EsSUFBSSxJQUFJLEVBQUVBLEVBQUc7Z0JBQzNCLElBQUk2SyxJQUFJbkUsSUFBSSxDQUFDLEVBQUUsQ0FBQzFHLEVBQUU7Z0JBQ2xCLElBQUlnTSxLQUFLdEYsSUFBSSxDQUFDLEVBQUUsQ0FBQzFHLEVBQUU7Z0JBQ25CLElBQUlpTSxLQUFLdkYsSUFBSSxDQUFDLEVBQUUsQ0FBQzFHLEVBQUU7Z0JBQ25CMEcsSUFBSSxDQUFDLEVBQUUsQ0FBQzFHLEVBQUUsR0FBRzZLLElBQUksU0FBU29CO2dCQUMxQnZGLElBQUksQ0FBQyxFQUFFLENBQUMxRyxFQUFFLEdBQUc2SyxJQUFJLFNBQVNtQixLQUFLLFNBQVNDO2dCQUN4Q3ZGLElBQUksQ0FBQyxFQUFFLENBQUMxRyxFQUFFLEdBQUc2SyxJQUFJLFNBQVNtQjtZQUM1QjtRQUNGO1FBQ0EsU0FBUzlCLGNBQWNJLEdBQUcsRUFBRWMsR0FBRyxFQUFFN0MsR0FBRztZQUNsQyxJQUFLLElBQUl2SSxJQUFJLEdBQUdBLElBQUksSUFBSSxFQUFFQSxFQUFHO2dCQUMzQm9MLEdBQUcsQ0FBQzdDLE1BQU12SSxFQUFFLEdBQUd2Qyw0Q0FBU0EsQ0FBQ3lPLFdBQVcsQ0FBQ0MsU0FBUzdCLEdBQUcsQ0FBQ3RLLEVBQUU7WUFDdEQ7UUFDRjtRQUNBLFNBQVNtTSxTQUFTQyxLQUFLO1lBQ3JCLElBQUlBLFNBQVMsR0FBRztnQkFDZCxPQUFPMU0sS0FBSzJNLElBQUksQ0FBQ0QsU0FBUzFNLEtBQUtDLEdBQUcsQ0FBQ0QsS0FBSzRNLEdBQUcsQ0FBQ0YsUUFBUTtZQUN0RCxPQUFPO2dCQUNMLE9BQU8xTSxLQUFLMk0sSUFBSSxDQUFDRCxTQUFTMU0sS0FBS0MsR0FBRyxDQUFDRixTQUFTQyxLQUFLNE0sR0FBRyxDQUFDRixTQUFTO1lBQ2hFO1FBQ0Y7UUFDQSxTQUFTRyxjQUFjQyxJQUFJO1lBQ3pCLE9BQU8sSUFBSTlFLFNBQVM4RSxLQUFLQyxLQUFLLENBQUN4TyxNQUFNLEVBQUV1TyxLQUFLRSxNQUFNLENBQUNoTCxLQUFLLEVBQUU4SyxLQUFLakYsSUFBSTtRQUNyRTtRQUNBLFNBQVNvRixjQUFjSCxJQUFJO1lBQ3pCLElBQUlJLGFBQWFKLEtBQUtLLE1BQU0sQ0FBQzVPLE1BQU0sQ0FBQzZPLEtBQUssQ0FBQ04sS0FBS0UsTUFBTSxDQUFDaEwsS0FBSyxFQUFFOEssS0FBS0UsTUFBTSxDQUFDaEwsS0FBSyxHQUFHOEssS0FBS2pGLElBQUk7WUFDMUYsSUFBSXdGLFlBQVksSUFBSWxLLFdBQVd5RSxnQkFBZ0JzRjtZQUMvQyxJQUFJSSxZQUFZLElBQUluSyxXQUFXa0ssVUFBVWhHLE1BQU07WUFDL0NILFVBQVVtRztZQUNWL0YsaUJBQWlCK0YsV0FBV0M7WUFDNUIsT0FBTyxJQUFJdEYsU0FBU3NGLFVBQVUvTyxNQUFNO1FBQ3RDO1FBQ0EsU0FBU2dQLGNBQWNULElBQUk7WUFDekIsSUFBSUksYUFBYUosS0FBS0MsS0FBSyxDQUFDSyxLQUFLLENBQUNOLEtBQUtFLE1BQU0sQ0FBQ2hMLEtBQUssRUFBRThLLEtBQUtFLE1BQU0sQ0FBQ2hMLEtBQUssR0FBRzhLLEtBQUtqRixJQUFJO1lBQ2xGLElBQUl3RixZQUFZclAsa0RBQVVBLENBQUNrUDtZQUMzQixJQUFJSSxZQUFZLElBQUluSyxXQUFXa0ssVUFBVWhHLE1BQU07WUFDL0NILFVBQVVtRztZQUNWL0YsaUJBQWlCK0YsV0FBV0M7WUFDNUIsT0FBTyxJQUFJdEYsU0FBU3NGLFVBQVUvTyxNQUFNO1FBQ3RDO1FBQ0EsU0FBU2lQLGNBQWNWLElBQUk7WUFDekIsSUFBSWxMLGFBQWFrTCxLQUFLSyxNQUFNO1lBQzVCLElBQUkvTCxXQUFXO2dCQUFFWSxPQUFPOEssS0FBS0UsTUFBTSxDQUFDaEwsS0FBSztZQUFDO1lBQzFDLElBQUllLFlBQVksSUFBSStHLFlBQVlnRCxLQUFLbEUsS0FBSyxHQUFHa0UsS0FBS1csaUJBQWlCLEdBQUlYLENBQUFBLEtBQUtZLFFBQVEsR0FBR1osS0FBS3pPLElBQUk7WUFDaEcsSUFBSThCLFNBQVMsSUFBSWdELFdBQVcxRTtZQUM1QixJQUFJa1AsZUFBZTtZQUNuQixJQUFJQyxpQkFBaUIsSUFBSXJNLE1BQU11TCxLQUFLWSxRQUFRO1lBQzVDLElBQUssSUFBSXBOLElBQUksR0FBR0EsSUFBSXdNLEtBQUtZLFFBQVEsRUFBRXBOLElBQUs7Z0JBQ3RDc04sY0FBYyxDQUFDdE4sRUFBRSxHQUFHLENBQUM7Z0JBQ3JCc04sY0FBYyxDQUFDdE4sRUFBRSxDQUFDLFFBQVEsR0FBR3FOO2dCQUM3QkMsY0FBYyxDQUFDdE4sRUFBRSxDQUFDLE1BQU0sR0FBR3NOLGNBQWMsQ0FBQ3ROLEVBQUUsQ0FBQyxRQUFRO2dCQUNyRHNOLGNBQWMsQ0FBQ3ROLEVBQUUsQ0FBQyxLQUFLLEdBQUd3TSxLQUFLbEUsS0FBSztnQkFDcENnRixjQUFjLENBQUN0TixFQUFFLENBQUMsS0FBSyxHQUFHd00sS0FBS2UsS0FBSztnQkFDcENELGNBQWMsQ0FBQ3ROLEVBQUUsQ0FBQyxPQUFPLEdBQUd3TSxLQUFLek8sSUFBSTtnQkFDckNzUCxnQkFBZ0JDLGNBQWMsQ0FBQ3ROLEVBQUUsQ0FBQ3FFLEVBQUUsR0FBR2lKLGNBQWMsQ0FBQ3ROLEVBQUUsQ0FBQ3VFLEVBQUUsR0FBRytJLGNBQWMsQ0FBQ3ROLEVBQUUsQ0FBQ3VILElBQUk7WUFDdEY7WUFDQSxJQUFJaUcsYUFBYUMsWUFBWW5NLFlBQVlSO1lBQ3pDLElBQUk0TSxhQUFhRCxZQUFZbk0sWUFBWVI7WUFDekMsSUFBSTRNLGNBQWN2UCxhQUFhO2dCQUM3QixNQUFNO1lBQ1I7WUFDQSxJQUFJcVAsY0FBY0UsWUFBWTtnQkFDNUIsSUFBSyxJQUFJMU4sSUFBSSxHQUFHQSxJQUFJME4sYUFBYUYsYUFBYSxHQUFHeE4sSUFBSztvQkFDcERILE1BQU0sQ0FBQ0csSUFBSXdOLFdBQVcsR0FBR0csV0FBV3JNLFlBQVlSO2dCQUNsRDtZQUNGO1lBQ0EsSUFBSWhCLE1BQU0sSUFBSTBKLFlBQVl0TDtZQUMxQixJQUFJMFAsV0FBV2hPLHFCQUFxQkMsUUFBUUM7WUFDNUMsSUFBSWlILFNBQVNSLFlBQVlqRixZQUFZUjtZQUNyQ3FGLGNBQWNxRyxLQUFLQyxLQUFLLEVBQUVuTCxZQUFZUixVQUFVaUcsUUFBUXRFLFdBQVc0SztZQUNuRSxJQUFLLElBQUlyTixJQUFJLEdBQUdBLElBQUl3TSxLQUFLWSxRQUFRLEVBQUUsRUFBRXBOLEVBQUc7Z0JBQ3RDLElBQUk2TixLQUFLUCxjQUFjLENBQUN0TixFQUFFO2dCQUMxQixJQUFLLElBQUlvRSxJQUFJLEdBQUdBLElBQUlrSixjQUFjLENBQUN0TixFQUFFLENBQUN1SCxJQUFJLEVBQUUsRUFBRW5ELEVBQUc7b0JBQy9DRixXQUFXekIsV0FBV29MLEdBQUdDLEtBQUssR0FBRzFKLEdBQUd5SixHQUFHeEosRUFBRSxFQUFFd0osR0FBR3RHLElBQUksRUFBRXNHLEdBQUd0SixFQUFFLEVBQUVzSixHQUFHeEosRUFBRSxHQUFHd0osR0FBR3RHLElBQUksRUFBRXFHO2dCQUM5RTtZQUNGO1lBQ0FuSCxTQUFTM0csS0FBSzJDLFdBQVc0SztZQUN6QixJQUFJVSxhQUFhO1lBQ2pCLElBQUlmLFlBQVksSUFBSW5LLFdBQVdKLFVBQVV4RSxNQUFNLENBQUN1SixVQUFVO1lBQzFELElBQUssSUFBSXFELElBQUksR0FBR0EsSUFBSTJCLEtBQUtlLEtBQUssRUFBRTFDLElBQUs7Z0JBQ25DLElBQUssSUFBSXBLLElBQUksR0FBR0EsSUFBSStMLEtBQUtZLFFBQVEsRUFBRTNNLElBQUs7b0JBQ3RDLElBQUlvTixLQUFLUCxjQUFjLENBQUM3TSxFQUFFO29CQUMxQixJQUFJUixJQUFJNE4sR0FBR3hKLEVBQUUsR0FBR3dKLEdBQUd0RyxJQUFJO29CQUN2QixJQUFJeUcsS0FBSyxJQUFJbkwsV0FBV0osVUFBVXhFLE1BQU0sRUFBRTRQLEdBQUdJLEdBQUcsR0FBRy9PLFlBQVllLElBQUlmO29CQUNuRThOLFVBQVVrQixHQUFHLENBQUNGLElBQUlEO29CQUNsQkEsY0FBYzlOLElBQUlmO29CQUNsQjJPLEdBQUdJLEdBQUcsSUFBSWhPO2dCQUNaO1lBQ0Y7WUFDQSxPQUFPLElBQUl5SCxTQUFTc0YsVUFBVS9PLE1BQU07UUFDdEM7UUFDQSxTQUFTa1EsY0FBYzNCLElBQUk7WUFDekIsSUFBSUksYUFBYUosS0FBS0MsS0FBSyxDQUFDSyxLQUFLLENBQUNOLEtBQUtFLE1BQU0sQ0FBQ2hMLEtBQUssRUFBRThLLEtBQUtFLE1BQU0sQ0FBQ2hMLEtBQUssR0FBRzhLLEtBQUtqRixJQUFJO1lBQ2xGLElBQUl3RixZQUFZclAsa0RBQVVBLENBQUNrUDtZQUMzQixNQUFNd0IsS0FBSzVCLEtBQUtlLEtBQUssR0FBR2YsS0FBS1ksUUFBUSxHQUFHWixLQUFLbEUsS0FBSztZQUNsRCxNQUFNMEUsWUFBWVIsS0FBS3pPLElBQUksSUFBSSxJQUFJLElBQUl5TCxZQUFZNEUsTUFBTSxJQUFJQyxZQUFZRDtZQUN6RSxJQUFJRSxlQUFlO1lBQ25CLElBQUlDLFdBQVc7WUFDZixNQUFNQyxNQUFNLElBQUl2TixNQUFNO1lBQ3RCLElBQUssSUFBSTRKLElBQUksR0FBR0EsSUFBSTJCLEtBQUtlLEtBQUssRUFBRTFDLElBQUs7Z0JBQ25DLElBQUssSUFBSXBLLElBQUksR0FBR0EsSUFBSStMLEtBQUtZLFFBQVEsRUFBRTNNLElBQUs7b0JBQ3RDLElBQUlnTyxRQUFRO29CQUNaLE9BQVFqQyxLQUFLek8sSUFBSTt3QkFDZixLQUFLOzRCQUNIeVEsR0FBRyxDQUFDLEVBQUUsR0FBR0Y7NEJBQ1RFLEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLEdBQUdoQyxLQUFLbEUsS0FBSzs0QkFDNUJnRyxlQUFlRSxHQUFHLENBQUMsRUFBRSxHQUFHaEMsS0FBS2xFLEtBQUs7NEJBQ2xDLElBQUssSUFBSWxFLElBQUksR0FBR0EsSUFBSW9JLEtBQUtsRSxLQUFLLEVBQUUsRUFBRWxFLEVBQUc7Z0NBQ25DLE1BQU1zSyxPQUFPM0IsU0FBUyxDQUFDeUIsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJLElBQUl6QixTQUFTLENBQUN5QixHQUFHLENBQUMsRUFBRSxHQUFHO2dDQUMzREMsU0FBU0M7Z0NBQ1QxQixTQUFTLENBQUN1QixTQUFTLEdBQUdFO2dDQUN0QkY7NEJBQ0Y7NEJBQ0E7d0JBQ0YsS0FBSzs0QkFDSEMsR0FBRyxDQUFDLEVBQUUsR0FBR0Y7NEJBQ1RFLEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLEdBQUdoQyxLQUFLbEUsS0FBSzs0QkFDNUJrRyxHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxHQUFHaEMsS0FBS2xFLEtBQUs7NEJBQzVCZ0csZUFBZUUsR0FBRyxDQUFDLEVBQUUsR0FBR2hDLEtBQUtsRSxLQUFLOzRCQUNsQyxJQUFLLElBQUlsRSxJQUFJLEdBQUdBLElBQUlvSSxLQUFLbEUsS0FBSyxFQUFFLEVBQUVsRSxFQUFHO2dDQUNuQyxNQUFNc0ssT0FBTzNCLFNBQVMsQ0FBQ3lCLEdBQUcsQ0FBQyxFQUFFLEdBQUcsSUFBSSxLQUFLekIsU0FBUyxDQUFDeUIsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJLEtBQUt6QixTQUFTLENBQUN5QixHQUFHLENBQUMsRUFBRSxHQUFHLElBQUk7Z0NBQzVGQyxTQUFTQztnQ0FDVDFCLFNBQVMsQ0FBQ3VCLFNBQVMsR0FBR0U7Z0NBQ3RCRjs0QkFDRjs0QkFDQTtvQkFDSjtnQkFDRjtZQUNGO1lBQ0EsT0FBTyxJQUFJN0csU0FBU3NGLFVBQVUvTyxNQUFNO1FBQ3RDO1FBQ0EsU0FBUzBRLGNBQWNuQyxJQUFJO1lBQ3pCLElBQUlsTCxhQUFha0wsS0FBS0ssTUFBTTtZQUM1QixJQUFJL0wsV0FBVztnQkFBRVksT0FBTzhLLEtBQUtFLE1BQU0sQ0FBQ2hMLEtBQUs7WUFBQztZQUMxQyxJQUFJZSxZQUFZLElBQUlJLFdBQVcySixLQUFLbEUsS0FBSyxHQUFHa0UsS0FBS2UsS0FBSyxHQUFJZixDQUFBQSxLQUFLWSxRQUFRLEdBQUdaLEtBQUt6TyxJQUFJLEdBQUdtQixVQUFTO1lBQy9GLElBQUkwUCxZQUFZO2dCQUNkQyxTQUFTQyxXQUFXeE4sWUFBWVI7Z0JBQ2hDaU8seUJBQXlCRCxXQUFXeE4sWUFBWVI7Z0JBQ2hEa08sdUJBQXVCRixXQUFXeE4sWUFBWVI7Z0JBQzlDbU8sa0JBQWtCSCxXQUFXeE4sWUFBWVI7Z0JBQ3pDb08sa0JBQWtCSixXQUFXeE4sWUFBWVI7Z0JBQ3pDcU8sbUJBQW1CTCxXQUFXeE4sWUFBWVI7Z0JBQzFDc08scUJBQXFCTixXQUFXeE4sWUFBWVI7Z0JBQzVDdU8sWUFBWVAsV0FBV3hOLFlBQVlSO2dCQUNuQ3dPLDBCQUEwQlIsV0FBV3hOLFlBQVlSO2dCQUNqRHlPLDBCQUEwQlQsV0FBV3hOLFlBQVlSO2dCQUNqRDBPLGVBQWVWLFdBQVd4TixZQUFZUjtZQUN4QztZQUNBLElBQUk4TixVQUFVQyxPQUFPLEdBQUcsR0FBRztnQkFDekIsTUFBTSxzQkFBc0JZLFVBQVVDLFdBQVcsR0FBRyxjQUFjZCxVQUFVQyxPQUFPLEdBQUc7WUFDeEY7WUFDQSxJQUFJYyxlQUFlLElBQUkxTztZQUN2QixJQUFJMk8sV0FBV25DLFlBQVluTSxZQUFZUixZQUFZNUI7WUFDbkQsTUFBTzBRLFdBQVcsRUFBRztnQkFDbkIsSUFBSUMsT0FBT0MsMEJBQTBCeE8sV0FBV3JELE1BQU0sRUFBRTZDO2dCQUN4RCxJQUFJWSxRQUFRaU0sV0FBV3JNLFlBQVlSO2dCQUNuQyxJQUFJNE8sY0FBY2hPLFNBQVMsSUFBSTtnQkFDL0IsSUFBSXFPLE1BQU0sQ0FBQ3JPLFNBQVMsS0FBSztnQkFDekIsSUFBSXdFLFFBQVEsSUFBSThKLFVBQVU7b0JBQUNEO2lCQUFJLENBQUMsQ0FBQyxFQUFFO2dCQUNuQyxJQUFJaFMsT0FBTzRQLFdBQVdyTSxZQUFZUjtnQkFDbEM2TyxhQUFhOUgsSUFBSSxDQUFDO29CQUNoQmdJO29CQUNBM0o7b0JBQ0FuSTtvQkFDQTJSO2dCQUNGO2dCQUNBRSxZQUFZQyxLQUFLOUksTUFBTSxHQUFHO1lBQzVCO1lBQ0EsSUFBSXFHLFdBQVdxQyxVQUFVckMsUUFBUTtZQUNqQyxJQUFJbEYsY0FBYyxJQUFJakgsTUFBTXVMLEtBQUtZLFFBQVE7WUFDekMsSUFBSyxJQUFJcE4sSUFBSSxHQUFHQSxJQUFJd00sS0FBS1ksUUFBUSxFQUFFLEVBQUVwTixFQUFHO2dCQUN0QyxJQUFJNk4sS0FBSzNGLFdBQVcsQ0FBQ2xJLEVBQUUsR0FBRyxDQUFDO2dCQUMzQixJQUFJaVEsVUFBVTdDLFFBQVEsQ0FBQ3BOLEVBQUU7Z0JBQ3pCNk4sR0FBR2dDLElBQUksR0FBR0ksUUFBUUosSUFBSTtnQkFDdEJoQyxHQUFHNkIsV0FBVyxHQUFHcFE7Z0JBQ2pCdU8sR0FBR2pELE9BQU8sR0FBRztnQkFDYmlELEdBQUc5UCxJQUFJLEdBQUdrUyxRQUFRQyxTQUFTO2dCQUMzQnJDLEdBQUdzQyxPQUFPLEdBQUdGLFFBQVFFLE9BQU87Z0JBQzVCdEMsR0FBR3ZGLEtBQUssR0FBR2tFLEtBQUtsRSxLQUFLO2dCQUNyQnVGLEdBQUdyRixNQUFNLEdBQUdnRSxLQUFLZSxLQUFLO1lBQ3hCO1lBQ0EsSUFBSXZGLFNBQVM7Z0JBQ1hPLEtBQUssSUFBSXRILE1BQU07WUFDakI7WUFDQSxJQUFLLElBQUlrSixVQUFVLEdBQUdBLFVBQVVxQyxLQUFLWSxRQUFRLEVBQUUsRUFBRWpELFFBQVM7Z0JBQ3hELElBQUkwRCxLQUFLM0YsV0FBVyxDQUFDaUMsUUFBUTtnQkFDN0IsSUFBSyxJQUFJbkssSUFBSSxHQUFHQSxJQUFJMlAsYUFBYTVJLE1BQU0sRUFBRSxFQUFFL0csRUFBRztvQkFDNUMsSUFBSW9RLE9BQU9ULFlBQVksQ0FBQzNQLEVBQUU7b0JBQzFCLElBQUk2TixHQUFHZ0MsSUFBSSxJQUFJTyxLQUFLUCxJQUFJLEVBQUU7d0JBQ3hCaEMsR0FBRzZCLFdBQVcsR0FBR1UsS0FBS1YsV0FBVzt3QkFDakMsSUFBSVUsS0FBS2xLLEtBQUssSUFBSSxHQUFHOzRCQUNuQjhCLE9BQU9PLEdBQUcsQ0FBQzZILEtBQUtsSyxLQUFLLENBQUMsR0FBR2lFO3dCQUMzQjt3QkFDQTBELEdBQUduQixNQUFNLEdBQUd2QztvQkFDZDtnQkFDRjtZQUNGO1lBQ0EsSUFBSXlFLFVBQVVLLGdCQUFnQixHQUFHLEdBQUc7Z0JBQ2xDLE9BQVFMLFVBQVVZLGFBQWE7b0JBQzdCLEtBQUtwUTt3QkFDSCxJQUFJK0ksV0FBVyxJQUFJcUIsWUFBWW9GLFVBQVVVLHdCQUF3Qjt3QkFDakVuSixjQUNFcUcsS0FBS0MsS0FBSyxFQUNWbkwsWUFDQVIsVUFDQThOLFVBQVVLLGdCQUFnQixFQUMxQjlHLFVBQ0F5RyxVQUFVVSx3QkFBd0I7d0JBRXBDO29CQUNGLEtBQUtqUTt3QkFDSCxJQUFJdU4sYUFBYUosS0FBS0MsS0FBSyxDQUFDSyxLQUFLLENBQUNoTSxTQUFTWSxLQUFLLEVBQUVaLFNBQVNZLEtBQUssR0FBR2tOLFVBQVVVLHdCQUF3Qjt3QkFDckcsSUFBSTVJLE9BQU9oSixrREFBVUEsQ0FBQ2tQO3dCQUN0QixJQUFJekUsV0FBVyxJQUFJcUIsWUFBWTlDLEtBQUt6SSxNQUFNO3dCQUMxQzZDLFNBQVNZLEtBQUssSUFBSWtOLFVBQVVVLHdCQUF3Qjt3QkFDcEQ7Z0JBQ0o7WUFDRjtZQUNBLElBQUlWLFVBQVVNLGdCQUFnQixHQUFHLEdBQUc7Z0JBQ2xDLElBQUltQixXQUFXO29CQUNiNUQsT0FBT0QsS0FBS0MsS0FBSztvQkFDakJDLFFBQVE1TDtvQkFDUnlHLE1BQU1xSCxVQUFVTSxnQkFBZ0I7Z0JBQ2xDO2dCQUNBLElBQUk5RyxXQUFXLElBQUlvQixZQUFZeUQsY0FBY29ELFVBQVVwUyxNQUFNO2dCQUM3RDZDLFNBQVNZLEtBQUssSUFBSWtOLFVBQVVNLGdCQUFnQjtZQUM5QztZQUNBLElBQUlOLFVBQVVTLFVBQVUsR0FBRyxHQUFHO2dCQUM1QixJQUFJekMsYUFBYUosS0FBS0MsS0FBSyxDQUFDSyxLQUFLLENBQUNoTSxTQUFTWSxLQUFLLEVBQUVaLFNBQVNZLEtBQUssR0FBR2tOLFVBQVVPLGlCQUFpQjtnQkFDOUYsSUFBSXpJLE9BQU9oSixrREFBVUEsQ0FBQ2tQO2dCQUN0QixJQUFJMEQsWUFBWWhKLGdCQUFnQlosS0FBS3pJLE1BQU07Z0JBQzNDNkMsU0FBU1ksS0FBSyxJQUFJa04sVUFBVU8saUJBQWlCO1lBQy9DO1lBQ0EsSUFBSTlCLGVBQWU7WUFDbkIsSUFBSWhFLGFBQWEsSUFBSXBJLE1BQU1pSCxZQUFZbkIsTUFBTTtZQUM3QyxJQUFLLElBQUkvRyxJQUFJLEdBQUdBLElBQUlxSixXQUFXdEMsTUFBTSxFQUFFLEVBQUUvRyxFQUFHO2dCQUMxQ3FKLFVBQVUsQ0FBQ3JKLEVBQUUsR0FBRyxJQUFJaUI7WUFDdEI7WUFDQSxJQUFLLElBQUk0SixJQUFJLEdBQUdBLElBQUkyQixLQUFLZSxLQUFLLEVBQUUsRUFBRTFDLEVBQUc7Z0JBQ25DLElBQUssSUFBSTBGLE9BQU8sR0FBR0EsT0FBT3JJLFlBQVluQixNQUFNLEVBQUUsRUFBRXdKLEtBQU07b0JBQ3BEbEgsVUFBVSxDQUFDa0gsS0FBSyxDQUFDMUksSUFBSSxDQUFDd0Y7b0JBQ3RCQSxnQkFBZ0JuRixXQUFXLENBQUNxSSxLQUFLLENBQUNqSSxLQUFLLEdBQUdrRSxLQUFLek8sSUFBSSxHQUFHbUI7Z0JBQ3hEO1lBQ0Y7WUFDQTZJLGVBQWVDLFFBQVFxQixZQUFZbkIsYUFBYUMsVUFBVUMsVUFBVTNGO1lBQ3BFLElBQUssSUFBSXpDLElBQUksR0FBR0EsSUFBSWtJLFlBQVluQixNQUFNLEVBQUUsRUFBRS9HLEVBQUc7Z0JBQzNDLElBQUk2TixLQUFLM0YsV0FBVyxDQUFDbEksRUFBRTtnQkFDdkIsSUFBSTZOLEdBQUdqRCxPQUFPLEVBQ1o7Z0JBQ0YsT0FBUWlELEdBQUc2QixXQUFXO29CQUNwQixLQUFLbFE7d0JBQ0gsSUFBSXFNLE1BQU07d0JBQ1YsSUFBSTJFLFlBQVk7d0JBQ2hCLElBQUssSUFBSTNGLElBQUksR0FBR0EsSUFBSTJCLEtBQUtlLEtBQUssRUFBRSxFQUFFMUMsRUFBRzs0QkFDbkMsSUFBSTRGLGlCQUFpQnBILFVBQVUsQ0FBQ3JKLEVBQUUsQ0FBQzZMLElBQUk7NEJBQ3ZDLElBQUssSUFBSWYsSUFBSSxHQUFHQSxJQUFJK0MsR0FBR3ZGLEtBQUssRUFBRSxFQUFFd0MsRUFBRztnQ0FDakMsSUFBSyxJQUFJNEYsT0FBTyxHQUFHQSxPQUFPeFIsYUFBYTJPLEdBQUc5UCxJQUFJLEVBQUUsRUFBRTJTLEtBQU07b0NBQ3REak8sU0FBUyxDQUFDZ08saUJBQWlCLEdBQUdILFNBQVMsQ0FBQ0UsWUFBWUUsT0FBTzdDLEdBQUd2RixLQUFLLEdBQUd1RixHQUFHckYsTUFBTSxDQUFDO2dDQUNsRjtnQ0FDQWdJOzRCQUNGOzRCQUNBM0U7d0JBQ0Y7d0JBQ0E7b0JBQ0YsS0FBS3RNO29CQUNMO3dCQUNFLE1BQU07Z0JBQ1Y7WUFDRjtZQUNBLE9BQU8sSUFBSW1JLFNBQVNqRixVQUFVeEUsTUFBTTtRQUN0QztRQUNBLFNBQVM2UiwwQkFBMEIzTCxPQUFPLEVBQUVnRyxPQUFPO1lBQ2pELElBQUl3RyxhQUFhLElBQUk5TixXQUFXc0I7WUFDaEMsSUFBSXlNLFlBQVk7WUFDaEIsTUFBT0QsVUFBVSxDQUFDeEcsUUFBUXpJLEtBQUssR0FBR2tQLFVBQVUsSUFBSSxFQUFHO2dCQUNqREEsYUFBYTtZQUNmO1lBQ0EsSUFBSUMsY0FBYyxJQUFJQyxjQUFjQyxNQUFNLENBQUNKLFdBQVc3RCxLQUFLLENBQUMzQyxRQUFRekksS0FBSyxFQUFFeUksUUFBUXpJLEtBQUssR0FBR2tQO1lBQzNGekcsUUFBUXpJLEtBQUssR0FBR3lJLFFBQVF6SSxLQUFLLEdBQUdrUCxZQUFZO1lBQzVDLE9BQU9DO1FBQ1Q7UUFDQSxTQUFTRyx1QkFBdUI3TSxPQUFPLEVBQUVnRyxPQUFPLEVBQUU1QyxJQUFJO1lBQ3BELElBQUlzSixjQUFjLElBQUlDLGNBQWNDLE1BQU0sQ0FBQyxJQUFJbE8sV0FBV3NCLFNBQVMySSxLQUFLLENBQUMzQyxRQUFRekksS0FBSyxFQUFFeUksUUFBUXpJLEtBQUssR0FBRzZGO1lBQ3hHNEMsUUFBUXpJLEtBQUssR0FBR3lJLFFBQVF6SSxLQUFLLEdBQUc2RjtZQUNoQyxPQUFPc0o7UUFDVDtRQUNBLFNBQVNJLGNBQWM1SSxRQUFRLEVBQUU4QixPQUFPO1lBQ3RDLElBQUlXLElBQUlvRyxXQUFXN0ksVUFBVThCO1lBQzdCLElBQUlVLElBQUl0RSxZQUFZOEIsVUFBVThCO1lBQzlCLE9BQU87Z0JBQUNXO2dCQUFHRDthQUFFO1FBQ2Y7UUFDQSxTQUFTc0csY0FBYzlJLFFBQVEsRUFBRThCLE9BQU87WUFDdEMsSUFBSVcsSUFBSXZFLFlBQVk4QixVQUFVOEI7WUFDOUIsSUFBSVUsSUFBSXRFLFlBQVk4QixVQUFVOEI7WUFDOUIsT0FBTztnQkFBQ1c7Z0JBQUdEO2FBQUU7UUFDZjtRQUNBLFNBQVNxRyxXQUFXN0ksUUFBUSxFQUFFOEIsT0FBTztZQUNuQyxJQUFJaUgsUUFBUS9JLFNBQVNnSixRQUFRLENBQUNsSCxRQUFRekksS0FBSyxFQUFFO1lBQzdDeUksUUFBUXpJLEtBQUssR0FBR3lJLFFBQVF6SSxLQUFLLEdBQUd6QztZQUNoQyxPQUFPbVM7UUFDVDtRQUNBLFNBQVM3SyxZQUFZOEIsUUFBUSxFQUFFOEIsT0FBTztZQUNwQyxJQUFJbUgsU0FBU2pKLFNBQVNrSixTQUFTLENBQUNwSCxRQUFRekksS0FBSyxFQUFFO1lBQy9DeUksUUFBUXpJLEtBQUssR0FBR3lJLFFBQVF6SSxLQUFLLEdBQUd6QztZQUNoQyxPQUFPcVM7UUFDVDtRQUNBLFNBQVN2USxnQkFBZ0JGLFdBQVcsRUFBRXNKLE9BQU87WUFDM0MsSUFBSXFILFFBQVEzUSxXQUFXLENBQUNzSixRQUFRekksS0FBSyxDQUFDO1lBQ3RDeUksUUFBUXpJLEtBQUssR0FBR3lJLFFBQVF6SSxLQUFLLEdBQUd2QztZQUNoQyxPQUFPcVM7UUFDVDtRQUNBLFNBQVM3RCxXQUFXdEYsUUFBUSxFQUFFOEIsT0FBTztZQUNuQyxJQUFJcUgsUUFBUW5KLFNBQVNQLFFBQVEsQ0FBQ3FDLFFBQVF6SSxLQUFLO1lBQzNDeUksUUFBUXpJLEtBQUssR0FBR3lJLFFBQVF6SSxLQUFLLEdBQUd2QztZQUNoQyxPQUFPcVM7UUFDVDtRQUNBLE1BQU0xQyxhQUFhLFNBQVN6RyxRQUFRLEVBQUU4QixPQUFPO1lBQzNDLElBQUlzSDtZQUNKLElBQUksaUJBQWlCL0osU0FBU2dLLFNBQVMsRUFBRTtnQkFDdkNELE1BQU1FLE9BQU90SixTQUFTdUosV0FBVyxDQUFDekgsUUFBUXpJLEtBQUssRUFBRTtZQUNuRCxPQUFPO2dCQUNMK1AsTUFBTXBKLFNBQVNrSixTQUFTLENBQUNwSCxRQUFRekksS0FBSyxHQUFHLEdBQUcsUUFBUWlRLE9BQU90SixTQUFTa0osU0FBUyxDQUFDcEgsUUFBUXpJLEtBQUssRUFBRSxTQUFTO1lBQ3hHO1lBQ0F5SSxRQUFRekksS0FBSyxJQUFJM0M7WUFDakIsT0FBTzBTO1FBQ1Q7UUFDQSxTQUFTSSxhQUFheEosUUFBUSxFQUFFOEIsT0FBTztZQUNyQyxJQUFJaUMsUUFBUS9ELFNBQVN5SixVQUFVLENBQUMzSCxRQUFRekksS0FBSyxFQUFFO1lBQy9DeUksUUFBUXpJLEtBQUssSUFBSTFDO1lBQ2pCLE9BQU9vTjtRQUNUO1FBQ0EsU0FBUzJGLGNBQWMxSixRQUFRLEVBQUU4QixPQUFPO1lBQ3RDLE9BQU8xTSw0Q0FBU0EsQ0FBQ3lPLFdBQVcsQ0FBQzJGLGFBQWF4SixVQUFVOEI7UUFDdEQ7UUFDQSxTQUFTYyxjQUFjK0csTUFBTTtZQUMzQixJQUFJQyxXQUFXLENBQUNELFNBQVMsS0FBSSxLQUFNLElBQUlFLFdBQVdGLFNBQVM7WUFDM0QsT0FBTyxDQUFDQSxVQUFVLEtBQUssQ0FBQyxJQUFJLEtBQU1DLENBQUFBLFdBQVdBLGFBQWEsS0FBS0MsV0FBV0MsTUFBTUMsV0FBVzFTLEtBQUtDLEdBQUcsQ0FBQyxHQUFHc1MsV0FBVyxNQUFPLEtBQUlDLFdBQVcsSUFBRyxJQUFLLGlCQUFrQkEsQ0FBQUEsV0FBVyxJQUFHLENBQUM7UUFDbkw7UUFDQSxTQUFTekUsWUFBWXBGLFFBQVEsRUFBRThCLE9BQU87WUFDcEMsSUFBSWtJLFNBQVNoSyxTQUFTMEMsU0FBUyxDQUFDWixRQUFRekksS0FBSyxFQUFFO1lBQy9DeUksUUFBUXpJLEtBQUssSUFBSXhDO1lBQ2pCLE9BQU9tVDtRQUNUO1FBQ0EsU0FBU0MsYUFBYW5PLE9BQU8sRUFBRWdHLE9BQU87WUFDcEMsT0FBT2MsY0FBY3dDLFlBQVl0SixTQUFTZ0c7UUFDNUM7UUFDQSxTQUFTb0ksWUFBWWxLLFFBQVEsRUFBRWxFLE9BQU8sRUFBRWdHLE9BQU8sRUFBRTVDLElBQUk7WUFDbkQsSUFBSWlMLGNBQWNySSxRQUFRekksS0FBSztZQUMvQixJQUFJMEwsV0FBVyxFQUFFO1lBQ2pCLE1BQU9qRCxRQUFRekksS0FBSyxHQUFHOFEsY0FBY2pMLE9BQU8sRUFBRztnQkFDN0MsSUFBSXNJLE9BQU9DLDBCQUEwQjNMLFNBQVNnRztnQkFDOUMsSUFBSStGLFlBQVlnQixXQUFXN0ksVUFBVThCO2dCQUNyQyxJQUFJZ0csVUFBVXhDLFdBQVd0RixVQUFVOEI7Z0JBQ25DQSxRQUFRekksS0FBSyxJQUFJO2dCQUNqQixJQUFJK1EsWUFBWXZCLFdBQVc3SSxVQUFVOEI7Z0JBQ3JDLElBQUl1SSxZQUFZeEIsV0FBVzdJLFVBQVU4QjtnQkFDckNpRCxTQUFTdkYsSUFBSSxDQUFDO29CQUNaZ0k7b0JBQ0FLO29CQUNBQztvQkFDQXNDO29CQUNBQztnQkFDRjtZQUNGO1lBQ0F2SSxRQUFRekksS0FBSyxJQUFJO1lBQ2pCLE9BQU8wTDtRQUNUO1FBQ0EsU0FBU3VGLG9CQUFvQnRLLFFBQVEsRUFBRThCLE9BQU87WUFDNUMsSUFBSXlJLE9BQU9mLGFBQWF4SixVQUFVOEI7WUFDbEMsSUFBSTBJLE9BQU9oQixhQUFheEosVUFBVThCO1lBQ2xDLElBQUkySSxTQUFTakIsYUFBYXhKLFVBQVU4QjtZQUNwQyxJQUFJNEksU0FBU2xCLGFBQWF4SixVQUFVOEI7WUFDcEMsSUFBSTZJLFFBQVFuQixhQUFheEosVUFBVThCO1lBQ25DLElBQUk4SSxRQUFRcEIsYUFBYXhKLFVBQVU4QjtZQUNuQyxJQUFJK0ksU0FBU3JCLGFBQWF4SixVQUFVOEI7WUFDcEMsSUFBSWdKLFNBQVN0QixhQUFheEosVUFBVThCO1lBQ3BDLE9BQU87Z0JBQ0x5STtnQkFDQUM7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7WUFDRjtRQUNGO1FBQ0EsU0FBU0MsaUJBQWlCL0ssUUFBUSxFQUFFOEIsT0FBTztZQUN6QyxJQUFJa0osbUJBQW1CO2dCQUNyQjtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTthQUNEO1lBQ0QsSUFBSTNELGNBQWMvQixXQUFXdEYsVUFBVThCO1lBQ3ZDLE9BQU9rSixnQkFBZ0IsQ0FBQzNELFlBQVk7UUFDdEM7UUFDQSxTQUFTNEQsV0FBV2pMLFFBQVEsRUFBRThCLE9BQU87WUFDbkMsSUFBSW9KLE9BQU9oTixZQUFZOEIsVUFBVThCO1lBQ2pDLElBQUlxSixPQUFPak4sWUFBWThCLFVBQVU4QjtZQUNqQyxJQUFJc0osT0FBT2xOLFlBQVk4QixVQUFVOEI7WUFDakMsSUFBSXVKLE9BQU9uTixZQUFZOEIsVUFBVThCO1lBQ2pDLE9BQU87Z0JBQUVvSjtnQkFBTUM7Z0JBQU1DO2dCQUFNQztZQUFLO1FBQ2xDO1FBQ0EsU0FBU0MsZUFBZXRMLFFBQVEsRUFBRThCLE9BQU87WUFDdkMsSUFBSXlKLGFBQWE7Z0JBQUM7YUFBZTtZQUNqQyxJQUFJQyxZQUFZbEcsV0FBV3RGLFVBQVU4QjtZQUNyQyxPQUFPeUosVUFBVSxDQUFDQyxVQUFVO1FBQzlCO1FBQ0EsU0FBU0MsU0FBU3pMLFFBQVEsRUFBRThCLE9BQU87WUFDakMsSUFBSVcsSUFBSStHLGFBQWF4SixVQUFVOEI7WUFDL0IsSUFBSVUsSUFBSWdILGFBQWF4SixVQUFVOEI7WUFDL0IsT0FBTztnQkFBQ1c7Z0JBQUdEO2FBQUU7UUFDZjtRQUNBLFNBQVNrSixTQUFTMUwsUUFBUSxFQUFFOEIsT0FBTztZQUNqQyxJQUFJVyxJQUFJK0csYUFBYXhKLFVBQVU4QjtZQUMvQixJQUFJVSxJQUFJZ0gsYUFBYXhKLFVBQVU4QjtZQUMvQixJQUFJNkosSUFBSW5DLGFBQWF4SixVQUFVOEI7WUFDL0IsT0FBTztnQkFBQ1c7Z0JBQUdEO2dCQUFHbUo7YUFBRTtRQUNsQjtRQUNBLFNBQVNDLFdBQVc1TCxRQUFRLEVBQUVsRSxPQUFPLEVBQUVnRyxPQUFPLEVBQUVwTSxJQUFJLEVBQUV3SixJQUFJO1lBQ3hELElBQUl4SixTQUFTLFlBQVlBLFNBQVMsa0JBQWtCQSxTQUFTLGNBQWM7Z0JBQ3pFLE9BQU9pVCx1QkFBdUI3TSxTQUFTZ0csU0FBUzVDO1lBQ2xELE9BQU8sSUFBSXhKLFNBQVMsVUFBVTtnQkFDNUIsT0FBT3dVLFlBQVlsSyxVQUFVbEUsU0FBU2dHLFNBQVM1QztZQUNqRCxPQUFPLElBQUl4SixTQUFTLGtCQUFrQjtnQkFDcEMsT0FBTzRVLG9CQUFvQnRLLFVBQVU4QjtZQUN2QyxPQUFPLElBQUlwTSxTQUFTLGVBQWU7Z0JBQ2pDLE9BQU9xVixpQkFBaUIvSyxVQUFVOEI7WUFDcEMsT0FBTyxJQUFJcE0sU0FBUyxTQUFTO2dCQUMzQixPQUFPdVYsV0FBV2pMLFVBQVU4QjtZQUM5QixPQUFPLElBQUlwTSxTQUFTLGFBQWE7Z0JBQy9CLE9BQU80VixlQUFldEwsVUFBVThCO1lBQ2xDLE9BQU8sSUFBSXBNLFNBQVMsU0FBUztnQkFDM0IsT0FBTzhULGFBQWF4SixVQUFVOEI7WUFDaEMsT0FBTyxJQUFJcE0sU0FBUyxPQUFPO2dCQUN6QixPQUFPK1YsU0FBU3pMLFVBQVU4QjtZQUM1QixPQUFPLElBQUlwTSxTQUFTLE9BQU87Z0JBQ3pCLE9BQU9nVyxTQUFTMUwsVUFBVThCO1lBQzVCLE9BQU8sSUFBSXBNLFNBQVMsT0FBTztnQkFDekIsT0FBT21ULFdBQVc3SSxVQUFVOEI7WUFDOUIsT0FBTyxJQUFJcE0sU0FBUyxZQUFZO2dCQUM5QixPQUFPa1QsY0FBYzVJLFVBQVU4QjtZQUNqQyxPQUFPLElBQUlwTSxTQUFTLFlBQVk7Z0JBQzlCLE9BQU9vVCxjQUFjOUksVUFBVThCO1lBQ2pDLE9BQU8sSUFBSXBNLFNBQVMsV0FBVztnQkFDN0JvTSxRQUFRekksS0FBSyxJQUFJNkY7Z0JBQ2pCLE9BQU87WUFDVCxPQUFPO2dCQUNMNEMsUUFBUXpJLEtBQUssSUFBSTZGO2dCQUNqQixPQUFPLEtBQUs7WUFDZDtRQUNGO1FBQ0EsU0FBUzJNLFlBQVk3TCxRQUFRLEVBQUVsRSxPQUFPLEVBQUVnRyxPQUFPO1lBQzdDLE1BQU1nSyxhQUFhLENBQUM7WUFDcEIsSUFBSTlMLFNBQVNrSixTQUFTLENBQUMsR0FBRyxTQUFTLFVBQVU7Z0JBQzNDLE1BQU07WUFDUjtZQUNBNEMsV0FBV3RGLE9BQU8sR0FBR3hHLFNBQVNQLFFBQVEsQ0FBQztZQUN2QyxNQUFNc00sT0FBTy9MLFNBQVNQLFFBQVEsQ0FBQztZQUMvQnFNLFdBQVdDLElBQUksR0FBRztnQkFDaEJDLFlBQVksQ0FBQyxDQUFFRCxDQUFBQSxPQUFPO2dCQUN0QkUsVUFBVSxDQUFDLENBQUVGLENBQUFBLE9BQU87Z0JBQ3BCRyxZQUFZLENBQUMsQ0FBRUgsQ0FBQUEsT0FBTztnQkFDdEJJLFdBQVcsQ0FBQyxDQUFFSixDQUFBQSxPQUFPLEVBQUM7WUFDeEI7WUFDQWpLLFFBQVF6SSxLQUFLLEdBQUc7WUFDaEIsSUFBSStTLGNBQWM7WUFDbEIsTUFBT0EsWUFBYTtnQkFDbEIsSUFBSUMsZ0JBQWdCNUUsMEJBQTBCM0wsU0FBU2dHO2dCQUN2RCxJQUFJdUssaUJBQWlCLEdBQUc7b0JBQ3RCRCxjQUFjO2dCQUNoQixPQUFPO29CQUNMLElBQUlFLGdCQUFnQjdFLDBCQUEwQjNMLFNBQVNnRztvQkFDdkQsSUFBSXlLLGdCQUFnQnJPLFlBQVk4QixVQUFVOEI7b0JBQzFDLElBQUkwSyxpQkFBaUJaLFdBQVc1TCxVQUFVbEUsU0FBU2dHLFNBQVN3SyxlQUFlQztvQkFDM0UsSUFBSUMsbUJBQW1CLEtBQUssR0FBRzt3QkFDN0JDLFFBQVFDLElBQUksQ0FBQyxDQUFDLHdEQUF3RCxFQUFFSixjQUFjLEVBQUUsQ0FBQztvQkFDM0YsT0FBTzt3QkFDTFIsVUFBVSxDQUFDTyxjQUFjLEdBQUdHO29CQUM5QjtnQkFDRjtZQUNGO1lBQ0EsSUFBSSxDQUFDVCxPQUFPLENBQUMsTUFBTSxHQUFHO2dCQUNwQlUsUUFBUUUsS0FBSyxDQUFDLGNBQWNiO2dCQUM1QixNQUFNO1lBQ1I7WUFDQSxPQUFPQTtRQUNUO1FBQ0EsU0FBU2MsYUFBYWQsVUFBVSxFQUFFOUwsUUFBUSxFQUFFeEgsV0FBVyxFQUFFc0osT0FBTyxFQUFFK0ssVUFBVTtZQUMxRSxNQUFNQyxjQUFjO2dCQUNsQjVOLE1BQU07Z0JBQ05zRixRQUFReEU7Z0JBQ1JvRSxPQUFPNUw7Z0JBQ1A2TCxRQUFRdkM7Z0JBQ1I3QixPQUFPNkwsV0FBV2lCLFVBQVUsQ0FBQzNCLElBQUksR0FBR1UsV0FBV2lCLFVBQVUsQ0FBQzdCLElBQUksR0FBRztnQkFDakUvSyxRQUFRMkwsV0FBV2lCLFVBQVUsQ0FBQzFCLElBQUksR0FBR1MsV0FBV2lCLFVBQVUsQ0FBQzVCLElBQUksR0FBRztnQkFDbEVwRyxVQUFVK0csV0FBVy9HLFFBQVEsQ0FBQ3JHLE1BQU07Z0JBQ3BDc08sY0FBYztnQkFDZDlILE9BQU87Z0JBQ1ArSCxXQUFXO2dCQUNYdlgsTUFBTW9XLFdBQVcvRyxRQUFRLENBQUMsRUFBRSxDQUFDOEMsU0FBUztnQkFDdENxRixZQUFZO2dCQUNaQyxRQUFRO2dCQUNSQyxRQUFRO2dCQUNSLENBQUM5WCxnQkFBZ0IsZUFBZSxXQUFXLEVBQUU7WUFDL0M7WUFDQSxPQUFRd1csV0FBV3pFLFdBQVc7Z0JBQzVCLEtBQUs7b0JBQ0h5RixZQUFZNUgsS0FBSyxHQUFHO29CQUNwQjRILFlBQVlJLFVBQVUsR0FBR2hKO29CQUN6QjtnQkFDRixLQUFLO29CQUNINEksWUFBWTVILEtBQUssR0FBRztvQkFDcEI0SCxZQUFZSSxVQUFVLEdBQUc1STtvQkFDekI7Z0JBQ0YsS0FBSztvQkFDSHdJLFlBQVk1SCxLQUFLLEdBQUc7b0JBQ3BCNEgsWUFBWUksVUFBVSxHQUFHdEk7b0JBQ3pCO2dCQUNGLEtBQUs7b0JBQ0hrSSxZQUFZNUgsS0FBSyxHQUFHO29CQUNwQjRILFlBQVlJLFVBQVUsR0FBR3RJO29CQUN6QjtnQkFDRixLQUFLO29CQUNIa0ksWUFBWTVILEtBQUssR0FBRztvQkFDcEI0SCxZQUFZSSxVQUFVLEdBQUdySTtvQkFDekI7Z0JBQ0YsS0FBSztvQkFDSGlJLFlBQVk1SCxLQUFLLEdBQUc7b0JBQ3BCNEgsWUFBWUksVUFBVSxHQUFHcEg7b0JBQ3pCO2dCQUNGLEtBQUs7b0JBQ0hnSCxZQUFZNUgsS0FBSyxHQUFHO29CQUNwQjRILFlBQVlJLFVBQVUsR0FBRzVHO29CQUN6QjtnQkFDRixLQUFLO29CQUNId0csWUFBWTVILEtBQUssR0FBRztvQkFDcEI0SCxZQUFZSSxVQUFVLEdBQUc1RztvQkFDekI7Z0JBQ0Y7b0JBQ0UsTUFBTSxzQkFBc0J3RixXQUFXekUsV0FBVyxHQUFHO1lBQ3pEO1lBQ0F5RixZQUFZaEksaUJBQWlCLEdBQUdnSSxZQUFZNUgsS0FBSztZQUNqRCxJQUFJNEgsWUFBWXBYLElBQUksSUFBSSxHQUFHO2dCQUN6QixPQUFRbVg7b0JBQ04sS0FBSzdYLDRDQUFTQTt3QkFDWjhYLFlBQVlLLE1BQU0sR0FBR2xEO3dCQUNyQjZDLFlBQVlHLFNBQVMsR0FBR3BXO3dCQUN4QjtvQkFDRixLQUFLOUIsZ0RBQWFBO3dCQUNoQitYLFlBQVlLLE1BQU0sR0FBRy9IO3dCQUNyQjBILFlBQVlHLFNBQVMsR0FBR3BXO3dCQUN4QjtnQkFDSjtZQUNGLE9BQU8sSUFBSWlXLFlBQVlwWCxJQUFJLElBQUksR0FBRztnQkFDaEMsT0FBUW1YO29CQUNOLEtBQUs3WCw0Q0FBU0E7d0JBQ1o4WCxZQUFZSyxNQUFNLEdBQUczRDt3QkFDckJzRCxZQUFZRyxTQUFTLEdBQUd0Vzt3QkFDeEI7b0JBQ0YsS0FBSzVCLGdEQUFhQTt3QkFDaEIrWCxZQUFZSyxNQUFNLEdBQUd6RDt3QkFDckJvRCxZQUFZRyxTQUFTLEdBQUd0VztnQkFDNUI7WUFDRixPQUFPO2dCQUNMLE1BQU0sNENBQTRDbVcsWUFBWXBYLElBQUksR0FBRyxVQUFVb1csV0FBV3pFLFdBQVcsR0FBRztZQUMxRztZQUNBeUYsWUFBWU8sVUFBVSxHQUFHLENBQUN2QixXQUFXaUIsVUFBVSxDQUFDMUIsSUFBSSxHQUFHLEtBQUt5QixZQUFZaEksaUJBQWlCO1lBQ3pGLElBQUssSUFBSW5OLElBQUksR0FBR0EsSUFBSW1WLFlBQVlPLFVBQVUsRUFBRTFWLElBQzFDOE8sV0FBV3pHLFVBQVU4QjtZQUN2QmdMLFlBQVlRLGNBQWMsR0FBR1IsWUFBWS9ILFFBQVEsSUFBSSxJQUFJLElBQUkrSCxZQUFZL0gsUUFBUTtZQUNqRixNQUFNN0YsT0FBTzROLFlBQVk3TSxLQUFLLEdBQUc2TSxZQUFZM00sTUFBTSxHQUFHMk0sWUFBWVEsY0FBYztZQUNoRixPQUFRVDtnQkFDTixLQUFLN1gsNENBQVNBO29CQUNaOFgsWUFBWVMsU0FBUyxHQUFHLElBQUlyTSxhQUFhaEM7b0JBQ3pDLElBQUk0TixZQUFZL0gsUUFBUSxHQUFHK0gsWUFBWVEsY0FBYyxFQUNuRFIsWUFBWVMsU0FBUyxDQUFDL0wsSUFBSSxDQUFDLEdBQUcsR0FBR3RDO29CQUNuQztnQkFDRixLQUFLbkssZ0RBQWFBO29CQUNoQitYLFlBQVlTLFNBQVMsR0FBRyxJQUFJcE0sWUFBWWpDO29CQUN4QyxJQUFJNE4sWUFBWS9ILFFBQVEsR0FBRytILFlBQVlRLGNBQWMsRUFDbkRSLFlBQVlTLFNBQVMsQ0FBQy9MLElBQUksQ0FBQyxPQUFPLEdBQUd0QztvQkFDdkM7Z0JBQ0Y7b0JBQ0V1TixRQUFRRSxLQUFLLENBQUMsdUNBQXVDRTtvQkFDckQ7WUFDSjtZQUNBQyxZQUFZRSxZQUFZLEdBQUdGLFlBQVk3TSxLQUFLLEdBQUc2TSxZQUFZRyxTQUFTLEdBQUdILFlBQVkvSCxRQUFRO1lBQzNGLElBQUkrSCxZQUFZUSxjQUFjLElBQUksR0FDaENSLFlBQVlNLE1BQU0sR0FBR25ZLDZDQUFVQTtpQkFFL0I2WCxZQUFZTSxNQUFNLEdBQUdsWSw0Q0FBU0E7WUFDaEMsSUFBSUksZUFDRndYLFlBQVlVLFVBQVUsR0FBRztpQkFFekJWLFlBQVlXLFFBQVEsR0FBRztZQUN6QixPQUFPWDtRQUNUO1FBQ0EsTUFBTVksaUJBQWlCLElBQUlyTyxTQUFTeko7UUFDcEMsTUFBTStYLGFBQWEsSUFBSW5ULFdBQVc1RTtRQUNsQyxNQUFNeU8sU0FBUztZQUFFaEwsT0FBTztRQUFFO1FBQzFCLE1BQU0rTixZQUFZeUUsWUFBWTZCLGdCQUFnQjlYLFFBQVF5TztRQUN0RCxNQUFNdUosYUFBYWhCLGFBQWF4RixXQUFXc0csZ0JBQWdCQyxZQUFZdEosUUFBUSxJQUFJLENBQUMzTyxJQUFJO1FBQ3hGLE1BQU1tWSxZQUFZO1lBQUV4VSxPQUFPO1FBQUU7UUFDN0IsTUFBTXlVLGlCQUFpQjtZQUFFQyxHQUFHO1lBQUdDLEdBQUc7WUFBR0MsR0FBRztZQUFHQyxHQUFHO1lBQUdDLEdBQUc7UUFBRTtRQUN0RCxJQUFLLElBQUlDLG1CQUFtQixHQUFHQSxtQkFBbUJSLFdBQVd6TixNQUFNLEdBQUd5TixXQUFXOUksaUJBQWlCLEVBQUVzSixtQkFBb0I7WUFDdEgsTUFBTUMsT0FBT25RLFlBQVl3UCxnQkFBZ0JySjtZQUN6Q3VKLFdBQVcxTyxJQUFJLEdBQUdoQixZQUFZd1AsZ0JBQWdCcko7WUFDOUN1SixXQUFXMUksS0FBSyxHQUFHbUosT0FBT1QsV0FBVzlJLGlCQUFpQixHQUFHOEksV0FBV3pOLE1BQU0sR0FBR3lOLFdBQVd6TixNQUFNLEdBQUdrTyxPQUFPVCxXQUFXOUksaUJBQWlCO1lBQ3BJLE1BQU13SixlQUFlVixXQUFXMU8sSUFBSSxHQUFHME8sV0FBVzFJLEtBQUssR0FBRzBJLFdBQVdaLFlBQVk7WUFDakYsTUFBTXhJLFNBQVM4SixlQUFlVixXQUFXVixVQUFVLENBQUNVLGNBQWMxSixjQUFjMEo7WUFDaEZ2SixPQUFPaEwsS0FBSyxJQUFJdVUsV0FBVzFPLElBQUk7WUFDL0IsSUFBSyxJQUFJcVAsU0FBUyxHQUFHQSxTQUFTWCxXQUFXOUksaUJBQWlCLEVBQUV5SixTQUFVO2dCQUNwRSxNQUFNQyxTQUFTRCxTQUFTSCxtQkFBbUJSLFdBQVc5SSxpQkFBaUI7Z0JBQ3ZFLElBQUkwSixVQUFVWixXQUFXek4sTUFBTSxFQUM3QjtnQkFDRixJQUFLLElBQUlzTyxZQUFZLEdBQUdBLFlBQVliLFdBQVc3SSxRQUFRLEVBQUUwSixZQUFhO29CQUNwRSxNQUFNQyxPQUFPWixjQUFjLENBQUMxRyxVQUFVckMsUUFBUSxDQUFDMEosVUFBVSxDQUFDakgsSUFBSSxDQUFDO29CQUMvRCxJQUFLLElBQUkvRSxJQUFJLEdBQUdBLElBQUltTCxXQUFXM04sS0FBSyxFQUFFd0MsSUFBSzt3QkFDekNvTCxVQUFVeFUsS0FBSyxHQUFHLENBQUNrVixTQUFVWCxDQUFBQSxXQUFXN0ksUUFBUSxHQUFHNkksV0FBVzNOLEtBQUssSUFBSXdPLFlBQVliLFdBQVczTixLQUFLLEdBQUd3QyxDQUFBQSxJQUFLbUwsV0FBV1gsU0FBUzt3QkFDL0gsTUFBTTBCLFdBQVcsQ0FBQ2YsV0FBV3pOLE1BQU0sR0FBRyxJQUFJcU8sTUFBSyxJQUFNWixDQUFBQSxXQUFXM04sS0FBSyxHQUFHMk4sV0FBV04sY0FBYyxJQUFJN0ssSUFBSW1MLFdBQVdOLGNBQWMsR0FBR29CO3dCQUNySWQsV0FBV0wsU0FBUyxDQUFDb0IsU0FBUyxHQUFHZixXQUFXVCxNQUFNLENBQUMzSSxRQUFRcUo7b0JBQzdEO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLE9BQU87WUFDTGUsUUFBUXhIO1lBQ1JuSCxPQUFPMk4sV0FBVzNOLEtBQUs7WUFDdkJFLFFBQVF5TixXQUFXek4sTUFBTTtZQUN6QjlCLE1BQU11UCxXQUFXTCxTQUFTO1lBQzFCSCxRQUFRUSxXQUFXUixNQUFNO1lBQ3pCLENBQUM5WCxnQkFBZ0IsZUFBZSxXQUFXLEVBQUVzWSxVQUFVLENBQUN0WSxnQkFBZ0IsZUFBZSxXQUFXO1lBQ2xHSSxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUNqQjtJQUNGO0lBQ0FtWixZQUFZeFYsS0FBSyxFQUFFO1FBQ2pCLElBQUksQ0FBQzNELElBQUksR0FBRzJEO1FBQ1osT0FBTyxJQUFJO0lBQ2I7SUFDQXlWLEtBQUtDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxTQUFTQyxlQUFlQyxPQUFPLEVBQUVDLE9BQU87WUFDdEMsSUFBSS9aLGVBQ0Y4WixRQUFRNUIsVUFBVSxHQUFHNkIsUUFBUTdCLFVBQVU7aUJBRXZDNEIsUUFBUTNCLFFBQVEsR0FBRzRCLFFBQVE1QixRQUFRO1lBQ3JDMkIsUUFBUUUsU0FBUyxHQUFHbmEsK0NBQVlBO1lBQ2hDaWEsUUFBUUcsU0FBUyxHQUFHcGEsK0NBQVlBO1lBQ2hDaWEsUUFBUUksZUFBZSxHQUFHO1lBQzFCSixRQUFRSyxLQUFLLEdBQUc7WUFDaEIsSUFBSVQsUUFDRkEsT0FBT0ksU0FBU0M7UUFDcEI7UUFDQSxPQUFPLEtBQUssQ0FBQ1AsS0FBS0MsS0FBS0ksZ0JBQWdCRixZQUFZQztJQUNyRDtBQUNGO0FBR0UsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmVhdGl2ZS00MDQvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRVhSTG9hZGVyLmpzPzdlNDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dHVyZSwgRGF0YVRleHR1cmVMb2FkZXIsIEhhbGZGbG9hdFR5cGUsIEZsb2F0VHlwZSwgUkdCQUZvcm1hdCwgUmVkRm9ybWF0LCBMaW5lYXJGaWx0ZXIsIERhdGFVdGlscyB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgdW56bGliU3luYyB9IGZyb20gXCJmZmxhdGVcIjtcbmNvbnN0IGhhc0NvbG9yU3BhY2UgPSBcImNvbG9yU3BhY2VcIiBpbiBuZXcgVGV4dHVyZSgpO1xuY2xhc3MgRVhSTG9hZGVyIGV4dGVuZHMgRGF0YVRleHR1cmVMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy50eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgfVxuICBwYXJzZShidWZmZXIpIHtcbiAgICBjb25zdCBVU0hPUlRfUkFOR0UgPSAxIDw8IDE2O1xuICAgIGNvbnN0IEJJVE1BUF9TSVpFID0gVVNIT1JUX1JBTkdFID4+IDM7XG4gICAgY29uc3QgSFVGX0VOQ0JJVFMgPSAxNjtcbiAgICBjb25zdCBIVUZfREVDQklUUyA9IDE0O1xuICAgIGNvbnN0IEhVRl9FTkNTSVpFID0gKDEgPDwgSFVGX0VOQ0JJVFMpICsgMTtcbiAgICBjb25zdCBIVUZfREVDU0laRSA9IDEgPDwgSFVGX0RFQ0JJVFM7XG4gICAgY29uc3QgSFVGX0RFQ01BU0sgPSBIVUZfREVDU0laRSAtIDE7XG4gICAgY29uc3QgTkJJVFMgPSAxNjtcbiAgICBjb25zdCBBX09GRlNFVCA9IDEgPDwgTkJJVFMgLSAxO1xuICAgIGNvbnN0IE1PRF9NQVNLID0gKDEgPDwgTkJJVFMpIC0gMTtcbiAgICBjb25zdCBTSE9SVF9aRVJPQ09ERV9SVU4gPSA1OTtcbiAgICBjb25zdCBMT05HX1pFUk9DT0RFX1JVTiA9IDYzO1xuICAgIGNvbnN0IFNIT1JURVNUX0xPTkdfUlVOID0gMiArIExPTkdfWkVST0NPREVfUlVOIC0gU0hPUlRfWkVST0NPREVfUlVOO1xuICAgIGNvbnN0IFVMT05HX1NJWkUgPSA4O1xuICAgIGNvbnN0IEZMT0FUMzJfU0laRSA9IDQ7XG4gICAgY29uc3QgSU5UMzJfU0laRSA9IDQ7XG4gICAgY29uc3QgSU5UMTZfU0laRSA9IDI7XG4gICAgY29uc3QgSU5UOF9TSVpFID0gMTtcbiAgICBjb25zdCBTVEFUSUNfSFVGRk1BTiA9IDA7XG4gICAgY29uc3QgREVGTEFURSA9IDE7XG4gICAgY29uc3QgVU5LTk9XTiA9IDA7XG4gICAgY29uc3QgTE9TU1lfRENUID0gMTtcbiAgICBjb25zdCBSTEUgPSAyO1xuICAgIGNvbnN0IGxvZ0Jhc2UgPSBNYXRoLnBvdygyLjcxODI4MTgsIDIuMik7XG4gICAgZnVuY3Rpb24gcmV2ZXJzZUx1dEZyb21CaXRtYXAoYml0bWFwLCBsdXQpIHtcbiAgICAgIHZhciBrID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVVNIT1JUX1JBTkdFOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT0gMCB8fCBiaXRtYXBbaSA+PiAzXSAmIDEgPDwgKGkgJiA3KSkge1xuICAgICAgICAgIGx1dFtrKytdID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG4gPSBrIC0gMTtcbiAgICAgIHdoaWxlIChrIDwgVVNIT1JUX1JBTkdFKVxuICAgICAgICBsdXRbaysrXSA9IDA7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmQ2xlYXJEZWNUYWJsZShoZGVjKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhVRl9ERUNTSVpFOyBpKyspIHtcbiAgICAgICAgaGRlY1tpXSA9IHt9O1xuICAgICAgICBoZGVjW2ldLmxlbiA9IDA7XG4gICAgICAgIGhkZWNbaV0ubGl0ID0gMDtcbiAgICAgICAgaGRlY1tpXS5wID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZ2V0Qml0c1JldHVybiA9IHsgbDogMCwgYzogMCwgbGM6IDAgfTtcbiAgICBmdW5jdGlvbiBnZXRCaXRzKG5CaXRzLCBjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KSB7XG4gICAgICB3aGlsZSAobGMgPCBuQml0cykge1xuICAgICAgICBjID0gYyA8PCA4IHwgcGFyc2VVaW50OEFycmF5KHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgIGxjICs9IDg7XG4gICAgICB9XG4gICAgICBsYyAtPSBuQml0cztcbiAgICAgIGdldEJpdHNSZXR1cm4ubCA9IGMgPj4gbGMgJiAoMSA8PCBuQml0cykgLSAxO1xuICAgICAgZ2V0Qml0c1JldHVybi5jID0gYztcbiAgICAgIGdldEJpdHNSZXR1cm4ubGMgPSBsYztcbiAgICB9XG4gICAgY29uc3QgaHVmVGFibGVCdWZmZXIgPSBuZXcgQXJyYXkoNTkpO1xuICAgIGZ1bmN0aW9uIGh1ZkNhbm9uaWNhbENvZGVUYWJsZShoY29kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gNTg7ICsraSlcbiAgICAgICAgaHVmVGFibGVCdWZmZXJbaV0gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIVUZfRU5DU0laRTsgKytpKVxuICAgICAgICBodWZUYWJsZUJ1ZmZlcltoY29kZVtpXV0gKz0gMTtcbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSA1ODsgaSA+IDA7IC0taSkge1xuICAgICAgICB2YXIgbmMgPSBjICsgaHVmVGFibGVCdWZmZXJbaV0gPj4gMTtcbiAgICAgICAgaHVmVGFibGVCdWZmZXJbaV0gPSBjO1xuICAgICAgICBjID0gbmM7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhVRl9FTkNTSVpFOyArK2kpIHtcbiAgICAgICAgdmFyIGwgPSBoY29kZVtpXTtcbiAgICAgICAgaWYgKGwgPiAwKVxuICAgICAgICAgIGhjb2RlW2ldID0gbCB8IGh1ZlRhYmxlQnVmZmVyW2xdKysgPDwgNjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmVW5wYWNrRW5jVGFibGUodUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBuaSwgaW0sIGlNLCBoY29kZSkge1xuICAgICAgdmFyIHAgPSBpbk9mZnNldDtcbiAgICAgIHZhciBjID0gMDtcbiAgICAgIHZhciBsYyA9IDA7XG4gICAgICBmb3IgKDsgaW0gPD0gaU07IGltKyspIHtcbiAgICAgICAgaWYgKHAudmFsdWUgLSBpbk9mZnNldC52YWx1ZSA+IG5pKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZ2V0Qml0cyg2LCBjLCBsYywgdUludDhBcnJheTIsIHApO1xuICAgICAgICB2YXIgbCA9IGdldEJpdHNSZXR1cm4ubDtcbiAgICAgICAgYyA9IGdldEJpdHNSZXR1cm4uYztcbiAgICAgICAgbGMgPSBnZXRCaXRzUmV0dXJuLmxjO1xuICAgICAgICBoY29kZVtpbV0gPSBsO1xuICAgICAgICBpZiAobCA9PSBMT05HX1pFUk9DT0RFX1JVTikge1xuICAgICAgICAgIGlmIChwLnZhbHVlIC0gaW5PZmZzZXQudmFsdWUgPiBuaSkge1xuICAgICAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnZXRCaXRzKDgsIGMsIGxjLCB1SW50OEFycmF5MiwgcCk7XG4gICAgICAgICAgdmFyIHplcnVuID0gZ2V0Qml0c1JldHVybi5sICsgU0hPUlRFU1RfTE9OR19SVU47XG4gICAgICAgICAgYyA9IGdldEJpdHNSZXR1cm4uYztcbiAgICAgICAgICBsYyA9IGdldEJpdHNSZXR1cm4ubGM7XG4gICAgICAgICAgaWYgKGltICsgemVydW4gPiBpTSArIDEpIHtcbiAgICAgICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5wYWNrRW5jVGFibGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHplcnVuLS0pXG4gICAgICAgICAgICBoY29kZVtpbSsrXSA9IDA7XG4gICAgICAgICAgaW0tLTtcbiAgICAgICAgfSBlbHNlIGlmIChsID49IFNIT1JUX1pFUk9DT0RFX1JVTikge1xuICAgICAgICAgIHZhciB6ZXJ1biA9IGwgLSBTSE9SVF9aRVJPQ09ERV9SVU4gKyAyO1xuICAgICAgICAgIGlmIChpbSArIHplcnVuID4gaU0gKyAxKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVucGFja0VuY1RhYmxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICh6ZXJ1bi0tKVxuICAgICAgICAgICAgaGNvZGVbaW0rK10gPSAwO1xuICAgICAgICAgIGltLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGh1ZkNhbm9uaWNhbENvZGVUYWJsZShoY29kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1Zkxlbmd0aChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSAmIDYzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZDb2RlKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID4+IDY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZkJ1aWxkRGVjVGFibGUoaGNvZGUsIGltLCBpTSwgaGRlY29kKSB7XG4gICAgICBmb3IgKDsgaW0gPD0gaU07IGltKyspIHtcbiAgICAgICAgdmFyIGMgPSBodWZDb2RlKGhjb2RlW2ltXSk7XG4gICAgICAgIHZhciBsID0gaHVmTGVuZ3RoKGhjb2RlW2ltXSk7XG4gICAgICAgIGlmIChjID4+IGwpIHtcbiAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGFibGUgZW50cnlcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobCA+IEhVRl9ERUNCSVRTKSB7XG4gICAgICAgICAgdmFyIHBsID0gaGRlY29kW2MgPj4gbCAtIEhVRl9ERUNCSVRTXTtcbiAgICAgICAgICBpZiAocGwubGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGFibGUgZW50cnlcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGwubGl0Kys7XG4gICAgICAgICAgaWYgKHBsLnApIHtcbiAgICAgICAgICAgIHZhciBwID0gcGwucDtcbiAgICAgICAgICAgIHBsLnAgPSBuZXcgQXJyYXkocGwubGl0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGwubGl0IC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgIHBsLnBbaV0gPSBwW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbC5wID0gbmV3IEFycmF5KDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwbC5wW3BsLmxpdCAtIDFdID0gaW07XG4gICAgICAgIH0gZWxzZSBpZiAobCkge1xuICAgICAgICAgIHZhciBwbE9mZnNldCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDEgPDwgSFVGX0RFQ0JJVFMgLSBsOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgcGwgPSBoZGVjb2RbKGMgPDwgSFVGX0RFQ0JJVFMgLSBsKSArIHBsT2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChwbC5sZW4gfHwgcGwucCkge1xuICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGFibGUgZW50cnlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsLmxlbiA9IGw7XG4gICAgICAgICAgICBwbC5saXQgPSBpbTtcbiAgICAgICAgICAgIHBsT2Zmc2V0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZ2V0Q2hhclJldHVybiA9IHsgYzogMCwgbGM6IDAgfTtcbiAgICBmdW5jdGlvbiBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpIHtcbiAgICAgIGMgPSBjIDw8IDggfCBwYXJzZVVpbnQ4QXJyYXkodUludDhBcnJheTIsIGluT2Zmc2V0KTtcbiAgICAgIGxjICs9IDg7XG4gICAgICBnZXRDaGFyUmV0dXJuLmMgPSBjO1xuICAgICAgZ2V0Q2hhclJldHVybi5sYyA9IGxjO1xuICAgIH1cbiAgICBjb25zdCBnZXRDb2RlUmV0dXJuID0geyBjOiAwLCBsYzogMCB9O1xuICAgIGZ1bmN0aW9uIGdldENvZGUocG8sIHJsYywgYywgbGMsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgb3V0QnVmZmVyLCBvdXRCdWZmZXJPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgICAgaWYgKHBvID09IHJsYykge1xuICAgICAgICBpZiAobGMgPCA4KSB7XG4gICAgICAgICAgZ2V0Q2hhcihjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KTtcbiAgICAgICAgICBjID0gZ2V0Q2hhclJldHVybi5jO1xuICAgICAgICAgIGxjID0gZ2V0Q2hhclJldHVybi5sYztcbiAgICAgICAgfVxuICAgICAgICBsYyAtPSA4O1xuICAgICAgICB2YXIgY3MgPSBjID4+IGxjO1xuICAgICAgICB2YXIgY3MgPSBuZXcgVWludDhBcnJheShbY3NdKVswXTtcbiAgICAgICAgaWYgKG91dEJ1ZmZlck9mZnNldC52YWx1ZSArIGNzID4gb3V0QnVmZmVyRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzID0gb3V0QnVmZmVyW291dEJ1ZmZlck9mZnNldC52YWx1ZSAtIDFdO1xuICAgICAgICB3aGlsZSAoY3MtLSA+IDApIHtcbiAgICAgICAgICBvdXRCdWZmZXJbb3V0QnVmZmVyT2Zmc2V0LnZhbHVlKytdID0gcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvdXRCdWZmZXJPZmZzZXQudmFsdWUgPCBvdXRCdWZmZXJFbmRPZmZzZXQpIHtcbiAgICAgICAgb3V0QnVmZmVyW291dEJ1ZmZlck9mZnNldC52YWx1ZSsrXSA9IHBvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZ2V0Q29kZVJldHVybi5jID0gYztcbiAgICAgIGdldENvZGVSZXR1cm4ubGMgPSBsYztcbiAgICB9XG4gICAgZnVuY3Rpb24gVUludDE2KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiA2NTUzNTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50MTYodmFsdWUpIHtcbiAgICAgIHZhciByZWYgPSBVSW50MTYodmFsdWUpO1xuICAgICAgcmV0dXJuIHJlZiA+IDMyNzY3ID8gcmVmIC0gNjU1MzYgOiByZWY7XG4gICAgfVxuICAgIGNvbnN0IHdkZWMxNFJldHVybiA9IHsgYTogMCwgYjogMCB9O1xuICAgIGZ1bmN0aW9uIHdkZWMxNChsLCBoKSB7XG4gICAgICB2YXIgbHMgPSBJbnQxNihsKTtcbiAgICAgIHZhciBocyA9IEludDE2KGgpO1xuICAgICAgdmFyIGhpID0gaHM7XG4gICAgICB2YXIgYWkgPSBscyArIChoaSAmIDEpICsgKGhpID4+IDEpO1xuICAgICAgdmFyIGFzID0gYWk7XG4gICAgICB2YXIgYnMgPSBhaSAtIGhpO1xuICAgICAgd2RlYzE0UmV0dXJuLmEgPSBhcztcbiAgICAgIHdkZWMxNFJldHVybi5iID0gYnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdkZWMxNihsLCBoKSB7XG4gICAgICB2YXIgbSA9IFVJbnQxNihsKTtcbiAgICAgIHZhciBkID0gVUludDE2KGgpO1xuICAgICAgdmFyIGJiID0gbSAtIChkID4+IDEpICYgTU9EX01BU0s7XG4gICAgICB2YXIgYWEgPSBkICsgYmIgLSBBX09GRlNFVCAmIE1PRF9NQVNLO1xuICAgICAgd2RlYzE0UmV0dXJuLmEgPSBhYTtcbiAgICAgIHdkZWMxNFJldHVybi5iID0gYmI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhdjJEZWNvZGUoYnVmZmVyMiwgaiwgbngsIG94LCBueSwgb3ksIG14KSB7XG4gICAgICB2YXIgdzE0ID0gbXggPCAxIDw8IDE0O1xuICAgICAgdmFyIG4gPSBueCA+IG55ID8gbnkgOiBueDtcbiAgICAgIHZhciBwID0gMTtcbiAgICAgIHZhciBwMjtcbiAgICAgIHdoaWxlIChwIDw9IG4pXG4gICAgICAgIHAgPDw9IDE7XG4gICAgICBwID4+PSAxO1xuICAgICAgcDIgPSBwO1xuICAgICAgcCA+Pj0gMTtcbiAgICAgIHdoaWxlIChwID49IDEpIHtcbiAgICAgICAgdmFyIHB5ID0gMDtcbiAgICAgICAgdmFyIGV5ID0gcHkgKyBveSAqIChueSAtIHAyKTtcbiAgICAgICAgdmFyIG95MSA9IG95ICogcDtcbiAgICAgICAgdmFyIG95MiA9IG95ICogcDI7XG4gICAgICAgIHZhciBveDEgPSBveCAqIHA7XG4gICAgICAgIHZhciBveDIgPSBveCAqIHAyO1xuICAgICAgICB2YXIgaTAwLCBpMDEsIGkxMCwgaTExO1xuICAgICAgICBmb3IgKDsgcHkgPD0gZXk7IHB5ICs9IG95Mikge1xuICAgICAgICAgIHZhciBweCA9IHB5O1xuICAgICAgICAgIHZhciBleCA9IHB5ICsgb3ggKiAobnggLSBwMik7XG4gICAgICAgICAgZm9yICg7IHB4IDw9IGV4OyBweCArPSBveDIpIHtcbiAgICAgICAgICAgIHZhciBwMDEgPSBweCArIG94MTtcbiAgICAgICAgICAgIHZhciBwMTAgPSBweCArIG95MTtcbiAgICAgICAgICAgIHZhciBwMTEgPSBwMTAgKyBveDE7XG4gICAgICAgICAgICBpZiAodzE0KSB7XG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDEwICsgal0pO1xuICAgICAgICAgICAgICBpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgaTEwID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXIyW3AwMSArIGpdLCBidWZmZXIyW3AxMSArIGpdKTtcbiAgICAgICAgICAgICAgaTAxID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTQoaTAwLCBpMDEpO1xuICAgICAgICAgICAgICBidWZmZXIyW3B4ICsgal0gPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMDEgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTQoaTEwLCBpMTEpO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDExICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDEwICsgal0pO1xuICAgICAgICAgICAgICBpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgaTEwID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXIyW3AwMSArIGpdLCBidWZmZXIyW3AxMSArIGpdKTtcbiAgICAgICAgICAgICAgaTAxID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTYoaTAwLCBpMDEpO1xuICAgICAgICAgICAgICBidWZmZXIyW3B4ICsgal0gPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMDEgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTYoaTEwLCBpMTEpO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDExICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG54ICYgcCkge1xuICAgICAgICAgICAgdmFyIHAxMCA9IHB4ICsgb3kxO1xuICAgICAgICAgICAgaWYgKHcxNClcbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMTAgKyBqXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDEwICsgal0pO1xuICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICBidWZmZXIyW3AxMCArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICBidWZmZXIyW3B4ICsgal0gPSBpMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChueSAmIHApIHtcbiAgICAgICAgICB2YXIgcHggPSBweTtcbiAgICAgICAgICB2YXIgZXggPSBweSArIG94ICogKG54IC0gcDIpO1xuICAgICAgICAgIGZvciAoOyBweCA8PSBleDsgcHggKz0gb3gyKSB7XG4gICAgICAgICAgICB2YXIgcDAxID0gcHggKyBveDE7XG4gICAgICAgICAgICBpZiAodzE0KVxuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AwMSArIGpdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgd2RlYzE2KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMDEgKyBqXSk7XG4gICAgICAgICAgICBpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgIGJ1ZmZlcjJbcDAxICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgIGJ1ZmZlcjJbcHggKyBqXSA9IGkwMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcDIgPSBwO1xuICAgICAgICBwID4+PSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZEZWNvZGUoZW5jb2RpbmdUYWJsZSwgZGVjb2RpbmdUYWJsZSwgdUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBuaSwgcmxjLCBubywgb3V0QnVmZmVyLCBvdXRPZmZzZXQpIHtcbiAgICAgIHZhciBjID0gMDtcbiAgICAgIHZhciBsYyA9IDA7XG4gICAgICB2YXIgb3V0QnVmZmVyRW5kT2Zmc2V0ID0gbm87XG4gICAgICB2YXIgaW5PZmZzZXRFbmQgPSBNYXRoLnRydW5jKGluT2Zmc2V0LnZhbHVlICsgKG5pICsgNykgLyA4KTtcbiAgICAgIHdoaWxlIChpbk9mZnNldC52YWx1ZSA8IGluT2Zmc2V0RW5kKSB7XG4gICAgICAgIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgIGMgPSBnZXRDaGFyUmV0dXJuLmM7XG4gICAgICAgIGxjID0gZ2V0Q2hhclJldHVybi5sYztcbiAgICAgICAgd2hpbGUgKGxjID49IEhVRl9ERUNCSVRTKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gYyA+PiBsYyAtIEhVRl9ERUNCSVRTICYgSFVGX0RFQ01BU0s7XG4gICAgICAgICAgdmFyIHBsID0gZGVjb2RpbmdUYWJsZVtpbmRleF07XG4gICAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgICAgbGMgLT0gcGwubGVuO1xuICAgICAgICAgICAgZ2V0Q29kZShwbC5saXQsIHJsYywgYywgbGMsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgb3V0QnVmZmVyLCBvdXRPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldCk7XG4gICAgICAgICAgICBjID0gZ2V0Q29kZVJldHVybi5jO1xuICAgICAgICAgICAgbGMgPSBnZXRDb2RlUmV0dXJuLmxjO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXBsLnApIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJodWZEZWNvZGUgaXNzdWVzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwbC5saXQ7IGorKykge1xuICAgICAgICAgICAgICB2YXIgbCA9IGh1Zkxlbmd0aChlbmNvZGluZ1RhYmxlW3BsLnBbal1dKTtcbiAgICAgICAgICAgICAgd2hpbGUgKGxjIDwgbCAmJiBpbk9mZnNldC52YWx1ZSA8IGluT2Zmc2V0RW5kKSB7XG4gICAgICAgICAgICAgICAgZ2V0Q2hhcihjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjID0gZ2V0Q2hhclJldHVybi5jO1xuICAgICAgICAgICAgICAgIGxjID0gZ2V0Q2hhclJldHVybi5sYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGMgPj0gbCkge1xuICAgICAgICAgICAgICAgIGlmIChodWZDb2RlKGVuY29kaW5nVGFibGVbcGwucFtqXV0pID09IChjID4+IGxjIC0gbCAmICgxIDw8IGwpIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgIGxjIC09IGw7XG4gICAgICAgICAgICAgICAgICBnZXRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBwbC5wW2pdLFxuICAgICAgICAgICAgICAgICAgICBybGMsXG4gICAgICAgICAgICAgICAgICAgIGMsXG4gICAgICAgICAgICAgICAgICAgIGxjLFxuICAgICAgICAgICAgICAgICAgICB1SW50OEFycmF5MixcbiAgICAgICAgICAgICAgICAgICAgaW5EYXRhVmlldyxcbiAgICAgICAgICAgICAgICAgICAgaW5PZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG91dEJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgb3V0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvdXRCdWZmZXJFbmRPZmZzZXRcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjID0gZ2V0Q29kZVJldHVybi5jO1xuICAgICAgICAgICAgICAgICAgbGMgPSBnZXRDb2RlUmV0dXJuLmxjO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA9PSBwbC5saXQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJodWZEZWNvZGUgaXNzdWVzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaSA9IDggLSBuaSAmIDc7XG4gICAgICBjID4+PSBpO1xuICAgICAgbGMgLT0gaTtcbiAgICAgIHdoaWxlIChsYyA+IDApIHtcbiAgICAgICAgdmFyIHBsID0gZGVjb2RpbmdUYWJsZVtjIDw8IEhVRl9ERUNCSVRTIC0gbGMgJiBIVUZfREVDTUFTS107XG4gICAgICAgIGlmIChwbC5sZW4pIHtcbiAgICAgICAgICBsYyAtPSBwbC5sZW47XG4gICAgICAgICAgZ2V0Q29kZShwbC5saXQsIHJsYywgYywgbGMsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgb3V0QnVmZmVyLCBvdXRPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldCk7XG4gICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uYztcbiAgICAgICAgICBsYyA9IGdldENvZGVSZXR1cm4ubGM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgXCJodWZEZWNvZGUgaXNzdWVzXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZVbmNvbXByZXNzKHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbkNvbXByZXNzZWQsIG91dEJ1ZmZlciwgblJhdykge1xuICAgICAgdmFyIG91dE9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICAgIHZhciBpbml0aWFsSW5PZmZzZXQgPSBpbk9mZnNldC52YWx1ZTtcbiAgICAgIHZhciBpbSA9IHBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIHZhciBpTSA9IHBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIGluT2Zmc2V0LnZhbHVlICs9IDQ7XG4gICAgICB2YXIgbkJpdHMgPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBpbk9mZnNldC52YWx1ZSArPSA0O1xuICAgICAgaWYgKGltIDwgMCB8fCBpbSA+PSBIVUZfRU5DU0laRSB8fCBpTSA8IDAgfHwgaU0gPj0gSFVGX0VOQ1NJWkUpIHtcbiAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBIVUZfRU5DU0laRVwiO1xuICAgICAgfVxuICAgICAgdmFyIGZyZXEgPSBuZXcgQXJyYXkoSFVGX0VOQ1NJWkUpO1xuICAgICAgdmFyIGhkZWMgPSBuZXcgQXJyYXkoSFVGX0RFQ1NJWkUpO1xuICAgICAgaHVmQ2xlYXJEZWNUYWJsZShoZGVjKTtcbiAgICAgIHZhciBuaSA9IG5Db21wcmVzc2VkIC0gKGluT2Zmc2V0LnZhbHVlIC0gaW5pdGlhbEluT2Zmc2V0KTtcbiAgICAgIGh1ZlVucGFja0VuY1RhYmxlKHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIGltLCBpTSwgZnJlcSk7XG4gICAgICBpZiAobkJpdHMgPiA4ICogKG5Db21wcmVzc2VkIC0gKGluT2Zmc2V0LnZhbHVlIC0gaW5pdGlhbEluT2Zmc2V0KSkpIHtcbiAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbmNvbXByZXNzXCI7XG4gICAgICB9XG4gICAgICBodWZCdWlsZERlY1RhYmxlKGZyZXEsIGltLCBpTSwgaGRlYyk7XG4gICAgICBodWZEZWNvZGUoZnJlcSwgaGRlYywgdUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBuQml0cywgaU0sIG5SYXcsIG91dEJ1ZmZlciwgb3V0T2Zmc2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlMdXQobHV0LCBkYXRhLCBuRGF0YSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuRGF0YTsgKytpKSB7XG4gICAgICAgIGRhdGFbaV0gPSBsdXRbZGF0YVtpXV07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWRpY3Rvcihzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgc291cmNlLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBkID0gc291cmNlW3QgLSAxXSArIHNvdXJjZVt0XSAtIDEyODtcbiAgICAgICAgc291cmNlW3RdID0gZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJsZWF2ZVNjYWxhcihzb3VyY2UsIG91dCkge1xuICAgICAgdmFyIHQxID0gMDtcbiAgICAgIHZhciB0MiA9IE1hdGguZmxvb3IoKHNvdXJjZS5sZW5ndGggKyAxKSAvIDIpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIHN0b3AgPSBzb3VyY2UubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChzID4gc3RvcClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgb3V0W3MrK10gPSBzb3VyY2VbdDErK107XG4gICAgICAgIGlmIChzID4gc3RvcClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgb3V0W3MrK10gPSBzb3VyY2VbdDIrK107XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVJ1bkxlbmd0aChzb3VyY2UpIHtcbiAgICAgIHZhciBzaXplID0gc291cmNlLmJ5dGVMZW5ndGg7XG4gICAgICB2YXIgb3V0ID0gbmV3IEFycmF5KCk7XG4gICAgICB2YXIgcCA9IDA7XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IERhdGFWaWV3KHNvdXJjZSk7XG4gICAgICB3aGlsZSAoc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIGwgPSByZWFkZXIuZ2V0SW50OChwKyspO1xuICAgICAgICBpZiAobCA8IDApIHtcbiAgICAgICAgICB2YXIgY291bnQgPSAtbDtcbiAgICAgICAgICBzaXplIC09IGNvdW50ICsgMTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHJlYWRlci5nZXRVaW50OChwKyspKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gbDtcbiAgICAgICAgICBzaXplIC09IDI7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVhZGVyLmdldFVpbnQ4KHArKyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCArIDE7IGkrKykge1xuICAgICAgICAgICAgb3V0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9zc3lEY3REZWNvZGUoY3NjU2V0LCByb3dQdHJzLCBjaGFubmVsRGF0YSwgYWNCdWZmZXIsIGRjQnVmZmVyLCBvdXRCdWZmZXIpIHtcbiAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyKTtcbiAgICAgIHZhciB3aWR0aCA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbMF1dLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbMF1dLmhlaWdodDtcbiAgICAgIHZhciBudW1Db21wID0gMztcbiAgICAgIHZhciBudW1GdWxsQmxvY2tzWCA9IE1hdGguZmxvb3Iod2lkdGggLyA4KTtcbiAgICAgIHZhciBudW1CbG9ja3NYID0gTWF0aC5jZWlsKHdpZHRoIC8gOCk7XG4gICAgICB2YXIgbnVtQmxvY2tzWSA9IE1hdGguY2VpbChoZWlnaHQgLyA4KTtcbiAgICAgIHZhciBsZWZ0b3ZlclggPSB3aWR0aCAtIChudW1CbG9ja3NYIC0gMSkgKiA4O1xuICAgICAgdmFyIGxlZnRvdmVyWSA9IGhlaWdodCAtIChudW1CbG9ja3NZIC0gMSkgKiA4O1xuICAgICAgdmFyIGN1cnJBY0NvbXAgPSB7IHZhbHVlOiAwIH07XG4gICAgICB2YXIgY3VyckRjQ29tcCA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIHZhciBkY3REYXRhID0gbmV3IEFycmF5KG51bUNvbXApO1xuICAgICAgdmFyIGhhbGZaaWdCbG9jayA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIHZhciByb3dCbG9jayA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIHZhciByb3dPZmZzZXRzID0gbmV3IEFycmF5KG51bUNvbXApO1xuICAgICAgZm9yIChsZXQgY29tcDIgPSAwOyBjb21wMiA8IG51bUNvbXA7ICsrY29tcDIpIHtcbiAgICAgICAgcm93T2Zmc2V0c1tjb21wMl0gPSByb3dQdHJzW2NzY1NldC5pZHhbY29tcDJdXTtcbiAgICAgICAgY3VyckRjQ29tcFtjb21wMl0gPSBjb21wMiA8IDEgPyAwIDogY3VyckRjQ29tcFtjb21wMiAtIDFdICsgbnVtQmxvY2tzWCAqIG51bUJsb2Nrc1k7XG4gICAgICAgIGRjdERhdGFbY29tcDJdID0gbmV3IEZsb2F0MzJBcnJheSg2NCk7XG4gICAgICAgIGhhbGZaaWdCbG9ja1tjb21wMl0gPSBuZXcgVWludDE2QXJyYXkoNjQpO1xuICAgICAgICByb3dCbG9ja1tjb21wMl0gPSBuZXcgVWludDE2QXJyYXkobnVtQmxvY2tzWCAqIDY0KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGJsb2NreSA9IDA7IGJsb2NreSA8IG51bUJsb2Nrc1k7ICsrYmxvY2t5KSB7XG4gICAgICAgIHZhciBtYXhZID0gODtcbiAgICAgICAgaWYgKGJsb2NreSA9PSBudW1CbG9ja3NZIC0gMSlcbiAgICAgICAgICBtYXhZID0gbGVmdG92ZXJZO1xuICAgICAgICB2YXIgbWF4WCA9IDg7XG4gICAgICAgIGZvciAobGV0IGJsb2NreCA9IDA7IGJsb2NreCA8IG51bUJsb2Nrc1g7ICsrYmxvY2t4KSB7XG4gICAgICAgICAgaWYgKGJsb2NreCA9PSBudW1CbG9ja3NYIC0gMSlcbiAgICAgICAgICAgIG1heFggPSBsZWZ0b3Zlclg7XG4gICAgICAgICAgZm9yIChsZXQgY29tcDIgPSAwOyBjb21wMiA8IG51bUNvbXA7ICsrY29tcDIpIHtcbiAgICAgICAgICAgIGhhbGZaaWdCbG9ja1tjb21wMl0uZmlsbCgwKTtcbiAgICAgICAgICAgIGhhbGZaaWdCbG9ja1tjb21wMl1bMF0gPSBkY0J1ZmZlcltjdXJyRGNDb21wW2NvbXAyXSsrXTtcbiAgICAgICAgICAgIHVuUmxlQUMoY3VyckFjQ29tcCwgYWNCdWZmZXIsIGhhbGZaaWdCbG9ja1tjb21wMl0pO1xuICAgICAgICAgICAgdW5aaWdaYWcoaGFsZlppZ0Jsb2NrW2NvbXAyXSwgZGN0RGF0YVtjb21wMl0pO1xuICAgICAgICAgICAgZGN0SW52ZXJzZShkY3REYXRhW2NvbXAyXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNzYzcwOUludmVyc2UoZGN0RGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgICAgICBjb252ZXJ0VG9IYWxmKGRjdERhdGFbY29tcDJdLCByb3dCbG9ja1tjb21wMl0sIGJsb2NreCAqIDY0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9mZnNldDIgPSAwO1xuICAgICAgICBmb3IgKGxldCBjb21wMiA9IDA7IGNvbXAyIDwgbnVtQ29tcDsgKytjb21wMikge1xuICAgICAgICAgIGNvbnN0IHR5cGUyID0gY2hhbm5lbERhdGFbY3NjU2V0LmlkeFtjb21wMl1dLnR5cGU7XG4gICAgICAgICAgZm9yIChsZXQgeTIgPSA4ICogYmxvY2t5OyB5MiA8IDggKiBibG9ja3kgKyBtYXhZOyArK3kyKSB7XG4gICAgICAgICAgICBvZmZzZXQyID0gcm93T2Zmc2V0c1tjb21wMl1beTJdO1xuICAgICAgICAgICAgZm9yIChsZXQgYmxvY2t4ID0gMDsgYmxvY2t4IDwgbnVtRnVsbEJsb2Nrc1g7ICsrYmxvY2t4KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNyYyA9IGJsb2NreCAqIDY0ICsgKHkyICYgNykgKiA4O1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDAgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyAwXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgMSAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDFdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAyICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgMl0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDMgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyAzXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgNCAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDRdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyA1ICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgNV0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDYgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA2XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgNyAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDddLCB0cnVlKTtcbiAgICAgICAgICAgICAgb2Zmc2V0MiArPSA4ICogSU5UMTZfU0laRSAqIHR5cGUyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVtRnVsbEJsb2Nrc1ggIT0gbnVtQmxvY2tzWCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeTIgPSA4ICogYmxvY2t5OyB5MiA8IDggKiBibG9ja3kgKyBtYXhZOyArK3kyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9mZnNldDMgPSByb3dPZmZzZXRzW2NvbXAyXVt5Ml0gKyA4ICogbnVtRnVsbEJsb2Nrc1ggKiBJTlQxNl9TSVpFICogdHlwZTI7XG4gICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG51bUZ1bGxCbG9ja3NYICogNjQgKyAoeTIgJiA3KSAqIDg7XG4gICAgICAgICAgICAgIGZvciAobGV0IHgyID0gMDsgeDIgPCBtYXhYOyArK3gyKSB7XG4gICAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDMgKyB4MiAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIHgyXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBoYWxmUm93ID0gbmV3IFVpbnQxNkFycmF5KHdpZHRoKTtcbiAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyKTtcbiAgICAgIGZvciAodmFyIGNvbXAgPSAwOyBjb21wIDwgbnVtQ29tcDsgKytjb21wKSB7XG4gICAgICAgIGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbY29tcF1dLmRlY29kZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdHlwZSA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbY29tcF1dLnR5cGU7XG4gICAgICAgIGlmIChjaGFubmVsRGF0YVtjb21wXS50eXBlICE9IDIpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQyID0gcm93T2Zmc2V0c1tjb21wXVt5XTtcbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgIGhhbGZSb3dbeF0gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0MiArIHggKiBJTlQxNl9TSVpFICogdHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0RmxvYXQzMihvZmZzZXQyICsgeCAqIElOVDE2X1NJWkUgKiB0eXBlLCBkZWNvZGVGbG9hdDE2KGhhbGZSb3dbeF0pLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5SbGVBQyhjdXJyQWNDb21wLCBhY0J1ZmZlciwgaGFsZlppZ0Jsb2NrKSB7XG4gICAgICB2YXIgYWNWYWx1ZTtcbiAgICAgIHZhciBkY3RDb21wID0gMTtcbiAgICAgIHdoaWxlIChkY3RDb21wIDwgNjQpIHtcbiAgICAgICAgYWNWYWx1ZSA9IGFjQnVmZmVyW2N1cnJBY0NvbXAudmFsdWVdO1xuICAgICAgICBpZiAoYWNWYWx1ZSA9PSA2NTI4MCkge1xuICAgICAgICAgIGRjdENvbXAgPSA2NDtcbiAgICAgICAgfSBlbHNlIGlmIChhY1ZhbHVlID4+IDggPT0gMjU1KSB7XG4gICAgICAgICAgZGN0Q29tcCArPSBhY1ZhbHVlICYgMjU1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbGZaaWdCbG9ja1tkY3RDb21wXSA9IGFjVmFsdWU7XG4gICAgICAgICAgZGN0Q29tcCsrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJBY0NvbXAudmFsdWUrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5aaWdaYWcoc3JjLCBkc3QpIHtcbiAgICAgIGRzdFswXSA9IGRlY29kZUZsb2F0MTYoc3JjWzBdKTtcbiAgICAgIGRzdFsxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzFdKTtcbiAgICAgIGRzdFsyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzVdKTtcbiAgICAgIGRzdFszXSA9IGRlY29kZUZsb2F0MTYoc3JjWzZdKTtcbiAgICAgIGRzdFs0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE0XSk7XG4gICAgICBkc3RbNV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxNV0pO1xuICAgICAgZHN0WzZdID0gZGVjb2RlRmxvYXQxNihzcmNbMjddKTtcbiAgICAgIGRzdFs3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI4XSk7XG4gICAgICBkc3RbOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syXSk7XG4gICAgICBkc3RbOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0XSk7XG4gICAgICBkc3RbMTBdID0gZGVjb2RlRmxvYXQxNihzcmNbN10pO1xuICAgICAgZHN0WzExXSA9IGRlY29kZUZsb2F0MTYoc3JjWzEzXSk7XG4gICAgICBkc3RbMTJdID0gZGVjb2RlRmxvYXQxNihzcmNbMTZdKTtcbiAgICAgIGRzdFsxM10gPSBkZWNvZGVGbG9hdDE2KHNyY1syNl0pO1xuICAgICAgZHN0WzE0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI5XSk7XG4gICAgICBkc3RbMTVdID0gZGVjb2RlRmxvYXQxNihzcmNbNDJdKTtcbiAgICAgIGRzdFsxNl0gPSBkZWNvZGVGbG9hdDE2KHNyY1szXSk7XG4gICAgICBkc3RbMTddID0gZGVjb2RlRmxvYXQxNihzcmNbOF0pO1xuICAgICAgZHN0WzE4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzEyXSk7XG4gICAgICBkc3RbMTldID0gZGVjb2RlRmxvYXQxNihzcmNbMTddKTtcbiAgICAgIGRzdFsyMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syNV0pO1xuICAgICAgZHN0WzIxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzMwXSk7XG4gICAgICBkc3RbMjJdID0gZGVjb2RlRmxvYXQxNihzcmNbNDFdKTtcbiAgICAgIGRzdFsyM10gPSBkZWNvZGVGbG9hdDE2KHNyY1s0M10pO1xuICAgICAgZHN0WzI0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzldKTtcbiAgICAgIGRzdFsyNV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxMV0pO1xuICAgICAgZHN0WzI2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE4XSk7XG4gICAgICBkc3RbMjddID0gZGVjb2RlRmxvYXQxNihzcmNbMjRdKTtcbiAgICAgIGRzdFsyOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1szMV0pO1xuICAgICAgZHN0WzI5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQwXSk7XG4gICAgICBkc3RbMzBdID0gZGVjb2RlRmxvYXQxNihzcmNbNDRdKTtcbiAgICAgIGRzdFszMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1M10pO1xuICAgICAgZHN0WzMyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzEwXSk7XG4gICAgICBkc3RbMzNdID0gZGVjb2RlRmxvYXQxNihzcmNbMTldKTtcbiAgICAgIGRzdFszNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syM10pO1xuICAgICAgZHN0WzM1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzMyXSk7XG4gICAgICBkc3RbMzZdID0gZGVjb2RlRmxvYXQxNihzcmNbMzldKTtcbiAgICAgIGRzdFszN10gPSBkZWNvZGVGbG9hdDE2KHNyY1s0NV0pO1xuICAgICAgZHN0WzM4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzUyXSk7XG4gICAgICBkc3RbMzldID0gZGVjb2RlRmxvYXQxNihzcmNbNTRdKTtcbiAgICAgIGRzdFs0MF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syMF0pO1xuICAgICAgZHN0WzQxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzIyXSk7XG4gICAgICBkc3RbNDJdID0gZGVjb2RlRmxvYXQxNihzcmNbMzNdKTtcbiAgICAgIGRzdFs0M10gPSBkZWNvZGVGbG9hdDE2KHNyY1szOF0pO1xuICAgICAgZHN0WzQ0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ2XSk7XG4gICAgICBkc3RbNDVdID0gZGVjb2RlRmxvYXQxNihzcmNbNTFdKTtcbiAgICAgIGRzdFs0Nl0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1NV0pO1xuICAgICAgZHN0WzQ3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzYwXSk7XG4gICAgICBkc3RbNDhdID0gZGVjb2RlRmxvYXQxNihzcmNbMjFdKTtcbiAgICAgIGRzdFs0OV0gPSBkZWNvZGVGbG9hdDE2KHNyY1szNF0pO1xuICAgICAgZHN0WzUwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzM3XSk7XG4gICAgICBkc3RbNTFdID0gZGVjb2RlRmxvYXQxNihzcmNbNDddKTtcbiAgICAgIGRzdFs1Ml0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1MF0pO1xuICAgICAgZHN0WzUzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzU2XSk7XG4gICAgICBkc3RbNTRdID0gZGVjb2RlRmxvYXQxNihzcmNbNTldKTtcbiAgICAgIGRzdFs1NV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s2MV0pO1xuICAgICAgZHN0WzU2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM1XSk7XG4gICAgICBkc3RbNTddID0gZGVjb2RlRmxvYXQxNihzcmNbMzZdKTtcbiAgICAgIGRzdFs1OF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0OF0pO1xuICAgICAgZHN0WzU5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ5XSk7XG4gICAgICBkc3RbNjBdID0gZGVjb2RlRmxvYXQxNihzcmNbNTddKTtcbiAgICAgIGRzdFs2MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1OF0pO1xuICAgICAgZHN0WzYyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzYyXSk7XG4gICAgICBkc3RbNjNdID0gZGVjb2RlRmxvYXQxNihzcmNbNjNdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGN0SW52ZXJzZShkYXRhKSB7XG4gICAgICBjb25zdCBhID0gMC41ICogTWF0aC5jb3MoMy4xNDE1OSAvIDQpO1xuICAgICAgY29uc3QgYiA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyAxNik7XG4gICAgICBjb25zdCBjID0gMC41ICogTWF0aC5jb3MoMy4xNDE1OSAvIDgpO1xuICAgICAgY29uc3QgZCA9IDAuNSAqIE1hdGguY29zKDMgKiAzLjE0MTU5IC8gMTYpO1xuICAgICAgY29uc3QgZSA9IDAuNSAqIE1hdGguY29zKDUgKiAzLjE0MTU5IC8gMTYpO1xuICAgICAgY29uc3QgZiA9IDAuNSAqIE1hdGguY29zKDMgKiAzLjE0MTU5IC8gOCk7XG4gICAgICBjb25zdCBnID0gMC41ICogTWF0aC5jb3MoNyAqIDMuMTQxNTkgLyAxNik7XG4gICAgICB2YXIgYWxwaGEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICB2YXIgYmV0YSA9IG5ldyBBcnJheSg0KTtcbiAgICAgIHZhciB0aGV0YSA9IG5ldyBBcnJheSg0KTtcbiAgICAgIHZhciBnYW1tYSA9IG5ldyBBcnJheSg0KTtcbiAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IDg7ICsrcm93KSB7XG4gICAgICAgIHZhciByb3dQdHIgPSByb3cgKiA4O1xuICAgICAgICBhbHBoYVswXSA9IGMgKiBkYXRhW3Jvd1B0ciArIDJdO1xuICAgICAgICBhbHBoYVsxXSA9IGYgKiBkYXRhW3Jvd1B0ciArIDJdO1xuICAgICAgICBhbHBoYVsyXSA9IGMgKiBkYXRhW3Jvd1B0ciArIDZdO1xuICAgICAgICBhbHBoYVszXSA9IGYgKiBkYXRhW3Jvd1B0ciArIDZdO1xuICAgICAgICBiZXRhWzBdID0gYiAqIGRhdGFbcm93UHRyICsgMV0gKyBkICogZGF0YVtyb3dQdHIgKyAzXSArIGUgKiBkYXRhW3Jvd1B0ciArIDVdICsgZyAqIGRhdGFbcm93UHRyICsgN107XG4gICAgICAgIGJldGFbMV0gPSBkICogZGF0YVtyb3dQdHIgKyAxXSAtIGcgKiBkYXRhW3Jvd1B0ciArIDNdIC0gYiAqIGRhdGFbcm93UHRyICsgNV0gLSBlICogZGF0YVtyb3dQdHIgKyA3XTtcbiAgICAgICAgYmV0YVsyXSA9IGUgKiBkYXRhW3Jvd1B0ciArIDFdIC0gYiAqIGRhdGFbcm93UHRyICsgM10gKyBnICogZGF0YVtyb3dQdHIgKyA1XSArIGQgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICBiZXRhWzNdID0gZyAqIGRhdGFbcm93UHRyICsgMV0gLSBlICogZGF0YVtyb3dQdHIgKyAzXSArIGQgKiBkYXRhW3Jvd1B0ciArIDVdIC0gYiAqIGRhdGFbcm93UHRyICsgN107XG4gICAgICAgIHRoZXRhWzBdID0gYSAqIChkYXRhW3Jvd1B0ciArIDBdICsgZGF0YVtyb3dQdHIgKyA0XSk7XG4gICAgICAgIHRoZXRhWzNdID0gYSAqIChkYXRhW3Jvd1B0ciArIDBdIC0gZGF0YVtyb3dQdHIgKyA0XSk7XG4gICAgICAgIHRoZXRhWzFdID0gYWxwaGFbMF0gKyBhbHBoYVszXTtcbiAgICAgICAgdGhldGFbMl0gPSBhbHBoYVsxXSAtIGFscGhhWzJdO1xuICAgICAgICBnYW1tYVswXSA9IHRoZXRhWzBdICsgdGhldGFbMV07XG4gICAgICAgIGdhbW1hWzFdID0gdGhldGFbM10gKyB0aGV0YVsyXTtcbiAgICAgICAgZ2FtbWFbMl0gPSB0aGV0YVszXSAtIHRoZXRhWzJdO1xuICAgICAgICBnYW1tYVszXSA9IHRoZXRhWzBdIC0gdGhldGFbMV07XG4gICAgICAgIGRhdGFbcm93UHRyICsgMF0gPSBnYW1tYVswXSArIGJldGFbMF07XG4gICAgICAgIGRhdGFbcm93UHRyICsgMV0gPSBnYW1tYVsxXSArIGJldGFbMV07XG4gICAgICAgIGRhdGFbcm93UHRyICsgMl0gPSBnYW1tYVsyXSArIGJldGFbMl07XG4gICAgICAgIGRhdGFbcm93UHRyICsgM10gPSBnYW1tYVszXSArIGJldGFbM107XG4gICAgICAgIGRhdGFbcm93UHRyICsgNF0gPSBnYW1tYVszXSAtIGJldGFbM107XG4gICAgICAgIGRhdGFbcm93UHRyICsgNV0gPSBnYW1tYVsyXSAtIGJldGFbMl07XG4gICAgICAgIGRhdGFbcm93UHRyICsgNl0gPSBnYW1tYVsxXSAtIGJldGFbMV07XG4gICAgICAgIGRhdGFbcm93UHRyICsgN10gPSBnYW1tYVswXSAtIGJldGFbMF07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBjb2x1bW4gPSAwOyBjb2x1bW4gPCA4OyArK2NvbHVtbikge1xuICAgICAgICBhbHBoYVswXSA9IGMgKiBkYXRhWzE2ICsgY29sdW1uXTtcbiAgICAgICAgYWxwaGFbMV0gPSBmICogZGF0YVsxNiArIGNvbHVtbl07XG4gICAgICAgIGFscGhhWzJdID0gYyAqIGRhdGFbNDggKyBjb2x1bW5dO1xuICAgICAgICBhbHBoYVszXSA9IGYgKiBkYXRhWzQ4ICsgY29sdW1uXTtcbiAgICAgICAgYmV0YVswXSA9IGIgKiBkYXRhWzggKyBjb2x1bW5dICsgZCAqIGRhdGFbMjQgKyBjb2x1bW5dICsgZSAqIGRhdGFbNDAgKyBjb2x1bW5dICsgZyAqIGRhdGFbNTYgKyBjb2x1bW5dO1xuICAgICAgICBiZXRhWzFdID0gZCAqIGRhdGFbOCArIGNvbHVtbl0gLSBnICogZGF0YVsyNCArIGNvbHVtbl0gLSBiICogZGF0YVs0MCArIGNvbHVtbl0gLSBlICogZGF0YVs1NiArIGNvbHVtbl07XG4gICAgICAgIGJldGFbMl0gPSBlICogZGF0YVs4ICsgY29sdW1uXSAtIGIgKiBkYXRhWzI0ICsgY29sdW1uXSArIGcgKiBkYXRhWzQwICsgY29sdW1uXSArIGQgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgYmV0YVszXSA9IGcgKiBkYXRhWzggKyBjb2x1bW5dIC0gZSAqIGRhdGFbMjQgKyBjb2x1bW5dICsgZCAqIGRhdGFbNDAgKyBjb2x1bW5dIC0gYiAqIGRhdGFbNTYgKyBjb2x1bW5dO1xuICAgICAgICB0aGV0YVswXSA9IGEgKiAoZGF0YVtjb2x1bW5dICsgZGF0YVszMiArIGNvbHVtbl0pO1xuICAgICAgICB0aGV0YVszXSA9IGEgKiAoZGF0YVtjb2x1bW5dIC0gZGF0YVszMiArIGNvbHVtbl0pO1xuICAgICAgICB0aGV0YVsxXSA9IGFscGhhWzBdICsgYWxwaGFbM107XG4gICAgICAgIHRoZXRhWzJdID0gYWxwaGFbMV0gLSBhbHBoYVsyXTtcbiAgICAgICAgZ2FtbWFbMF0gPSB0aGV0YVswXSArIHRoZXRhWzFdO1xuICAgICAgICBnYW1tYVsxXSA9IHRoZXRhWzNdICsgdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzJdID0gdGhldGFbM10gLSB0aGV0YVsyXTtcbiAgICAgICAgZ2FtbWFbM10gPSB0aGV0YVswXSAtIHRoZXRhWzFdO1xuICAgICAgICBkYXRhWzAgKyBjb2x1bW5dID0gZ2FtbWFbMF0gKyBiZXRhWzBdO1xuICAgICAgICBkYXRhWzggKyBjb2x1bW5dID0gZ2FtbWFbMV0gKyBiZXRhWzFdO1xuICAgICAgICBkYXRhWzE2ICsgY29sdW1uXSA9IGdhbW1hWzJdICsgYmV0YVsyXTtcbiAgICAgICAgZGF0YVsyNCArIGNvbHVtbl0gPSBnYW1tYVszXSArIGJldGFbM107XG4gICAgICAgIGRhdGFbMzIgKyBjb2x1bW5dID0gZ2FtbWFbM10gLSBiZXRhWzNdO1xuICAgICAgICBkYXRhWzQwICsgY29sdW1uXSA9IGdhbW1hWzJdIC0gYmV0YVsyXTtcbiAgICAgICAgZGF0YVs0OCArIGNvbHVtbl0gPSBnYW1tYVsxXSAtIGJldGFbMV07XG4gICAgICAgIGRhdGFbNTYgKyBjb2x1bW5dID0gZ2FtbWFbMF0gLSBiZXRhWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjc2M3MDlJbnZlcnNlKGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICB2YXIgeSA9IGRhdGFbMF1baV07XG4gICAgICAgIHZhciBjYiA9IGRhdGFbMV1baV07XG4gICAgICAgIHZhciBjciA9IGRhdGFbMl1baV07XG4gICAgICAgIGRhdGFbMF1baV0gPSB5ICsgMS41NzQ3ICogY3I7XG4gICAgICAgIGRhdGFbMV1baV0gPSB5IC0gMC4xODczICogY2IgLSAwLjQ2ODIgKiBjcjtcbiAgICAgICAgZGF0YVsyXVtpXSA9IHkgKyAxLjg1NTYgKiBjYjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFRvSGFsZihzcmMsIGRzdCwgaWR4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgICAgZHN0W2lkeCArIGldID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KHRvTGluZWFyKHNyY1tpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b0xpbmVhcihmbG9hdCkge1xuICAgICAgaWYgKGZsb2F0IDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbihmbG9hdCkgKiBNYXRoLnBvdyhNYXRoLmFicyhmbG9hdCksIDIuMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5zaWduKGZsb2F0KSAqIE1hdGgucG93KGxvZ0Jhc2UsIE1hdGguYWJzKGZsb2F0KSAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzUkFXKGluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoaW5mby5hcnJheS5idWZmZXIsIGluZm8ub2Zmc2V0LnZhbHVlLCBpbmZvLnNpemUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzUkxFKGluZm8pIHtcbiAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby52aWV3ZXIuYnVmZmVyLnNsaWNlKGluZm8ub2Zmc2V0LnZhbHVlLCBpbmZvLm9mZnNldC52YWx1ZSArIGluZm8uc2l6ZSk7XG4gICAgICB2YXIgcmF3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlUnVuTGVuZ3RoKGNvbXByZXNzZWQpKTtcbiAgICAgIHZhciB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShyYXdCdWZmZXIubGVuZ3RoKTtcbiAgICAgIHByZWRpY3RvcihyYXdCdWZmZXIpO1xuICAgICAgaW50ZXJsZWF2ZVNjYWxhcihyYXdCdWZmZXIsIHRtcEJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzWklQKGluZm8pIHtcbiAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUpO1xuICAgICAgdmFyIHJhd0J1ZmZlciA9IHVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgICB2YXIgdG1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocmF3QnVmZmVyLmxlbmd0aCk7XG4gICAgICBwcmVkaWN0b3IocmF3QnVmZmVyKTtcbiAgICAgIGludGVybGVhdmVTY2FsYXIocmF3QnVmZmVyLCB0bXBCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1BJWihpbmZvKSB7XG4gICAgICB2YXIgaW5EYXRhVmlldyA9IGluZm8udmlld2VyO1xuICAgICAgdmFyIGluT2Zmc2V0ID0geyB2YWx1ZTogaW5mby5vZmZzZXQudmFsdWUgfTtcbiAgICAgIHZhciBvdXRCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoaW5mby53aWR0aCAqIGluZm8uc2NhbmxpbmVCbG9ja1NpemUgKiAoaW5mby5jaGFubmVscyAqIGluZm8udHlwZSkpO1xuICAgICAgdmFyIGJpdG1hcCA9IG5ldyBVaW50OEFycmF5KEJJVE1BUF9TSVpFKTtcbiAgICAgIHZhciBvdXRCdWZmZXJFbmQgPSAwO1xuICAgICAgdmFyIHBpekNoYW5uZWxEYXRhID0gbmV3IEFycmF5KGluZm8uY2hhbm5lbHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLmNoYW5uZWxzOyBpKyspIHtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV0gPSB7fTtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJzdGFydFwiXSA9IG91dEJ1ZmZlckVuZDtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJlbmRcIl0gPSBwaXpDaGFubmVsRGF0YVtpXVtcInN0YXJ0XCJdO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcIm54XCJdID0gaW5mby53aWR0aDtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJueVwiXSA9IGluZm8ubGluZXM7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wic2l6ZVwiXSA9IGluZm8udHlwZTtcbiAgICAgICAgb3V0QnVmZmVyRW5kICs9IHBpekNoYW5uZWxEYXRhW2ldLm54ICogcGl6Q2hhbm5lbERhdGFbaV0ubnkgKiBwaXpDaGFubmVsRGF0YVtpXS5zaXplO1xuICAgICAgfVxuICAgICAgdmFyIG1pbk5vblplcm8gPSBwYXJzZVVpbnQxNihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICB2YXIgbWF4Tm9uWmVybyA9IHBhcnNlVWludDE2KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIGlmIChtYXhOb25aZXJvID49IEJJVE1BUF9TSVpFKSB7XG4gICAgICAgIHRocm93IFwiU29tZXRoaW5nIGlzIHdyb25nIHdpdGggUElaX0NPTVBSRVNTSU9OIEJJVE1BUF9TSVpFXCI7XG4gICAgICB9XG4gICAgICBpZiAobWluTm9uWmVybyA8PSBtYXhOb25aZXJvKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4Tm9uWmVybyAtIG1pbk5vblplcm8gKyAxOyBpKyspIHtcbiAgICAgICAgICBiaXRtYXBbaSArIG1pbk5vblplcm9dID0gcGFyc2VVaW50OChpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBsdXQgPSBuZXcgVWludDE2QXJyYXkoVVNIT1JUX1JBTkdFKTtcbiAgICAgIHZhciBtYXhWYWx1ZSA9IHJldmVyc2VMdXRGcm9tQml0bWFwKGJpdG1hcCwgbHV0KTtcbiAgICAgIHZhciBsZW5ndGggPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBodWZVbmNvbXByZXNzKGluZm8uYXJyYXksIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBsZW5ndGgsIG91dEJ1ZmZlciwgb3V0QnVmZmVyRW5kKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5jaGFubmVsczsgKytpKSB7XG4gICAgICAgIHZhciBjZCA9IHBpekNoYW5uZWxEYXRhW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBpekNoYW5uZWxEYXRhW2ldLnNpemU7ICsraikge1xuICAgICAgICAgIHdhdjJEZWNvZGUob3V0QnVmZmVyLCBjZC5zdGFydCArIGosIGNkLm54LCBjZC5zaXplLCBjZC5ueSwgY2QubnggKiBjZC5zaXplLCBtYXhWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFwcGx5THV0KGx1dCwgb3V0QnVmZmVyLCBvdXRCdWZmZXJFbmQpO1xuICAgICAgdmFyIHRtcE9mZnNldDIgPSAwO1xuICAgICAgdmFyIHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG91dEJ1ZmZlci5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGluZm8ubGluZXM7IHkrKykge1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGluZm8uY2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgIHZhciBjZCA9IHBpekNoYW5uZWxEYXRhW2NdO1xuICAgICAgICAgIHZhciBuID0gY2QubnggKiBjZC5zaXplO1xuICAgICAgICAgIHZhciBjcCA9IG5ldyBVaW50OEFycmF5KG91dEJ1ZmZlci5idWZmZXIsIGNkLmVuZCAqIElOVDE2X1NJWkUsIG4gKiBJTlQxNl9TSVpFKTtcbiAgICAgICAgICB0bXBCdWZmZXIuc2V0KGNwLCB0bXBPZmZzZXQyKTtcbiAgICAgICAgICB0bXBPZmZzZXQyICs9IG4gKiBJTlQxNl9TSVpFO1xuICAgICAgICAgIGNkLmVuZCArPSBuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzUFhSKGluZm8pIHtcbiAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUpO1xuICAgICAgdmFyIHJhd0J1ZmZlciA9IHVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgICBjb25zdCBzeiA9IGluZm8ubGluZXMgKiBpbmZvLmNoYW5uZWxzICogaW5mby53aWR0aDtcbiAgICAgIGNvbnN0IHRtcEJ1ZmZlciA9IGluZm8udHlwZSA9PSAxID8gbmV3IFVpbnQxNkFycmF5KHN6KSA6IG5ldyBVaW50MzJBcnJheShzeik7XG4gICAgICBsZXQgdG1wQnVmZmVyRW5kID0gMDtcbiAgICAgIGxldCB3cml0ZVB0ciA9IDA7XG4gICAgICBjb25zdCBwdHIgPSBuZXcgQXJyYXkoNCk7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGluZm8ubGluZXM7IHkrKykge1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGluZm8uY2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgIGxldCBwaXhlbCA9IDA7XG4gICAgICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcHRyWzBdID0gdG1wQnVmZmVyRW5kO1xuICAgICAgICAgICAgICBwdHJbMV0gPSBwdHJbMF0gKyBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICB0bXBCdWZmZXJFbmQgPSBwdHJbMV0gKyBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZm8ud2lkdGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSByYXdCdWZmZXJbcHRyWzBdKytdIDw8IDggfCByYXdCdWZmZXJbcHRyWzFdKytdO1xuICAgICAgICAgICAgICAgIHBpeGVsICs9IGRpZmY7XG4gICAgICAgICAgICAgICAgdG1wQnVmZmVyW3dyaXRlUHRyXSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgIHdyaXRlUHRyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHB0clswXSA9IHRtcEJ1ZmZlckVuZDtcbiAgICAgICAgICAgICAgcHRyWzFdID0gcHRyWzBdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgcHRyWzJdID0gcHRyWzFdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgdG1wQnVmZmVyRW5kID0gcHRyWzJdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLndpZHRoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gcmF3QnVmZmVyW3B0clswXSsrXSA8PCAyNCB8IHJhd0J1ZmZlcltwdHJbMV0rK10gPDwgMTYgfCByYXdCdWZmZXJbcHRyWzJdKytdIDw8IDg7XG4gICAgICAgICAgICAgICAgcGl4ZWwgKz0gZGlmZjtcbiAgICAgICAgICAgICAgICB0bXBCdWZmZXJbd3JpdGVQdHJdID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgd3JpdGVQdHIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NEV0EoaW5mbykge1xuICAgICAgdmFyIGluRGF0YVZpZXcgPSBpbmZvLnZpZXdlcjtcbiAgICAgIHZhciBpbk9mZnNldCA9IHsgdmFsdWU6IGluZm8ub2Zmc2V0LnZhbHVlIH07XG4gICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoaW5mby53aWR0aCAqIGluZm8ubGluZXMgKiAoaW5mby5jaGFubmVscyAqIGluZm8udHlwZSAqIElOVDE2X1NJWkUpKTtcbiAgICAgIHZhciBkd2FIZWFkZXIgPSB7XG4gICAgICAgIHZlcnNpb246IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB1bmtub3duVW5jb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHVua25vd25Db21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIGFjQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBkY0NvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgcmxlQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBybGVVbmNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgcmxlUmF3U2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHRvdGFsQWNVbmNvbXByZXNzZWRDb3VudDogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHRvdGFsRGNVbmNvbXByZXNzZWRDb3VudDogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIGFjQ29tcHJlc3Npb246IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpXG4gICAgICB9O1xuICAgICAgaWYgKGR3YUhlYWRlci52ZXJzaW9uIDwgMikge1xuICAgICAgICB0aHJvdyBcIkVYUkxvYWRlci5wYXJzZTogXCIgKyBFWFJIZWFkZXIuY29tcHJlc3Npb24gKyBcIiB2ZXJzaW9uIFwiICsgZHdhSGVhZGVyLnZlcnNpb24gKyBcIiBpcyB1bnN1cHBvcnRlZFwiO1xuICAgICAgfVxuICAgICAgdmFyIGNoYW5uZWxSdWxlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgdmFyIHJ1bGVTaXplID0gcGFyc2VVaW50MTYoaW5EYXRhVmlldywgaW5PZmZzZXQpIC0gSU5UMTZfU0laRTtcbiAgICAgIHdoaWxlIChydWxlU2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGluRGF0YVZpZXcuYnVmZmVyLCBpbk9mZnNldCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlVWludDgoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSB2YWx1ZSA+PiAyICYgMztcbiAgICAgICAgdmFyIGNzYyA9ICh2YWx1ZSA+PiA0KSAtIDE7XG4gICAgICAgIHZhciBpbmRleCA9IG5ldyBJbnQ4QXJyYXkoW2NzY10pWzBdO1xuICAgICAgICB2YXIgdHlwZSA9IHBhcnNlVWludDgoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgICBjaGFubmVsUnVsZXMucHVzaCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGNvbXByZXNzaW9uXG4gICAgICAgIH0pO1xuICAgICAgICBydWxlU2l6ZSAtPSBuYW1lLmxlbmd0aCArIDM7XG4gICAgICB9XG4gICAgICB2YXIgY2hhbm5lbHMgPSBFWFJIZWFkZXIuY2hhbm5lbHM7XG4gICAgICB2YXIgY2hhbm5lbERhdGEgPSBuZXcgQXJyYXkoaW5mby5jaGFubmVscyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm8uY2hhbm5lbHM7ICsraSkge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtpXSA9IHt9O1xuICAgICAgICB2YXIgY2hhbm5lbCA9IGNoYW5uZWxzW2ldO1xuICAgICAgICBjZC5uYW1lID0gY2hhbm5lbC5uYW1lO1xuICAgICAgICBjZC5jb21wcmVzc2lvbiA9IFVOS05PV047XG4gICAgICAgIGNkLmRlY29kZWQgPSBmYWxzZTtcbiAgICAgICAgY2QudHlwZSA9IGNoYW5uZWwucGl4ZWxUeXBlO1xuICAgICAgICBjZC5wTGluZWFyID0gY2hhbm5lbC5wTGluZWFyO1xuICAgICAgICBjZC53aWR0aCA9IGluZm8ud2lkdGg7XG4gICAgICAgIGNkLmhlaWdodCA9IGluZm8ubGluZXM7XG4gICAgICB9XG4gICAgICB2YXIgY3NjU2V0ID0ge1xuICAgICAgICBpZHg6IG5ldyBBcnJheSgzKVxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIG9mZnNldDIgPSAwOyBvZmZzZXQyIDwgaW5mby5jaGFubmVsczsgKytvZmZzZXQyKSB7XG4gICAgICAgIHZhciBjZCA9IGNoYW5uZWxEYXRhW29mZnNldDJdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWxSdWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBydWxlID0gY2hhbm5lbFJ1bGVzW2ldO1xuICAgICAgICAgIGlmIChjZC5uYW1lID09IHJ1bGUubmFtZSkge1xuICAgICAgICAgICAgY2QuY29tcHJlc3Npb24gPSBydWxlLmNvbXByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKHJ1bGUuaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICBjc2NTZXQuaWR4W3J1bGUuaW5kZXhdID0gb2Zmc2V0MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNkLm9mZnNldCA9IG9mZnNldDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHdhSGVhZGVyLmFjQ29tcHJlc3NlZFNpemUgPiAwKSB7XG4gICAgICAgIHN3aXRjaCAoZHdhSGVhZGVyLmFjQ29tcHJlc3Npb24pIHtcbiAgICAgICAgICBjYXNlIFNUQVRJQ19IVUZGTUFOOlxuICAgICAgICAgICAgdmFyIGFjQnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnQpO1xuICAgICAgICAgICAgaHVmVW5jb21wcmVzcyhcbiAgICAgICAgICAgICAgaW5mby5hcnJheSxcbiAgICAgICAgICAgICAgaW5EYXRhVmlldyxcbiAgICAgICAgICAgICAgaW5PZmZzZXQsXG4gICAgICAgICAgICAgIGR3YUhlYWRlci5hY0NvbXByZXNzZWRTaXplLFxuICAgICAgICAgICAgICBhY0J1ZmZlcixcbiAgICAgICAgICAgICAgZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgREVGTEFURTpcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbk9mZnNldC52YWx1ZSwgaW5PZmZzZXQudmFsdWUgKyBkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50KTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHZhciBhY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheShkYXRhLmJ1ZmZlcik7XG4gICAgICAgICAgICBpbk9mZnNldC52YWx1ZSArPSBkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkd2FIZWFkZXIuZGNDb21wcmVzc2VkU2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIHpsaWJJbmZvID0ge1xuICAgICAgICAgIGFycmF5OiBpbmZvLmFycmF5LFxuICAgICAgICAgIG9mZnNldDogaW5PZmZzZXQsXG4gICAgICAgICAgc2l6ZTogZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRjQnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KHVuY29tcHJlc3NaSVAoemxpYkluZm8pLmJ1ZmZlcik7XG4gICAgICAgIGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci5kY0NvbXByZXNzZWRTaXplO1xuICAgICAgfVxuICAgICAgaWYgKGR3YUhlYWRlci5ybGVSYXdTaXplID4gMCkge1xuICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5PZmZzZXQudmFsdWUsIGluT2Zmc2V0LnZhbHVlICsgZHdhSGVhZGVyLnJsZUNvbXByZXNzZWRTaXplKTtcbiAgICAgICAgdmFyIGRhdGEgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgICB2YXIgcmxlQnVmZmVyID0gZGVjb2RlUnVuTGVuZ3RoKGRhdGEuYnVmZmVyKTtcbiAgICAgICAgaW5PZmZzZXQudmFsdWUgKz0gZHdhSGVhZGVyLnJsZUNvbXByZXNzZWRTaXplO1xuICAgICAgfVxuICAgICAgdmFyIG91dEJ1ZmZlckVuZCA9IDA7XG4gICAgICB2YXIgcm93T2Zmc2V0cyA9IG5ldyBBcnJheShjaGFubmVsRGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dPZmZzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJvd09mZnNldHNbaV0gPSBuZXcgQXJyYXkoKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaW5mby5saW5lczsgKyt5KSB7XG4gICAgICAgIGZvciAodmFyIGNoYW4gPSAwOyBjaGFuIDwgY2hhbm5lbERhdGEubGVuZ3RoOyArK2NoYW4pIHtcbiAgICAgICAgICByb3dPZmZzZXRzW2NoYW5dLnB1c2gob3V0QnVmZmVyRW5kKTtcbiAgICAgICAgICBvdXRCdWZmZXJFbmQgKz0gY2hhbm5lbERhdGFbY2hhbl0ud2lkdGggKiBpbmZvLnR5cGUgKiBJTlQxNl9TSVpFO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsb3NzeURjdERlY29kZShjc2NTZXQsIHJvd09mZnNldHMsIGNoYW5uZWxEYXRhLCBhY0J1ZmZlciwgZGNCdWZmZXIsIG91dEJ1ZmZlcik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWxEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjZCA9IGNoYW5uZWxEYXRhW2ldO1xuICAgICAgICBpZiAoY2QuZGVjb2RlZClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc3dpdGNoIChjZC5jb21wcmVzc2lvbikge1xuICAgICAgICAgIGNhc2UgUkxFOlxuICAgICAgICAgICAgdmFyIHJvdyA9IDA7XG4gICAgICAgICAgICB2YXIgcmxlT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaW5mby5saW5lczsgKyt5KSB7XG4gICAgICAgICAgICAgIHZhciByb3dPZmZzZXRCeXRlcyA9IHJvd09mZnNldHNbaV1bcm93XTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjZC53aWR0aDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYnl0ZSA9IDA7IGJ5dGUgPCBJTlQxNl9TSVpFICogY2QudHlwZTsgKytieXRlKSB7XG4gICAgICAgICAgICAgICAgICBvdXRCdWZmZXJbcm93T2Zmc2V0Qnl0ZXMrK10gPSBybGVCdWZmZXJbcmxlT2Zmc2V0ICsgYnl0ZSAqIGNkLndpZHRoICogY2QuaGVpZ2h0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmxlT2Zmc2V0Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIExPU1NZX0RDVDpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IHVuc3VwcG9ydGVkIGNoYW5uZWwgY29tcHJlc3Npb25cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhidWZmZXIyLCBvZmZzZXQyKSB7XG4gICAgICB2YXIgdWludEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpO1xuICAgICAgdmFyIGVuZE9mZnNldCA9IDA7XG4gICAgICB3aGlsZSAodWludEJ1ZmZlcltvZmZzZXQyLnZhbHVlICsgZW5kT2Zmc2V0XSAhPSAwKSB7XG4gICAgICAgIGVuZE9mZnNldCArPSAxO1xuICAgICAgfVxuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnRCdWZmZXIuc2xpY2Uob2Zmc2V0Mi52YWx1ZSwgb2Zmc2V0Mi52YWx1ZSArIGVuZE9mZnNldCkpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBlbmRPZmZzZXQgKyAxO1xuICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUZpeGVkTGVuZ3RoU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIsIHNpemUpIHtcbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIyKS5zbGljZShvZmZzZXQyLnZhbHVlLCBvZmZzZXQyLnZhbHVlICsgc2l6ZSkpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBzaXplO1xuICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVJhdGlvbmFsKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgeCA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHkgPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVRpbWVjb2RlKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgeCA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIEludDMyID0gZGF0YVZpZXcuZ2V0SW50MzIob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDMyX1NJWkU7XG4gICAgICByZXR1cm4gSW50MzI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgVWludDMyID0gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldDIudmFsdWUsIHRydWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBJTlQzMl9TSVpFO1xuICAgICAgcmV0dXJuIFVpbnQzMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVaW50OEFycmF5KHVJbnQ4QXJyYXkyLCBvZmZzZXQyKSB7XG4gICAgICB2YXIgVWludDggPSB1SW50OEFycmF5MltvZmZzZXQyLnZhbHVlXTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgSU5UOF9TSVpFO1xuICAgICAgcmV0dXJuIFVpbnQ4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgVWludDggPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQyLnZhbHVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgSU5UOF9TSVpFO1xuICAgICAgcmV0dXJuIFVpbnQ4O1xuICAgIH1cbiAgICBjb25zdCBwYXJzZUludDY0ID0gZnVuY3Rpb24oZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIGxldCBpbnQ7XG4gICAgICBpZiAoXCJnZXRCaWdJbnQ2NFwiIGluIERhdGFWaWV3LnByb3RvdHlwZSkge1xuICAgICAgICBpbnQgPSBOdW1iZXIoZGF0YVZpZXcuZ2V0QmlnSW50NjQob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ID0gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldDIudmFsdWUgKyA0LCB0cnVlKSArIE51bWJlcihkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSkgPDwgMzIpO1xuICAgICAgfVxuICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBVTE9OR19TSVpFO1xuICAgICAgcmV0dXJuIGludDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIGZsb2F0ID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgKz0gRkxPQVQzMl9TSVpFO1xuICAgICAgcmV0dXJuIGZsb2F0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICByZXR1cm4gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0MikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVGbG9hdDE2KGJpbmFyeSkge1xuICAgICAgdmFyIGV4cG9uZW50ID0gKGJpbmFyeSAmIDMxNzQ0KSA+PiAxMCwgZnJhY3Rpb24gPSBiaW5hcnkgJiAxMDIzO1xuICAgICAgcmV0dXJuIChiaW5hcnkgPj4gMTUgPyAtMSA6IDEpICogKGV4cG9uZW50ID8gZXhwb25lbnQgPT09IDMxID8gZnJhY3Rpb24gPyBOYU4gOiBJbmZpbml0eSA6IE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTUpICogKDEgKyBmcmFjdGlvbiAvIDEwMjQpIDogNjEwMzUxNTYyNWUtMTQgKiAoZnJhY3Rpb24gLyAxMDI0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDE2KGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgVWludDE2ID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldDIudmFsdWUsIHRydWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBJTlQxNl9TSVpFO1xuICAgICAgcmV0dXJuIFVpbnQxNjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VGbG9hdDE2KGJ1ZmZlcjIsIG9mZnNldDIpIHtcbiAgICAgIHJldHVybiBkZWNvZGVGbG9hdDE2KHBhcnNlVWludDE2KGJ1ZmZlcjIsIG9mZnNldDIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VDaGxpc3QoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIsIHNpemUpIHtcbiAgICAgIHZhciBzdGFydE9mZnNldCA9IG9mZnNldDIudmFsdWU7XG4gICAgICB2YXIgY2hhbm5lbHMgPSBbXTtcbiAgICAgIHdoaWxlIChvZmZzZXQyLnZhbHVlIDwgc3RhcnRPZmZzZXQgKyBzaXplIC0gMSkge1xuICAgICAgICB2YXIgbmFtZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mik7XG4gICAgICAgIHZhciBwaXhlbFR5cGUgPSBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgICAgdmFyIHBMaW5lYXIgPSBwYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgICAgb2Zmc2V0Mi52YWx1ZSArPSAzO1xuICAgICAgICB2YXIgeFNhbXBsaW5nID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIHZhciB5U2FtcGxpbmcgPSBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgICAgY2hhbm5lbHMucHVzaCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBwaXhlbFR5cGUsXG4gICAgICAgICAgcExpbmVhcixcbiAgICAgICAgICB4U2FtcGxpbmcsXG4gICAgICAgICAgeVNhbXBsaW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgb2Zmc2V0Mi52YWx1ZSArPSAxO1xuICAgICAgcmV0dXJuIGNoYW5uZWxzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNocm9tYXRpY2l0aWVzKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgcmVkWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgcmVkWSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgZ3JlZW5YID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciBncmVlblkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIGJsdWVYID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciBibHVlWSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgd2hpdGVYID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB3aGl0ZVkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkWCxcbiAgICAgICAgcmVkWSxcbiAgICAgICAgZ3JlZW5YLFxuICAgICAgICBncmVlblksXG4gICAgICAgIGJsdWVYLFxuICAgICAgICBibHVlWSxcbiAgICAgICAgd2hpdGVYLFxuICAgICAgICB3aGl0ZVlcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ29tcHJlc3Npb24oZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBjb21wcmVzc2lvbkNvZGVzID0gW1xuICAgICAgICBcIk5PX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiUkxFX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiWklQU19DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlpJUF9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlBJWl9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlBYUjI0X0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiQjQ0X0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiQjQ0QV9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkRXQUFfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJEV0FCX0NPTVBSRVNTSU9OXCJcbiAgICAgIF07XG4gICAgICB2YXIgY29tcHJlc3Npb24gPSBwYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBjb21wcmVzc2lvbkNvZGVzW2NvbXByZXNzaW9uXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VCb3gyaShkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHhNaW4gPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeU1pbiA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB4TWF4ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHlNYXggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4geyB4TWluLCB5TWluLCB4TWF4LCB5TWF4IH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTGluZU9yZGVyKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgbGluZU9yZGVycyA9IFtcIklOQ1JFQVNJTkdfWVwiXTtcbiAgICAgIHZhciBsaW5lT3JkZXIgPSBwYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBsaW5lT3JkZXJzW2xpbmVPcmRlcl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVjJmKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgeCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVYzZihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHogPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZShkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0MiwgdHlwZSwgc2l6ZSkge1xuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmd2ZWN0b3JcIiB8fCB0eXBlID09PSBcImljY1Byb2ZpbGVcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VGaXhlZExlbmd0aFN0cmluZyhidWZmZXIyLCBvZmZzZXQyLCBzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjaGxpc3RcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VDaGxpc3QoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIsIHNpemUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNocm9tYXRpY2l0aWVzXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hyb21hdGljaXRpZXMoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbXByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ29tcHJlc3Npb24oZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImJveDJpXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQm94MmkoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImxpbmVPcmRlclwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUxpbmVPcmRlcihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZmxvYXRcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2MmZcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VWMmYoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInYzZlwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVYzZihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInJhdGlvbmFsXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmF0aW9uYWwoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInRpbWVjb2RlXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVGltZWNvZGUoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInByZXZpZXdcIikge1xuICAgICAgICBvZmZzZXQyLnZhbHVlICs9IHNpemU7XG4gICAgICAgIHJldHVybiBcInNraXBwZWRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldDIudmFsdWUgKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIpIHtcbiAgICAgIGNvbnN0IEVYUkhlYWRlcjIgPSB7fTtcbiAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIoMCwgdHJ1ZSkgIT0gMjAwMDA2MzApIHtcbiAgICAgICAgdGhyb3cgXCJUSFJFRS5FWFJMb2FkZXI6IHByb3ZpZGVkIGZpbGUgZG9lc24ndCBhcHBlYXIgdG8gYmUgaW4gT3BlbkVYUiBmb3JtYXQuXCI7XG4gICAgICB9XG4gICAgICBFWFJIZWFkZXIyLnZlcnNpb24gPSBkYXRhVmlldy5nZXRVaW50OCg0KTtcbiAgICAgIGNvbnN0IHNwZWMgPSBkYXRhVmlldy5nZXRVaW50OCg1KTtcbiAgICAgIEVYUkhlYWRlcjIuc3BlYyA9IHtcbiAgICAgICAgc2luZ2xlVGlsZTogISEoc3BlYyAmIDIpLFxuICAgICAgICBsb25nTmFtZTogISEoc3BlYyAmIDQpLFxuICAgICAgICBkZWVwRm9ybWF0OiAhIShzcGVjICYgOCksXG4gICAgICAgIG11bHRpUGFydDogISEoc3BlYyAmIDE2KVxuICAgICAgfTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSA4O1xuICAgICAgdmFyIGtlZXBSZWFkaW5nID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChrZWVwUmVhZGluZykge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mik7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09IDApIHtcbiAgICAgICAgICBrZWVwUmVhZGluZyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVUeXBlID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhidWZmZXIyLCBvZmZzZXQyKTtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlU2l6ZSA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSBwYXJzZVZhbHVlKGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGVTaXplKTtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBFWFJMb2FkZXIucGFyc2U6IHNraXBwZWQgdW5rbm93biBoZWFkZXIgYXR0cmlidXRlIHR5cGUgJyR7YXR0cmlidXRlVHlwZX0nLmApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFWFJIZWFkZXIyW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKHNwZWMgJiB+NCkgIT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRVhSSGVhZGVyOlwiLCBFWFJIZWFkZXIyKTtcbiAgICAgICAgdGhyb3cgXCJUSFJFRS5FWFJMb2FkZXI6IHByb3ZpZGVkIGZpbGUgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEVYUkhlYWRlcjI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHVwRGVjb2RlcihFWFJIZWFkZXIyLCBkYXRhVmlldywgdUludDhBcnJheTIsIG9mZnNldDIsIG91dHB1dFR5cGUpIHtcbiAgICAgIGNvbnN0IEVYUkRlY29kZXIyID0ge1xuICAgICAgICBzaXplOiAwLFxuICAgICAgICB2aWV3ZXI6IGRhdGFWaWV3LFxuICAgICAgICBhcnJheTogdUludDhBcnJheTIsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0MixcbiAgICAgICAgd2lkdGg6IEVYUkhlYWRlcjIuZGF0YVdpbmRvdy54TWF4IC0gRVhSSGVhZGVyMi5kYXRhV2luZG93LnhNaW4gKyAxLFxuICAgICAgICBoZWlnaHQ6IEVYUkhlYWRlcjIuZGF0YVdpbmRvdy55TWF4IC0gRVhSSGVhZGVyMi5kYXRhV2luZG93LnlNaW4gKyAxLFxuICAgICAgICBjaGFubmVsczogRVhSSGVhZGVyMi5jaGFubmVscy5sZW5ndGgsXG4gICAgICAgIGJ5dGVzUGVyTGluZTogbnVsbCxcbiAgICAgICAgbGluZXM6IG51bGwsXG4gICAgICAgIGlucHV0U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZTogRVhSSGVhZGVyMi5jaGFubmVsc1swXS5waXhlbFR5cGUsXG4gICAgICAgIHVuY29tcHJlc3M6IG51bGwsXG4gICAgICAgIGdldHRlcjogbnVsbCxcbiAgICAgICAgZm9ybWF0OiBudWxsLFxuICAgICAgICBbaGFzQ29sb3JTcGFjZSA/IFwiY29sb3JTcGFjZVwiIDogXCJlbmNvZGluZ1wiXTogbnVsbFxuICAgICAgfTtcbiAgICAgIHN3aXRjaCAoRVhSSGVhZGVyMi5jb21wcmVzc2lvbikge1xuICAgICAgICBjYXNlIFwiTk9fQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NSQVc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSTEVfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NSTEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJaSVBTX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzWklQO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiWklQX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxNjtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1pJUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBJWl9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMzI7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NQSVo7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQWFIyNF9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTY7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NQWFI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEV0FBX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAzMjtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc0RXQTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRXQUJfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDI1NjtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc0RXQTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBcIkVYUkxvYWRlci5wYXJzZTogXCIgKyBFWFJIZWFkZXIyLmNvbXByZXNzaW9uICsgXCIgaXMgdW5zdXBwb3J0ZWRcIjtcbiAgICAgIH1cbiAgICAgIEVYUkRlY29kZXIyLnNjYW5saW5lQmxvY2tTaXplID0gRVhSRGVjb2RlcjIubGluZXM7XG4gICAgICBpZiAoRVhSRGVjb2RlcjIudHlwZSA9PSAxKSB7XG4gICAgICAgIHN3aXRjaCAob3V0cHV0VHlwZSkge1xuICAgICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuZ2V0dGVyID0gcGFyc2VGbG9hdDE2O1xuICAgICAgICAgICAgRVhSRGVjb2RlcjIuaW5wdXRTaXplID0gSU5UMTZfU0laRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmdldHRlciA9IHBhcnNlVWludDE2O1xuICAgICAgICAgICAgRVhSRGVjb2RlcjIuaW5wdXRTaXplID0gSU5UMTZfU0laRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEVYUkRlY29kZXIyLnR5cGUgPT0gMikge1xuICAgICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmdldHRlciA9IHBhcnNlRmxvYXQzMjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IEZMT0FUMzJfU0laRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmdldHRlciA9IGRlY29kZUZsb2F0MzI7XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5pbnB1dFNpemUgPSBGTE9BVDMyX1NJWkU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFwiRVhSTG9hZGVyLnBhcnNlOiB1bnN1cHBvcnRlZCBwaXhlbFR5cGUgXCIgKyBFWFJEZWNvZGVyMi50eXBlICsgXCIgZm9yIFwiICsgRVhSSGVhZGVyMi5jb21wcmVzc2lvbiArIFwiLlwiO1xuICAgICAgfVxuICAgICAgRVhSRGVjb2RlcjIuYmxvY2tDb3VudCA9IChFWFJIZWFkZXIyLmRhdGFXaW5kb3cueU1heCArIDEpIC8gRVhSRGVjb2RlcjIuc2NhbmxpbmVCbG9ja1NpemU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVYUkRlY29kZXIyLmJsb2NrQ291bnQ7IGkrKylcbiAgICAgICAgcGFyc2VJbnQ2NChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICBFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscyA9IEVYUkRlY29kZXIyLmNoYW5uZWxzID09IDMgPyA0IDogRVhSRGVjb2RlcjIuY2hhbm5lbHM7XG4gICAgICBjb25zdCBzaXplID0gRVhSRGVjb2RlcjIud2lkdGggKiBFWFJEZWNvZGVyMi5oZWlnaHQgKiBFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscztcbiAgICAgIHN3aXRjaCAob3V0cHV0VHlwZSkge1xuICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5ieXRlQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgICAgICAgIGlmIChFWFJEZWNvZGVyMi5jaGFubmVscyA8IEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzKVxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5LmZpbGwoMSwgMCwgc2l6ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5ieXRlQXJyYXkgPSBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XG4gICAgICAgICAgaWYgKEVYUkRlY29kZXIyLmNoYW5uZWxzIDwgRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMpXG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5ieXRlQXJyYXkuZmlsbCgxNTM2MCwgMCwgc2l6ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkVYUkxvYWRlcjogdW5zdXBwb3J0ZWQgdHlwZTogXCIsIG91dHB1dFR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgRVhSRGVjb2RlcjIuYnl0ZXNQZXJMaW5lID0gRVhSRGVjb2RlcjIud2lkdGggKiBFWFJEZWNvZGVyMi5pbnB1dFNpemUgKiBFWFJEZWNvZGVyMi5jaGFubmVscztcbiAgICAgIGlmIChFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscyA9PSA0KVxuICAgICAgICBFWFJEZWNvZGVyMi5mb3JtYXQgPSBSR0JBRm9ybWF0O1xuICAgICAgZWxzZVxuICAgICAgICBFWFJEZWNvZGVyMi5mb3JtYXQgPSBSZWRGb3JtYXQ7XG4gICAgICBpZiAoaGFzQ29sb3JTcGFjZSlcbiAgICAgICAgRVhSRGVjb2RlcjIuY29sb3JTcGFjZSA9IFwic3JnYi1saW5lYXJcIjtcbiAgICAgIGVsc2VcbiAgICAgICAgRVhSRGVjb2RlcjIuZW5jb2RpbmcgPSAzZTM7XG4gICAgICByZXR1cm4gRVhSRGVjb2RlcjI7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgY29uc3QgdUludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3Qgb2Zmc2V0ID0geyB2YWx1ZTogMCB9O1xuICAgIGNvbnN0IEVYUkhlYWRlciA9IHBhcnNlSGVhZGVyKGJ1ZmZlckRhdGFWaWV3LCBidWZmZXIsIG9mZnNldCk7XG4gICAgY29uc3QgRVhSRGVjb2RlciA9IHNldHVwRGVjb2RlcihFWFJIZWFkZXIsIGJ1ZmZlckRhdGFWaWV3LCB1SW50OEFycmF5LCBvZmZzZXQsIHRoaXMudHlwZSk7XG4gICAgY29uc3QgdG1wT2Zmc2V0ID0geyB2YWx1ZTogMCB9O1xuICAgIGNvbnN0IGNoYW5uZWxPZmZzZXRzID0geyBSOiAwLCBHOiAxLCBCOiAyLCBBOiAzLCBZOiAwIH07XG4gICAgZm9yIChsZXQgc2NhbmxpbmVCbG9ja0lkeCA9IDA7IHNjYW5saW5lQmxvY2tJZHggPCBFWFJEZWNvZGVyLmhlaWdodCAvIEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7IHNjYW5saW5lQmxvY2tJZHgrKykge1xuICAgICAgY29uc3QgbGluZSA9IHBhcnNlVWludDMyKGJ1ZmZlckRhdGFWaWV3LCBvZmZzZXQpO1xuICAgICAgRVhSRGVjb2Rlci5zaXplID0gcGFyc2VVaW50MzIoYnVmZmVyRGF0YVZpZXcsIG9mZnNldCk7XG4gICAgICBFWFJEZWNvZGVyLmxpbmVzID0gbGluZSArIEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemUgPiBFWFJEZWNvZGVyLmhlaWdodCA/IEVYUkRlY29kZXIuaGVpZ2h0IC0gbGluZSA6IEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7XG4gICAgICBjb25zdCBpc0NvbXByZXNzZWQgPSBFWFJEZWNvZGVyLnNpemUgPCBFWFJEZWNvZGVyLmxpbmVzICogRVhSRGVjb2Rlci5ieXRlc1BlckxpbmU7XG4gICAgICBjb25zdCB2aWV3ZXIgPSBpc0NvbXByZXNzZWQgPyBFWFJEZWNvZGVyLnVuY29tcHJlc3MoRVhSRGVjb2RlcikgOiB1bmNvbXByZXNzUkFXKEVYUkRlY29kZXIpO1xuICAgICAgb2Zmc2V0LnZhbHVlICs9IEVYUkRlY29kZXIuc2l6ZTtcbiAgICAgIGZvciAobGV0IGxpbmVfeSA9IDA7IGxpbmVfeSA8IEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7IGxpbmVfeSsrKSB7XG4gICAgICAgIGNvbnN0IHRydWVfeSA9IGxpbmVfeSArIHNjYW5saW5lQmxvY2tJZHggKiBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgICBpZiAodHJ1ZV95ID49IEVYUkRlY29kZXIuaGVpZ2h0KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKGxldCBjaGFubmVsSUQgPSAwOyBjaGFubmVsSUQgPCBFWFJEZWNvZGVyLmNoYW5uZWxzOyBjaGFubmVsSUQrKykge1xuICAgICAgICAgIGNvbnN0IGNPZmYgPSBjaGFubmVsT2Zmc2V0c1tFWFJIZWFkZXIuY2hhbm5lbHNbY2hhbm5lbElEXS5uYW1lXTtcbiAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IEVYUkRlY29kZXIud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgdG1wT2Zmc2V0LnZhbHVlID0gKGxpbmVfeSAqIChFWFJEZWNvZGVyLmNoYW5uZWxzICogRVhSRGVjb2Rlci53aWR0aCkgKyBjaGFubmVsSUQgKiBFWFJEZWNvZGVyLndpZHRoICsgeCkgKiBFWFJEZWNvZGVyLmlucHV0U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IG91dEluZGV4ID0gKEVYUkRlY29kZXIuaGVpZ2h0IC0gMSAtIHRydWVfeSkgKiAoRVhSRGVjb2Rlci53aWR0aCAqIEVYUkRlY29kZXIub3V0cHV0Q2hhbm5lbHMpICsgeCAqIEVYUkRlY29kZXIub3V0cHV0Q2hhbm5lbHMgKyBjT2ZmO1xuICAgICAgICAgICAgRVhSRGVjb2Rlci5ieXRlQXJyYXlbb3V0SW5kZXhdID0gRVhSRGVjb2Rlci5nZXR0ZXIodmlld2VyLCB0bXBPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaGVhZGVyOiBFWFJIZWFkZXIsXG4gICAgICB3aWR0aDogRVhSRGVjb2Rlci53aWR0aCxcbiAgICAgIGhlaWdodDogRVhSRGVjb2Rlci5oZWlnaHQsXG4gICAgICBkYXRhOiBFWFJEZWNvZGVyLmJ5dGVBcnJheSxcbiAgICAgIGZvcm1hdDogRVhSRGVjb2Rlci5mb3JtYXQsXG4gICAgICBbaGFzQ29sb3JTcGFjZSA/IFwiY29sb3JTcGFjZVwiIDogXCJlbmNvZGluZ1wiXTogRVhSRGVjb2RlcltoYXNDb2xvclNwYWNlID8gXCJjb2xvclNwYWNlXCIgOiBcImVuY29kaW5nXCJdLFxuICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgfTtcbiAgfVxuICBzZXREYXRhVHlwZSh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBmdW5jdGlvbiBvbkxvYWRDYWxsYmFjayh0ZXh0dXJlLCB0ZXhEYXRhKSB7XG4gICAgICBpZiAoaGFzQ29sb3JTcGFjZSlcbiAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gdGV4RGF0YS5jb2xvclNwYWNlO1xuICAgICAgZWxzZVxuICAgICAgICB0ZXh0dXJlLmVuY29kaW5nID0gdGV4RGF0YS5lbmNvZGluZztcbiAgICAgIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgdGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgaWYgKG9uTG9hZClcbiAgICAgICAgb25Mb2FkKHRleHR1cmUsIHRleERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIubG9hZCh1cmwsIG9uTG9hZENhbGxiYWNrLCBvblByb2dyZXNzLCBvbkVycm9yKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgRVhSTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RVhSTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlRleHR1cmUiLCJEYXRhVGV4dHVyZUxvYWRlciIsIkhhbGZGbG9hdFR5cGUiLCJGbG9hdFR5cGUiLCJSR0JBRm9ybWF0IiwiUmVkRm9ybWF0IiwiTGluZWFyRmlsdGVyIiwiRGF0YVV0aWxzIiwidW56bGliU3luYyIsImhhc0NvbG9yU3BhY2UiLCJFWFJMb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJ0eXBlIiwicGFyc2UiLCJidWZmZXIiLCJVU0hPUlRfUkFOR0UiLCJCSVRNQVBfU0laRSIsIkhVRl9FTkNCSVRTIiwiSFVGX0RFQ0JJVFMiLCJIVUZfRU5DU0laRSIsIkhVRl9ERUNTSVpFIiwiSFVGX0RFQ01BU0siLCJOQklUUyIsIkFfT0ZGU0VUIiwiTU9EX01BU0siLCJTSE9SVF9aRVJPQ09ERV9SVU4iLCJMT05HX1pFUk9DT0RFX1JVTiIsIlNIT1JURVNUX0xPTkdfUlVOIiwiVUxPTkdfU0laRSIsIkZMT0FUMzJfU0laRSIsIklOVDMyX1NJWkUiLCJJTlQxNl9TSVpFIiwiSU5UOF9TSVpFIiwiU1RBVElDX0hVRkZNQU4iLCJERUZMQVRFIiwiVU5LTk9XTiIsIkxPU1NZX0RDVCIsIlJMRSIsImxvZ0Jhc2UiLCJNYXRoIiwicG93IiwicmV2ZXJzZUx1dEZyb21CaXRtYXAiLCJiaXRtYXAiLCJsdXQiLCJrIiwiaSIsIm4iLCJodWZDbGVhckRlY1RhYmxlIiwiaGRlYyIsImxlbiIsImxpdCIsInAiLCJnZXRCaXRzUmV0dXJuIiwibCIsImMiLCJsYyIsImdldEJpdHMiLCJuQml0cyIsInVJbnQ4QXJyYXkyIiwiaW5PZmZzZXQiLCJwYXJzZVVpbnQ4QXJyYXkiLCJodWZUYWJsZUJ1ZmZlciIsIkFycmF5IiwiaHVmQ2Fub25pY2FsQ29kZVRhYmxlIiwiaGNvZGUiLCJuYyIsImh1ZlVucGFja0VuY1RhYmxlIiwiaW5EYXRhVmlldyIsIm5pIiwiaW0iLCJpTSIsInZhbHVlIiwiemVydW4iLCJodWZMZW5ndGgiLCJjb2RlIiwiaHVmQ29kZSIsImh1ZkJ1aWxkRGVjVGFibGUiLCJoZGVjb2QiLCJwbCIsInBsT2Zmc2V0IiwiZ2V0Q2hhclJldHVybiIsImdldENoYXIiLCJnZXRDb2RlUmV0dXJuIiwiZ2V0Q29kZSIsInBvIiwicmxjIiwib3V0QnVmZmVyIiwib3V0QnVmZmVyT2Zmc2V0Iiwib3V0QnVmZmVyRW5kT2Zmc2V0IiwiY3MiLCJVaW50OEFycmF5IiwicyIsIlVJbnQxNiIsIkludDE2IiwicmVmIiwid2RlYzE0UmV0dXJuIiwiYSIsImIiLCJ3ZGVjMTQiLCJoIiwibHMiLCJocyIsImhpIiwiYWkiLCJhcyIsImJzIiwid2RlYzE2IiwibSIsImQiLCJiYiIsImFhIiwid2F2MkRlY29kZSIsImJ1ZmZlcjIiLCJqIiwibngiLCJveCIsIm55Iiwib3kiLCJteCIsIncxNCIsInAyIiwicHkiLCJleSIsIm95MSIsIm95MiIsIm94MSIsIm94MiIsImkwMCIsImkwMSIsImkxMCIsImkxMSIsInB4IiwiZXgiLCJwMDEiLCJwMTAiLCJwMTEiLCJodWZEZWNvZGUiLCJlbmNvZGluZ1RhYmxlIiwiZGVjb2RpbmdUYWJsZSIsIm5vIiwib3V0T2Zmc2V0IiwiaW5PZmZzZXRFbmQiLCJ0cnVuYyIsImluZGV4IiwiaHVmVW5jb21wcmVzcyIsIm5Db21wcmVzc2VkIiwiblJhdyIsImluaXRpYWxJbk9mZnNldCIsInBhcnNlVWludDMyIiwiZnJlcSIsImFwcGx5THV0IiwiZGF0YSIsIm5EYXRhIiwicHJlZGljdG9yIiwic291cmNlIiwidCIsImxlbmd0aCIsImludGVybGVhdmVTY2FsYXIiLCJvdXQiLCJ0MSIsInQyIiwiZmxvb3IiLCJzdG9wIiwiZGVjb2RlUnVuTGVuZ3RoIiwic2l6ZSIsImJ5dGVMZW5ndGgiLCJyZWFkZXIiLCJEYXRhVmlldyIsImdldEludDgiLCJjb3VudCIsInB1c2giLCJnZXRVaW50OCIsImxvc3N5RGN0RGVjb2RlIiwiY3NjU2V0Iiwicm93UHRycyIsImNoYW5uZWxEYXRhIiwiYWNCdWZmZXIiLCJkY0J1ZmZlciIsImRhdGFWaWV3Iiwid2lkdGgiLCJpZHgiLCJoZWlnaHQiLCJudW1Db21wIiwibnVtRnVsbEJsb2Nrc1giLCJudW1CbG9ja3NYIiwiY2VpbCIsIm51bUJsb2Nrc1kiLCJsZWZ0b3ZlclgiLCJsZWZ0b3ZlclkiLCJjdXJyQWNDb21wIiwiY3VyckRjQ29tcCIsImRjdERhdGEiLCJoYWxmWmlnQmxvY2siLCJyb3dCbG9jayIsInJvd09mZnNldHMiLCJjb21wMiIsIkZsb2F0MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiYmxvY2t5IiwibWF4WSIsIm1heFgiLCJibG9ja3giLCJmaWxsIiwidW5SbGVBQyIsInVuWmlnWmFnIiwiZGN0SW52ZXJzZSIsImNzYzcwOUludmVyc2UiLCJjb252ZXJ0VG9IYWxmIiwib2Zmc2V0MiIsInR5cGUyIiwieTIiLCJzcmMiLCJzZXRVaW50MTYiLCJvZmZzZXQzIiwieDIiLCJoYWxmUm93IiwiY29tcCIsImRlY29kZWQiLCJ5IiwieCIsImdldFVpbnQxNiIsInNldEZsb2F0MzIiLCJkZWNvZGVGbG9hdDE2IiwiYWNWYWx1ZSIsImRjdENvbXAiLCJkc3QiLCJjb3MiLCJlIiwiZiIsImciLCJhbHBoYSIsImJldGEiLCJ0aGV0YSIsImdhbW1hIiwicm93Iiwicm93UHRyIiwiY29sdW1uIiwiY2IiLCJjciIsInRvSGFsZkZsb2F0IiwidG9MaW5lYXIiLCJmbG9hdCIsInNpZ24iLCJhYnMiLCJ1bmNvbXByZXNzUkFXIiwiaW5mbyIsImFycmF5Iiwib2Zmc2V0IiwidW5jb21wcmVzc1JMRSIsImNvbXByZXNzZWQiLCJ2aWV3ZXIiLCJzbGljZSIsInJhd0J1ZmZlciIsInRtcEJ1ZmZlciIsInVuY29tcHJlc3NaSVAiLCJ1bmNvbXByZXNzUElaIiwic2NhbmxpbmVCbG9ja1NpemUiLCJjaGFubmVscyIsIm91dEJ1ZmZlckVuZCIsInBpekNoYW5uZWxEYXRhIiwibGluZXMiLCJtaW5Ob25aZXJvIiwicGFyc2VVaW50MTYiLCJtYXhOb25aZXJvIiwicGFyc2VVaW50OCIsIm1heFZhbHVlIiwiY2QiLCJzdGFydCIsInRtcE9mZnNldDIiLCJjcCIsImVuZCIsInNldCIsInVuY29tcHJlc3NQWFIiLCJzeiIsIlVpbnQzMkFycmF5IiwidG1wQnVmZmVyRW5kIiwid3JpdGVQdHIiLCJwdHIiLCJwaXhlbCIsImRpZmYiLCJ1bmNvbXByZXNzRFdBIiwiZHdhSGVhZGVyIiwidmVyc2lvbiIsInBhcnNlSW50NjQiLCJ1bmtub3duVW5jb21wcmVzc2VkU2l6ZSIsInVua25vd25Db21wcmVzc2VkU2l6ZSIsImFjQ29tcHJlc3NlZFNpemUiLCJkY0NvbXByZXNzZWRTaXplIiwicmxlQ29tcHJlc3NlZFNpemUiLCJybGVVbmNvbXByZXNzZWRTaXplIiwicmxlUmF3U2l6ZSIsInRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCIsInRvdGFsRGNVbmNvbXByZXNzZWRDb3VudCIsImFjQ29tcHJlc3Npb24iLCJFWFJIZWFkZXIiLCJjb21wcmVzc2lvbiIsImNoYW5uZWxSdWxlcyIsInJ1bGVTaXplIiwibmFtZSIsInBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmciLCJjc2MiLCJJbnQ4QXJyYXkiLCJjaGFubmVsIiwicGl4ZWxUeXBlIiwicExpbmVhciIsInJ1bGUiLCJ6bGliSW5mbyIsInJsZUJ1ZmZlciIsImNoYW4iLCJybGVPZmZzZXQiLCJyb3dPZmZzZXRCeXRlcyIsImJ5dGUiLCJ1aW50QnVmZmVyIiwiZW5kT2Zmc2V0Iiwic3RyaW5nVmFsdWUiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInBhcnNlRml4ZWRMZW5ndGhTdHJpbmciLCJwYXJzZVJhdGlvbmFsIiwicGFyc2VJbnQzMiIsInBhcnNlVGltZWNvZGUiLCJJbnQzMiIsImdldEludDMyIiwiVWludDMyIiwiZ2V0VWludDMyIiwiVWludDgiLCJpbnQiLCJwcm90b3R5cGUiLCJOdW1iZXIiLCJnZXRCaWdJbnQ2NCIsInBhcnNlRmxvYXQzMiIsImdldEZsb2F0MzIiLCJkZWNvZGVGbG9hdDMyIiwiYmluYXJ5IiwiZXhwb25lbnQiLCJmcmFjdGlvbiIsIk5hTiIsIkluZmluaXR5IiwiVWludDE2IiwicGFyc2VGbG9hdDE2IiwicGFyc2VDaGxpc3QiLCJzdGFydE9mZnNldCIsInhTYW1wbGluZyIsInlTYW1wbGluZyIsInBhcnNlQ2hyb21hdGljaXRpZXMiLCJyZWRYIiwicmVkWSIsImdyZWVuWCIsImdyZWVuWSIsImJsdWVYIiwiYmx1ZVkiLCJ3aGl0ZVgiLCJ3aGl0ZVkiLCJwYXJzZUNvbXByZXNzaW9uIiwiY29tcHJlc3Npb25Db2RlcyIsInBhcnNlQm94MmkiLCJ4TWluIiwieU1pbiIsInhNYXgiLCJ5TWF4IiwicGFyc2VMaW5lT3JkZXIiLCJsaW5lT3JkZXJzIiwibGluZU9yZGVyIiwicGFyc2VWMmYiLCJwYXJzZVYzZiIsInoiLCJwYXJzZVZhbHVlIiwicGFyc2VIZWFkZXIiLCJFWFJIZWFkZXIyIiwic3BlYyIsInNpbmdsZVRpbGUiLCJsb25nTmFtZSIsImRlZXBGb3JtYXQiLCJtdWx0aVBhcnQiLCJrZWVwUmVhZGluZyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVUeXBlIiwiYXR0cmlidXRlU2l6ZSIsImF0dHJpYnV0ZVZhbHVlIiwiY29uc29sZSIsIndhcm4iLCJlcnJvciIsInNldHVwRGVjb2RlciIsIm91dHB1dFR5cGUiLCJFWFJEZWNvZGVyMiIsImRhdGFXaW5kb3ciLCJieXRlc1BlckxpbmUiLCJpbnB1dFNpemUiLCJ1bmNvbXByZXNzIiwiZ2V0dGVyIiwiZm9ybWF0IiwiYmxvY2tDb3VudCIsIm91dHB1dENoYW5uZWxzIiwiYnl0ZUFycmF5IiwiY29sb3JTcGFjZSIsImVuY29kaW5nIiwiYnVmZmVyRGF0YVZpZXciLCJ1SW50OEFycmF5IiwiRVhSRGVjb2RlciIsInRtcE9mZnNldCIsImNoYW5uZWxPZmZzZXRzIiwiUiIsIkciLCJCIiwiQSIsIlkiLCJzY2FubGluZUJsb2NrSWR4IiwibGluZSIsImlzQ29tcHJlc3NlZCIsImxpbmVfeSIsInRydWVfeSIsImNoYW5uZWxJRCIsImNPZmYiLCJvdXRJbmRleCIsImhlYWRlciIsInNldERhdGFUeXBlIiwibG9hZCIsInVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwib25Mb2FkQ2FsbGJhY2siLCJ0ZXh0dXJlIiwidGV4RGF0YSIsIm1pbkZpbHRlciIsIm1hZ0ZpbHRlciIsImdlbmVyYXRlTWlwbWFwcyIsImZsaXBZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\n\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.dracoLoader = null;\n        this.ktx2Loader = null;\n        this.meshoptDecoder = null;\n        this.pluginCallbacks = [];\n        this.register(function(parser) {\n            return new GLTFMaterialsClearcoatExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureBasisUExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureWebPExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureAVIFExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSheenExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsTransmissionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsVolumeExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIorExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsEmissiveStrengthExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSpecularExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIridescenceExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsAnisotropyExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFLightsExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshoptCompression(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshGpuInstancing(parser);\n        });\n    }\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        let resourcePath;\n        if (this.resourcePath !== \"\") {\n            resourcePath = this.resourcePath;\n        } else if (this.path !== \"\") {\n            resourcePath = this.path;\n        } else {\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n        }\n        this.manager.itemStart(url);\n        const _onError = function(e) {\n            if (onError) {\n                onError(e);\n            } else {\n                console.error(e);\n            }\n            scope.manager.itemError(url);\n            scope.manager.itemEnd(url);\n        };\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, function(data) {\n            try {\n                scope.parse(data, resourcePath, function(gltf) {\n                    onLoad(gltf);\n                    scope.manager.itemEnd(url);\n                }, _onError);\n            } catch (e) {\n                _onError(e);\n            }\n        }, onProgress, _onError);\n    }\n    setDRACOLoader(dracoLoader) {\n        this.dracoLoader = dracoLoader;\n        return this;\n    }\n    setDDSLoader() {\n        throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n    }\n    setKTX2Loader(ktx2Loader) {\n        this.ktx2Loader = ktx2Loader;\n        return this;\n    }\n    setMeshoptDecoder(meshoptDecoder) {\n        this.meshoptDecoder = meshoptDecoder;\n        return this;\n    }\n    register(callback) {\n        if (this.pluginCallbacks.indexOf(callback) === -1) {\n            this.pluginCallbacks.push(callback);\n        }\n        return this;\n    }\n    unregister(callback) {\n        if (this.pluginCallbacks.indexOf(callback) !== -1) {\n            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n        }\n        return this;\n    }\n    parse(data, path, onLoad, onError) {\n        let json;\n        const extensions = {};\n        const plugins = {};\n        if (typeof data === \"string\") {\n            json = JSON.parse(data);\n        } else if (data instanceof ArrayBuffer) {\n            const magic = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4)));\n            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n                try {\n                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n                } catch (error) {\n                    if (onError) onError(error);\n                    return;\n                }\n                json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n            } else {\n                json = JSON.parse(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data)));\n            }\n        } else {\n            json = data;\n        }\n        if (json.asset === void 0 || json.asset.version[0] < 2) {\n            if (onError) onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n            return;\n        }\n        const parser = new GLTFParser(json, {\n            path: path || this.resourcePath || \"\",\n            crossOrigin: this.crossOrigin,\n            requestHeader: this.requestHeader,\n            manager: this.manager,\n            ktx2Loader: this.ktx2Loader,\n            meshoptDecoder: this.meshoptDecoder\n        });\n        parser.fileLoader.setRequestHeader(this.requestHeader);\n        for(let i = 0; i < this.pluginCallbacks.length; i++){\n            const plugin = this.pluginCallbacks[i](parser);\n            plugins[plugin.name] = plugin;\n            extensions[plugin.name] = true;\n        }\n        if (json.extensionsUsed) {\n            for(let i = 0; i < json.extensionsUsed.length; ++i){\n                const extensionName = json.extensionsUsed[i];\n                const extensionsRequired = json.extensionsRequired || [];\n                switch(extensionName){\n                    case EXTENSIONS.KHR_MATERIALS_UNLIT:\n                        extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n                        break;\n                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n                        break;\n                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n                        extensions[extensionName] = new GLTFTextureTransformExtension();\n                        break;\n                    case EXTENSIONS.KHR_MESH_QUANTIZATION:\n                        extensions[extensionName] = new GLTFMeshQuantizationExtension();\n                        break;\n                    default:\n                        if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n                            console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n                        }\n                }\n            }\n        }\n        parser.setExtensions(extensions);\n        parser.setPlugins(plugins);\n        parser.parse(onLoad, onError);\n    }\n    parseAsync(data, path) {\n        const scope = this;\n        return new Promise(function(resolve, reject) {\n            scope.parse(data, path, resolve, reject);\n        });\n    }\n}\nfunction GLTFRegistry() {\n    let objects = {};\n    return {\n        get: function(key) {\n            return objects[key];\n        },\n        add: function(key, object) {\n            objects[key] = object;\n        },\n        remove: function(key) {\n            delete objects[key];\n        },\n        removeAll: function() {\n            objects = {};\n        }\n    };\n}\nconst EXTENSIONS = {\n    KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n    KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n    KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n    KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n    KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n    KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n    KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n    KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n    KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n    KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n    KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n    KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n    KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n    KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n    KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n    KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n    EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n    EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n    EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n    EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n        this.cache = {\n            refs: {},\n            uses: {}\n        };\n    }\n    _markDefs() {\n        const parser = this.parser;\n        const nodeDefs = this.parser.json.nodes || [];\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n            }\n        }\n    }\n    _loadLight(lightIndex) {\n        const parser = this.parser;\n        const cacheKey = \"light:\" + lightIndex;\n        let dependency = parser.cache.get(cacheKey);\n        if (dependency) return dependency;\n        const json = parser.json;\n        const extensions = json.extensions && json.extensions[this.name] || {};\n        const lightDefs = extensions.lights || [];\n        const lightDef = lightDefs[lightIndex];\n        let lightNode;\n        const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        if (lightDef.color !== void 0) color.fromArray(lightDef.color);\n        const range = lightDef.range !== void 0 ? lightDef.range : 0;\n        switch(lightDef.type){\n            case \"directional\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            case \"point\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n                lightNode.distance = range;\n                break;\n            case \"spot\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n                lightNode.distance = range;\n                lightDef.spot = lightDef.spot || {};\n                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n                lightNode.angle = lightDef.spot.outerConeAngle;\n                lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            default:\n                throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n        }\n        lightNode.position.set(0, 0, 0);\n        lightNode.decay = 2;\n        assignExtrasToUserData(lightNode, lightDef);\n        if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;\n        lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n        dependency = Promise.resolve(lightNode);\n        parser.cache.add(cacheKey, dependency);\n        return dependency;\n    }\n    getDependency(type, index) {\n        if (type !== \"light\") return;\n        return this._loadLight(index);\n    }\n    createNodeAttachment(nodeIndex) {\n        const self2 = this;\n        const parser = this.parser;\n        const json = parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n        const lightIndex = lightDef.light;\n        if (lightIndex === void 0) return null;\n        return this._loadLight(lightIndex).then(function(light) {\n            return parser._getNodeRef(self2.cache, lightIndex, light);\n        });\n    }\n}\nclass GLTFMaterialsUnlitExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n    }\n    extendParams(materialParams, materialDef, parser) {\n        const pending = [];\n        materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n        materialParams.opacity = 1;\n        const metallicRoughness = materialDef.pbrMetallicRoughness;\n        if (metallicRoughness) {\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.fromArray(array);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n        if (emissiveStrength !== void 0) {\n            materialParams.emissiveIntensity = emissiveStrength;\n        }\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsClearcoatExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.clearcoatFactor !== void 0) {\n            materialParams.clearcoat = extension.clearcoatFactor;\n        }\n        if (extension.clearcoatTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n        }\n        if (extension.clearcoatRoughnessFactor !== void 0) {\n            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n        }\n        if (extension.clearcoatRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n        }\n        if (extension.clearcoatNormalTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n            if (extension.clearcoatNormalTexture.scale !== void 0) {\n                const scale = extension.clearcoatNormalTexture.scale;\n                materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIridescenceExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.iridescenceFactor !== void 0) {\n            materialParams.iridescence = extension.iridescenceFactor;\n        }\n        if (extension.iridescenceTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n        }\n        if (extension.iridescenceIor !== void 0) {\n            materialParams.iridescenceIOR = extension.iridescenceIor;\n        }\n        if (materialParams.iridescenceThicknessRange === void 0) {\n            materialParams.iridescenceThicknessRange = [\n                100,\n                400\n            ];\n        }\n        if (extension.iridescenceThicknessMinimum !== void 0) {\n            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n        }\n        if (extension.iridescenceThicknessMaximum !== void 0) {\n            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n        }\n        if (extension.iridescenceThicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsSheenExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n        materialParams.sheenRoughness = 0;\n        materialParams.sheen = 1;\n        const extension = materialDef.extensions[this.name];\n        if (extension.sheenColorFactor !== void 0) {\n            materialParams.sheenColor.fromArray(extension.sheenColorFactor);\n        }\n        if (extension.sheenRoughnessFactor !== void 0) {\n            materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n        }\n        if (extension.sheenColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, 3001));\n        }\n        if (extension.sheenRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsTransmissionExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.transmissionFactor !== void 0) {\n            materialParams.transmission = extension.transmissionFactor;\n        }\n        if (extension.transmissionTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsVolumeExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n        if (extension.thicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n        }\n        materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n        const colorArray = extension.attenuationColor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(colorArray[0], colorArray[1], colorArray[2]);\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIorExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsSpecularExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n        if (extension.specularTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n        }\n        const colorArray = extension.specularColorFactor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(colorArray[0], colorArray[1], colorArray[2]);\n        if (extension.specularColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, 3001));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsAnisotropyExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.anisotropyStrength !== void 0) {\n            materialParams.anisotropy = extension.anisotropyStrength;\n        }\n        if (extension.anisotropyRotation !== void 0) {\n            materialParams.anisotropyRotation = extension.anisotropyRotation;\n        }\n        if (extension.anisotropyTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFTextureBasisUExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n    }\n    loadTexture(textureIndex) {\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[this.name];\n        const loader = parser.options.ktx2Loader;\n        if (!loader) {\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n            } else {\n                return null;\n            }\n        }\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n    }\n}\nclass GLTFTextureWebPExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFTextureAVIFExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFMeshoptCompression {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n        this.parser = parser;\n    }\n    loadBufferView(index) {\n        const json = this.parser.json;\n        const bufferView = json.bufferViews[index];\n        if (bufferView.extensions && bufferView.extensions[this.name]) {\n            const extensionDef = bufferView.extensions[this.name];\n            const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n            const decoder = this.parser.options.meshoptDecoder;\n            if (!decoder || !decoder.supported) {\n                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                    throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n                } else {\n                    return null;\n                }\n            }\n            return buffer.then(function(res) {\n                const byteOffset = extensionDef.byteOffset || 0;\n                const byteLength = extensionDef.byteLength || 0;\n                const count = extensionDef.count;\n                const stride = extensionDef.byteStride;\n                const source = new Uint8Array(res, byteOffset, byteLength);\n                if (decoder.decodeGltfBufferAsync) {\n                    return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n                        return res2.buffer;\n                    });\n                } else {\n                    return decoder.ready.then(function() {\n                        const result = new ArrayBuffer(count * stride);\n                        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n                        return result;\n                    });\n                }\n            });\n        } else {\n            return null;\n        }\n    }\n}\nclass GLTFMeshGpuInstancing {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n        this.parser = parser;\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n            return null;\n        }\n        const meshDef = json.meshes[nodeDef.mesh];\n        for (const primitive of meshDef.primitives){\n            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n                return null;\n            }\n        }\n        const extensionDef = nodeDef.extensions[this.name];\n        const attributesDef = extensionDef.attributes;\n        const pending = [];\n        const attributes = {};\n        for(const key in attributesDef){\n            pending.push(this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor)=>{\n                attributes[key] = accessor;\n                return attributes[key];\n            }));\n        }\n        if (pending.length < 1) {\n            return null;\n        }\n        pending.push(this.parser.createNodeMesh(nodeIndex));\n        return Promise.all(pending).then((results)=>{\n            const nodeObject = results.pop();\n            const meshes = nodeObject.isGroup ? nodeObject.children : [\n                nodeObject\n            ];\n            const count = results[0].count;\n            const instancedMeshes = [];\n            for (const mesh of meshes){\n                const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n                const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n                const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n                for(let i = 0; i < count; i++){\n                    if (attributes.TRANSLATION) {\n                        p.fromBufferAttribute(attributes.TRANSLATION, i);\n                    }\n                    if (attributes.ROTATION) {\n                        q.fromBufferAttribute(attributes.ROTATION, i);\n                    }\n                    if (attributes.SCALE) {\n                        s.fromBufferAttribute(attributes.SCALE, i);\n                    }\n                    instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n                }\n                for(const attributeName in attributes){\n                    if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n                        mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n                    }\n                }\n                three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n                this.parser.assignFinalMaterial(instancedMesh);\n                instancedMeshes.push(instancedMesh);\n            }\n            if (nodeObject.isGroup) {\n                nodeObject.clear();\n                nodeObject.add(...instancedMeshes);\n                return nodeObject;\n            }\n            return instancedMeshes[0];\n        });\n    }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 1313821514,\n    BIN: 5130562\n};\nclass GLTFBinaryExtension {\n    constructor(data){\n        this.name = EXTENSIONS.KHR_BINARY_GLTF;\n        this.content = null;\n        this.body = null;\n        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n        this.header = {\n            magic: three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n            version: headerView.getUint32(4, true),\n            length: headerView.getUint32(8, true)\n        };\n        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n            throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n        } else if (this.header.version < 2) {\n            throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n        }\n        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n        let chunkIndex = 0;\n        while(chunkIndex < chunkContentsLength){\n            const chunkLength = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            const chunkType = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n                const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n                this.content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(contentArray);\n            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n                const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n                this.body = data.slice(byteOffset, byteOffset + chunkLength);\n            }\n            chunkIndex += chunkLength;\n        }\n        if (this.content === null) {\n            throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n        }\n    }\n}\nclass GLTFDracoMeshCompressionExtension {\n    constructor(json, dracoLoader){\n        if (!dracoLoader) {\n            throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n        }\n        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n        this.json = json;\n        this.dracoLoader = dracoLoader;\n        this.dracoLoader.preload();\n    }\n    decodePrimitive(primitive, parser) {\n        const json = this.json;\n        const dracoLoader = this.dracoLoader;\n        const bufferViewIndex = primitive.extensions[this.name].bufferView;\n        const gltfAttributeMap = primitive.extensions[this.name].attributes;\n        const threeAttributeMap = {};\n        const attributeNormalizedMap = {};\n        const attributeTypeMap = {};\n        for(const attributeName in gltfAttributeMap){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n        }\n        for(const attributeName in primitive.attributes){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            if (gltfAttributeMap[attributeName] !== void 0) {\n                const accessorDef = json.accessors[primitive.attributes[attributeName]];\n                const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n                attributeTypeMap[threeAttributeName] = componentType.name;\n                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n            }\n        }\n        return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n            return new Promise(function(resolve) {\n                dracoLoader.decodeDracoFile(bufferView, function(geometry) {\n                    for(const attributeName in geometry.attributes){\n                        const attribute = geometry.attributes[attributeName];\n                        const normalized = attributeNormalizedMap[attributeName];\n                        if (normalized !== void 0) attribute.normalized = normalized;\n                    }\n                    resolve(geometry);\n                }, threeAttributeMap, attributeTypeMap);\n            });\n        });\n    }\n}\nclass GLTFTextureTransformExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n    }\n    extendTexture(texture, transform) {\n        if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n            return texture;\n        }\n        texture = texture.clone();\n        if (transform.texCoord !== void 0) {\n            texture.channel = transform.texCoord;\n        }\n        if (transform.offset !== void 0) {\n            texture.offset.fromArray(transform.offset);\n        }\n        if (transform.rotation !== void 0) {\n            texture.rotation = transform.rotation;\n        }\n        if (transform.scale !== void 0) {\n            texture.repeat.fromArray(transform.scale);\n        }\n        texture.needsUpdate = true;\n        return texture;\n    }\n}\nclass GLTFMeshQuantizationExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n    }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){\n        super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    }\n    copySampleValue_(index) {\n        const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n        for(let i = 0; i !== valueSize; i++){\n            result[i] = values[offset + i];\n        }\n        return result;\n    }\n    interpolate_(i1, t0, t, t1) {\n        const result = this.resultBuffer;\n        const values = this.sampleValues;\n        const stride = this.valueSize;\n        const stride2 = stride * 2;\n        const stride3 = stride * 3;\n        const td = t1 - t0;\n        const p = (t - t0) / td;\n        const pp = p * p;\n        const ppp = pp * p;\n        const offset1 = i1 * stride3;\n        const offset0 = offset1 - stride3;\n        const s2 = -2 * ppp + 3 * pp;\n        const s3 = ppp - pp;\n        const s0 = 1 - s2;\n        const s1 = s3 - pp + p;\n        for(let i = 0; i !== stride; i++){\n            const p0 = values[offset0 + i + stride];\n            const m0 = values[offset0 + i + stride2] * td;\n            const p1 = values[offset1 + i + stride];\n            const m1 = values[offset1 + i] * td;\n            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n        }\n        return result;\n    }\n}\nconst _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n    interpolate_(i1, t0, t, t1) {\n        const result = super.interpolate_(i1, t0, t, t1);\n        _q.fromArray(result).normalize().toArray(result);\n        return result;\n    }\n}\nconst WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n    9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n    9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n    9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n    9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n    9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n    9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n    33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n    33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n    10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst ATTRIBUTES = {\n    POSITION: \"position\",\n    NORMAL: \"normal\",\n    TANGENT: \"tangent\",\n    // uv => uv1, 4 uv channels\n    // https://github.com/mrdoob/three.js/pull/25943\n    // https://github.com/mrdoob/three.js/pull/25788\n    ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__.version >= 152 ? {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv1\",\n        TEXCOORD_2: \"uv2\",\n        TEXCOORD_3: \"uv3\"\n    } : {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv2\"\n    },\n    COLOR_0: \"color\",\n    WEIGHTS_0: \"skinWeight\",\n    JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n    scale: \"scale\",\n    translation: \"position\",\n    rotation: \"quaternion\",\n    weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n    CUBICSPLINE: void 0,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n    STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n    OPAQUE: \"OPAQUE\",\n    MASK: \"MASK\",\n    BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n    if (cache[\"DefaultMaterial\"] === void 0) {\n        cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: 16777215,\n            emissive: 0,\n            metalness: 1,\n            roughness: 1,\n            transparent: false,\n            depthTest: true,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n        });\n    }\n    return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    for(const name in objectDef.extensions){\n        if (knownExtensions[name] === void 0) {\n            object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n            object.userData.gltfExtensions[name] = objectDef.extensions[name];\n        }\n    }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== void 0) {\n        if (typeof gltfDef.extras === \"object\") {\n            Object.assign(object.userData, gltfDef.extras);\n        } else {\n            console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n        }\n    }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n    let hasMorphPosition = false;\n    let hasMorphNormal = false;\n    let hasMorphColor = false;\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (target.POSITION !== void 0) hasMorphPosition = true;\n        if (target.NORMAL !== void 0) hasMorphNormal = true;\n        if (target.COLOR_0 !== void 0) hasMorphColor = true;\n        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n    }\n    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n    const pendingPositionAccessors = [];\n    const pendingNormalAccessors = [];\n    const pendingColorAccessors = [];\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (hasMorphPosition) {\n            const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n            pendingPositionAccessors.push(pendingAccessor);\n        }\n        if (hasMorphNormal) {\n            const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n            pendingNormalAccessors.push(pendingAccessor);\n        }\n        if (hasMorphColor) {\n            const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n            pendingColorAccessors.push(pendingAccessor);\n        }\n    }\n    return Promise.all([\n        Promise.all(pendingPositionAccessors),\n        Promise.all(pendingNormalAccessors),\n        Promise.all(pendingColorAccessors)\n    ]).then(function(accessors) {\n        const morphPositions = accessors[0];\n        const morphNormals = accessors[1];\n        const morphColors = accessors[2];\n        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n        if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n        geometry.morphTargetsRelative = true;\n        return geometry;\n    });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n    if (meshDef.weights !== void 0) {\n        for(let i = 0, il = meshDef.weights.length; i < il; i++){\n            mesh.morphTargetInfluences[i] = meshDef.weights[i];\n        }\n    }\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n        const targetNames = meshDef.extras.targetNames;\n        if (mesh.morphTargetInfluences.length === targetNames.length) {\n            mesh.morphTargetDictionary = {};\n            for(let i = 0, il = targetNames.length; i < il; i++){\n                mesh.morphTargetDictionary[targetNames[i]] = i;\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n        }\n    }\n}\nfunction createPrimitiveKey(primitiveDef) {\n    let geometryKey;\n    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    if (dracoExtension) {\n        geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n    } else {\n        geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n    }\n    if (primitiveDef.targets !== void 0) {\n        for(let i = 0, il = primitiveDef.targets.length; i < il; i++){\n            geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n        }\n    }\n    return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n    let attributesKey = \"\";\n    const keys = Object.keys(attributes).sort();\n    for(let i = 0, il = keys.length; i < il; i++){\n        attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n    }\n    return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n    switch(constructor){\n        case Int8Array:\n            return 1 / 127;\n        case Uint8Array:\n            return 1 / 255;\n        case Int16Array:\n            return 1 / 32767;\n        case Uint16Array:\n            return 1 / 65535;\n        default:\n            throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n    }\n}\nfunction getImageURIMimeType(uri) {\n    if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return \"image/jpeg\";\n    if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return \"image/webp\";\n    return \"image/png\";\n}\nconst _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n    constructor(json = {}, options = {}){\n        this.json = json;\n        this.extensions = {};\n        this.plugins = {};\n        this.options = options;\n        this.cache = new GLTFRegistry();\n        this.associations = /* @__PURE__ */ new Map();\n        this.primitiveCache = {};\n        this.nodeCache = {};\n        this.meshCache = {\n            refs: {},\n            uses: {}\n        };\n        this.cameraCache = {\n            refs: {},\n            uses: {}\n        };\n        this.lightCache = {\n            refs: {},\n            uses: {}\n        };\n        this.sourceCache = {};\n        this.textureCache = {};\n        this.nodeNamesUsed = {};\n        let isSafari = false;\n        let isFirefox = false;\n        let firefoxVersion = -1;\n        if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n            isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n        }\n        if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n        } else {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n        }\n        this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n        this.textureLoader.setRequestHeader(this.options.requestHeader);\n        this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n        this.fileLoader.setResponseType(\"arraybuffer\");\n        if (this.options.crossOrigin === \"use-credentials\") {\n            this.fileLoader.setWithCredentials(true);\n        }\n    }\n    setExtensions(extensions) {\n        this.extensions = extensions;\n    }\n    setPlugins(plugins) {\n        this.plugins = plugins;\n    }\n    parse(onLoad, onError) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        this.cache.removeAll();\n        this.nodeCache = {};\n        this._invokeAll(function(ext) {\n            return ext._markDefs && ext._markDefs();\n        });\n        Promise.all(this._invokeAll(function(ext) {\n            return ext.beforeRoot && ext.beforeRoot();\n        })).then(function() {\n            return Promise.all([\n                parser.getDependencies(\"scene\"),\n                parser.getDependencies(\"animation\"),\n                parser.getDependencies(\"camera\")\n            ]);\n        }).then(function(dependencies) {\n            const result = {\n                scene: dependencies[0][json.scene || 0],\n                scenes: dependencies[0],\n                animations: dependencies[1],\n                cameras: dependencies[2],\n                asset: json.asset,\n                parser,\n                userData: {}\n            };\n            addUnknownExtensionsToUserData(extensions, result, json);\n            assignExtrasToUserData(result, json);\n            Promise.all(parser._invokeAll(function(ext) {\n                return ext.afterRoot && ext.afterRoot(result);\n            })).then(function() {\n                onLoad(result);\n            });\n        }).catch(onError);\n    }\n    /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */ _markDefs() {\n        const nodeDefs = this.json.nodes || [];\n        const skinDefs = this.json.skins || [];\n        const meshDefs = this.json.meshes || [];\n        for(let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){\n            const joints = skinDefs[skinIndex].joints;\n            for(let i = 0, il = joints.length; i < il; i++){\n                nodeDefs[joints[i]].isBone = true;\n            }\n        }\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.mesh !== void 0) {\n                this._addNodeRef(this.meshCache, nodeDef.mesh);\n                if (nodeDef.skin !== void 0) {\n                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n                }\n            }\n            if (nodeDef.camera !== void 0) {\n                this._addNodeRef(this.cameraCache, nodeDef.camera);\n            }\n        }\n    }\n    /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */ _addNodeRef(cache, index) {\n        if (index === void 0) return;\n        if (cache.refs[index] === void 0) {\n            cache.refs[index] = cache.uses[index] = 0;\n        }\n        cache.refs[index]++;\n    }\n    /** Returns a reference to a shared resource, cloning it if necessary. */ _getNodeRef(cache, index, object) {\n        if (cache.refs[index] <= 1) return object;\n        const ref = object.clone();\n        const updateMappings = (original, clone)=>{\n            const mappings = this.associations.get(original);\n            if (mappings != null) {\n                this.associations.set(clone, mappings);\n            }\n            for (const [i, child] of original.children.entries()){\n                updateMappings(child, clone.children[i]);\n            }\n        };\n        updateMappings(object, ref);\n        ref.name += \"_instance_\" + cache.uses[index]++;\n        return ref;\n    }\n    _invokeOne(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.push(this);\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) return result;\n        }\n        return null;\n    }\n    _invokeAll(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.unshift(this);\n        const pending = [];\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) pending.push(result);\n        }\n        return pending;\n    }\n    /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */ getDependency(type, index) {\n        const cacheKey = type + \":\" + index;\n        let dependency = this.cache.get(cacheKey);\n        if (!dependency) {\n            switch(type){\n                case \"scene\":\n                    dependency = this.loadScene(index);\n                    break;\n                case \"node\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadNode && ext.loadNode(index);\n                    });\n                    break;\n                case \"mesh\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMesh && ext.loadMesh(index);\n                    });\n                    break;\n                case \"accessor\":\n                    dependency = this.loadAccessor(index);\n                    break;\n                case \"bufferView\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadBufferView && ext.loadBufferView(index);\n                    });\n                    break;\n                case \"buffer\":\n                    dependency = this.loadBuffer(index);\n                    break;\n                case \"material\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMaterial && ext.loadMaterial(index);\n                    });\n                    break;\n                case \"texture\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadTexture && ext.loadTexture(index);\n                    });\n                    break;\n                case \"skin\":\n                    dependency = this.loadSkin(index);\n                    break;\n                case \"animation\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadAnimation && ext.loadAnimation(index);\n                    });\n                    break;\n                case \"camera\":\n                    dependency = this.loadCamera(index);\n                    break;\n                default:\n                    dependency = this._invokeOne(function(ext) {\n                        return ext != this && ext.getDependency && ext.getDependency(type, index);\n                    });\n                    if (!dependency) {\n                        throw new Error(\"Unknown type: \" + type);\n                    }\n                    break;\n            }\n            this.cache.add(cacheKey, dependency);\n        }\n        return dependency;\n    }\n    /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */ getDependencies(type) {\n        let dependencies = this.cache.get(type);\n        if (!dependencies) {\n            const parser = this;\n            const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n            dependencies = Promise.all(defs.map(function(def, index) {\n                return parser.getDependency(type, index);\n            }));\n            this.cache.add(type, dependencies);\n        }\n        return dependencies;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBuffer(bufferIndex) {\n        const bufferDef = this.json.buffers[bufferIndex];\n        const loader = this.fileLoader;\n        if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n            throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n        }\n        if (bufferDef.uri === void 0 && bufferIndex === 0) {\n            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n        }\n        const options = this.options;\n        return new Promise(function(resolve, reject) {\n            loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n                reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n            });\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBufferView(bufferViewIndex) {\n        const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n        return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n            const byteLength = bufferViewDef.byteLength || 0;\n            const byteOffset = bufferViewDef.byteOffset || 0;\n            return buffer.slice(byteOffset, byteOffset + byteLength);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */ loadAccessor(accessorIndex) {\n        const parser = this;\n        const json = this.json;\n        const accessorDef = this.json.accessors[accessorIndex];\n        if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const normalized = accessorDef.normalized === true;\n            const array = new TypedArray(accessorDef.count * itemSize);\n            return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n        }\n        const pendingBufferViews = [];\n        if (accessorDef.bufferView !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n        } else {\n            pendingBufferViews.push(null);\n        }\n        if (accessorDef.sparse !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n        }\n        return Promise.all(pendingBufferViews).then(function(bufferViews) {\n            const bufferView = bufferViews[0];\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n            const itemBytes = elementBytes * itemSize;\n            const byteOffset = accessorDef.byteOffset || 0;\n            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n            const normalized = accessorDef.normalized === true;\n            let array, bufferAttribute;\n            if (byteStride && byteStride !== itemBytes) {\n                const ibSlice = Math.floor(byteOffset / byteStride);\n                const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n                let ib = parser.cache.get(ibCacheKey);\n                if (!ib) {\n                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n                    ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n                    parser.cache.add(ibCacheKey, ib);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n            } else {\n                if (bufferView === null) {\n                    array = new TypedArray(accessorDef.count * itemSize);\n                } else {\n                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n            }\n            if (accessorDef.sparse !== void 0) {\n                const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n                const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n                const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n                const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n                const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n                const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n                if (bufferView !== null) {\n                    bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n                }\n                for(let i = 0, il = sparseIndices.length; i < il; i++){\n                    const index = sparseIndices[i];\n                    bufferAttribute.setX(index, sparseValues[i * itemSize]);\n                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n                    if (itemSize >= 5) throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n                }\n            }\n            return bufferAttribute;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */ loadTexture(textureIndex) {\n        const json = this.json;\n        const options = this.options;\n        const textureDef = json.textures[textureIndex];\n        const sourceIndex = textureDef.source;\n        const sourceDef = json.images[sourceIndex];\n        let loader = this.textureLoader;\n        if (sourceDef.uri) {\n            const handler = options.manager.getHandler(sourceDef.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.loadTextureImage(textureIndex, sourceIndex, loader);\n    }\n    loadTextureImage(textureIndex, sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const textureDef = json.textures[textureIndex];\n        const sourceDef = json.images[sourceIndex];\n        const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n        if (this.textureCache[cacheKey]) {\n            return this.textureCache[cacheKey];\n        }\n        const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n            texture.flipY = false;\n            texture.name = textureDef.name || sourceDef.name || \"\";\n            if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n                texture.name = sourceDef.uri;\n            }\n            const samplers = json.samplers || {};\n            const sampler = samplers[textureDef.sampler] || {};\n            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            parser.associations.set(texture, {\n                textures: textureIndex\n            });\n            return texture;\n        }).catch(function() {\n            return null;\n        });\n        this.textureCache[cacheKey] = promise;\n        return promise;\n    }\n    loadImageSource(sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const options = this.options;\n        if (this.sourceCache[sourceIndex] !== void 0) {\n            return this.sourceCache[sourceIndex].then((texture)=>texture.clone());\n        }\n        const sourceDef = json.images[sourceIndex];\n        const URL = self.URL || self.webkitURL;\n        let sourceURI = sourceDef.uri || \"\";\n        let isObjectURL = false;\n        if (sourceDef.bufferView !== void 0) {\n            sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n                isObjectURL = true;\n                const blob = new Blob([\n                    bufferView\n                ], {\n                    type: sourceDef.mimeType\n                });\n                sourceURI = URL.createObjectURL(blob);\n                return sourceURI;\n            });\n        } else if (sourceDef.uri === void 0) {\n            throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n        }\n        const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n            return new Promise(function(resolve, reject) {\n                let onLoad = resolve;\n                if (loader.isImageBitmapLoader === true) {\n                    onLoad = function(imageBitmap) {\n                        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n                        texture.needsUpdate = true;\n                        resolve(texture);\n                    };\n                }\n                loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n            });\n        }).then(function(texture) {\n            if (isObjectURL === true) {\n                URL.revokeObjectURL(sourceURI);\n            }\n            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n            return texture;\n        }).catch(function(error) {\n            console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n            throw error;\n        });\n        this.sourceCache[sourceIndex] = promise;\n        return promise;\n    }\n    /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */ assignTexture(materialParams, mapName, mapDef, encoding) {\n        const parser = this;\n        return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n            if (!texture) return null;\n            if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n                texture = texture.clone();\n                texture.channel = mapDef.texCoord;\n            }\n            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n                const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n                if (transform) {\n                    const gltfReference = parser.associations.get(texture);\n                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n                    parser.associations.set(texture, gltfReference);\n                }\n            }\n            if (encoding !== void 0) {\n                if (\"colorSpace\" in texture) texture.colorSpace = encoding === 3001 ? \"srgb\" : \"srgb-linear\";\n                else texture.encoding = encoding;\n            }\n            materialParams[mapName] = texture;\n            return texture;\n        });\n    }\n    /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */ assignFinalMaterial(mesh) {\n        const geometry = mesh.geometry;\n        let material = mesh.material;\n        const useDerivativeTangents = geometry.attributes.tangent === void 0;\n        const useVertexColors = geometry.attributes.color !== void 0;\n        const useFlatShading = geometry.attributes.normal === void 0;\n        if (mesh.isPoints) {\n            const cacheKey = \"PointsMaterial:\" + material.uuid;\n            let pointsMaterial = this.cache.get(cacheKey);\n            if (!pointsMaterial) {\n                pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n                pointsMaterial.color.copy(material.color);\n                pointsMaterial.map = material.map;\n                pointsMaterial.sizeAttenuation = false;\n                this.cache.add(cacheKey, pointsMaterial);\n            }\n            material = pointsMaterial;\n        } else if (mesh.isLine) {\n            const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n            let lineMaterial = this.cache.get(cacheKey);\n            if (!lineMaterial) {\n                lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n                lineMaterial.color.copy(material.color);\n                lineMaterial.map = material.map;\n                this.cache.add(cacheKey, lineMaterial);\n            }\n            material = lineMaterial;\n        }\n        if (useDerivativeTangents || useVertexColors || useFlatShading) {\n            let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n            if (useDerivativeTangents) cacheKey += \"derivative-tangents:\";\n            if (useVertexColors) cacheKey += \"vertex-colors:\";\n            if (useFlatShading) cacheKey += \"flat-shading:\";\n            let cachedMaterial = this.cache.get(cacheKey);\n            if (!cachedMaterial) {\n                cachedMaterial = material.clone();\n                if (useVertexColors) cachedMaterial.vertexColors = true;\n                if (useFlatShading) cachedMaterial.flatShading = true;\n                if (useDerivativeTangents) {\n                    if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n                    if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n                }\n                this.cache.add(cacheKey, cachedMaterial);\n                this.associations.set(cachedMaterial, this.associations.get(material));\n            }\n            material = cachedMaterial;\n        }\n        mesh.material = material;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */ loadMaterial(materialIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const materialDef = json.materials[materialIndex];\n        let materialType;\n        const materialParams = {};\n        const materialExtensions = materialDef.extensions || {};\n        const pending = [];\n        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n            materialType = kmuExtension.getMaterialType();\n            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n        } else {\n            const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n            materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            materialParams.opacity = 1;\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.fromArray(array);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n            }\n            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n            if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n                pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n            }\n            materialType = this._invokeOne(function(ext) {\n                return ext.getMaterialType && ext.getMaterialType(materialIndex);\n            });\n            pending.push(Promise.all(this._invokeAll(function(ext) {\n                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n            })));\n        }\n        if (materialDef.doubleSided === true) {\n            materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        }\n        const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n        if (alphaMode === ALPHA_MODES.BLEND) {\n            materialParams.transparent = true;\n            materialParams.depthWrite = false;\n        } else {\n            materialParams.transparent = false;\n            if (alphaMode === ALPHA_MODES.MASK) {\n                materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n            }\n        }\n        if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n            materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n            if (materialDef.normalTexture.scale !== void 0) {\n                const scale = materialDef.normalTexture.scale;\n                materialParams.normalScale.set(scale, scale);\n            }\n        }\n        if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n            if (materialDef.occlusionTexture.strength !== void 0) {\n                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n            }\n        }\n        if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(materialDef.emissiveFactor);\n        }\n        if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, 3001));\n        }\n        return Promise.all(pending).then(function() {\n            const material = new materialType(materialParams);\n            if (materialDef.name) material.name = materialDef.name;\n            assignExtrasToUserData(material, materialDef);\n            parser.associations.set(material, {\n                materials: materialIndex\n            });\n            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n            return material;\n        });\n    }\n    /** When Object3D instances are targeted by animation, they need unique names. */ createUniqueName(originalName) {\n        const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n        if (sanitizedName in this.nodeNamesUsed) {\n            return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n        } else {\n            this.nodeNamesUsed[sanitizedName] = 0;\n            return sanitizedName;\n        }\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */ loadGeometries(primitives) {\n        const parser = this;\n        const extensions = this.extensions;\n        const cache = this.primitiveCache;\n        function createDracoPrimitive(primitive) {\n            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n                return addPrimitiveAttributes(geometry, primitive, parser);\n            });\n        }\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const primitive = primitives[i];\n            const cacheKey = createPrimitiveKey(primitive);\n            const cached = cache[cacheKey];\n            if (cached) {\n                pending.push(cached.promise);\n            } else {\n                let geometryPromise;\n                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n                    geometryPromise = createDracoPrimitive(primitive);\n                } else {\n                    geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n                }\n                cache[cacheKey] = {\n                    primitive,\n                    promise: geometryPromise\n                };\n                pending.push(geometryPromise);\n            }\n        }\n        return Promise.all(pending);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */ loadMesh(meshIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const meshDef = json.meshes[meshIndex];\n        const primitives = meshDef.primitives;\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n            pending.push(material);\n        }\n        pending.push(parser.loadGeometries(primitives));\n        return Promise.all(pending).then(function(results) {\n            const materials = results.slice(0, results.length - 1);\n            const geometries = results[results.length - 1];\n            const meshes = [];\n            for(let i = 0, il = geometries.length; i < il; i++){\n                const geometry = geometries[i];\n                const primitive = primitives[i];\n                let mesh;\n                const material = materials[i];\n                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n                    mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n                    if (mesh.isSkinnedMesh === true) {\n                        mesh.normalizeSkinWeights();\n                    }\n                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n                    }\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n                } else {\n                    throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n                }\n                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n                    updateMorphTargets(mesh, meshDef);\n                }\n                mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n                assignExtrasToUserData(mesh, meshDef);\n                if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n                parser.assignFinalMaterial(mesh);\n                meshes.push(mesh);\n            }\n            for(let i = 0, il = meshes.length; i < il; i++){\n                parser.associations.set(meshes[i], {\n                    meshes: meshIndex,\n                    primitives: i\n                });\n            }\n            if (meshes.length === 1) {\n                if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n                return meshes[0];\n            }\n            const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);\n            parser.associations.set(group, {\n                meshes: meshIndex\n            });\n            for(let i = 0, il = meshes.length; i < il; i++){\n                group.add(meshes[i]);\n            }\n            return group;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */ loadCamera(cameraIndex) {\n        let camera;\n        const cameraDef = this.json.cameras[cameraIndex];\n        const params = cameraDef[cameraDef.type];\n        if (!params) {\n            console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n            return;\n        }\n        if (cameraDef.type === \"perspective\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n        } else if (cameraDef.type === \"orthographic\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n        }\n        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n        assignExtrasToUserData(camera, cameraDef);\n        return Promise.resolve(camera);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */ loadSkin(skinIndex) {\n        const skinDef = this.json.skins[skinIndex];\n        const pending = [];\n        for(let i = 0, il = skinDef.joints.length; i < il; i++){\n            pending.push(this._loadNodeShallow(skinDef.joints[i]));\n        }\n        if (skinDef.inverseBindMatrices !== void 0) {\n            pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n        } else {\n            pending.push(null);\n        }\n        return Promise.all(pending).then(function(results) {\n            const inverseBindMatrices = results.pop();\n            const jointNodes = results;\n            const bones = [];\n            const boneInverses = [];\n            for(let i = 0, il = jointNodes.length; i < il; i++){\n                const jointNode = jointNodes[i];\n                if (jointNode) {\n                    bones.push(jointNode);\n                    const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                    if (inverseBindMatrices !== null) {\n                        mat.fromArray(inverseBindMatrices.array, i * 16);\n                    }\n                    boneInverses.push(mat);\n                } else {\n                    console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */ loadAnimation(animationIndex) {\n        const json = this.json;\n        const animationDef = json.animations[animationIndex];\n        const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n        const pendingNodes = [];\n        const pendingInputAccessors = [];\n        const pendingOutputAccessors = [];\n        const pendingSamplers = [];\n        const pendingTargets = [];\n        for(let i = 0, il = animationDef.channels.length; i < il; i++){\n            const channel = animationDef.channels[i];\n            const sampler = animationDef.samplers[channel.sampler];\n            const target = channel.target;\n            const name = target.node;\n            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n            if (target.node === void 0) continue;\n            pendingNodes.push(this.getDependency(\"node\", name));\n            pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n            pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n            pendingSamplers.push(sampler);\n            pendingTargets.push(target);\n        }\n        return Promise.all([\n            Promise.all(pendingNodes),\n            Promise.all(pendingInputAccessors),\n            Promise.all(pendingOutputAccessors),\n            Promise.all(pendingSamplers),\n            Promise.all(pendingTargets)\n        ]).then(function(dependencies) {\n            const nodes = dependencies[0];\n            const inputAccessors = dependencies[1];\n            const outputAccessors = dependencies[2];\n            const samplers = dependencies[3];\n            const targets = dependencies[4];\n            const tracks = [];\n            for(let i = 0, il = nodes.length; i < il; i++){\n                const node = nodes[i];\n                const inputAccessor = inputAccessors[i];\n                const outputAccessor = outputAccessors[i];\n                const sampler = samplers[i];\n                const target = targets[i];\n                if (node === void 0) continue;\n                node.updateMatrix();\n                let TypedKeyframeTrack;\n                switch(PATH_PROPERTIES[target.path]){\n                    case PATH_PROPERTIES.weights:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                        break;\n                    case PATH_PROPERTIES.rotation:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n                        break;\n                    case PATH_PROPERTIES.position:\n                    case PATH_PROPERTIES.scale:\n                    default:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                        break;\n                }\n                const targetName = node.name ? node.name : node.uuid;\n                const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n                const targetNames = [];\n                if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n                    node.traverse(function(object) {\n                        if (object.morphTargetInfluences) {\n                            targetNames.push(object.name ? object.name : object.uuid);\n                        }\n                    });\n                } else {\n                    targetNames.push(targetName);\n                }\n                let outputArray = outputAccessor.array;\n                if (outputAccessor.normalized) {\n                    const scale = getNormalizedComponentScale(outputArray.constructor);\n                    const scaled = new Float32Array(outputArray.length);\n                    for(let j = 0, jl = outputArray.length; j < jl; j++){\n                        scaled[j] = outputArray[j] * scale;\n                    }\n                    outputArray = scaled;\n                }\n                for(let j = 0, jl = targetNames.length; j < jl; j++){\n                    const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n                    if (sampler.interpolation === \"CUBICSPLINE\") {\n                        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n                            const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n                            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n                        };\n                        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n                    }\n                    tracks.push(track);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n        });\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        if (nodeDef.mesh === void 0) return null;\n        return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n            if (nodeDef.weights !== void 0) {\n                node.traverse(function(o) {\n                    if (!o.isMesh) return;\n                    for(let i = 0, il = nodeDef.weights.length; i < il; i++){\n                        o.morphTargetInfluences[i] = nodeDef.weights[i];\n                    }\n                });\n            }\n            return node;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */ loadNode(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        const nodePending = parser._loadNodeShallow(nodeIndex);\n        const childPending = [];\n        const childrenDef = nodeDef.children || [];\n        for(let i = 0, il = childrenDef.length; i < il; i++){\n            childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n        }\n        const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n        return Promise.all([\n            nodePending,\n            Promise.all(childPending),\n            skeletonPending\n        ]).then(function(results) {\n            const node = results[0];\n            const children = results[1];\n            const skeleton = results[2];\n            if (skeleton !== null) {\n                node.traverse(function(mesh) {\n                    if (!mesh.isSkinnedMesh) return;\n                    mesh.bind(skeleton, _identityMatrix);\n                });\n            }\n            for(let i = 0, il = children.length; i < il; i++){\n                node.add(children[i]);\n            }\n            return node;\n        });\n    }\n    // ._loadNodeShallow() parses a single node.\n    // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n    _loadNodeShallow(nodeIndex) {\n        const json = this.json;\n        const extensions = this.extensions;\n        const parser = this;\n        if (this.nodeCache[nodeIndex] !== void 0) {\n            return this.nodeCache[nodeIndex];\n        }\n        const nodeDef = json.nodes[nodeIndex];\n        const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n        const pending = [];\n        const meshPromise = parser._invokeOne(function(ext) {\n            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n        });\n        if (meshPromise) {\n            pending.push(meshPromise);\n        }\n        if (nodeDef.camera !== void 0) {\n            pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n            }));\n        }\n        parser._invokeAll(function(ext) {\n            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n        }).forEach(function(promise) {\n            pending.push(promise);\n        });\n        this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n            let node;\n            if (nodeDef.isBone === true) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n            } else if (objects.length > 1) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            } else if (objects.length === 1) {\n                node = objects[0];\n            } else {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n            }\n            if (node !== objects[0]) {\n                for(let i = 0, il = objects.length; i < il; i++){\n                    node.add(objects[i]);\n                }\n            }\n            if (nodeDef.name) {\n                node.userData.name = nodeDef.name;\n                node.name = nodeName;\n            }\n            assignExtrasToUserData(node, nodeDef);\n            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n            if (nodeDef.matrix !== void 0) {\n                const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                matrix.fromArray(nodeDef.matrix);\n                node.applyMatrix4(matrix);\n            } else {\n                if (nodeDef.translation !== void 0) {\n                    node.position.fromArray(nodeDef.translation);\n                }\n                if (nodeDef.rotation !== void 0) {\n                    node.quaternion.fromArray(nodeDef.rotation);\n                }\n                if (nodeDef.scale !== void 0) {\n                    node.scale.fromArray(nodeDef.scale);\n                }\n            }\n            if (!parser.associations.has(node)) {\n                parser.associations.set(node, {});\n            }\n            parser.associations.get(node).nodes = nodeIndex;\n            return node;\n        });\n        return this.nodeCache[nodeIndex];\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */ loadScene(sceneIndex) {\n        const extensions = this.extensions;\n        const sceneDef = this.json.scenes[sceneIndex];\n        const parser = this;\n        const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n        assignExtrasToUserData(scene, sceneDef);\n        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n        const nodeIds = sceneDef.nodes || [];\n        const pending = [];\n        for(let i = 0, il = nodeIds.length; i < il; i++){\n            pending.push(parser.getDependency(\"node\", nodeIds[i]));\n        }\n        return Promise.all(pending).then(function(nodes) {\n            for(let i = 0, il = nodes.length; i < il; i++){\n                scene.add(nodes[i]);\n            }\n            const reduceAssociations = (node)=>{\n                const reducedAssociations = /* @__PURE__ */ new Map();\n                for (const [key, value] of parser.associations){\n                    if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n                        reducedAssociations.set(key, value);\n                    }\n                }\n                node.traverse((node2)=>{\n                    const mappings = parser.associations.get(node2);\n                    if (mappings != null) {\n                        reducedAssociations.set(node2, mappings);\n                    }\n                });\n                return reducedAssociations;\n            };\n            parser.associations = reduceAssociations(scene);\n            return scene;\n        });\n    }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n    if (attributes.POSITION !== void 0) {\n        const accessor = parser.json.accessors[attributes.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n            box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n            if (accessor.normalized) {\n                const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                box.min.multiplyScalar(boxScale);\n                box.max.multiplyScalar(boxScale);\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n            return;\n        }\n    } else {\n        return;\n    }\n    const targets = primitiveDef.targets;\n    if (targets !== void 0) {\n        const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        for(let i = 0, il = targets.length; i < il; i++){\n            const target = targets[i];\n            if (target.POSITION !== void 0) {\n                const accessor = parser.json.accessors[target.POSITION];\n                const min = accessor.min;\n                const max = accessor.max;\n                if (min !== void 0 && max !== void 0) {\n                    vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n                    vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n                    vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n                    if (accessor.normalized) {\n                        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                        vector.multiplyScalar(boxScale);\n                    }\n                    maxDisplacement.max(vector);\n                } else {\n                    console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n                }\n            }\n        }\n        box.expandByVector(maxDisplacement);\n    }\n    geometry.boundingBox = box;\n    const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const pending = [];\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n        return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n            geometry.setAttribute(attributeName, accessor);\n        });\n    }\n    for(const gltfAttributeName in attributes){\n        const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n        if (threeAttributeName in geometry.attributes) continue;\n        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n    if (primitiveDef.indices !== void 0 && !geometry.index) {\n        const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n            geometry.setIndex(accessor2);\n        });\n        pending.push(accessor);\n    }\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function() {\n        return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n}\n //# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWc4QjtBQUMxM0I7QUFDbEI7QUFDcEQsTUFBTStELG1CQUFtQi9ELHlDQUFNQTtJQUM3QmdFLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsRUFBRTtRQUN6QixJQUFJLENBQUNDLFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUMsZ0NBQWdDRDtRQUM3QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJRSwyQkFBMkJGO1FBQ3hDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlHLHlCQUF5Qkg7UUFDdEM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUkseUJBQXlCSjtRQUN0QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJSyw0QkFBNEJMO1FBQ3pDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlNLG1DQUFtQ047UUFDaEQ7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSU8sNkJBQTZCUDtRQUMxQztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJUSwwQkFBMEJSO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlTLHVD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QUFDLFNBQVN5SCxRQUFRO1lBQzNFWSxTQUFTUyxZQUFZLENBQUNELGVBQWVwQjtRQUN2QztJQUNGO0lBQ0EsSUFBSyxNQUFNc2MscUJBQXFCdmMsV0FBWTtRQUMxQyxNQUFNaUQscUJBQXFCQyxVQUFVLENBQUNxWixrQkFBa0IsSUFBSUEsa0JBQWtCcFosV0FBVztRQUN6RixJQUFJRixzQkFBc0JwQyxTQUFTYixVQUFVLEVBQzNDO1FBQ0ZsSCxRQUFRbEgsSUFBSSxDQUFDMHFCLHdCQUF3QnRjLFVBQVUsQ0FBQ3VjLGtCQUFrQixFQUFFdFo7SUFDdEU7SUFDQSxJQUFJMkksYUFBYUcsT0FBTyxLQUFLLEtBQUssS0FBSyxDQUFDbEwsU0FBU3hJLEtBQUssRUFBRTtRQUN0RCxNQUFNNEgsV0FBV3RSLE9BQU95SixhQUFhLENBQUMsWUFBWXdULGFBQWFHLE9BQU8sRUFBRXZULElBQUksQ0FBQyxTQUFTZ2tCLFNBQVM7WUFDN0YzYixTQUFTNGIsUUFBUSxDQUFDRDtRQUNwQjtRQUNBMWpCLFFBQVFsSCxJQUFJLENBQUNxTztJQUNmO0lBQ0FoSSx1QkFBdUI0SSxVQUFVK0s7SUFDakN5UCxjQUFjeGEsVUFBVStLLGNBQWNqZDtJQUN0QyxPQUFPeUYsUUFBUW9GLEdBQUcsQ0FBQ1YsU0FBU04sSUFBSSxDQUFDO1FBQy9CLE9BQU9vVCxhQUFhcEIsT0FBTyxLQUFLLEtBQUssSUFBSUQsZ0JBQWdCMUosVUFBVStLLGFBQWFwQixPQUFPLEVBQUU3YixVQUFVa1M7SUFDckc7QUFDRjtBQUdFLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JlYXRpdmUtNDA0Ly4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0dMVEZMb2FkZXIuanM/YmZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2FkZXIsIExvYWRlclV0aWxzLCBGaWxlTG9hZGVyLCBDb2xvciwgU3BvdExpZ2h0LCBQb2ludExpZ2h0LCBEaXJlY3Rpb25hbExpZ2h0LCBNZXNoQmFzaWNNYXRlcmlhbCwgTWVzaFBoeXNpY2FsTWF0ZXJpYWwsIFZlY3RvcjIsIE1hdHJpeDQsIFZlY3RvcjMsIFF1YXRlcm5pb24sIEluc3RhbmNlZE1lc2gsIE9iamVjdDNELCBUZXh0dXJlTG9hZGVyLCBJbWFnZUJpdG1hcExvYWRlciwgQnVmZmVyQXR0cmlidXRlLCBJbnRlcmxlYXZlZEJ1ZmZlciwgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsIExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLCBSZXBlYXRXcmFwcGluZywgUG9pbnRzTWF0ZXJpYWwsIE1hdGVyaWFsLCBMaW5lQmFzaWNNYXRlcmlhbCwgTWVzaFN0YW5kYXJkTWF0ZXJpYWwsIERvdWJsZVNpZGUsIFByb3BlcnR5QmluZGluZywgQnVmZmVyR2VvbWV0cnksIFNraW5uZWRNZXNoLCBNZXNoLCBUcmlhbmdsZVN0cmlwRHJhd01vZGUsIFRyaWFuZ2xlRmFuRHJhd01vZGUsIExpbmVTZWdtZW50cywgTGluZSwgTGluZUxvb3AsIFBvaW50cywgR3JvdXAsIFBlcnNwZWN0aXZlQ2FtZXJhLCBNYXRoVXRpbHMsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgU2tlbGV0b24sIEludGVycG9sYXRlTGluZWFyLCBBbmltYXRpb25DbGlwLCBCb25lLCBOZWFyZXN0RmlsdGVyLCBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciwgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciwgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTWlycm9yZWRSZXBlYXRXcmFwcGluZywgSW50ZXJwb2xhdGVEaXNjcmV0ZSwgRnJvbnRTaWRlLCBUZXh0dXJlLCBWZWN0b3JLZXlmcmFtZVRyYWNrLCBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgTnVtYmVyS2V5ZnJhbWVUcmFjaywgQm94MywgU3BoZXJlLCBJbnRlcnBvbGFudCB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgdG9UcmlhbmdsZXNEcmF3TW9kZSB9IGZyb20gXCIuLi91dGlscy9CdWZmZXJHZW9tZXRyeVV0aWxzLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL19wb2x5ZmlsbC9jb25zdGFudHMuanNcIjtcbmNsYXNzIEdMVEZMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IG51bGw7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLm1lc2hvcHREZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzVm9sdW1lRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0lyaWRlc2NlbmNlRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTGlnaHRzRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1lc2hvcHRDb21wcmVzc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNZXNoR3B1SW5zdGFuY2luZyhwYXJzZXIpO1xuICAgIH0pO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgbGV0IHJlc291cmNlUGF0aDtcbiAgICBpZiAodGhpcy5yZXNvdXJjZVBhdGggIT09IFwiXCIpIHtcbiAgICAgIHJlc291cmNlUGF0aCA9IHRoaXMucmVzb3VyY2VQYXRoO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wYXRoICE9PSBcIlwiKSB7XG4gICAgICByZXNvdXJjZVBhdGggPSB0aGlzLnBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc291cmNlUGF0aCA9IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKHVybCk7XG4gICAgfVxuICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICBjb25zdCBfb25FcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfVxuICAgICAgc2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgIH07XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcbiAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgIGxvYWRlci5sb2FkKFxuICAgICAgdXJsLFxuICAgICAgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNjb3BlLnBhcnNlKFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHJlc291cmNlUGF0aCxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGdsdGYpIHtcbiAgICAgICAgICAgICAgb25Mb2FkKGdsdGYpO1xuICAgICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25FcnJvclxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBfb25FcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBfb25FcnJvclxuICAgICk7XG4gIH1cbiAgc2V0RFJBQ09Mb2FkZXIoZHJhY29Mb2FkZXIpIHtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0RERTTG9hZGVyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVEhSRUUuR0xURkxvYWRlcjogXCJNU0ZUX3RleHR1cmVfZGRzXCIgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSB0byBcIktIUl90ZXh0dXJlX2Jhc2lzdVwiLicpO1xuICB9XG4gIHNldEtUWDJMb2FkZXIoa3R4MkxvYWRlcikge1xuICAgIHRoaXMua3R4MkxvYWRlciA9IGt0eDJMb2FkZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0TWVzaG9wdERlY29kZXIobWVzaG9wdERlY29kZXIpIHtcbiAgICB0aGlzLm1lc2hvcHREZWNvZGVyID0gbWVzaG9wdERlY29kZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVnaXN0ZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xKSB7XG4gICAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdW5yZWdpc3RlcihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSAhPT0gLTEpIHtcbiAgICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzLnNwbGljZSh0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBhcnNlKGRhdGEsIHBhdGgsIG9uTG9hZCwgb25FcnJvcikge1xuICAgIGxldCBqc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcbiAgICBjb25zdCBwbHVnaW5zID0ge307XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgY29uc3QgbWFnaWMgPSBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEuc2xpY2UoMCwgNCkpKTtcbiAgICAgIGlmIChtYWdpYyA9PT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGXSA9IG5ldyBHTFRGQmluYXJ5RXh0ZW5zaW9uKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChvbkVycm9yKVxuICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdLmNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UoTG9hZGVyVXRpbHMuZGVjb2RlVGV4dChuZXcgVWludDhBcnJheShkYXRhKSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBqc29uID0gZGF0YTtcbiAgICB9XG4gICAgaWYgKGpzb24uYXNzZXQgPT09IHZvaWQgMCB8fCBqc29uLmFzc2V0LnZlcnNpb25bMF0gPCAyKSB7XG4gICAgICBpZiAob25FcnJvcilcbiAgICAgICAgb25FcnJvcihuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBhc3NldC4gZ2xURiB2ZXJzaW9ucyA+PTIuMCBhcmUgc3VwcG9ydGVkLlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBHTFRGUGFyc2VyKGpzb24sIHtcbiAgICAgIHBhdGg6IHBhdGggfHwgdGhpcy5yZXNvdXJjZVBhdGggfHwgXCJcIixcbiAgICAgIGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luLFxuICAgICAgcmVxdWVzdEhlYWRlcjogdGhpcy5yZXF1ZXN0SGVhZGVyLFxuICAgICAgbWFuYWdlcjogdGhpcy5tYW5hZ2VyLFxuICAgICAga3R4MkxvYWRlcjogdGhpcy5rdHgyTG9hZGVyLFxuICAgICAgbWVzaG9wdERlY29kZXI6IHRoaXMubWVzaG9wdERlY29kZXJcbiAgICB9KTtcbiAgICBwYXJzZXIuZmlsZUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy5wbHVnaW5DYWxsYmFja3NbaV0ocGFyc2VyKTtcbiAgICAgIHBsdWdpbnNbcGx1Z2luLm5hbWVdID0gcGx1Z2luO1xuICAgICAgZXh0ZW5zaW9uc1twbHVnaW4ubmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoanNvbi5leHRlbnNpb25zVXNlZCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLmV4dGVuc2lvbnNVc2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWUgPSBqc29uLmV4dGVuc2lvbnNVc2VkW2ldO1xuICAgICAgICBjb25zdCBleHRlbnNpb25zUmVxdWlyZWQgPSBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCB8fCBbXTtcbiAgICAgICAgc3dpdGNoIChleHRlbnNpb25OYW1lKSB7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ6XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24oanNvbiwgdGhpcy5kcmFjb0xvYWRlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoZXh0ZW5zaW9uTmFtZSkgPj0gMCAmJiBwbHVnaW5zW2V4dGVuc2lvbk5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5HTFRGTG9hZGVyOiBVbmtub3duIGV4dGVuc2lvbiBcIicgKyBleHRlbnNpb25OYW1lICsgJ1wiLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnNlci5zZXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICAgIHBhcnNlci5zZXRQbHVnaW5zKHBsdWdpbnMpO1xuICAgIHBhcnNlci5wYXJzZShvbkxvYWQsIG9uRXJyb3IpO1xuICB9XG4gIHBhcnNlQXN5bmMoZGF0YSwgcGF0aCkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBzY29wZS5wYXJzZShkYXRhLCBwYXRoLCByZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBHTFRGUmVnaXN0cnkoKSB7XG4gIGxldCBvYmplY3RzID0ge307XG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3RzW2tleV07XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGtleSwgb2JqZWN0KSB7XG4gICAgICBvYmplY3RzW2tleV0gPSBvYmplY3Q7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgZGVsZXRlIG9iamVjdHNba2V5XTtcbiAgICB9LFxuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICBvYmplY3RzID0ge307XG4gICAgfVxuICB9O1xufVxuY29uc3QgRVhURU5TSU9OUyA9IHtcbiAgS0hSX0JJTkFSWV9HTFRGOiBcIktIUl9iaW5hcnlfZ2xURlwiLFxuICBLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjogXCJLSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvblwiLFxuICBLSFJfTElHSFRTX1BVTkNUVUFMOiBcIktIUl9saWdodHNfcHVuY3R1YWxcIixcbiAgS0hSX01BVEVSSUFMU19DTEVBUkNPQVQ6IFwiS0hSX21hdGVyaWFsc19jbGVhcmNvYXRcIixcbiAgS0hSX01BVEVSSUFMU19JT1I6IFwiS0hSX21hdGVyaWFsc19pb3JcIixcbiAgS0hSX01BVEVSSUFMU19TSEVFTjogXCJLSFJfbWF0ZXJpYWxzX3NoZWVuXCIsXG4gIEtIUl9NQVRFUklBTFNfU1BFQ1VMQVI6IFwiS0hSX21hdGVyaWFsc19zcGVjdWxhclwiLFxuICBLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjogXCJLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvblwiLFxuICBLSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFOiBcIktIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2VcIixcbiAgS0hSX01BVEVSSUFMU19BTklTT1RST1BZOiBcIktIUl9tYXRlcmlhbHNfYW5pc290cm9weVwiLFxuICBLSFJfTUFURVJJQUxTX1VOTElUOiBcIktIUl9tYXRlcmlhbHNfdW5saXRcIixcbiAgS0hSX01BVEVSSUFMU19WT0xVTUU6IFwiS0hSX21hdGVyaWFsc192b2x1bWVcIixcbiAgS0hSX1RFWFRVUkVfQkFTSVNVOiBcIktIUl90ZXh0dXJlX2Jhc2lzdVwiLFxuICBLSFJfVEVYVFVSRV9UUkFOU0ZPUk06IFwiS0hSX3RleHR1cmVfdHJhbnNmb3JtXCIsXG4gIEtIUl9NRVNIX1FVQU5USVpBVElPTjogXCJLSFJfbWVzaF9xdWFudGl6YXRpb25cIixcbiAgS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSDogXCJLSFJfbWF0ZXJpYWxzX2VtaXNzaXZlX3N0cmVuZ3RoXCIsXG4gIEVYVF9URVhUVVJFX1dFQlA6IFwiRVhUX3RleHR1cmVfd2VicFwiLFxuICBFWFRfVEVYVFVSRV9BVklGOiBcIkVYVF90ZXh0dXJlX2F2aWZcIixcbiAgRVhUX01FU0hPUFRfQ09NUFJFU1NJT046IFwiRVhUX21lc2hvcHRfY29tcHJlc3Npb25cIixcbiAgRVhUX01FU0hfR1BVX0lOU1RBTkNJTkc6IFwiRVhUX21lc2hfZ3B1X2luc3RhbmNpbmdcIlxufTtcbmNsYXNzIEdMVEZMaWdodHNFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9MSUdIVFNfUFVOQ1RVQUw7XG4gICAgdGhpcy5jYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gIH1cbiAgX21hcmtEZWZzKCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG5vZGVEZWZzID0gdGhpcy5wYXJzZXIuanNvbi5ub2RlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBub2RlSW5kZXggPSAwLCBub2RlTGVuZ3RoID0gbm9kZURlZnMubGVuZ3RoOyBub2RlSW5kZXggPCBub2RlTGVuZ3RoOyBub2RlSW5kZXgrKykge1xuICAgICAgY29uc3Qgbm9kZURlZiA9IG5vZGVEZWZzW25vZGVJbmRleF07XG4gICAgICBpZiAobm9kZURlZi5leHRlbnNpb25zICYmIG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdICYmIG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmxpZ2h0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGFyc2VyLl9hZGROb2RlUmVmKHRoaXMuY2FjaGUsIG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmxpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2xvYWRMaWdodChsaWdodEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBcImxpZ2h0OlwiICsgbGlnaHRJbmRleDtcbiAgICBsZXQgZGVwZW5kZW5jeSA9IHBhcnNlci5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChkZXBlbmRlbmN5KVxuICAgICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBqc29uLmV4dGVuc2lvbnMgJiYganNvbi5leHRlbnNpb25zW3RoaXMubmFtZV0gfHwge307XG4gICAgY29uc3QgbGlnaHREZWZzID0gZXh0ZW5zaW9ucy5saWdodHMgfHwgW107XG4gICAgY29uc3QgbGlnaHREZWYgPSBsaWdodERlZnNbbGlnaHRJbmRleF07XG4gICAgbGV0IGxpZ2h0Tm9kZTtcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigxNjc3NzIxNSk7XG4gICAgaWYgKGxpZ2h0RGVmLmNvbG9yICE9PSB2b2lkIDApXG4gICAgICBjb2xvci5mcm9tQXJyYXkobGlnaHREZWYuY29sb3IpO1xuICAgIGNvbnN0IHJhbmdlID0gbGlnaHREZWYucmFuZ2UgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnJhbmdlIDogMDtcbiAgICBzd2l0Y2ggKGxpZ2h0RGVmLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJkaXJlY3Rpb25hbFwiOlxuICAgICAgICBsaWdodE5vZGUgPSBuZXcgRGlyZWN0aW9uYWxMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KDAsIDAsIC0xKTtcbiAgICAgICAgbGlnaHROb2RlLmFkZChsaWdodE5vZGUudGFyZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9pbnRcIjpcbiAgICAgICAgbGlnaHROb2RlID0gbmV3IFBvaW50TGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3BvdFwiOlxuICAgICAgICBsaWdodE5vZGUgPSBuZXcgU3BvdExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLmRpc3RhbmNlID0gcmFuZ2U7XG4gICAgICAgIGxpZ2h0RGVmLnNwb3QgPSBsaWdodERlZi5zcG90IHx8IHt9O1xuICAgICAgICBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAhPT0gdm9pZCAwID8gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA6IDA7XG4gICAgICAgIGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlICE9PSB2b2lkIDAgPyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlIDogTWF0aC5QSSAvIDQ7XG4gICAgICAgIGxpZ2h0Tm9kZS5hbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG4gICAgICAgIGxpZ2h0Tm9kZS5wZW51bWJyYSA9IDEgLSBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlIC8gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcbiAgICAgICAgbGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoMCwgMCwgLTEpO1xuICAgICAgICBsaWdodE5vZGUuYWRkKGxpZ2h0Tm9kZS50YXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuZXhwZWN0ZWQgbGlnaHQgdHlwZTogXCIgKyBsaWdodERlZi50eXBlKTtcbiAgICB9XG4gICAgbGlnaHROb2RlLnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICBsaWdodE5vZGUuZGVjYXkgPSAyO1xuICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobGlnaHROb2RlLCBsaWdodERlZik7XG4gICAgaWYgKGxpZ2h0RGVmLmludGVuc2l0eSAhPT0gdm9pZCAwKVxuICAgICAgbGlnaHROb2RlLmludGVuc2l0eSA9IGxpZ2h0RGVmLmludGVuc2l0eTtcbiAgICBsaWdodE5vZGUubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKGxpZ2h0RGVmLm5hbWUgfHwgXCJsaWdodF9cIiArIGxpZ2h0SW5kZXgpO1xuICAgIGRlcGVuZGVuY3kgPSBQcm9taXNlLnJlc29sdmUobGlnaHROb2RlKTtcbiAgICBwYXJzZXIuY2FjaGUuYWRkKGNhY2hlS2V5LCBkZXBlbmRlbmN5KTtcbiAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgfVxuICBnZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KSB7XG4gICAgaWYgKHR5cGUgIT09IFwibGlnaHRcIilcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy5fbG9hZExpZ2h0KGluZGV4KTtcbiAgfVxuICBjcmVhdGVOb2RlQXR0YWNobWVudChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBzZWxmMiA9IHRoaXM7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgY29uc3QgbGlnaHREZWYgPSBub2RlRGVmLmV4dGVuc2lvbnMgJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gfHwge307XG4gICAgY29uc3QgbGlnaHRJbmRleCA9IGxpZ2h0RGVmLmxpZ2h0O1xuICAgIGlmIChsaWdodEluZGV4ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fbG9hZExpZ2h0KGxpZ2h0SW5kZXgpLnRoZW4oZnVuY3Rpb24obGlnaHQpIHtcbiAgICAgIHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYoc2VsZjIuY2FjaGUsIGxpZ2h0SW5kZXgsIGxpZ2h0KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZSgpIHtcbiAgICByZXR1cm4gTWVzaEJhc2ljTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kUGFyYW1zKG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyKSB7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEpO1xuICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxO1xuICAgIGNvbnN0IG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3M7XG4gICAgaWYgKG1ldGFsbGljUm91Z2huZXNzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5jb2xvci5mcm9tQXJyYXkoYXJyYXkpO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gYXJyYXlbM107XG4gICAgICB9XG4gICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJtYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSwgMzAwMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgZW1pc3NpdmVTdHJlbmd0aCA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5lbWlzc2l2ZVN0cmVuZ3RoO1xuICAgIGlmIChlbWlzc2l2ZVN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlSW50ZW5zaXR5ID0gZW1pc3NpdmVTdHJlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0NMRUFSQ09BVDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXQgPSBleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdE1hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdFJvdWdobmVzc01hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdE5vcm1hbE1hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSkpO1xuICAgICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMihzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JUklERVNDRU5DRTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiaXJpZGVzY2VuY2VNYXBcIiwgZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlSW9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlSU9SID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlSW9yO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0gWzEwMCwgNDAwXTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVswXSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMV0gPSBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwXCIsIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TSEVFTjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCk7XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSAwO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuID0gMTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlbkNvbG9yRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuQ29sb3IuZnJvbUFycmF5KGV4dGVuc2lvbi5zaGVlbkNvbG9yRmFjdG9yKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaGVlblJvdWdobmVzcyA9IGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc0ZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlbkNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic2hlZW5Db2xvck1hcFwiLCBleHRlbnNpb24uc2hlZW5Db2xvclRleHR1cmUsIDMwMDEpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNoZWVuUm91Z2huZXNzTWFwXCIsIGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc21pc3Npb24gPSBleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnRyYW5zbWlzc2lvblRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInRyYW5zbWlzc2lvbk1hcFwiLCBleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNWb2x1bWVFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVk9MVU1FO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnRoaWNrbmVzcyA9IGV4dGVuc2lvbi50aGlja25lc3NGYWN0b3IgIT09IHZvaWQgMCA/IGV4dGVuc2lvbi50aGlja25lc3NGYWN0b3IgOiAwO1xuICAgIGlmIChleHRlbnNpb24udGhpY2tuZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwidGhpY2tuZXNzTWFwXCIsIGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlKSk7XG4gICAgfVxuICAgIG1hdGVyaWFsUGFyYW1zLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBleHRlbnNpb24uYXR0ZW51YXRpb25EaXN0YW5jZSB8fCBJbmZpbml0eTtcbiAgICBjb25zdCBjb2xvckFycmF5ID0gZXh0ZW5zaW9uLmF0dGVudWF0aW9uQ29sb3IgfHwgWzEsIDEsIDFdO1xuICAgIG1hdGVyaWFsUGFyYW1zLmF0dGVudWF0aW9uQ29sb3IgPSBuZXcgQ29sb3IoY29sb3JBcnJheVswXSwgY29sb3JBcnJheVsxXSwgY29sb3JBcnJheVsyXSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0lPUjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLmlvciA9IGV4dGVuc2lvbi5pb3IgIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5pb3IgOiAxLjU7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfU1BFQ1VMQVI7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXJJbnRlbnNpdHkgPSBleHRlbnNpb24uc3BlY3VsYXJGYWN0b3IgIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5zcGVjdWxhckZhY3RvciA6IDE7XG4gICAgaWYgKGV4dGVuc2lvbi5zcGVjdWxhclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNwZWN1bGFySW50ZW5zaXR5TWFwXCIsIGV4dGVuc2lvbi5zcGVjdWxhclRleHR1cmUpKTtcbiAgICB9XG4gICAgY29uc3QgY29sb3JBcnJheSA9IGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yRmFjdG9yIHx8IFsxLCAxLCAxXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhckNvbG9yID0gbmV3IENvbG9yKGNvbG9yQXJyYXlbMF0sIGNvbG9yQXJyYXlbMV0sIGNvbG9yQXJyYXlbMl0pO1xuICAgIGlmIChleHRlbnNpb24uc3BlY3VsYXJDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzcGVjdWxhckNvbG9yTWFwXCIsIGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSwgMzAwMSlcbiAgICAgICAgLy8gc1JHQkVuY29kaW5nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0FOSVNPVFJPUFk7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5U3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuYW5pc290cm9weSA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5U3RyZW5ndGg7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmFuaXNvdHJvcHlSb3RhdGlvbiA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5Um90YXRpb247XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImFuaXNvdHJvcHlNYXBcIiwgZXh0ZW5zaW9uLmFuaXNvdHJvcHlUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX0JBU0lTVTtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBjb25zdCBsb2FkZXIgPSBwYXJzZXIub3B0aW9ucy5rdHgyTG9hZGVyO1xuICAgIGlmICghbG9hZGVyKSB7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogc2V0S1RYMkxvYWRlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBLVFgyIHRleHR1cmVzXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfV0VCUDtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgY29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbZXh0ZW5zaW9uLnNvdXJjZV07XG4gICAgbGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2UudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZS51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKGZ1bmN0aW9uKGlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFdlYlAgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUodGV4dHVyZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBkZXRlY3RTdXBwb3J0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaUlBQUFCWFJVSlFWbEE0SUJZQUFBQXdBUUNkQVNvQkFBRUFEc0QrSmFRQUEzQUFBQUFBXCI7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKGltYWdlLmhlaWdodCA9PT0gMSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfQVZJRjtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgY29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbZXh0ZW5zaW9uLnNvdXJjZV07XG4gICAgbGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2UudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZS51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKGZ1bmN0aW9uKGlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEFWSUYgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUodGV4dHVyZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBkZXRlY3RTdXBwb3J0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL2F2aWY7YmFzZTY0LEFBQUFJR1owZVhCaGRtbG1BQUFBQUdGMmFXWnRhV1l4YldsaFprMUJNVUlBQUFEeWJXVjBZUUFBQUFBQUFBQW9hR1JzY2dBQUFBQUFBQUFBY0dsamRBQUFBQUFBQUFBQUFBQUFBR3hwWW1GMmFXWUFBQUFBRG5CcGRHMEFBQUFBQUFFQUFBQWVhV3h2WXdBQUFBQkVBQUFCQUFFQUFBQUJBQUFCR2dBQUFCY0FBQUFvYVdsdVpnQUFBQUFBQVFBQUFCcHBibVpsQWdBQUFBQUJBQUJoZGpBeFEyOXNiM0lBQUFBQWFtbHdjbkFBQUFCTGFYQmpid0FBQUJScGMzQmxBQUFBQUFBQUFBRUFBQUFCQUFBQUVIQnBlR2tBQUFBQUF3Z0lDQUFBQUF4aGRqRkRnUUFNQUFBQUFCTmpiMnh5Ym1Oc2VBQUNBQUlBQm9BQUFBQVhhWEJ0WVFBQUFBQUFBQUFCQUFFRUFRS0RCQUFBQUI5dFpHRjBFZ0FLQ0JnQUJvZ1FFRFFnTWdrUUFBQUFCOGRTTGZJPVwiO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbWFnZS5oZWlnaHQgPT09IDEpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzU3VwcG9ydGVkO1xuICB9XG59XG5jbGFzcyBHTFRGTWVzaG9wdENvbXByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSE9QVF9DT01QUkVTU0lPTjtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBsb2FkQnVmZmVyVmlldyhpbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBqc29uLmJ1ZmZlclZpZXdzW2luZGV4XTtcbiAgICBpZiAoYnVmZmVyVmlldy5leHRlbnNpb25zICYmIGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICBjb25zdCBleHRlbnNpb25EZWYgPSBidWZmZXJWaWV3LmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJcIiwgZXh0ZW5zaW9uRGVmLmJ1ZmZlcik7XG4gICAgICBjb25zdCBkZWNvZGVyID0gdGhpcy5wYXJzZXIub3B0aW9ucy5tZXNob3B0RGVjb2RlcjtcbiAgICAgIGlmICghZGVjb2RlciB8fCAhZGVjb2Rlci5zdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YodGhpcy5uYW1lKSA+PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogc2V0TWVzaG9wdERlY29kZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgY29tcHJlc3NlZCBmaWxlc1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlci50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gZXh0ZW5zaW9uRGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGV4dGVuc2lvbkRlZi5ieXRlTGVuZ3RoIHx8IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gZXh0ZW5zaW9uRGVmLmNvdW50O1xuICAgICAgICBjb25zdCBzdHJpZGUgPSBleHRlbnNpb25EZWYuYnl0ZVN0cmlkZTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkocmVzLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgaWYgKGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jKGNvdW50LCBzdHJpZGUsIHNvdXJjZSwgZXh0ZW5zaW9uRGVmLm1vZGUsIGV4dGVuc2lvbkRlZi5maWx0ZXIpLnRoZW4oZnVuY3Rpb24ocmVzMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlczIuYnVmZmVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVyLnJlYWR5LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoY291bnQgKiBzdHJpZGUpO1xuICAgICAgICAgICAgZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyKFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLFxuICAgICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbkRlZi5tb2RlLFxuICAgICAgICAgICAgICBleHRlbnNpb25EZWYuZmlsdGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURk1lc2hHcHVJbnN0YW5jaW5nIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSF9HUFVfSU5TVEFOQ0lORztcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBjcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5wYXJzZXIuanNvbjtcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmICghbm9kZURlZi5leHRlbnNpb25zIHx8ICFub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCBub2RlRGVmLm1lc2ggPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1tub2RlRGVmLm1lc2hdO1xuICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIG1lc2hEZWYucHJpbWl0aXZlcykge1xuICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTICYmIHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgJiYgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gJiYgcHJpbWl0aXZlLm1vZGUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uRGVmID0gbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgY29uc3QgYXR0cmlidXRlc0RlZiA9IGV4dGVuc2lvbkRlZi5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlc0RlZikge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgYXR0cmlidXRlc0RlZltrZXldKS50aGVuKChhY2Nlc3NvcikgPT4ge1xuICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGFjY2Vzc29yO1xuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocGVuZGluZy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGVuZGluZy5wdXNoKHRoaXMucGFyc2VyLmNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICBjb25zdCBub2RlT2JqZWN0ID0gcmVzdWx0cy5wb3AoKTtcbiAgICAgIGNvbnN0IG1lc2hlcyA9IG5vZGVPYmplY3QuaXNHcm91cCA/IG5vZGVPYmplY3QuY2hpbGRyZW4gOiBbbm9kZU9iamVjdF07XG4gICAgICBjb25zdCBjb3VudCA9IHJlc3VsdHNbMF0uY291bnQ7XG4gICAgICBjb25zdCBpbnN0YW5jZWRNZXNoZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbWVzaCBvZiBtZXNoZXMpIHtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICBjb25zdCBxID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgICAgICBjb25zdCBpbnN0YW5jZWRNZXNoID0gbmV3IEluc3RhbmNlZE1lc2gobWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRlcmlhbCwgY291bnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5UUkFOU0xBVElPTikge1xuICAgICAgICAgICAgcC5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuVFJBTlNMQVRJT04sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5ST1RBVElPTikge1xuICAgICAgICAgICAgcS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuUk9UQVRJT04sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5TQ0FMRSkge1xuICAgICAgICAgICAgcy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuU0NBTEUsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KGksIG0uY29tcG9zZShwLCBxLCBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSAhPT0gXCJUUkFOU0xBVElPTlwiICYmIGF0dHJpYnV0ZU5hbWUgIT09IFwiUk9UQVRJT05cIiAmJiBhdHRyaWJ1dGVOYW1lICE9PSBcIlNDQUxFXCIpIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKGluc3RhbmNlZE1lc2gsIG1lc2gpO1xuICAgICAgICB0aGlzLnBhcnNlci5hc3NpZ25GaW5hbE1hdGVyaWFsKGluc3RhbmNlZE1lc2gpO1xuICAgICAgICBpbnN0YW5jZWRNZXNoZXMucHVzaChpbnN0YW5jZWRNZXNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlT2JqZWN0LmlzR3JvdXApIHtcbiAgICAgICAgbm9kZU9iamVjdC5jbGVhcigpO1xuICAgICAgICBub2RlT2JqZWN0LmFkZCguLi5pbnN0YW5jZWRNZXNoZXMpO1xuICAgICAgICByZXR1cm4gbm9kZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnN0YW5jZWRNZXNoZXNbMF07XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDID0gXCJnbFRGXCI7XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggPSAxMjtcbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMgPSB7IEpTT046IDEzMTM4MjE1MTQsIEJJTjogNTEzMDU2MiB9O1xuY2xhc3MgR0xURkJpbmFyeUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURjtcbiAgICB0aGlzLmNvbnRlbnQgPSBudWxsO1xuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgY29uc3QgaGVhZGVyVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLCAwLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgpO1xuICAgIHRoaXMuaGVhZGVyID0ge1xuICAgICAgbWFnaWM6IExvYWRlclV0aWxzLmRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YS5zbGljZSgwLCA0KSkpLFxuICAgICAgdmVyc2lvbjogaGVhZGVyVmlldy5nZXRVaW50MzIoNCwgdHJ1ZSksXG4gICAgICBsZW5ndGg6IGhlYWRlclZpZXcuZ2V0VWludDMyKDgsIHRydWUpXG4gICAgfTtcbiAgICBpZiAodGhpcy5oZWFkZXIubWFnaWMgIT09IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBnbFRGLUJpbmFyeSBoZWFkZXIuXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oZWFkZXIudmVyc2lvbiA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IExlZ2FjeSBiaW5hcnkgZmlsZSBkZXRlY3RlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rQ29udGVudHNMZW5ndGggPSB0aGlzLmhlYWRlci5sZW5ndGggLSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEg7XG4gICAgY29uc3QgY2h1bmtWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCk7XG4gICAgbGV0IGNodW5rSW5kZXggPSAwO1xuICAgIHdoaWxlIChjaHVua0luZGV4IDwgY2h1bmtDb250ZW50c0xlbmd0aCkge1xuICAgICAgY29uc3QgY2h1bmtMZW5ndGggPSBjaHVua1ZpZXcuZ2V0VWludDMyKGNodW5rSW5kZXgsIHRydWUpO1xuICAgICAgY2h1bmtJbmRleCArPSA0O1xuICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmtWaWV3LmdldFVpbnQzMihjaHVua0luZGV4LCB0cnVlKTtcbiAgICAgIGNodW5rSW5kZXggKz0gNDtcbiAgICAgIGlmIChjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuSlNPTikge1xuICAgICAgICBjb25zdCBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4LCBjaHVua0xlbmd0aCk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IExvYWRlclV0aWxzLmRlY29kZVRleHQoY29udGVudEFycmF5KTtcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkJJTikge1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleDtcbiAgICAgICAgdGhpcy5ib2R5ID0gZGF0YS5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgY2h1bmtMZW5ndGgpO1xuICAgICAgfVxuICAgICAgY2h1bmtJbmRleCArPSBjaHVua0xlbmd0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udGVudCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogSlNPTiBjb250ZW50IG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3Rvcihqc29uLCBkcmFjb0xvYWRlcikge1xuICAgIGlmICghZHJhY29Mb2FkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IE5vIERSQUNPTG9hZGVyIGluc3RhbmNlIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjtcbiAgICB0aGlzLmpzb24gPSBqc29uO1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcbiAgICB0aGlzLmRyYWNvTG9hZGVyLnByZWxvYWQoKTtcbiAgfVxuICBkZWNvZGVQcmltaXRpdmUocHJpbWl0aXZlLCBwYXJzZXIpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGRyYWNvTG9hZGVyID0gdGhpcy5kcmFjb0xvYWRlcjtcbiAgICBjb25zdCBidWZmZXJWaWV3SW5kZXggPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmJ1ZmZlclZpZXc7XG4gICAgY29uc3QgZ2x0ZkF0dHJpYnV0ZU1hcCA9IHByaW1pdGl2ZS5leHRlbnNpb25zW3RoaXMubmFtZV0uYXR0cmlidXRlcztcbiAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU1hcCA9IHt9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXAgPSB7fTtcbiAgICBjb25zdCBhdHRyaWJ1dGVUeXBlTWFwID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGdsdGZBdHRyaWJ1dGVNYXApIHtcbiAgICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbYXR0cmlidXRlTmFtZV0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhyZWVBdHRyaWJ1dGVNYXBbdGhyZWVBdHRyaWJ1dGVOYW1lXSA9IGdsdGZBdHRyaWJ1dGVNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBwcmltaXRpdmUuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1thdHRyaWJ1dGVOYW1lXSB8fCBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZ2x0ZkF0dHJpYnV0ZU1hcFthdHRyaWJ1dGVOYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc29yRGVmID0ganNvbi5hY2Nlc3NvcnNbcHJpbWl0aXZlLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgICBjb25zdCBjb21wb25lbnRUeXBlID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGVdO1xuICAgICAgICBhdHRyaWJ1dGVUeXBlTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBjb21wb25lbnRUeXBlLm5hbWU7XG4gICAgICAgIGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbdGhyZWVBdHRyaWJ1dGVOYW1lXSA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYnVmZmVyVmlld0luZGV4KS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGRyYWNvTG9hZGVyLmRlY29kZURyYWNvRmlsZShcbiAgICAgICAgICBidWZmZXJWaWV3LFxuICAgICAgICAgIGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gYXR0cmlidXRlTm9ybWFsaXplZE1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGdlb21ldHJ5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRocmVlQXR0cmlidXRlTWFwLFxuICAgICAgICAgIGF0dHJpYnV0ZVR5cGVNYXBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNO1xuICB9XG4gIGV4dGVuZFRleHR1cmUodGV4dHVyZSwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKCh0cmFuc2Zvcm0udGV4Q29vcmQgPT09IHZvaWQgMCB8fCB0cmFuc2Zvcm0udGV4Q29vcmQgPT09IHRleHR1cmUuY2hhbm5lbCkgJiYgdHJhbnNmb3JtLm9mZnNldCA9PT0gdm9pZCAwICYmIHRyYW5zZm9ybS5yb3RhdGlvbiA9PT0gdm9pZCAwICYmIHRyYW5zZm9ybS5zY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG4gICAgdGV4dHVyZSA9IHRleHR1cmUuY2xvbmUoKTtcbiAgICBpZiAodHJhbnNmb3JtLnRleENvb3JkICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUuY2hhbm5lbCA9IHRyYW5zZm9ybS50ZXhDb29yZDtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5vZmZzZXQgIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KHRyYW5zZm9ybS5vZmZzZXQpO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUucm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb247XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0uc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KHRyYW5zZm9ybS5zY2FsZSk7XG4gICAgfVxuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG59XG5jbGFzcyBHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01FU0hfUVVBTlRJWkFUSU9OO1xuICB9XG59XG5jbGFzcyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCBleHRlbmRzIEludGVycG9sYW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuICAgIHN1cGVyKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpO1xuICB9XG4gIGNvcHlTYW1wbGVWYWx1ZV8oaW5kZXgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlciwgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsIHZhbHVlU2l6ZSA9IHRoaXMudmFsdWVTaXplLCBvZmZzZXQgPSBpbmRleCAqIHZhbHVlU2l6ZSAqIDMgKyB2YWx1ZVNpemU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHZhbHVlU2l6ZTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSB2YWx1ZXNbb2Zmc2V0ICsgaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcjtcbiAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcztcbiAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcbiAgICBjb25zdCBzdHJpZGUyID0gc3RyaWRlICogMjtcbiAgICBjb25zdCBzdHJpZGUzID0gc3RyaWRlICogMztcbiAgICBjb25zdCB0ZCA9IHQxIC0gdDA7XG4gICAgY29uc3QgcCA9ICh0IC0gdDApIC8gdGQ7XG4gICAgY29uc3QgcHAgPSBwICogcDtcbiAgICBjb25zdCBwcHAgPSBwcCAqIHA7XG4gICAgY29uc3Qgb2Zmc2V0MSA9IGkxICogc3RyaWRlMztcbiAgICBjb25zdCBvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZTM7XG4gICAgY29uc3QgczIgPSAtMiAqIHBwcCArIDMgKiBwcDtcbiAgICBjb25zdCBzMyA9IHBwcCAtIHBwO1xuICAgIGNvbnN0IHMwID0gMSAtIHMyO1xuICAgIGNvbnN0IHMxID0gczMgLSBwcCArIHA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgaSsrKSB7XG4gICAgICBjb25zdCBwMCA9IHZhbHVlc1tvZmZzZXQwICsgaSArIHN0cmlkZV07XG4gICAgICBjb25zdCBtMCA9IHZhbHVlc1tvZmZzZXQwICsgaSArIHN0cmlkZTJdICogdGQ7XG4gICAgICBjb25zdCBwMSA9IHZhbHVlc1tvZmZzZXQxICsgaSArIHN0cmlkZV07XG4gICAgICBjb25zdCBtMSA9IHZhbHVlc1tvZmZzZXQxICsgaV0gKiB0ZDtcbiAgICAgIHJlc3VsdFtpXSA9IHMwICogcDAgKyBzMSAqIG0wICsgczIgKiBwMSArIHMzICogbTE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmNvbnN0IF9xID0gbmV3IFF1YXRlcm5pb24oKTtcbmNsYXNzIEdMVEZDdWJpY1NwbGluZVF1YXRlcm5pb25JbnRlcnBvbGFudCBleHRlbmRzIEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50IHtcbiAgaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5pbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSk7XG4gICAgX3EuZnJvbUFycmF5KHJlc3VsdCkubm9ybWFsaXplKCkudG9BcnJheShyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmNvbnN0IFdFQkdMX0NPTlNUQU5UUyA9IHtcbiAgRkxPQVQ6IDUxMjYsXG4gIC8vRkxPQVRfTUFUMjogMzU2NzQsXG4gIEZMT0FUX01BVDM6IDM1Njc1LFxuICBGTE9BVF9NQVQ0OiAzNTY3NixcbiAgRkxPQVRfVkVDMjogMzU2NjQsXG4gIEZMT0FUX1ZFQzM6IDM1NjY1LFxuICBGTE9BVF9WRUM0OiAzNTY2NixcbiAgTElORUFSOiA5NzI5LFxuICBSRVBFQVQ6IDEwNDk3LFxuICBTQU1QTEVSXzJEOiAzNTY3OCxcbiAgUE9JTlRTOiAwLFxuICBMSU5FUzogMSxcbiAgTElORV9MT09QOiAyLFxuICBMSU5FX1NUUklQOiAzLFxuICBUUklBTkdMRVM6IDQsXG4gIFRSSUFOR0xFX1NUUklQOiA1LFxuICBUUklBTkdMRV9GQU46IDYsXG4gIFVOU0lHTkVEX0JZVEU6IDUxMjEsXG4gIFVOU0lHTkVEX1NIT1JUOiA1MTIzXG59O1xuY29uc3QgV0VCR0xfQ09NUE9ORU5UX1RZUEVTID0ge1xuICA1MTIwOiBJbnQ4QXJyYXksXG4gIDUxMjE6IFVpbnQ4QXJyYXksXG4gIDUxMjI6IEludDE2QXJyYXksXG4gIDUxMjM6IFVpbnQxNkFycmF5LFxuICA1MTI1OiBVaW50MzJBcnJheSxcbiAgNTEyNjogRmxvYXQzMkFycmF5XG59O1xuY29uc3QgV0VCR0xfRklMVEVSUyA9IHtcbiAgOTcyODogTmVhcmVzdEZpbHRlcixcbiAgOTcyOTogTGluZWFyRmlsdGVyLFxuICA5OTg0OiBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcixcbiAgOTk4NTogTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcixcbiAgOTk4NjogTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcixcbiAgOTk4NzogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXG59O1xuY29uc3QgV0VCR0xfV1JBUFBJTkdTID0ge1xuICAzMzA3MTogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcbiAgMzM2NDg6IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsXG4gIDEwNDk3OiBSZXBlYXRXcmFwcGluZ1xufTtcbmNvbnN0IFdFQkdMX1RZUEVfU0laRVMgPSB7XG4gIFNDQUxBUjogMSxcbiAgVkVDMjogMixcbiAgVkVDMzogMyxcbiAgVkVDNDogNCxcbiAgTUFUMjogNCxcbiAgTUFUMzogOSxcbiAgTUFUNDogMTZcbn07XG5jb25zdCBBVFRSSUJVVEVTID0ge1xuICBQT1NJVElPTjogXCJwb3NpdGlvblwiLFxuICBOT1JNQUw6IFwibm9ybWFsXCIsXG4gIFRBTkdFTlQ6IFwidGFuZ2VudFwiLFxuICAvLyB1diA9PiB1djEsIDQgdXYgY2hhbm5lbHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI1OTQzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTc4OFxuICAuLi52ZXJzaW9uID49IDE1MiA/IHtcbiAgICBURVhDT09SRF8wOiBcInV2XCIsXG4gICAgVEVYQ09PUkRfMTogXCJ1djFcIixcbiAgICBURVhDT09SRF8yOiBcInV2MlwiLFxuICAgIFRFWENPT1JEXzM6IFwidXYzXCJcbiAgfSA6IHtcbiAgICBURVhDT09SRF8wOiBcInV2XCIsXG4gICAgVEVYQ09PUkRfMTogXCJ1djJcIlxuICB9LFxuICBDT0xPUl8wOiBcImNvbG9yXCIsXG4gIFdFSUdIVFNfMDogXCJza2luV2VpZ2h0XCIsXG4gIEpPSU5UU18wOiBcInNraW5JbmRleFwiXG59O1xuY29uc3QgUEFUSF9QUk9QRVJUSUVTID0ge1xuICBzY2FsZTogXCJzY2FsZVwiLFxuICB0cmFuc2xhdGlvbjogXCJwb3NpdGlvblwiLFxuICByb3RhdGlvbjogXCJxdWF0ZXJuaW9uXCIsXG4gIHdlaWdodHM6IFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCJcbn07XG5jb25zdCBJTlRFUlBPTEFUSU9OID0ge1xuICBDVUJJQ1NQTElORTogdm9pZCAwLFxuICAvLyBXZSB1c2UgYSBjdXN0b20gaW50ZXJwb2xhbnQgKEdMVEZDdWJpY1NwbGluZUludGVycG9sYXRpb24pIGZvciBDVUJJQ1NQTElORSB0cmFja3MuIEVhY2hcbiAgLy8ga2V5ZnJhbWUgdHJhY2sgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGEgZGVmYXVsdCBpbnRlcnBvbGF0aW9uIHR5cGUsIHRoZW4gbW9kaWZpZWQuXG4gIExJTkVBUjogSW50ZXJwb2xhdGVMaW5lYXIsXG4gIFNURVA6IEludGVycG9sYXRlRGlzY3JldGVcbn07XG5jb25zdCBBTFBIQV9NT0RFUyA9IHtcbiAgT1BBUVVFOiBcIk9QQVFVRVwiLFxuICBNQVNLOiBcIk1BU0tcIixcbiAgQkxFTkQ6IFwiQkxFTkRcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRNYXRlcmlhbChjYWNoZSkge1xuICBpZiAoY2FjaGVbXCJEZWZhdWx0TWF0ZXJpYWxcIl0gPT09IHZvaWQgMCkge1xuICAgIGNhY2hlW1wiRGVmYXVsdE1hdGVyaWFsXCJdID0gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAxNjc3NzIxNSxcbiAgICAgIGVtaXNzaXZlOiAwLFxuICAgICAgbWV0YWxuZXNzOiAxLFxuICAgICAgcm91Z2huZXNzOiAxLFxuICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiB0cnVlLFxuICAgICAgc2lkZTogRnJvbnRTaWRlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlW1wiRGVmYXVsdE1hdGVyaWFsXCJdO1xufVxuZnVuY3Rpb24gYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGtub3duRXh0ZW5zaW9ucywgb2JqZWN0LCBvYmplY3REZWYpIHtcbiAgZm9yIChjb25zdCBuYW1lIGluIG9iamVjdERlZi5leHRlbnNpb25zKSB7XG4gICAgaWYgKGtub3duRXh0ZW5zaW9uc1tuYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICBvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnMgPSBvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnMgfHwge307XG4gICAgICBvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnNbbmFtZV0gPSBvYmplY3REZWYuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEob2JqZWN0LCBnbHRmRGVmKSB7XG4gIGlmIChnbHRmRGVmLmV4dHJhcyAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKHR5cGVvZiBnbHRmRGVmLmV4dHJhcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgT2JqZWN0LmFzc2lnbihvYmplY3QudXNlckRhdGEsIGdsdGZEZWYuZXh0cmFzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogSWdub3JpbmcgcHJpbWl0aXZlIHR5cGUgLmV4dHJhcywgXCIgKyBnbHRmRGVmLmV4dHJhcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRNb3JwaFRhcmdldHMoZ2VvbWV0cnksIHRhcmdldHMsIHBhcnNlcikge1xuICBsZXQgaGFzTW9ycGhQb3NpdGlvbiA9IGZhbHNlO1xuICBsZXQgaGFzTW9ycGhOb3JtYWwgPSBmYWxzZTtcbiAgbGV0IGhhc01vcnBoQ29sb3IgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICBpZiAodGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDApXG4gICAgICBoYXNNb3JwaFBvc2l0aW9uID0gdHJ1ZTtcbiAgICBpZiAodGFyZ2V0Lk5PUk1BTCAhPT0gdm9pZCAwKVxuICAgICAgaGFzTW9ycGhOb3JtYWwgPSB0cnVlO1xuICAgIGlmICh0YXJnZXQuQ09MT1JfMCAhPT0gdm9pZCAwKVxuICAgICAgaGFzTW9ycGhDb2xvciA9IHRydWU7XG4gICAgaWYgKGhhc01vcnBoUG9zaXRpb24gJiYgaGFzTW9ycGhOb3JtYWwgJiYgaGFzTW9ycGhDb2xvcilcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmICghaGFzTW9ycGhQb3NpdGlvbiAmJiAhaGFzTW9ycGhOb3JtYWwgJiYgIWhhc01vcnBoQ29sb3IpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShnZW9tZXRyeSk7XG4gIGNvbnN0IHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyA9IFtdO1xuICBjb25zdCBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzID0gW107XG4gIGNvbnN0IHBlbmRpbmdDb2xvckFjY2Vzc29ycyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMCA/IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgdGFyZ2V0LlBPU0lUSU9OKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMucHVzaChwZW5kaW5nQWNjZXNzb3IpO1xuICAgIH1cbiAgICBpZiAoaGFzTW9ycGhOb3JtYWwpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5OT1JNQUwgIT09IHZvaWQgMCA/IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgdGFyZ2V0Lk5PUk1BTCkgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcbiAgICAgIHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMucHVzaChwZW5kaW5nQWNjZXNzb3IpO1xuICAgIH1cbiAgICBpZiAoaGFzTW9ycGhDb2xvcikge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LkNPTE9SXzAgIT09IHZvaWQgMCA/IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgdGFyZ2V0LkNPTE9SXzApIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvcjtcbiAgICAgIHBlbmRpbmdDb2xvckFjY2Vzc29ycy5wdXNoKHBlbmRpbmdBY2Nlc3Nvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzKSxcbiAgICBQcm9taXNlLmFsbChwZW5kaW5nTm9ybWFsQWNjZXNzb3JzKSxcbiAgICBQcm9taXNlLmFsbChwZW5kaW5nQ29sb3JBY2Nlc3NvcnMpXG4gIF0pLnRoZW4oZnVuY3Rpb24oYWNjZXNzb3JzKSB7XG4gICAgY29uc3QgbW9ycGhQb3NpdGlvbnMgPSBhY2Nlc3NvcnNbMF07XG4gICAgY29uc3QgbW9ycGhOb3JtYWxzID0gYWNjZXNzb3JzWzFdO1xuICAgIGNvbnN0IG1vcnBoQ29sb3JzID0gYWNjZXNzb3JzWzJdO1xuICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uKVxuICAgICAgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uID0gbW9ycGhQb3NpdGlvbnM7XG4gICAgaWYgKGhhc01vcnBoTm9ybWFsKVxuICAgICAgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCA9IG1vcnBoTm9ybWFscztcbiAgICBpZiAoaGFzTW9ycGhDb2xvcilcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciA9IG1vcnBoQ29sb3JzO1xuICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdHJ1ZTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlTW9ycGhUYXJnZXRzKG1lc2gsIG1lc2hEZWYpIHtcbiAgbWVzaC51cGRhdGVNb3JwaFRhcmdldHMoKTtcbiAgaWYgKG1lc2hEZWYud2VpZ2h0cyAhPT0gdm9pZCAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbWVzaERlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldID0gbWVzaERlZi53ZWlnaHRzW2ldO1xuICAgIH1cbiAgfVxuICBpZiAobWVzaERlZi5leHRyYXMgJiYgQXJyYXkuaXNBcnJheShtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcykpIHtcbiAgICBjb25zdCB0YXJnZXROYW1lcyA9IG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzO1xuICAgIGlmIChtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGggPT09IHRhcmdldE5hbWVzLmxlbmd0aCkge1xuICAgICAgbWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgbWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnlbdGFyZ2V0TmFtZXNbaV1dID0gaTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogSW52YWxpZCBleHRyYXMudGFyZ2V0TmFtZXMgbGVuZ3RoLiBJZ25vcmluZyBuYW1lcy5cIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVLZXkocHJpbWl0aXZlRGVmKSB7XG4gIGxldCBnZW9tZXRyeUtleTtcbiAgY29uc3QgZHJhY29FeHRlbnNpb24gPSBwcmltaXRpdmVEZWYuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmVEZWYuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXTtcbiAgaWYgKGRyYWNvRXh0ZW5zaW9uKSB7XG4gICAgZ2VvbWV0cnlLZXkgPSBcImRyYWNvOlwiICsgZHJhY29FeHRlbnNpb24uYnVmZmVyVmlldyArIFwiOlwiICsgZHJhY29FeHRlbnNpb24uaW5kaWNlcyArIFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShkcmFjb0V4dGVuc2lvbi5hdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICBnZW9tZXRyeUtleSA9IHByaW1pdGl2ZURlZi5pbmRpY2VzICsgXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzKSArIFwiOlwiICsgcHJpbWl0aXZlRGVmLm1vZGU7XG4gIH1cbiAgaWYgKHByaW1pdGl2ZURlZi50YXJnZXRzICE9PSB2b2lkIDApIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVEZWYudGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBnZW9tZXRyeUtleSArPSBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkocHJpbWl0aXZlRGVmLnRhcmdldHNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VvbWV0cnlLZXk7XG59XG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVzS2V5KGF0dHJpYnV0ZXMpIHtcbiAgbGV0IGF0dHJpYnV0ZXNLZXkgPSBcIlwiO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykuc29ydCgpO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBhdHRyaWJ1dGVzS2V5ICs9IGtleXNbaV0gKyBcIjpcIiArIGF0dHJpYnV0ZXNba2V5c1tpXV0gKyBcIjtcIjtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlc0tleTtcbn1cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShjb25zdHJ1Y3Rvcikge1xuICBzd2l0Y2ggKGNvbnN0cnVjdG9yKSB7XG4gICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICByZXR1cm4gMSAvIDEyNztcbiAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICByZXR1cm4gMSAvIDI1NTtcbiAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICByZXR1cm4gMSAvIDMyNzY3O1xuICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICByZXR1cm4gMSAvIDY1NTM1O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBub3JtYWxpemVkIGFjY2Vzc29yIGNvbXBvbmVudCB0eXBlLlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SW1hZ2VVUklNaW1lVHlwZSh1cmkpIHtcbiAgaWYgKHVyaS5zZWFyY2goL1xcLmpwZT9nKCR8XFw/KS9pKSA+IDAgfHwgdXJpLnNlYXJjaCgvXmRhdGFcXDppbWFnZVxcL2pwZWcvKSA9PT0gMClcbiAgICByZXR1cm4gXCJpbWFnZS9qcGVnXCI7XG4gIGlmICh1cmkuc2VhcmNoKC9cXC53ZWJwKCR8XFw/KS9pKSA+IDAgfHwgdXJpLnNlYXJjaCgvXmRhdGFcXDppbWFnZVxcL3dlYnAvKSA9PT0gMClcbiAgICByZXR1cm4gXCJpbWFnZS93ZWJwXCI7XG4gIHJldHVybiBcImltYWdlL3BuZ1wiO1xufVxuY29uc3QgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbmNsYXNzIEdMVEZQYXJzZXIge1xuICBjb25zdHJ1Y3Rvcihqc29uID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuanNvbiA9IGpzb247XG4gICAgdGhpcy5leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNhY2hlID0gbmV3IEdMVEZSZWdpc3RyeSgpO1xuICAgIHRoaXMuYXNzb2NpYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByaW1pdGl2ZUNhY2hlID0ge307XG4gICAgdGhpcy5ub2RlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLm1lc2hDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5jYW1lcmFDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5saWdodENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLnNvdXJjZUNhY2hlID0ge307XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLm5vZGVOYW1lc1VzZWQgPSB7fTtcbiAgICBsZXQgaXNTYWZhcmkgPSBmYWxzZTtcbiAgICBsZXQgaXNGaXJlZm94ID0gZmFsc2U7XG4gICAgbGV0IGZpcmVmb3hWZXJzaW9uID0gLTE7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA9PT0gdHJ1ZTtcbiAgICAgIGlzRmlyZWZveCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPiAtMTtcbiAgICAgIGZpcmVmb3hWZXJzaW9uID0gaXNGaXJlZm94ID8gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLyhbMC05XSspXFwuLylbMV0gOiAtMTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc1NhZmFyaSB8fCBpc0ZpcmVmb3ggJiYgZmlyZWZveFZlcnNpb24gPCA5OCkge1xuICAgICAgdGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIodGhpcy5vcHRpb25zLm1hbmFnZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRleHR1cmVMb2FkZXIgPSBuZXcgSW1hZ2VCaXRtYXBMb2FkZXIodGhpcy5vcHRpb25zLm1hbmFnZXIpO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4odGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgICB0aGlzLnRleHR1cmVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLm9wdGlvbnMucmVxdWVzdEhlYWRlcik7XG4gICAgdGhpcy5maWxlTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5vcHRpb25zLm1hbmFnZXIpO1xuICAgIHRoaXMuZmlsZUxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSBcInVzZS1jcmVkZW50aWFsc1wiKSB7XG4gICAgICB0aGlzLmZpbGVMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRydWUpO1xuICAgIH1cbiAgfVxuICBzZXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICB9XG4gIHNldFBsdWdpbnMocGx1Z2lucykge1xuICAgIHRoaXMucGx1Z2lucyA9IHBsdWdpbnM7XG4gIH1cbiAgcGFyc2Uob25Mb2FkLCBvbkVycm9yKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgdGhpcy5jYWNoZS5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLm5vZGVDYWNoZSA9IHt9O1xuICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuX21hcmtEZWZzICYmIGV4dC5fbWFya0RlZnMoKTtcbiAgICB9KTtcbiAgICBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgcmV0dXJuIGV4dC5iZWZvcmVSb290ICYmIGV4dC5iZWZvcmVSb290KCk7XG4gICAgICB9KVxuICAgICkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJzY2VuZVwiKSxcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY2llcyhcImFuaW1hdGlvblwiKSxcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY2llcyhcImNhbWVyYVwiKVxuICAgICAgXSk7XG4gICAgfSkudGhlbihmdW5jdGlvbihkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc2NlbmU6IGRlcGVuZGVuY2llc1swXVtqc29uLnNjZW5lIHx8IDBdLFxuICAgICAgICBzY2VuZXM6IGRlcGVuZGVuY2llc1swXSxcbiAgICAgICAgYW5pbWF0aW9uczogZGVwZW5kZW5jaWVzWzFdLFxuICAgICAgICBjYW1lcmFzOiBkZXBlbmRlbmNpZXNbMl0sXG4gICAgICAgIGFzc2V0OiBqc29uLmFzc2V0LFxuICAgICAgICBwYXJzZXIsXG4gICAgICAgIHVzZXJEYXRhOiB7fVxuICAgICAgfTtcbiAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCByZXN1bHQsIGpzb24pO1xuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShyZXN1bHQsIGpzb24pO1xuICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgIHBhcnNlci5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgIHJldHVybiBleHQuYWZ0ZXJSb290ICYmIGV4dC5hZnRlclJvb3QocmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICAgICkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgb25Mb2FkKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaChvbkVycm9yKTtcbiAgfVxuICAvKipcbiAgICogTWFya3MgdGhlIHNwZWNpYWwgbm9kZXMvbWVzaGVzIGluIGpzb24gZm9yIGVmZmljaWVudCBwYXJzZS5cbiAgICovXG4gIF9tYXJrRGVmcygpIHtcbiAgICBjb25zdCBub2RlRGVmcyA9IHRoaXMuanNvbi5ub2RlcyB8fCBbXTtcbiAgICBjb25zdCBza2luRGVmcyA9IHRoaXMuanNvbi5za2lucyB8fCBbXTtcbiAgICBjb25zdCBtZXNoRGVmcyA9IHRoaXMuanNvbi5tZXNoZXMgfHwgW107XG4gICAgZm9yIChsZXQgc2tpbkluZGV4ID0gMCwgc2tpbkxlbmd0aCA9IHNraW5EZWZzLmxlbmd0aDsgc2tpbkluZGV4IDwgc2tpbkxlbmd0aDsgc2tpbkluZGV4KyspIHtcbiAgICAgIGNvbnN0IGpvaW50cyA9IHNraW5EZWZzW3NraW5JbmRleF0uam9pbnRzO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgbm9kZURlZnNbam9pbnRzW2ldXS5pc0JvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBub2RlSW5kZXggPSAwLCBub2RlTGVuZ3RoID0gbm9kZURlZnMubGVuZ3RoOyBub2RlSW5kZXggPCBub2RlTGVuZ3RoOyBub2RlSW5kZXgrKykge1xuICAgICAgY29uc3Qgbm9kZURlZiA9IG5vZGVEZWZzW25vZGVJbmRleF07XG4gICAgICBpZiAobm9kZURlZi5tZXNoICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5fYWRkTm9kZVJlZih0aGlzLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoKTtcbiAgICAgICAgaWYgKG5vZGVEZWYuc2tpbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbWVzaERlZnNbbm9kZURlZi5tZXNoXS5pc1NraW5uZWRNZXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVEZWYuY2FtZXJhICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5fYWRkTm9kZVJlZih0aGlzLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb3VudHMgcmVmZXJlbmNlcyB0byBzaGFyZWQgbm9kZSAvIE9iamVjdDNEIHJlc291cmNlcy4gVGhlc2UgcmVzb3VyY2VzXG4gICAqIGNhbiBiZSByZXVzZWQsIG9yIFwiaW5zdGFudGlhdGVkXCIsIGF0IG11bHRpcGxlIG5vZGVzIGluIHRoZSBzY2VuZVxuICAgKiBoaWVyYXJjaHkuIE1lc2gsIENhbWVyYSwgYW5kIExpZ2h0IGluc3RhbmNlcyBhcmUgaW5zdGFudGlhdGVkIGFuZCBtdXN0XG4gICAqIGJlIG1hcmtlZC4gTm9uLXNjZW5lZ3JhcGggcmVzb3VyY2VzIChsaWtlIE1hdGVyaWFscywgR2VvbWV0cmllcywgYW5kXG4gICAqIFRleHR1cmVzKSBjYW4gYmUgcmV1c2VkIGRpcmVjdGx5IGFuZCBhcmUgbm90IG1hcmtlZCBoZXJlLlxuICAgKlxuICAgKiBFeGFtcGxlOiBDZXNpdW1NaWxrVHJ1Y2sgc2FtcGxlIG1vZGVsIHJldXNlcyBcIldoZWVsXCIgbWVzaGVzLlxuICAgKi9cbiAgX2FkZE5vZGVSZWYoY2FjaGUsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKGNhY2hlLnJlZnNbaW5kZXhdID09PSB2b2lkIDApIHtcbiAgICAgIGNhY2hlLnJlZnNbaW5kZXhdID0gY2FjaGUudXNlc1tpbmRleF0gPSAwO1xuICAgIH1cbiAgICBjYWNoZS5yZWZzW2luZGV4XSsrO1xuICB9XG4gIC8qKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGEgc2hhcmVkIHJlc291cmNlLCBjbG9uaW5nIGl0IGlmIG5lY2Vzc2FyeS4gKi9cbiAgX2dldE5vZGVSZWYoY2FjaGUsIGluZGV4LCBvYmplY3QpIHtcbiAgICBpZiAoY2FjaGUucmVmc1tpbmRleF0gPD0gMSlcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgY29uc3QgcmVmID0gb2JqZWN0LmNsb25lKCk7XG4gICAgY29uc3QgdXBkYXRlTWFwcGluZ3MgPSAob3JpZ2luYWwsIGNsb25lKSA9PiB7XG4gICAgICBjb25zdCBtYXBwaW5ncyA9IHRoaXMuYXNzb2NpYXRpb25zLmdldChvcmlnaW5hbCk7XG4gICAgICBpZiAobWFwcGluZ3MgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFzc29jaWF0aW9ucy5zZXQoY2xvbmUsIG1hcHBpbmdzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2ksIGNoaWxkXSBvZiBvcmlnaW5hbC5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgdXBkYXRlTWFwcGluZ3MoY2hpbGQsIGNsb25lLmNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZU1hcHBpbmdzKG9iamVjdCwgcmVmKTtcbiAgICByZWYubmFtZSArPSBcIl9pbnN0YW5jZV9cIiArIGNhY2hlLnVzZXNbaW5kZXhdKys7XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuICBfaW52b2tlT25lKGZ1bmMpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLnBsdWdpbnMpO1xuICAgIGV4dGVuc2lvbnMucHVzaCh0aGlzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMoZXh0ZW5zaW9uc1tpXSk7XG4gICAgICBpZiAocmVzdWx0KVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfaW52b2tlQWxsKGZ1bmMpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLnBsdWdpbnMpO1xuICAgIGV4dGVuc2lvbnMudW5zaGlmdCh0aGlzKTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmdW5jKGV4dGVuc2lvbnNbaV0pO1xuICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgcGVuZGluZy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgc3BlY2lmaWVkIGRlcGVuZGVuY3kgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0R8TWF0ZXJpYWx8VEhSRUUuVGV4dHVyZXxBbmltYXRpb25DbGlwfEFycmF5QnVmZmVyfE9iamVjdD59XG4gICAqL1xuICBnZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSB0eXBlICsgXCI6XCIgKyBpbmRleDtcbiAgICBsZXQgZGVwZW5kZW5jeSA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWRlcGVuZGVuY3kpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic2NlbmVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2NlbmUoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm9kZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWROb2RlICYmIGV4dC5sb2FkTm9kZShpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXNoXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE1lc2ggJiYgZXh0LmxvYWRNZXNoKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFjY2Vzc29yXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZEFjY2Vzc29yKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ1ZmZlclZpZXdcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkQnVmZmVyVmlldyAmJiBleHQubG9hZEJ1ZmZlclZpZXcoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYnVmZmVyXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZEJ1ZmZlcihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXRlcmlhbFwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRNYXRlcmlhbCAmJiBleHQubG9hZE1hdGVyaWFsKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRleHR1cmVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkVGV4dHVyZSAmJiBleHQubG9hZFRleHR1cmUoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2tpblwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTa2luKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFuaW1hdGlvblwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRBbmltYXRpb24gJiYgZXh0LmxvYWRBbmltYXRpb24oaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FtZXJhXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZENhbWVyYShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQgIT0gdGhpcyAmJiBleHQuZ2V0RGVwZW5kZW5jeSAmJiBleHQuZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGRlcGVuZGVuY3kpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxPYmplY3Q+Pn1cbiAgICovXG4gIGdldERlcGVuZGVuY2llcyh0eXBlKSB7XG4gICAgbGV0IGRlcGVuZGVuY2llcyA9IHRoaXMuY2FjaGUuZ2V0KHR5cGUpO1xuICAgIGlmICghZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgICAgY29uc3QgZGVmcyA9IHRoaXMuanNvblt0eXBlICsgKHR5cGUgPT09IFwibWVzaFwiID8gXCJlc1wiIDogXCJzXCIpXSB8fCBbXTtcbiAgICAgIGRlcGVuZGVuY2llcyA9IFByb21pc2UuYWxsKFxuICAgICAgICBkZWZzLm1hcChmdW5jdGlvbihkZWYsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICB0aGlzLmNhY2hlLmFkZCh0eXBlLCBkZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2J1ZmZlcnMtYW5kLWJ1ZmZlci12aWV3c1xuICAgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVySW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBsb2FkQnVmZmVyKGJ1ZmZlckluZGV4KSB7XG4gICAgY29uc3QgYnVmZmVyRGVmID0gdGhpcy5qc29uLmJ1ZmZlcnNbYnVmZmVySW5kZXhdO1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZmlsZUxvYWRlcjtcbiAgICBpZiAoYnVmZmVyRGVmLnR5cGUgJiYgYnVmZmVyRGVmLnR5cGUgIT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogXCIgKyBidWZmZXJEZWYudHlwZSArIFwiIGJ1ZmZlciB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyRGVmLnVyaSA9PT0gdm9pZCAwICYmIGJ1ZmZlckluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0uYm9keSk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgbG9hZGVyLmxvYWQoTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChidWZmZXJEZWYudXJpLCBvcHRpb25zLnBhdGgpLCByZXNvbHZlLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdUSFJFRS5HTFRGTG9hZGVyOiBGYWlsZWQgdG8gbG9hZCBidWZmZXIgXCInICsgYnVmZmVyRGVmLnVyaSArICdcIi4nKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclZpZXdJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGxvYWRCdWZmZXJWaWV3KGJ1ZmZlclZpZXdJbmRleCkge1xuICAgIGNvbnN0IGJ1ZmZlclZpZXdEZWYgPSB0aGlzLmpzb24uYnVmZmVyVmlld3NbYnVmZmVyVmlld0luZGV4XTtcbiAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyXCIsIGJ1ZmZlclZpZXdEZWYuYnVmZmVyKS50aGVuKGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGJ1ZmZlclZpZXdEZWYuYnl0ZUxlbmd0aCB8fCAwO1xuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGJ1ZmZlclZpZXdEZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYWNjZXNzb3JzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhY2Nlc3NvckluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QnVmZmVyQXR0cmlidXRlfEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlPn1cbiAgICovXG4gIGxvYWRBY2Nlc3NvcihhY2Nlc3NvckluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGFjY2Vzc29yRGVmID0gdGhpcy5qc29uLmFjY2Vzc29yc1thY2Nlc3NvckluZGV4XTtcbiAgICBpZiAoYWNjZXNzb3JEZWYuYnVmZmVyVmlldyA9PT0gdm9pZCAwICYmIGFjY2Vzc29yRGVmLnNwYXJzZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IFdFQkdMX1RZUEVfU0laRVNbYWNjZXNzb3JEZWYudHlwZV07XG4gICAgICBjb25zdCBUeXBlZEFycmF5ID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGVdO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICBjb25zdCBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nQnVmZmVyVmlld3MgPSBbXTtcbiAgICBpZiAoYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2gobnVsbCk7XG4gICAgfVxuICAgIGlmIChhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5idWZmZXJWaWV3KSk7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGFjY2Vzc29yRGVmLnNwYXJzZS52YWx1ZXMuYnVmZmVyVmlldykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZ0J1ZmZlclZpZXdzKS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXdzKSB7XG4gICAgICBjb25zdCBidWZmZXJWaWV3ID0gYnVmZmVyVmlld3NbMF07XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IFdFQkdMX1RZUEVfU0laRVNbYWNjZXNzb3JEZWYudHlwZV07XG4gICAgICBjb25zdCBUeXBlZEFycmF5ID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGVdO1xuICAgICAgY29uc3QgZWxlbWVudEJ5dGVzID0gVHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgIGNvbnN0IGl0ZW1CeXRlcyA9IGVsZW1lbnRCeXRlcyAqIGl0ZW1TaXplO1xuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGFjY2Vzc29yRGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgIGNvbnN0IGJ5dGVTdHJpZGUgPSBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDAgPyBqc29uLmJ1ZmZlclZpZXdzW2FjY2Vzc29yRGVmLmJ1ZmZlclZpZXddLmJ5dGVTdHJpZGUgOiB2b2lkIDA7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcbiAgICAgIGxldCBhcnJheSwgYnVmZmVyQXR0cmlidXRlO1xuICAgICAgaWYgKGJ5dGVTdHJpZGUgJiYgYnl0ZVN0cmlkZSAhPT0gaXRlbUJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGliU2xpY2UgPSBNYXRoLmZsb29yKGJ5dGVPZmZzZXQgLyBieXRlU3RyaWRlKTtcbiAgICAgICAgY29uc3QgaWJDYWNoZUtleSA9IFwiSW50ZXJsZWF2ZWRCdWZmZXI6XCIgKyBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICsgXCI6XCIgKyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlICsgXCI6XCIgKyBpYlNsaWNlICsgXCI6XCIgKyBhY2Nlc3NvckRlZi5jb3VudDtcbiAgICAgICAgbGV0IGliID0gcGFyc2VyLmNhY2hlLmdldChpYkNhY2hlS2V5KTtcbiAgICAgICAgaWYgKCFpYikge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlldywgaWJTbGljZSAqIGJ5dGVTdHJpZGUsIGFjY2Vzc29yRGVmLmNvdW50ICogYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyk7XG4gICAgICAgICAgaWIgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXIoYXJyYXksIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMpO1xuICAgICAgICAgIHBhcnNlci5jYWNoZS5hZGQoaWJDYWNoZUtleSwgaWIpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShcbiAgICAgICAgICBpYixcbiAgICAgICAgICBpdGVtU2l6ZSxcbiAgICAgICAgICBieXRlT2Zmc2V0ICUgYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyxcbiAgICAgICAgICBub3JtYWxpemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYnVmZmVyVmlldyA9PT0gbnVsbCkge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShidWZmZXJWaWV3LCBieXRlT2Zmc2V0LCBhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gICAgICB9XG4gICAgICBpZiAoYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgaXRlbVNpemVJbmRpY2VzID0gV0VCR0xfVFlQRV9TSVpFUy5TQ0FMQVI7XG4gICAgICAgIGNvbnN0IFR5cGVkQXJyYXlJbmRpY2VzID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmNvbXBvbmVudFR5cGVdO1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0SW5kaWNlcyA9IGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldFZhbHVlcyA9IGFjY2Vzc29yRGVmLnNwYXJzZS52YWx1ZXMuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBzcGFyc2VJbmRpY2VzID0gbmV3IFR5cGVkQXJyYXlJbmRpY2VzKFxuICAgICAgICAgIGJ1ZmZlclZpZXdzWzFdLFxuICAgICAgICAgIGJ5dGVPZmZzZXRJbmRpY2VzLFxuICAgICAgICAgIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplSW5kaWNlc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBzcGFyc2VWYWx1ZXMgPSBuZXcgVHlwZWRBcnJheShidWZmZXJWaWV3c1syXSwgYnl0ZU9mZnNldFZhbHVlcywgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICBpZiAoYnVmZmVyVmlldyAhPT0gbnVsbCkge1xuICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSxcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSxcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5ub3JtYWxpemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBzcGFyc2VJbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHNwYXJzZUluZGljZXNbaV07XG4gICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFgoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemVdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gMilcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRZKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgMV0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSAzKVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFooaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAyXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDQpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0VyhpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDNdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gNSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGl0ZW1TaXplIGluIHNwYXJzZSBCdWZmZXJBdHRyaWJ1dGUuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyQXR0cmlidXRlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjdGV4dHVyZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRleHR1cmVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLlRleHR1cmV8bnVsbD59XG4gICAqL1xuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBjb25zdCBzb3VyY2VJbmRleCA9IHRleHR1cmVEZWYuc291cmNlO1xuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBsZXQgbG9hZGVyID0gdGhpcy50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2VEZWYudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gb3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlRGVmLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIHNvdXJjZUluZGV4LCBsb2FkZXIpO1xuICB9XG4gIGxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBzb3VyY2VJbmRleCwgbG9hZGVyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gKHNvdXJjZURlZi51cmkgfHwgc291cmNlRGVmLmJ1ZmZlclZpZXcpICsgXCI6XCIgKyB0ZXh0dXJlRGVmLnNhbXBsZXI7XG4gICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubG9hZEltYWdlU291cmNlKHNvdXJjZUluZGV4LCBsb2FkZXIpLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgdGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgdGV4dHVyZS5uYW1lID0gdGV4dHVyZURlZi5uYW1lIHx8IHNvdXJjZURlZi5uYW1lIHx8IFwiXCI7XG4gICAgICBpZiAodGV4dHVyZS5uYW1lID09PSBcIlwiICYmIHR5cGVvZiBzb3VyY2VEZWYudXJpID09PSBcInN0cmluZ1wiICYmIHNvdXJjZURlZi51cmkuc3RhcnRzV2l0aChcImRhdGE6aW1hZ2UvXCIpID09PSBmYWxzZSkge1xuICAgICAgICB0ZXh0dXJlLm5hbWUgPSBzb3VyY2VEZWYudXJpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2FtcGxlcnMgPSBqc29uLnNhbXBsZXJzIHx8IHt9O1xuICAgICAgY29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzW3RleHR1cmVEZWYuc2FtcGxlcl0gfHwge307XG4gICAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbc2FtcGxlci5tYWdGaWx0ZXJdIHx8IExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUubWluRmlsdGVyID0gV0VCR0xfRklMVEVSU1tzYW1wbGVyLm1pbkZpbHRlcl0gfHwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS53cmFwUyA9IFdFQkdMX1dSQVBQSU5HU1tzYW1wbGVyLndyYXBTXSB8fCBSZXBlYXRXcmFwcGluZztcbiAgICAgIHRleHR1cmUud3JhcFQgPSBXRUJHTF9XUkFQUElOR1Nbc2FtcGxlci53cmFwVF0gfHwgUmVwZWF0V3JhcHBpbmc7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldCh0ZXh0dXJlLCB7IHRleHR1cmVzOiB0ZXh0dXJlSW5kZXggfSk7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICAgIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgbG9hZEltYWdlU291cmNlKHNvdXJjZUluZGV4LCBsb2FkZXIpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdLnRoZW4oKHRleHR1cmUpID0+IHRleHR1cmUuY2xvbmUoKSk7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBjb25zdCBVUkwgPSBzZWxmLlVSTCB8fCBzZWxmLndlYmtpdFVSTDtcbiAgICBsZXQgc291cmNlVVJJID0gc291cmNlRGVmLnVyaSB8fCBcIlwiO1xuICAgIGxldCBpc09iamVjdFVSTCA9IGZhbHNlO1xuICAgIGlmIChzb3VyY2VEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICBzb3VyY2VVUkkgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgc291cmNlRGVmLmJ1ZmZlclZpZXcpLnRoZW4oZnVuY3Rpb24oYnVmZmVyVmlldykge1xuICAgICAgICBpc09iamVjdFVSTCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyVmlld10sIHsgdHlwZTogc291cmNlRGVmLm1pbWVUeXBlIH0pO1xuICAgICAgICBzb3VyY2VVUkkgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICByZXR1cm4gc291cmNlVVJJO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VEZWYudXJpID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEltYWdlIFwiICsgc291cmNlSW5kZXggKyBcIiBpcyBtaXNzaW5nIFVSSSBhbmQgYnVmZmVyVmlld1wiKTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShzb3VyY2VVUkkpLnRoZW4oZnVuY3Rpb24oc291cmNlVVJJMikge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBsZXQgb25Mb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgaWYgKGxvYWRlci5pc0ltYWdlQml0bWFwTG9hZGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgb25Mb2FkID0gZnVuY3Rpb24oaW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShpbWFnZUJpdG1hcCk7XG4gICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUodGV4dHVyZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIubG9hZChMb2FkZXJVdGlscy5yZXNvbHZlVVJMKHNvdXJjZVVSSTIsIG9wdGlvbnMucGF0aCksIG9uTG9hZCwgdm9pZCAwLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSkudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICBpZiAoaXNPYmplY3RVUkwgPT09IHRydWUpIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChzb3VyY2VVUkkpO1xuICAgICAgfVxuICAgICAgdGV4dHVyZS51c2VyRGF0YS5taW1lVHlwZSA9IHNvdXJjZURlZi5taW1lVHlwZSB8fCBnZXRJbWFnZVVSSU1pbWVUeXBlKHNvdXJjZURlZi51cmkpO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBDb3VsZG4ndCBsb2FkIHRleHR1cmVcIiwgc291cmNlVVJJKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgYXNzaWducyBhIHRleHR1cmUgdG8gdGhlIGdpdmVuIG1hdGVyaWFsIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXRlcmlhbFBhcmFtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFwTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwRGVmXG4gICAqIEByZXR1cm4ge1Byb21pc2U8VGV4dHVyZT59XG4gICAqL1xuICBhc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBtYXBOYW1lLCBtYXBEZWYsIGVuY29kaW5nKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KFwidGV4dHVyZVwiLCBtYXBEZWYuaW5kZXgpLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgaWYgKCF0ZXh0dXJlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChtYXBEZWYudGV4Q29vcmQgIT09IHZvaWQgMCAmJiBtYXBEZWYudGV4Q29vcmQgPiAwKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG4gICAgICAgIHRleHR1cmUuY2hhbm5lbCA9IG1hcERlZi50ZXhDb29yZDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZXIuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0pIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gbWFwRGVmLmV4dGVuc2lvbnMgIT09IHZvaWQgMCA/IG1hcERlZi5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgIGNvbnN0IGdsdGZSZWZlcmVuY2UgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldCh0ZXh0dXJlKTtcbiAgICAgICAgICB0ZXh0dXJlID0gcGFyc2VyLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dLmV4dGVuZFRleHR1cmUodGV4dHVyZSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldCh0ZXh0dXJlLCBnbHRmUmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVuY29kaW5nICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKFwiY29sb3JTcGFjZVwiIGluIHRleHR1cmUpXG4gICAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gZW5jb2RpbmcgPT09IDMwMDEgPyBcInNyZ2JcIiA6IFwic3JnYi1saW5lYXJcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsUGFyYW1zW21hcE5hbWVdID0gdGV4dHVyZTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ25zIGZpbmFsIG1hdGVyaWFsIHRvIGEgTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLiBUaGUgaW5zdGFuY2VcbiAgICogYWxyZWFkeSBoYXMgYSBtYXRlcmlhbCAoZ2VuZXJhdGVkIGZyb20gdGhlIGdsVEYgbWF0ZXJpYWwgb3B0aW9ucyBhbG9uZSlcbiAgICogYnV0IHJldXNlIG9mIHRoZSBzYW1lIGdsVEYgbWF0ZXJpYWwgbWF5IHJlcXVpcmUgbXVsdGlwbGUgdGhyZWVqcyBtYXRlcmlhbHNcbiAgICogdG8gYWNjb21tb2RhdGUgZGlmZmVyZW50IHByaW1pdGl2ZSB0eXBlcywgZGVmaW5lcywgZXRjLiBOZXcgbWF0ZXJpYWxzIHdpbGxcbiAgICogYmUgY3JlYXRlZCBpZiBuZWNlc3NhcnksIGFuZCByZXVzZWQgZnJvbSBhIGNhY2hlLlxuICAgKiBAcGFyYW0gIHtPYmplY3QzRH0gbWVzaCBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuXG4gICAqL1xuICBhc3NpZ25GaW5hbE1hdGVyaWFsKG1lc2gpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG1lc2guZ2VvbWV0cnk7XG4gICAgbGV0IG1hdGVyaWFsID0gbWVzaC5tYXRlcmlhbDtcbiAgICBjb25zdCB1c2VEZXJpdmF0aXZlVGFuZ2VudHMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQgPT09IHZvaWQgMDtcbiAgICBjb25zdCB1c2VWZXJ0ZXhDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB2b2lkIDA7XG4gICAgY29uc3QgdXNlRmxhdFNoYWRpbmcgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdm9pZCAwO1xuICAgIGlmIChtZXNoLmlzUG9pbnRzKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IFwiUG9pbnRzTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkO1xuICAgICAgbGV0IHBvaW50c01hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFwb2ludHNNYXRlcmlhbCkge1xuICAgICAgICBwb2ludHNNYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCgpO1xuICAgICAgICBNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKHBvaW50c01hdGVyaWFsLCBtYXRlcmlhbCk7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLmNvbG9yLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgcG9pbnRzTWF0ZXJpYWwpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBwb2ludHNNYXRlcmlhbDtcbiAgICB9IGVsc2UgaWYgKG1lc2guaXNMaW5lKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IFwiTGluZUJhc2ljTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkO1xuICAgICAgbGV0IGxpbmVNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghbGluZU1hdGVyaWFsKSB7XG4gICAgICAgIGxpbmVNYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuICAgICAgICBNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKGxpbmVNYXRlcmlhbCwgbWF0ZXJpYWwpO1xuICAgICAgICBsaW5lTWF0ZXJpYWwuY29sb3IuY29weShtYXRlcmlhbC5jb2xvcik7XG4gICAgICAgIGxpbmVNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBsaW5lTWF0ZXJpYWwpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBsaW5lTWF0ZXJpYWw7XG4gICAgfVxuICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMgfHwgdXNlVmVydGV4Q29sb3JzIHx8IHVzZUZsYXRTaGFkaW5nKSB7XG4gICAgICBsZXQgY2FjaGVLZXkgPSBcIkNsb25lZE1hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZCArIFwiOlwiO1xuICAgICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJkZXJpdmF0aXZlLXRhbmdlbnRzOlwiO1xuICAgICAgaWYgKHVzZVZlcnRleENvbG9ycylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJ2ZXJ0ZXgtY29sb3JzOlwiO1xuICAgICAgaWYgKHVzZUZsYXRTaGFkaW5nKVxuICAgICAgICBjYWNoZUtleSArPSBcImZsYXQtc2hhZGluZzpcIjtcbiAgICAgIGxldCBjYWNoZWRNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghY2FjaGVkTWF0ZXJpYWwpIHtcbiAgICAgICAgY2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICBpZiAodXNlVmVydGV4Q29sb3JzKVxuICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG4gICAgICAgIGlmICh1c2VGbGF0U2hhZGluZylcbiAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5mbGF0U2hhZGluZyA9IHRydWU7XG4gICAgICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMpIHtcbiAgICAgICAgICBpZiAoY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUpXG4gICAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5ub3JtYWxTY2FsZS55ICo9IC0xO1xuICAgICAgICAgIGlmIChjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSlcbiAgICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlLnkgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGNhY2hlZE1hdGVyaWFsKTtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGNhY2hlZE1hdGVyaWFsLCB0aGlzLmFzc29jaWF0aW9ucy5nZXQobWF0ZXJpYWwpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gY2FjaGVkTWF0ZXJpYWw7XG4gICAgfVxuICAgIG1lc2gubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUoKSB7XG4gICAgcmV0dXJuIE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21hdGVyaWFsc1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWF0ZXJpYWxJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1hdGVyaWFsPn1cbiAgICovXG4gIGxvYWRNYXRlcmlhbChtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBqc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBsZXQgbWF0ZXJpYWxUeXBlO1xuICAgIGNvbnN0IG1hdGVyaWFsUGFyYW1zID0ge307XG4gICAgY29uc3QgbWF0ZXJpYWxFeHRlbnNpb25zID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgaWYgKG1hdGVyaWFsRXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVRdKSB7XG4gICAgICBjb25zdCBrbXVFeHRlbnNpb24gPSBleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVF07XG4gICAgICBtYXRlcmlhbFR5cGUgPSBrbXVFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG4gICAgICBwZW5kaW5nLnB1c2goa211RXh0ZW5zaW9uLmV4dGVuZFBhcmFtcyhtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzIHx8IHt9O1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcikpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheShhcnJheSk7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVszXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCAzMDAxKSk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbFBhcmFtcy5tZXRhbG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciAhPT0gdm9pZCAwID8gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgOiAxO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMucm91Z2huZXNzID0gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yICE9PSB2b2lkIDAgPyBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgOiAxO1xuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJtZXRhbG5lc3NNYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJyb3VnaG5lc3NNYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbFR5cGUgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgIHJldHVybiBleHQuZ2V0TWF0ZXJpYWxUeXBlICYmIGV4dC5nZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5leHRlbmRNYXRlcmlhbFBhcmFtcyAmJiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpO1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5kb3VibGVTaWRlZCA9PT0gdHJ1ZSkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2lkZSA9IERvdWJsZVNpZGU7XG4gICAgfVxuICAgIGNvbnN0IGFscGhhTW9kZSA9IG1hdGVyaWFsRGVmLmFscGhhTW9kZSB8fCBBTFBIQV9NT0RFUy5PUEFRVUU7XG4gICAgaWYgKGFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuQkxFTkQpIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmRlcHRoV3JpdGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLk1BU0spIHtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuYWxwaGFUZXN0ID0gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgIT09IHZvaWQgMCA/IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmIDogMC41O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJub3JtYWxNYXBcIiwgbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSkpO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZS5zZXQoc2NhbGUsIHNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiYW9NYXBcIiwgbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSkpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5hb01hcEludGVuc2l0eSA9IG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3RvciAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yKTtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJlbWlzc2l2ZU1hcFwiLCBtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUsIDMwMDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBtYXRlcmlhbFR5cGUobWF0ZXJpYWxQYXJhbXMpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm5hbWUpXG4gICAgICAgIG1hdGVyaWFsLm5hbWUgPSBtYXRlcmlhbERlZi5uYW1lO1xuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShtYXRlcmlhbCwgbWF0ZXJpYWxEZWYpO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobWF0ZXJpYWwsIHsgbWF0ZXJpYWxzOiBtYXRlcmlhbEluZGV4IH0pO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYpO1xuICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuICAgIH0pO1xuICB9XG4gIC8qKiBXaGVuIE9iamVjdDNEIGluc3RhbmNlcyBhcmUgdGFyZ2V0ZWQgYnkgYW5pbWF0aW9uLCB0aGV5IG5lZWQgdW5pcXVlIG5hbWVzLiAqL1xuICBjcmVhdGVVbmlxdWVOYW1lKG9yaWdpbmFsTmFtZSkge1xuICAgIGNvbnN0IHNhbml0aXplZE5hbWUgPSBQcm9wZXJ0eUJpbmRpbmcuc2FuaXRpemVOb2RlTmFtZShvcmlnaW5hbE5hbWUgfHwgXCJcIik7XG4gICAgaWYgKHNhbml0aXplZE5hbWUgaW4gdGhpcy5ub2RlTmFtZXNVc2VkKSB7XG4gICAgICByZXR1cm4gc2FuaXRpemVkTmFtZSArIFwiX1wiICsgKyt0aGlzLm5vZGVOYW1lc1VzZWRbc2FuaXRpemVkTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZU5hbWVzVXNlZFtzYW5pdGl6ZWROYW1lXSA9IDA7XG4gICAgICByZXR1cm4gc2FuaXRpemVkTmFtZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjZ2VvbWV0cnlcbiAgICpcbiAgICogQ3JlYXRlcyBCdWZmZXJHZW9tZXRyaWVzIGZyb20gcHJpbWl0aXZlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxHTFRGLlByaW1pdGl2ZT59IHByaW1pdGl2ZXNcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxCdWZmZXJHZW9tZXRyeT4+fVxuICAgKi9cbiAgbG9hZEdlb21ldHJpZXMocHJpbWl0aXZlcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMucHJpbWl0aXZlQ2FjaGU7XG4gICAgZnVuY3Rpb24gY3JlYXRlRHJhY29QcmltaXRpdmUocHJpbWl0aXZlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXS5kZWNvZGVQcmltaXRpdmUocHJpbWl0aXZlLCBwYXJzZXIpLnRoZW4oZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICAgICAgcmV0dXJuIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoZ2VvbWV0cnksIHByaW1pdGl2ZSwgcGFyc2VyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzW2ldO1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVQcmltaXRpdmVLZXkocHJpbWl0aXZlKTtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKGNhY2hlZC5wcm9taXNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBnZW9tZXRyeVByb21pc2U7XG4gICAgICAgIGlmIChwcmltaXRpdmUuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmUuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXSkge1xuICAgICAgICAgIGdlb21ldHJ5UHJvbWlzZSA9IGNyZWF0ZURyYWNvUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VvbWV0cnlQcm9taXNlID0gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhuZXcgQnVmZmVyR2VvbWV0cnkoKSwgcHJpbWl0aXZlLCBwYXJzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHsgcHJpbWl0aXZlLCBwcm9taXNlOiBnZW9tZXRyeVByb21pc2UgfTtcbiAgICAgICAgcGVuZGluZy5wdXNoKGdlb21ldHJ5UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtZXNoZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1lc2hJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwfE1lc2h8U2tpbm5lZE1lc2g+fVxuICAgKi9cbiAgbG9hZE1lc2gobWVzaEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgbWVzaERlZiA9IGpzb24ubWVzaGVzW21lc2hJbmRleF07XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IG1lc2hEZWYucHJpbWl0aXZlcztcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IHByaW1pdGl2ZXNbaV0ubWF0ZXJpYWwgPT09IHZvaWQgMCA/IGNyZWF0ZURlZmF1bHRNYXRlcmlhbCh0aGlzLmNhY2hlKSA6IHRoaXMuZ2V0RGVwZW5kZW5jeShcIm1hdGVyaWFsXCIsIHByaW1pdGl2ZXNbaV0ubWF0ZXJpYWwpO1xuICAgICAgcGVuZGluZy5wdXNoKG1hdGVyaWFsKTtcbiAgICB9XG4gICAgcGVuZGluZy5wdXNoKHBhcnNlci5sb2FkR2VvbWV0cmllcyhwcmltaXRpdmVzKSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3QgbWF0ZXJpYWxzID0gcmVzdWx0cy5zbGljZSgwLCByZXN1bHRzLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IG1lc2hlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1tpXTtcbiAgICAgICAgbGV0IG1lc2g7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbWF0ZXJpYWxzW2ldO1xuICAgICAgICBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVMgfHwgcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCB8fCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiB8fCBwcmltaXRpdmUubW9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbWVzaCA9IG1lc2hEZWYuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSA/IG5ldyBTa2lubmVkTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpIDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICBpZiAobWVzaC5pc1NraW5uZWRNZXNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtZXNoLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZShtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZVN0cmlwRHJhd01vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4pIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlRmFuRHJhd01vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVTKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfU1RSSVApIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfTE9PUCkge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZUxvb3AoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlBPSU5UUykge1xuICAgICAgICAgIG1lc2ggPSBuZXcgUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogUHJpbWl0aXZlIG1vZGUgdW5zdXBwb3J0ZWQ6IFwiICsgcHJpbWl0aXZlLm1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtZXNoLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVwZGF0ZU1vcnBoVGFyZ2V0cyhtZXNoLCBtZXNoRGVmKTtcbiAgICAgICAgfVxuICAgICAgICBtZXNoLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShtZXNoRGVmLm5hbWUgfHwgXCJtZXNoX1wiICsgbWVzaEluZGV4KTtcbiAgICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShtZXNoLCBtZXNoRGVmKTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5leHRlbnNpb25zKVxuICAgICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtZXNoLCBwcmltaXRpdmUpO1xuICAgICAgICBwYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChtZXNoKTtcbiAgICAgICAgbWVzaGVzLnB1c2gobWVzaCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChtZXNoZXNbaV0sIHtcbiAgICAgICAgICBtZXNoZXM6IG1lc2hJbmRleCxcbiAgICAgICAgICBwcmltaXRpdmVzOiBpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1lc2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKG1lc2hEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWVzaGVzWzBdLCBtZXNoRGVmKTtcbiAgICAgICAgcmV0dXJuIG1lc2hlc1swXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKCk7XG4gICAgICBpZiAobWVzaERlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgZ3JvdXAsIG1lc2hEZWYpO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoZ3JvdXAsIHsgbWVzaGVzOiBtZXNoSW5kZXggfSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cC5hZGQobWVzaGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2NhbWVyYXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNhbWVyYUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuQ2FtZXJhPn1cbiAgICovXG4gIGxvYWRDYW1lcmEoY2FtZXJhSW5kZXgpIHtcbiAgICBsZXQgY2FtZXJhO1xuICAgIGNvbnN0IGNhbWVyYURlZiA9IHRoaXMuanNvbi5jYW1lcmFzW2NhbWVyYUluZGV4XTtcbiAgICBjb25zdCBwYXJhbXMgPSBjYW1lcmFEZWZbY2FtZXJhRGVmLnR5cGVdO1xuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIGNhbWVyYSBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhbWVyYURlZi50eXBlID09PSBcInBlcnNwZWN0aXZlXCIpIHtcbiAgICAgIGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShcbiAgICAgICAgTWF0aFV0aWxzLnJhZFRvRGVnKHBhcmFtcy55Zm92KSxcbiAgICAgICAgcGFyYW1zLmFzcGVjdFJhdGlvIHx8IDEsXG4gICAgICAgIHBhcmFtcy56bmVhciB8fCAxLFxuICAgICAgICBwYXJhbXMuemZhciB8fCAyZTZcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjYW1lcmFEZWYudHlwZSA9PT0gXCJvcnRob2dyYXBoaWNcIikge1xuICAgICAgY2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSgtcGFyYW1zLnhtYWcsIHBhcmFtcy54bWFnLCBwYXJhbXMueW1hZywgLXBhcmFtcy55bWFnLCBwYXJhbXMuem5lYXIsIHBhcmFtcy56ZmFyKTtcbiAgICB9XG4gICAgaWYgKGNhbWVyYURlZi5uYW1lKVxuICAgICAgY2FtZXJhLm5hbWUgPSB0aGlzLmNyZWF0ZVVuaXF1ZU5hbWUoY2FtZXJhRGVmLm5hbWUpO1xuICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoY2FtZXJhLCBjYW1lcmFEZWYpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NraW5zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBza2luSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxTa2VsZXRvbj59XG4gICAqL1xuICBsb2FkU2tpbihza2luSW5kZXgpIHtcbiAgICBjb25zdCBza2luRGVmID0gdGhpcy5qc29uLnNraW5zW3NraW5JbmRleF07XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHNraW5EZWYuam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHBlbmRpbmcucHVzaCh0aGlzLl9sb2FkTm9kZVNoYWxsb3coc2tpbkRlZi5qb2ludHNbaV0pKTtcbiAgICB9XG4gICAgaWYgKHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcyAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmcucHVzaChudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3QgaW52ZXJzZUJpbmRNYXRyaWNlcyA9IHJlc3VsdHMucG9wKCk7XG4gICAgICBjb25zdCBqb2ludE5vZGVzID0gcmVzdWx0cztcbiAgICAgIGNvbnN0IGJvbmVzID0gW107XG4gICAgICBjb25zdCBib25lSW52ZXJzZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGpvaW50Tm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBqb2ludE5vZGUgPSBqb2ludE5vZGVzW2ldO1xuICAgICAgICBpZiAoam9pbnROb2RlKSB7XG4gICAgICAgICAgYm9uZXMucHVzaChqb2ludE5vZGUpO1xuICAgICAgICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgICAgaWYgKGludmVyc2VCaW5kTWF0cmljZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1hdC5mcm9tQXJyYXkoaW52ZXJzZUJpbmRNYXRyaWNlcy5hcnJheSwgaSAqIDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9uZUludmVyc2VzLnB1c2gobWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkdMVEZMb2FkZXI6IEpvaW50IFwiJXNcIiBjb3VsZCBub3QgYmUgZm91bmQuJywgc2tpbkRlZi5qb2ludHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNrZWxldG9uKGJvbmVzLCBib25lSW52ZXJzZXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjYW5pbWF0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0aW9uSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBbmltYXRpb25DbGlwPn1cbiAgICovXG4gIGxvYWRBbmltYXRpb24oYW5pbWF0aW9uSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRlZiA9IGpzb24uYW5pbWF0aW9uc1thbmltYXRpb25JbmRleF07XG4gICAgY29uc3QgYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbkRlZi5uYW1lID8gYW5pbWF0aW9uRGVmLm5hbWUgOiBcImFuaW1hdGlvbl9cIiArIGFuaW1hdGlvbkluZGV4O1xuICAgIGNvbnN0IHBlbmRpbmdOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdJbnB1dEFjY2Vzc29ycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nU2FtcGxlcnMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nVGFyZ2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVscy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzW2ldO1xuICAgICAgY29uc3Qgc2FtcGxlciA9IGFuaW1hdGlvbkRlZi5zYW1wbGVyc1tjaGFubmVsLnNhbXBsZXJdO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2hhbm5lbC50YXJnZXQ7XG4gICAgICBjb25zdCBuYW1lID0gdGFyZ2V0Lm5vZGU7XG4gICAgICBjb25zdCBpbnB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1tzYW1wbGVyLmlucHV0XSA6IHNhbXBsZXIuaW5wdXQ7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhbmltYXRpb25EZWYucGFyYW1ldGVycyAhPT0gdm9pZCAwID8gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnNbc2FtcGxlci5vdXRwdXRdIDogc2FtcGxlci5vdXRwdXQ7XG4gICAgICBpZiAodGFyZ2V0Lm5vZGUgPT09IHZvaWQgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBwZW5kaW5nTm9kZXMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJub2RlXCIsIG5hbWUpKTtcbiAgICAgIHBlbmRpbmdJbnB1dEFjY2Vzc29ycy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGlucHV0KSk7XG4gICAgICBwZW5kaW5nT3V0cHV0QWNjZXNzb3JzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgb3V0cHV0KSk7XG4gICAgICBwZW5kaW5nU2FtcGxlcnMucHVzaChzYW1wbGVyKTtcbiAgICAgIHBlbmRpbmdUYXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdOb2RlcyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nSW5wdXRBY2Nlc3NvcnMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ091dHB1dEFjY2Vzc29ycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nU2FtcGxlcnMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ1RhcmdldHMpXG4gICAgXSkudGhlbihmdW5jdGlvbihkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gZGVwZW5kZW5jaWVzWzBdO1xuICAgICAgY29uc3QgaW5wdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbMV07XG4gICAgICBjb25zdCBvdXRwdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbMl07XG4gICAgICBjb25zdCBzYW1wbGVycyA9IGRlcGVuZGVuY2llc1szXTtcbiAgICAgIGNvbnN0IHRhcmdldHMgPSBkZXBlbmRlbmNpZXNbNF07XG4gICAgICBjb25zdCB0cmFja3MgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBjb25zdCBpbnB1dEFjY2Vzc29yID0gaW5wdXRBY2Nlc3NvcnNbaV07XG4gICAgICAgIGNvbnN0IG91dHB1dEFjY2Vzc29yID0gb3V0cHV0QWNjZXNzb3JzW2ldO1xuICAgICAgICBjb25zdCBzYW1wbGVyID0gc2FtcGxlcnNbaV07XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIG5vZGUudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIGxldCBUeXBlZEtleWZyYW1lVHJhY2s7XG4gICAgICAgIHN3aXRjaCAoUEFUSF9QUk9QRVJUSUVTW3RhcmdldC5wYXRoXSkge1xuICAgICAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLndlaWdodHM6XG4gICAgICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMucm90YXRpb246XG4gICAgICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnBvc2l0aW9uOlxuICAgICAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnNjYWxlOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IG5vZGUubmFtZSA/IG5vZGUubmFtZSA6IG5vZGUudXVpZDtcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IHNhbXBsZXIuaW50ZXJwb2xhdGlvbiAhPT0gdm9pZCAwID8gSU5URVJQT0xBVElPTltzYW1wbGVyLmludGVycG9sYXRpb25dIDogSW50ZXJwb2xhdGVMaW5lYXI7XG4gICAgICAgIGNvbnN0IHRhcmdldE5hbWVzID0gW107XG4gICAgICAgIGlmIChQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdID09PSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0cykge1xuICAgICAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcykge1xuICAgICAgICAgICAgICB0YXJnZXROYW1lcy5wdXNoKG9iamVjdC5uYW1lID8gb2JqZWN0Lm5hbWUgOiBvYmplY3QudXVpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0TmFtZXMucHVzaCh0YXJnZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0cHV0QXJyYXkgPSBvdXRwdXRBY2Nlc3Nvci5hcnJheTtcbiAgICAgICAgaWYgKG91dHB1dEFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICBjb25zdCBzY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShvdXRwdXRBcnJheS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkID0gbmV3IEZsb2F0MzJBcnJheShvdXRwdXRBcnJheS5sZW5ndGgpO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG91dHB1dEFycmF5Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgIHNjYWxlZFtqXSA9IG91dHB1dEFycmF5W2pdICogc2NhbGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dEFycmF5ID0gc2NhbGVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICBjb25zdCB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2soXG4gICAgICAgICAgICB0YXJnZXROYW1lc1tqXSArIFwiLlwiICsgUEFUSF9QUk9QRVJUSUVTW3RhcmdldC5wYXRoXSxcbiAgICAgICAgICAgIGlucHV0QWNjZXNzb3IuYXJyYXksXG4gICAgICAgICAgICBvdXRwdXRBcnJheSxcbiAgICAgICAgICAgIGludGVycG9sYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChzYW1wbGVyLmludGVycG9sYXRpb24gPT09IFwiQ1VCSUNTUExJTkVcIikge1xuICAgICAgICAgICAgdHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgPSBmdW5jdGlvbiBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGludGVycG9sYW50VHlwZSA9IHRoaXMgaW5zdGFuY2VvZiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayA/IEdMVEZDdWJpY1NwbGluZVF1YXRlcm5pb25JbnRlcnBvbGFudCA6IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50O1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IGludGVycG9sYW50VHlwZSh0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSAvIDMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2suY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFja3MucHVzaCh0cmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcChhbmltYXRpb25OYW1lLCB2b2lkIDAsIHRyYWNrcyk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgaWYgKG5vZGVEZWYubWVzaCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwibWVzaFwiLCBub2RlRGVmLm1lc2gpLnRoZW4oZnVuY3Rpb24obWVzaCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHBhcnNlci5fZ2V0Tm9kZVJlZihwYXJzZXIubWVzaENhY2hlLCBub2RlRGVmLm1lc2gsIG1lc2gpO1xuICAgICAgaWYgKG5vZGVEZWYud2VpZ2h0cyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24obykge1xuICAgICAgICAgIGlmICghby5pc01lc2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZURlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICAgIG8ubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldID0gbm9kZURlZi53ZWlnaHRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI25vZGVzLWFuZC1oaWVyYXJjaHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vZGVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEPn1cbiAgICovXG4gIGxvYWROb2RlKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IG5vZGVQZW5kaW5nID0gcGFyc2VyLl9sb2FkTm9kZVNoYWxsb3cobm9kZUluZGV4KTtcbiAgICBjb25zdCBjaGlsZFBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBjaGlsZHJlbkRlZiA9IG5vZGVEZWYuY2hpbGRyZW4gfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gY2hpbGRyZW5EZWYubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY2hpbGRQZW5kaW5nLnB1c2gocGFyc2VyLmdldERlcGVuZGVuY3koXCJub2RlXCIsIGNoaWxkcmVuRGVmW2ldKSk7XG4gICAgfVxuICAgIGNvbnN0IHNrZWxldG9uUGVuZGluZyA9IG5vZGVEZWYuc2tpbiA9PT0gdm9pZCAwID8gUHJvbWlzZS5yZXNvbHZlKG51bGwpIDogcGFyc2VyLmdldERlcGVuZGVuY3koXCJza2luXCIsIG5vZGVEZWYuc2tpbik7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtub2RlUGVuZGluZywgUHJvbWlzZS5hbGwoY2hpbGRQZW5kaW5nKSwgc2tlbGV0b25QZW5kaW5nXSkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBub2RlID0gcmVzdWx0c1swXTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gcmVzdWx0c1sxXTtcbiAgICAgIGNvbnN0IHNrZWxldG9uID0gcmVzdWx0c1syXTtcbiAgICAgIGlmIChza2VsZXRvbiAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG1lc2gpIHtcbiAgICAgICAgICBpZiAoIW1lc2guaXNTa2lubmVkTWVzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBtZXNoLmJpbmQoc2tlbGV0b24sIF9pZGVudGl0eU1hdHJpeCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBub2RlLmFkZChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuICAvLyAuX2xvYWROb2RlU2hhbGxvdygpIHBhcnNlcyBhIHNpbmdsZSBub2RlLlxuICAvLyBza2luIGFuZCBjaGlsZCBub2RlcyBhcmUgY3JlYXRlZCBhbmQgYWRkZWQgaW4gLmxvYWROb2RlKCkgKG5vICdfJyBwcmVmaXgpLlxuICBfbG9hZE5vZGVTaGFsbG93KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGlmICh0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdO1xuICAgIH1cbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IG5vZGVOYW1lID0gbm9kZURlZi5uYW1lID8gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobm9kZURlZi5uYW1lKSA6IFwiXCI7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IG1lc2hQcm9taXNlID0gcGFyc2VyLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0LmNyZWF0ZU5vZGVNZXNoICYmIGV4dC5jcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpO1xuICAgIH0pO1xuICAgIGlmIChtZXNoUHJvbWlzZSkge1xuICAgICAgcGVuZGluZy5wdXNoKG1lc2hQcm9taXNlKTtcbiAgICB9XG4gICAgaWYgKG5vZGVEZWYuY2FtZXJhICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY3koXCJjYW1lcmFcIiwgbm9kZURlZi5jYW1lcmEpLnRoZW4oZnVuY3Rpb24oY2FtZXJhKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZihwYXJzZXIuY2FtZXJhQ2FjaGUsIG5vZGVEZWYuY2FtZXJhLCBjYW1lcmEpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcGFyc2VyLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50ICYmIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudChub2RlSW5kZXgpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgcGVuZGluZy5wdXNoKHByb21pc2UpO1xuICAgIH0pO1xuICAgIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF0gPSBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgICAgIGxldCBub2RlO1xuICAgICAgaWYgKG5vZGVEZWYuaXNCb25lID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgQm9uZSgpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBHcm91cCgpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBub2RlID0gb2JqZWN0c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgT2JqZWN0M0QoKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlICE9PSBvYmplY3RzWzBdKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIG5vZGUuYWRkKG9iamVjdHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZURlZi5uYW1lKSB7XG4gICAgICAgIG5vZGUudXNlckRhdGEubmFtZSA9IG5vZGVEZWYubmFtZTtcbiAgICAgICAgbm9kZS5uYW1lID0gbm9kZU5hbWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG5vZGUsIG5vZGVEZWYpO1xuICAgICAgaWYgKG5vZGVEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG5vZGUsIG5vZGVEZWYpO1xuICAgICAgaWYgKG5vZGVEZWYubWF0cml4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgbWF0cml4LmZyb21BcnJheShub2RlRGVmLm1hdHJpeCk7XG4gICAgICAgIG5vZGUuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZURlZi50cmFuc2xhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5wb3NpdGlvbi5mcm9tQXJyYXkobm9kZURlZi50cmFuc2xhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVEZWYucm90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUucXVhdGVybmlvbi5mcm9tQXJyYXkobm9kZURlZi5yb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVEZWYuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUuc2NhbGUuZnJvbUFycmF5KG5vZGVEZWYuc2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXBhcnNlci5hc3NvY2lhdGlvbnMuaGFzKG5vZGUpKSB7XG4gICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG5vZGUsIHt9KTtcbiAgICAgIH1cbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KG5vZGUpLm5vZGVzID0gbm9kZUluZGV4O1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNzY2VuZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjZW5lSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxHcm91cD59XG4gICAqL1xuICBsb2FkU2NlbmUoc2NlbmVJbmRleCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3Qgc2NlbmVEZWYgPSB0aGlzLmpzb24uc2NlbmVzW3NjZW5lSW5kZXhdO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgR3JvdXAoKTtcbiAgICBpZiAoc2NlbmVEZWYubmFtZSlcbiAgICAgIHNjZW5lLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShzY2VuZURlZi5uYW1lKTtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKHNjZW5lLCBzY2VuZURlZik7XG4gICAgaWYgKHNjZW5lRGVmLmV4dGVuc2lvbnMpXG4gICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgc2NlbmUsIHNjZW5lRGVmKTtcbiAgICBjb25zdCBub2RlSWRzID0gc2NlbmVEZWYubm9kZXMgfHwgW107XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVJZHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBub2RlSWRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHNjZW5lLmFkZChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWR1Y2VBc3NvY2lhdGlvbnMgPSAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByZWR1Y2VkQXNzb2NpYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcGFyc2VyLmFzc29jaWF0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBNYXRlcmlhbCB8fCBrZXkgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICByZWR1Y2VkQXNzb2NpYXRpb25zLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50cmF2ZXJzZSgobm9kZTIpID0+IHtcbiAgICAgICAgICBjb25zdCBtYXBwaW5ncyA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KG5vZGUyKTtcbiAgICAgICAgICBpZiAobWFwcGluZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVkdWNlZEFzc29jaWF0aW9ucy5zZXQobm9kZTIsIG1hcHBpbmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVkdWNlZEFzc29jaWF0aW9ucztcbiAgICAgIH07XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zID0gcmVkdWNlQXNzb2NpYXRpb25zKHNjZW5lKTtcbiAgICAgIHJldHVybiBzY2VuZTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kcyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIpIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuICBjb25zdCBib3ggPSBuZXcgQm94MygpO1xuICBpZiAoYXR0cmlidXRlcy5QT1NJVElPTiAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbYXR0cmlidXRlcy5QT1NJVElPTl07XG4gICAgY29uc3QgbWluID0gYWNjZXNzb3IubWluO1xuICAgIGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcbiAgICBpZiAobWluICE9PSB2b2lkIDAgJiYgbWF4ICE9PSB2b2lkIDApIHtcbiAgICAgIGJveC5zZXQobmV3IFZlY3RvcjMobWluWzBdLCBtaW5bMV0sIG1pblsyXSksIG5ldyBWZWN0b3IzKG1heFswXSwgbWF4WzFdLCBtYXhbMl0pKTtcbiAgICAgIGlmIChhY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IGJveFNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3Nvci5jb21wb25lbnRUeXBlXSk7XG4gICAgICAgIGJveC5taW4ubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgICBib3gubWF4Lm11bHRpcGx5U2NhbGFyKGJveFNjYWxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhcmdldHMgPSBwcmltaXRpdmVEZWYudGFyZ2V0cztcbiAgaWYgKHRhcmdldHMgIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IG1heERpc3BsYWNlbWVudCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICBpZiAodGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbdGFyZ2V0LlBPU0lUSU9OXTtcbiAgICAgICAgY29uc3QgbWluID0gYWNjZXNzb3IubWluO1xuICAgICAgICBjb25zdCBtYXggPSBhY2Nlc3Nvci5tYXg7XG4gICAgICAgIGlmIChtaW4gIT09IHZvaWQgMCAmJiBtYXggIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZlY3Rvci5zZXRYKE1hdGgubWF4KE1hdGguYWJzKG1pblswXSksIE1hdGguYWJzKG1heFswXSkpKTtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WShNYXRoLm1heChNYXRoLmFicyhtaW5bMV0pLCBNYXRoLmFicyhtYXhbMV0pKSk7XG4gICAgICAgICAgdmVjdG9yLnNldFooTWF0aC5tYXgoTWF0aC5hYnMobWluWzJdKSwgTWF0aC5hYnMobWF4WzJdKSkpO1xuICAgICAgICAgIGlmIChhY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICAgICAgICBjb25zdCBib3hTY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3IuY29tcG9uZW50VHlwZV0pO1xuICAgICAgICAgICAgdmVjdG9yLm11bHRpcGx5U2NhbGFyKGJveFNjYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF4RGlzcGxhY2VtZW50Lm1heCh2ZWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYm94LmV4cGFuZEJ5VmVjdG9yKG1heERpc3BsYWNlbWVudCk7XG4gIH1cbiAgZ2VvbWV0cnkuYm91bmRpbmdCb3ggPSBib3g7XG4gIGNvbnN0IHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcbiAgYm94LmdldENlbnRlcihzcGhlcmUuY2VudGVyKTtcbiAgc3BoZXJlLnJhZGl1cyA9IGJveC5taW4uZGlzdGFuY2VUbyhib3gubWF4KSAvIDI7XG4gIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gc3BoZXJlO1xufVxuZnVuY3Rpb24gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIpIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuICBjb25zdCBwZW5kaW5nID0gW107XG4gIGZ1bmN0aW9uIGFzc2lnbkF0dHJpYnV0ZUFjY2Vzc29yKGFjY2Vzc29ySW5kZXgsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBhY2Nlc3NvckluZGV4KS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29yKSB7XG4gICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYWNjZXNzb3IpO1xuICAgIH0pO1xuICB9XG4gIGZvciAoY29uc3QgZ2x0ZkF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbZ2x0ZkF0dHJpYnV0ZU5hbWVdIHx8IGdsdGZBdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRocmVlQXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKVxuICAgICAgY29udGludWU7XG4gICAgcGVuZGluZy5wdXNoKGFzc2lnbkF0dHJpYnV0ZUFjY2Vzc29yKGF0dHJpYnV0ZXNbZ2x0ZkF0dHJpYnV0ZU5hbWVdLCB0aHJlZUF0dHJpYnV0ZU5hbWUpKTtcbiAgfVxuICBpZiAocHJpbWl0aXZlRGVmLmluZGljZXMgIT09IHZvaWQgMCAmJiAhZ2VvbWV0cnkuaW5kZXgpIHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgcHJpbWl0aXZlRGVmLmluZGljZXMpLnRoZW4oZnVuY3Rpb24oYWNjZXNzb3IyKSB7XG4gICAgICBnZW9tZXRyeS5zZXRJbmRleChhY2Nlc3NvcjIpO1xuICAgIH0pO1xuICAgIHBlbmRpbmcucHVzaChhY2Nlc3Nvcik7XG4gIH1cbiAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShnZW9tZXRyeSwgcHJpbWl0aXZlRGVmKTtcbiAgY29tcHV0ZUJvdW5kcyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIpO1xuICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlRGVmLnRhcmdldHMgIT09IHZvaWQgMCA/IGFkZE1vcnBoVGFyZ2V0cyhnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLnRhcmdldHMsIHBhcnNlcikgOiBnZW9tZXRyeTtcbiAgfSk7XG59XG5leHBvcnQge1xuICBHTFRGTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xURkxvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJMb2FkZXIiLCJMb2FkZXJVdGlscyIsIkZpbGVMb2FkZXIiLCJDb2xvciIsIlNwb3RMaWdodCIsIlBvaW50TGlnaHQiLCJEaXJlY3Rpb25hbExpZ2h0IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJNZXNoUGh5c2ljYWxNYXRlcmlhbCIsIlZlY3RvcjIiLCJNYXRyaXg0IiwiVmVjdG9yMyIsIlF1YXRlcm5pb24iLCJJbnN0YW5jZWRNZXNoIiwiT2JqZWN0M0QiLCJUZXh0dXJlTG9hZGVyIiwiSW1hZ2VCaXRtYXBMb2FkZXIiLCJCdWZmZXJBdHRyaWJ1dGUiLCJJbnRlcmxlYXZlZEJ1ZmZlciIsIkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIiwiTGluZWFyRmlsdGVyIiwiTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyIiwiUmVwZWF0V3JhcHBpbmciLCJQb2ludHNNYXRlcmlhbCIsIk1hdGVyaWFsIiwiTGluZUJhc2ljTWF0ZXJpYWwiLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsIkRvdWJsZVNpZGUiLCJQcm9wZXJ0eUJpbmRpbmciLCJCdWZmZXJHZW9tZXRyeSIsIlNraW5uZWRNZXNoIiwiTWVzaCIsIlRyaWFuZ2xlU3RyaXBEcmF3TW9kZSIsIlRyaWFuZ2xlRmFuRHJhd01vZGUiLCJMaW5lU2VnbWVudHMiLCJMaW5lIiwiTGluZUxvb3AiLCJQb2ludHMiLCJHcm91cCIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiTWF0aFV0aWxzIiwiT3J0aG9ncmFwaGljQ2FtZXJhIiwiU2tlbGV0b24iLCJJbnRlcnBvbGF0ZUxpbmVhciIsIkFuaW1hdGlvbkNsaXAiLCJCb25lIiwiTmVhcmVzdEZpbHRlciIsIk5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyIiwiTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciIsIk5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIiLCJDbGFtcFRvRWRnZVdyYXBwaW5nIiwiTWlycm9yZWRSZXBlYXRXcmFwcGluZyIsIkludGVycG9sYXRlRGlzY3JldGUiLCJGcm9udFNpZGUiLCJUZXh0dXJlIiwiVmVjdG9yS2V5ZnJhbWVUcmFjayIsIlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrIiwiTnVtYmVyS2V5ZnJhbWVUcmFjayIsIkJveDMiLCJTcGhlcmUiLCJJbnRlcnBvbGFudCIsInRvVHJpYW5nbGVzRHJhd01vZGUiLCJ2ZXJzaW9uIiwiR0xURkxvYWRlciIsImNvbnN0cnVjdG9yIiwibWFuYWdlciIsImRyYWNvTG9hZGVyIiwia3R4MkxvYWRlciIsIm1lc2hvcHREZWNvZGVyIiwicGx1Z2luQ2FsbGJhY2tzIiwicmVnaXN0ZXIiLCJwYXJzZXIiLCJHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uIiwiR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24iLCJHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24iLCJHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzU2hlZW5FeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aEV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uIiwiR0xURkxpZ2h0c0V4dGVuc2lvbiIsIkdMVEZNZXNob3B0Q29tcHJlc3Npb24iLCJHTFRGTWVzaEdwdUluc3RhbmNpbmciLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJzY29wZSIsInJlc291cmNlUGF0aCIsInBhdGgiLCJleHRyYWN0VXJsQmFzZSIsIml0ZW1TdGFydCIsIl9vbkVycm9yIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsIml0ZW1FcnJvciIsIml0ZW1FbmQiLCJsb2FkZXIiLCJzZXRQYXRoIiwic2V0UmVzcG9uc2VUeXBlIiwic2V0UmVxdWVzdEhlYWRlciIsInJlcXVlc3RIZWFkZXIiLCJzZXRXaXRoQ3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJkYXRhIiwicGFyc2UiLCJnbHRmIiwic2V0RFJBQ09Mb2FkZXIiLCJzZXRERFNMb2FkZXIiLCJFcnJvciIsInNldEtUWDJMb2FkZXIiLCJzZXRNZXNob3B0RGVjb2RlciIsImNhbGxiYWNrIiwiaW5kZXhPZiIsInB1c2giLCJ1bnJlZ2lzdGVyIiwic3BsaWNlIiwianNvbiIsImV4dGVuc2lvbnMiLCJwbHVnaW5zIiwiSlNPTiIsIkFycmF5QnVmZmVyIiwibWFnaWMiLCJkZWNvZGVUZXh0IiwiVWludDhBcnJheSIsInNsaWNlIiwiQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMiLCJFWFRFTlNJT05TIiwiS0hSX0JJTkFSWV9HTFRGIiwiR0xURkJpbmFyeUV4dGVuc2lvbiIsImNvbnRlbnQiLCJhc3NldCIsIkdMVEZQYXJzZXIiLCJjcm9zc09yaWdpbiIsImZpbGVMb2FkZXIiLCJpIiwibGVuZ3RoIiwicGx1Z2luIiwibmFtZSIsImV4dGVuc2lvbnNVc2VkIiwiZXh0ZW5zaW9uTmFtZSIsImV4dGVuc2lvbnNSZXF1aXJlZCIsIktIUl9NQVRFUklBTFNfVU5MSVQiLCJHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24iLCJLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiIsIkdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbiIsIktIUl9URVhUVVJFX1RSQU5TRk9STSIsIkdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uIiwiS0hSX01FU0hfUVVBTlRJWkFUSU9OIiwiR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24iLCJ3YXJuIiwic2V0RXh0ZW5zaW9ucyIsInNldFBsdWdpbnMiLCJwYXJzZUFzeW5jIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJHTFRGUmVnaXN0cnkiLCJvYmplY3RzIiwiZ2V0Iiwia2V5IiwiYWRkIiwib2JqZWN0IiwicmVtb3ZlIiwicmVtb3ZlQWxsIiwiS0hSX0xJR0hUU19QVU5DVFVBTCIsIktIUl9NQVRFUklBTFNfQ0xFQVJDT0FUIiwiS0hSX01BVEVSSUFMU19JT1IiLCJLSFJfTUFURVJJQUxTX1NIRUVOIiwiS0hSX01BVEVSSUFMU19TUEVDVUxBUiIsIktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OIiwiS0hSX01BVEVSSUFMU19JUklERVNDRU5DRSIsIktIUl9NQVRFUklBTFNfQU5JU09UUk9QWSIsIktIUl9NQVRFUklBTFNfVk9MVU1FIiwiS0hSX1RFWFRVUkVfQkFTSVNVIiwiS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSCIsIkVYVF9URVhUVVJFX1dFQlAiLCJFWFRfVEVYVFVSRV9BVklGIiwiRVhUX01FU0hPUFRfQ09NUFJFU1NJT04iLCJFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORyIsImNhY2hlIiwicmVmcyIsInVzZXMiLCJfbWFya0RlZnMiLCJub2RlRGVmcyIsIm5vZGVzIiwibm9kZUluZGV4Iiwibm9kZUxlbmd0aCIsIm5vZGVEZWYiLCJsaWdodCIsIl9hZGROb2RlUmVmIiwiX2xvYWRMaWdodCIsImxpZ2h0SW5kZXgiLCJjYWNoZUtleSIsImRlcGVuZGVuY3kiLCJsaWdodERlZnMiLCJsaWdodHMiLCJsaWdodERlZiIsImxpZ2h0Tm9kZSIsImNvbG9yIiwiZnJvbUFycmF5IiwicmFuZ2UiLCJ0eXBlIiwidGFyZ2V0IiwicG9zaXRpb24iLCJzZXQiLCJkaXN0YW5jZSIsInNwb3QiLCJpbm5lckNvbmVBbmdsZSIsIm91dGVyQ29uZUFuZ2xlIiwiTWF0aCIsIlBJIiwiYW5nbGUiLCJwZW51bWJyYSIsImRlY2F5IiwiYXNzaWduRXh0cmFzVG9Vc2VyRGF0YSIsImludGVuc2l0eSIsImNyZWF0ZVVuaXF1ZU5hbWUiLCJnZXREZXBlbmRlbmN5IiwiaW5kZXgiLCJjcmVhdGVOb2RlQXR0YWNobWVudCIsInNlbGYyIiwidGhlbiIsIl9nZXROb2RlUmVmIiwiZ2V0TWF0ZXJpYWxUeXBlIiwiZXh0ZW5kUGFyYW1zIiwibWF0ZXJpYWxQYXJhbXMiLCJtYXRlcmlhbERlZiIsInBlbmRpbmciLCJvcGFjaXR5IiwibWV0YWxsaWNSb3VnaG5lc3MiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyIsIkFycmF5IiwiaXNBcnJheSIsImJhc2VDb2xvckZhY3RvciIsImFycmF5IiwiYmFzZUNvbG9yVGV4dHVyZSIsImFzc2lnblRleHR1cmUiLCJhbGwiLCJleHRlbmRNYXRlcmlhbFBhcmFtcyIsIm1hdGVyaWFsSW5kZXgiLCJtYXRlcmlhbHMiLCJlbWlzc2l2ZVN0cmVuZ3RoIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJleHRlbnNpb24iLCJjbGVhcmNvYXRGYWN0b3IiLCJjbGVhcmNvYXQiLCJjbGVhcmNvYXRUZXh0dXJlIiwiY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yIiwiY2xlYXJjb2F0Um91Z2huZXNzIiwiY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSIsImNsZWFyY29hdE5vcm1hbFRleHR1cmUiLCJzY2FsZSIsImNsZWFyY29hdE5vcm1hbFNjYWxlIiwiaXJpZGVzY2VuY2VGYWN0b3IiLCJpcmlkZXNjZW5jZSIsImlyaWRlc2NlbmNlVGV4dHVyZSIsImlyaWRlc2NlbmNlSW9yIiwiaXJpZGVzY2VuY2VJT1IiLCJpcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlIiwiaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtIiwiaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtIiwiaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlIiwic2hlZW5Db2xvciIsInNoZWVuUm91Z2huZXNzIiwic2hlZW4iLCJzaGVlbkNvbG9yRmFjdG9yIiwic2hlZW5Sb3VnaG5lc3NGYWN0b3IiLCJzaGVlbkNvbG9yVGV4dHVyZSIsInNoZWVuUm91Z2huZXNzVGV4dHVyZSIsInRyYW5zbWlzc2lvbkZhY3RvciIsInRyYW5zbWlzc2lvbiIsInRyYW5zbWlzc2lvblRleHR1cmUiLCJ0aGlja25lc3MiLCJ0aGlja25lc3NGYWN0b3IiLCJ0aGlja25lc3NUZXh0dXJlIiwiYXR0ZW51YXRpb25EaXN0YW5jZSIsIkluZmluaXR5IiwiY29sb3JBcnJheSIsImF0dGVudWF0aW9uQ29sb3IiLCJpb3IiLCJzcGVjdWxhckludGVuc2l0eSIsInNwZWN1bGFyRmFjdG9yIiwic3BlY3VsYXJUZXh0dXJlIiwic3BlY3VsYXJDb2xvckZhY3RvciIsInNwZWN1bGFyQ29sb3IiLCJzcGVjdWxhckNvbG9yVGV4dHVyZSIsImFuaXNvdHJvcHlTdHJlbmd0aCIsImFuaXNvdHJvcHkiLCJhbmlzb3Ryb3B5Um90YXRpb24iLCJhbmlzb3Ryb3B5VGV4dHVyZSIsImxvYWRUZXh0dXJlIiwidGV4dHVyZUluZGV4IiwidGV4dHVyZURlZiIsInRleHR1cmVzIiwib3B0aW9ucyIsImxvYWRUZXh0dXJlSW1hZ2UiLCJzb3VyY2UiLCJpc1N1cHBvcnRlZCIsImltYWdlcyIsInRleHR1cmVMb2FkZXIiLCJ1cmkiLCJoYW5kbGVyIiwiZ2V0SGFuZGxlciIsImRldGVjdFN1cHBvcnQiLCJpbWFnZSIsIkltYWdlIiwic3JjIiwib25sb2FkIiwib25lcnJvciIsImhlaWdodCIsImxvYWRCdWZmZXJWaWV3IiwiYnVmZmVyVmlldyIsImJ1ZmZlclZpZXdzIiwiZXh0ZW5zaW9uRGVmIiwiYnVmZmVyIiwiZGVjb2RlciIsInN1cHBvcnRlZCIsInJlcyIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiY291bnQiLCJzdHJpZGUiLCJieXRlU3RyaWRlIiwiZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jIiwibW9kZSIsImZpbHRlciIsInJlczIiLCJyZWFkeSIsInJlc3VsdCIsImRlY29kZUdsdGZCdWZmZXIiLCJjcmVhdGVOb2RlTWVzaCIsIm1lc2giLCJtZXNoRGVmIiwibWVzaGVzIiwicHJpbWl0aXZlIiwicHJpbWl0aXZlcyIsIldFQkdMX0NPTlNUQU5UUyIsIlRSSUFOR0xFUyIsIlRSSUFOR0xFX1NUUklQIiwiVFJJQU5HTEVfRkFOIiwiYXR0cmlidXRlc0RlZiIsImF0dHJpYnV0ZXMiLCJhY2Nlc3NvciIsInJlc3VsdHMiLCJub2RlT2JqZWN0IiwicG9wIiwiaXNHcm91cCIsImNoaWxkcmVuIiwiaW5zdGFuY2VkTWVzaGVzIiwibSIsInAiLCJxIiwicyIsImluc3RhbmNlZE1lc2giLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiVFJBTlNMQVRJT04iLCJmcm9tQnVmZmVyQXR0cmlidXRlIiwiUk9UQVRJT04iLCJTQ0FMRSIsInNldE1hdHJpeEF0IiwiY29tcG9zZSIsImF0dHJpYnV0ZU5hbWUiLCJzZXRBdHRyaWJ1dGUiLCJwcm90b3R5cGUiLCJjb3B5IiwiY2FsbCIsImFzc2lnbkZpbmFsTWF0ZXJpYWwiLCJjbGVhciIsIkJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCIsIkJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMiLCJCSU4iLCJib2R5IiwiaGVhZGVyVmlldyIsIkRhdGFWaWV3IiwiaGVhZGVyIiwiZ2V0VWludDMyIiwiY2h1bmtDb250ZW50c0xlbmd0aCIsImNodW5rVmlldyIsImNodW5rSW5kZXgiLCJjaHVua0xlbmd0aCIsImNodW5rVHlwZSIsImNvbnRlbnRBcnJheSIsInByZWxvYWQiLCJkZWNvZGVQcmltaXRpdmUiLCJidWZmZXJWaWV3SW5kZXgiLCJnbHRmQXR0cmlidXRlTWFwIiwidGhyZWVBdHRyaWJ1dGVNYXAiLCJhdHRyaWJ1dGVOb3JtYWxpemVkTWFwIiwiYXR0cmlidXRlVHlwZU1hcCIsInRocmVlQXR0cmlidXRlTmFtZSIsIkFUVFJJQlVURVMiLCJ0b0xvd2VyQ2FzZSIsImFjY2Vzc29yRGVmIiwiYWNjZXNzb3JzIiwiY29tcG9uZW50VHlwZSIsIldFQkdMX0NPTVBPTkVOVF9UWVBFUyIsIm5vcm1hbGl6ZWQiLCJkZWNvZGVEcmFjb0ZpbGUiLCJhdHRyaWJ1dGUiLCJleHRlbmRUZXh0dXJlIiwidGV4dHVyZSIsInRyYW5zZm9ybSIsInRleENvb3JkIiwiY2hhbm5lbCIsIm9mZnNldCIsInJvdGF0aW9uIiwiY2xvbmUiLCJyZXBlYXQiLCJuZWVkc1VwZGF0ZSIsIkdMVEZDdWJpY1NwbGluZUludGVycG9sYW50IiwicGFyYW1ldGVyUG9zaXRpb25zIiwic2FtcGxlVmFsdWVzIiwic2FtcGxlU2l6ZSIsInJlc3VsdEJ1ZmZlciIsImNvcHlTYW1wbGVWYWx1ZV8iLCJ2YWx1ZXMiLCJ2YWx1ZVNpemUiLCJpbnRlcnBvbGF0ZV8iLCJpMSIsInQwIiwidCIsInQxIiwic3RyaWRlMiIsInN0cmlkZTMiLCJ0ZCIsInBwIiwicHBwIiwib2Zmc2V0MSIsIm9mZnNldDAiLCJzMiIsInMzIiwiczAiLCJzMSIsInAwIiwibTAiLCJwMSIsIm0xIiwiX3EiLCJHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQiLCJub3JtYWxpemUiLCJ0b0FycmF5IiwiRkxPQVQiLCJGTE9BVF9NQVQzIiwiRkxPQVRfTUFUNCIsIkZMT0FUX1ZFQzIiLCJGTE9BVF9WRUMzIiwiRkxPQVRfVkVDNCIsIkxJTkVBUiIsIlJFUEVBVCIsIlNBTVBMRVJfMkQiLCJQT0lOVFMiLCJMSU5FUyIsIkxJTkVfTE9PUCIsIkxJTkVfU1RSSVAiLCJVTlNJR05FRF9CWVRFIiwiVU5TSUdORURfU0hPUlQiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIldFQkdMX0ZJTFRFUlMiLCJXRUJHTF9XUkFQUElOR1MiLCJXRUJHTF9UWVBFX1NJWkVTIiwiU0NBTEFSIiwiVkVDMiIsIlZFQzMiLCJWRUM0IiwiTUFUMiIsIk1BVDMiLCJNQVQ0IiwiUE9TSVRJT04iLCJOT1JNQUwiLCJUQU5HRU5UIiwiVEVYQ09PUkRfMCIsIlRFWENPT1JEXzEiLCJURVhDT09SRF8yIiwiVEVYQ09PUkRfMyIsIkNPTE9SXzAiLCJXRUlHSFRTXzAiLCJKT0lOVFNfMCIsIlBBVEhfUFJPUEVSVElFUyIsInRyYW5zbGF0aW9uIiwid2VpZ2h0cyIsIklOVEVSUE9MQVRJT04iLCJDVUJJQ1NQTElORSIsIlNURVAiLCJBTFBIQV9NT0RFUyIsIk9QQVFVRSIsIk1BU0siLCJCTEVORCIsImNyZWF0ZURlZmF1bHRNYXRlcmlhbCIsImVtaXNzaXZlIiwibWV0YWxuZXNzIiwicm91Z2huZXNzIiwidHJhbnNwYXJlbnQiLCJkZXB0aFRlc3QiLCJzaWRlIiwiYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhIiwia25vd25FeHRlbnNpb25zIiwib2JqZWN0RGVmIiwidXNlckRhdGEiLCJnbHRmRXh0ZW5zaW9ucyIsImdsdGZEZWYiLCJleHRyYXMiLCJPYmplY3QiLCJhc3NpZ24iLCJhZGRNb3JwaFRhcmdldHMiLCJ0YXJnZXRzIiwiaGFzTW9ycGhQb3NpdGlvbiIsImhhc01vcnBoTm9ybWFsIiwiaGFzTW9ycGhDb2xvciIsImlsIiwicGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzIiwicGVuZGluZ05vcm1hbEFjY2Vzc29ycyIsInBlbmRpbmdDb2xvckFjY2Vzc29ycyIsInBlbmRpbmdBY2Nlc3NvciIsIm5vcm1hbCIsIm1vcnBoUG9zaXRpb25zIiwibW9ycGhOb3JtYWxzIiwibW9ycGhDb2xvcnMiLCJtb3JwaEF0dHJpYnV0ZXMiLCJtb3JwaFRhcmdldHNSZWxhdGl2ZSIsInVwZGF0ZU1vcnBoVGFyZ2V0cyIsIm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyIsInRhcmdldE5hbWVzIiwibW9ycGhUYXJnZXREaWN0aW9uYXJ5IiwiY3JlYXRlUHJpbWl0aXZlS2V5IiwicHJpbWl0aXZlRGVmIiwiZ2VvbWV0cnlLZXkiLCJkcmFjb0V4dGVuc2lvbiIsImluZGljZXMiLCJjcmVhdGVBdHRyaWJ1dGVzS2V5IiwiYXR0cmlidXRlc0tleSIsImtleXMiLCJzb3J0IiwiZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlIiwiZ2V0SW1hZ2VVUklNaW1lVHlwZSIsInNlYXJjaCIsIl9pZGVudGl0eU1hdHJpeCIsImFzc29jaWF0aW9ucyIsIk1hcCIsInByaW1pdGl2ZUNhY2hlIiwibm9kZUNhY2hlIiwibWVzaENhY2hlIiwiY2FtZXJhQ2FjaGUiLCJsaWdodENhY2hlIiwic291cmNlQ2FjaGUiLCJ0ZXh0dXJlQ2FjaGUiLCJub2RlTmFtZXNVc2VkIiwiaXNTYWZhcmkiLCJpc0ZpcmVmb3giLCJmaXJlZm94VmVyc2lvbiIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRlc3QiLCJtYXRjaCIsImNyZWF0ZUltYWdlQml0bWFwIiwic2V0Q3Jvc3NPcmlnaW4iLCJfaW52b2tlQWxsIiwiZXh0IiwiYmVmb3JlUm9vdCIsImdldERlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsInNjZW5lIiwic2NlbmVzIiwiYW5pbWF0aW9ucyIsImNhbWVyYXMiLCJhZnRlclJvb3QiLCJjYXRjaCIsInNraW5EZWZzIiwic2tpbnMiLCJtZXNoRGVmcyIsInNraW5JbmRleCIsInNraW5MZW5ndGgiLCJqb2ludHMiLCJpc0JvbmUiLCJza2luIiwiaXNTa2lubmVkTWVzaCIsImNhbWVyYSIsInJlZiIsInVwZGF0ZU1hcHBpbmdzIiwib3JpZ2luYWwiLCJtYXBwaW5ncyIsImNoaWxkIiwiZW50cmllcyIsIl9pbnZva2VPbmUiLCJmdW5jIiwidW5zaGlmdCIsImxvYWRTY2VuZSIsImxvYWROb2RlIiwibG9hZE1lc2giLCJsb2FkQWNjZXNzb3IiLCJsb2FkQnVmZmVyIiwibG9hZE1hdGVyaWFsIiwibG9hZFNraW4iLCJsb2FkQW5pbWF0aW9uIiwibG9hZENhbWVyYSIsImRlZnMiLCJtYXAiLCJkZWYiLCJidWZmZXJJbmRleCIsImJ1ZmZlckRlZiIsImJ1ZmZlcnMiLCJyZXNvbHZlVVJMIiwiYnVmZmVyVmlld0RlZiIsImFjY2Vzc29ySW5kZXgiLCJzcGFyc2UiLCJpdGVtU2l6ZSIsIlR5cGVkQXJyYXkiLCJwZW5kaW5nQnVmZmVyVmlld3MiLCJlbGVtZW50Qnl0ZXMiLCJCWVRFU19QRVJfRUxFTUVOVCIsIml0ZW1CeXRlcyIsImJ1ZmZlckF0dHJpYnV0ZSIsImliU2xpY2UiLCJmbG9vciIsImliQ2FjaGVLZXkiLCJpYiIsIml0ZW1TaXplSW5kaWNlcyIsIlR5cGVkQXJyYXlJbmRpY2VzIiwiYnl0ZU9mZnNldEluZGljZXMiLCJieXRlT2Zmc2V0VmFsdWVzIiwic3BhcnNlSW5kaWNlcyIsInNwYXJzZVZhbHVlcyIsInNldFgiLCJzZXRZIiwic2V0WiIsInNldFciLCJzb3VyY2VJbmRleCIsInNvdXJjZURlZiIsInNhbXBsZXIiLCJwcm9taXNlIiwibG9hZEltYWdlU291cmNlIiwiZmxpcFkiLCJzdGFydHNXaXRoIiwic2FtcGxlcnMiLCJtYWdGaWx0ZXIiLCJtaW5GaWx0ZXIiLCJ3cmFwUyIsIndyYXBUIiwiVVJMIiwic2VsZiIsIndlYmtpdFVSTCIsInNvdXJjZVVSSSIsImlzT2JqZWN0VVJMIiwiYmxvYiIsIkJsb2IiLCJtaW1lVHlwZSIsImNyZWF0ZU9iamVjdFVSTCIsInNvdXJjZVVSSTIiLCJpc0ltYWdlQml0bWFwTG9hZGVyIiwiaW1hZ2VCaXRtYXAiLCJyZXZva2VPYmplY3RVUkwiLCJtYXBOYW1lIiwibWFwRGVmIiwiZW5jb2RpbmciLCJnbHRmUmVmZXJlbmNlIiwiY29sb3JTcGFjZSIsInVzZURlcml2YXRpdmVUYW5nZW50cyIsInRhbmdlbnQiLCJ1c2VWZXJ0ZXhDb2xvcnMiLCJ1c2VGbGF0U2hhZGluZyIsImlzUG9pbnRzIiwidXVpZCIsInBvaW50c01hdGVyaWFsIiwic2l6ZUF0dGVudWF0aW9uIiwiaXNMaW5lIiwibGluZU1hdGVyaWFsIiwiY2FjaGVkTWF0ZXJpYWwiLCJ2ZXJ0ZXhDb2xvcnMiLCJmbGF0U2hhZGluZyIsIm5vcm1hbFNjYWxlIiwieSIsIm1hdGVyaWFsVHlwZSIsIm1hdGVyaWFsRXh0ZW5zaW9ucyIsImttdUV4dGVuc2lvbiIsIm1ldGFsbGljRmFjdG9yIiwicm91Z2huZXNzRmFjdG9yIiwibWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlIiwiZG91YmxlU2lkZWQiLCJhbHBoYU1vZGUiLCJkZXB0aFdyaXRlIiwiYWxwaGFUZXN0IiwiYWxwaGFDdXRvZmYiLCJub3JtYWxUZXh0dXJlIiwib2NjbHVzaW9uVGV4dHVyZSIsInN0cmVuZ3RoIiwiYW9NYXBJbnRlbnNpdHkiLCJlbWlzc2l2ZUZhY3RvciIsImVtaXNzaXZlVGV4dHVyZSIsIm9yaWdpbmFsTmFtZSIsInNhbml0aXplZE5hbWUiLCJzYW5pdGl6ZU5vZGVOYW1lIiwibG9hZEdlb21ldHJpZXMiLCJjcmVhdGVEcmFjb1ByaW1pdGl2ZSIsImFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMiLCJjYWNoZWQiLCJnZW9tZXRyeVByb21pc2UiLCJtZXNoSW5kZXgiLCJnZW9tZXRyaWVzIiwibm9ybWFsaXplU2tpbldlaWdodHMiLCJncm91cCIsImNhbWVyYUluZGV4IiwiY2FtZXJhRGVmIiwicGFyYW1zIiwicmFkVG9EZWciLCJ5Zm92IiwiYXNwZWN0UmF0aW8iLCJ6bmVhciIsInpmYXIiLCJ4bWFnIiwieW1hZyIsInNraW5EZWYiLCJfbG9hZE5vZGVTaGFsbG93IiwiaW52ZXJzZUJpbmRNYXRyaWNlcyIsImpvaW50Tm9kZXMiLCJib25lcyIsImJvbmVJbnZlcnNlcyIsImpvaW50Tm9kZSIsIm1hdCIsImFuaW1hdGlvbkluZGV4IiwiYW5pbWF0aW9uRGVmIiwiYW5pbWF0aW9uTmFtZSIsInBlbmRpbmdOb2RlcyIsInBlbmRpbmdJbnB1dEFjY2Vzc29ycyIsInBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMiLCJwZW5kaW5nU2FtcGxlcnMiLCJwZW5kaW5nVGFyZ2V0cyIsImNoYW5uZWxzIiwibm9kZSIsImlucHV0IiwicGFyYW1ldGVycyIsIm91dHB1dCIsImlucHV0QWNjZXNzb3JzIiwib3V0cHV0QWNjZXNzb3JzIiwidHJhY2tzIiwiaW5wdXRBY2Nlc3NvciIsIm91dHB1dEFjY2Vzc29yIiwidXBkYXRlTWF0cml4IiwiVHlwZWRLZXlmcmFtZVRyYWNrIiwidGFyZ2V0TmFtZSIsImludGVycG9sYXRpb24iLCJ0cmF2ZXJzZSIsIm91dHB1dEFycmF5Iiwic2NhbGVkIiwiaiIsImpsIiwidHJhY2siLCJjcmVhdGVJbnRlcnBvbGFudCIsIkludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSIsImludGVycG9sYW50VHlwZSIsInRpbWVzIiwiZ2V0VmFsdWVTaXplIiwiaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUiLCJvIiwiaXNNZXNoIiwibm9kZVBlbmRpbmciLCJjaGlsZFBlbmRpbmciLCJjaGlsZHJlbkRlZiIsInNrZWxldG9uUGVuZGluZyIsInNrZWxldG9uIiwiYmluZCIsIm5vZGVOYW1lIiwibWVzaFByb21pc2UiLCJmb3JFYWNoIiwibWF0cml4IiwiYXBwbHlNYXRyaXg0IiwicXVhdGVybmlvbiIsImhhcyIsInNjZW5lSW5kZXgiLCJzY2VuZURlZiIsIm5vZGVJZHMiLCJyZWR1Y2VBc3NvY2lhdGlvbnMiLCJyZWR1Y2VkQXNzb2NpYXRpb25zIiwidmFsdWUiLCJub2RlMiIsImNvbXB1dGVCb3VuZHMiLCJib3giLCJtaW4iLCJtYXgiLCJib3hTY2FsZSIsIm11bHRpcGx5U2NhbGFyIiwibWF4RGlzcGxhY2VtZW50IiwidmVjdG9yIiwiYWJzIiwiZXhwYW5kQnlWZWN0b3IiLCJib3VuZGluZ0JveCIsInNwaGVyZSIsImdldENlbnRlciIsImNlbnRlciIsInJhZGl1cyIsImRpc3RhbmNlVG8iLCJib3VuZGluZ1NwaGVyZSIsImFzc2lnbkF0dHJpYnV0ZUFjY2Vzc29yIiwiZ2x0ZkF0dHJpYnV0ZU5hbWUiLCJhY2Nlc3NvcjIiLCJzZXRJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/RGBELoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RGBELoader: () => (/* binding */ RGBELoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nclass RGBELoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    console.error(\"THREE.RGBELoader Read Error: \" + (msg || \"\"));\n                    break;\n                case rgbe_write_error:\n                    console.error(\"THREE.RGBELoader Write Error: \" + (msg || \"\"));\n                    break;\n                case rgbe_format_error:\n                    console.error(\"THREE.RGBELoader Bad File Format: \" + (msg || \"\"));\n                    break;\n                default:\n                case rgbe_memory_error:\n                    console.error(\"THREE.RGBELoader: Error: \" + (msg || \"\"));\n            }\n            return RGBE_RETURN_FAILURE;\n        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                if (false !== consume) buffer2.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, RGBE_ReadHeader = function(buffer2) {\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n                valid: 0,\n                string: \"\",\n                comments: \"\",\n                programtype: \"RGBE\",\n                format: \"\",\n                gamma: 1,\n                exposure: 1,\n                width: 0,\n                height: 0\n            };\n            let line, match;\n            if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n                return rgbe_error(rgbe_read_error, \"no header found\");\n            }\n            if (!(match = line.match(magic_token_re))) {\n                return rgbe_error(rgbe_format_error, \"bad initial token\");\n            }\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer2);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue;\n                }\n                if (match = line.match(gamma_re)) {\n                    header.gamma = parseFloat(match[1]);\n                }\n                if (match = line.match(exposure_re)) {\n                    header.exposure = parseFloat(match[1]);\n                }\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1];\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) {\n                return rgbe_error(rgbe_format_error, \"missing format specifier\");\n            }\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n                return rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            }\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer2, w, h) {\n            const scanline_width = w;\n            if (// run length encoding is not allowed so read flat\n            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {\n                return new Uint8Array(buffer2);\n            }\n            if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n                return rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            }\n            const data_rgba = new Uint8Array(4 * w * h);\n            if (!data_rgba.length) {\n                return rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            }\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h;\n            while(num_scanlines > 0 && pos < buffer2.byteLength){\n                if (pos + 4 > buffer2.byteLength) {\n                    return rgbe_error(rgbe_read_error);\n                }\n                rgbeStart[0] = buffer2[pos++];\n                rgbeStart[1] = buffer2[pos++];\n                rgbeStart[2] = buffer2[pos++];\n                rgbeStart[3] = buffer2[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n                    return rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                }\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer2.byteLength){\n                    count = buffer2[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) {\n                        return rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    }\n                    if (isEncodedRun) {\n                        const byteValue = buffer2[pos++];\n                        for(let i = 0; i < count; i++){\n                            scanline_buffer[ptr++] = byteValue;\n                        }\n                    } else {\n                        scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                const l = scanline_width;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n            const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n            if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n                let data, type;\n                let numElements;\n                switch(this.type){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        numElements = image_rgba_data.length / 4;\n                        const floatArray = new Float32Array(numElements * 4);\n                        for(let j = 0; j < numElements; j++){\n                            RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                        }\n                        data = floatArray;\n                        type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        numElements = image_rgba_data.length / 4;\n                        const halfArray = new Uint16Array(numElements * 4);\n                        for(let j = 0; j < numElements; j++){\n                            RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                        }\n                        data = halfArray;\n                        type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n                        break;\n                    default:\n                        console.error(\"THREE.RGBELoader: unsupported type: \", this.type);\n                        break;\n                }\n                return {\n                    width: w,\n                    height: h,\n                    data,\n                    header: rgbe_header_info.string,\n                    gamma: rgbe_header_info.gamma,\n                    exposure: rgbe_header_info.exposure,\n                    type\n                };\n            }\n        }\n        return null;\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    if (\"colorSpace\" in texture) texture.colorSpace = \"srgb-linear\";\n                    else texture.encoding = 3e3;\n                    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=RGBELoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvUkdCRUxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RjtBQUM3RixNQUFNSyxtQkFBbUJMLG9EQUFpQkE7SUFDeENNLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdQLGdEQUFhQTtJQUMzQjtJQUNBLDhEQUE4RDtJQUM5RFEsTUFBTUMsTUFBTSxFQUFFO1FBQ1osTUFBTUMsc0JBQXNCLENBQUMsR0FBR0Msa0JBQWtCLEdBQUdDLG1CQUFtQixHQUFHQyxvQkFBb0IsR0FBR0Msb0JBQW9CLEdBQUdDLGFBQWEsU0FBU0MsZUFBZSxFQUFFQyxHQUFHO1lBQ2pLLE9BQVFEO2dCQUNOLEtBQUtMO29CQUNITyxRQUFRQyxLQUFLLENBQUMsa0NBQW1DRixDQUFBQSxPQUFPLEVBQUM7b0JBQ3pEO2dCQUNGLEtBQUtMO29CQUNITSxRQUFRQyxLQUFLLENBQUMsbUNBQW9DRixDQUFBQSxPQUFPLEVBQUM7b0JBQzFEO2dCQUNGLEtBQUtKO29CQUNISyxRQUFRQyxLQUFLLENBQUMsdUNBQXdDRixDQUFBQSxPQUFPLEVBQUM7b0JBQzlEO2dCQUNGO2dCQUNBLEtBQUtIO29CQUNISSxRQUFRQyxLQUFLLENBQUMsOEJBQStCRixDQUFBQSxPQUFPLEVBQUM7WUFDekQ7WUFDQSxPQUFPUDtRQUNULEdBQUdVLHlCQUF5QixHQUFHQyxvQkFBb0IsR0FBR0Msd0JBQXdCLEdBQUdDLFVBQVUsTUFBTUMsUUFBUSxTQUFTQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsT0FBTztZQUMzSSxNQUFNQyxZQUFZO1lBQ2xCRixZQUFZLENBQUNBLFlBQVksT0FBT0E7WUFDaEMsSUFBSUcsSUFBSUosUUFBUUssR0FBRyxFQUFFQyxJQUFJLENBQUMsR0FBR0MsTUFBTSxHQUFHQyxJQUFJLElBQUlDLFFBQVFDLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU0s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dGl2ZS00MDQvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvUkdCRUxvYWRlci5qcz83YWIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGFUZXh0dXJlTG9hZGVyLCBIYWxmRmxvYXRUeXBlLCBGbG9hdFR5cGUsIERhdGFVdGlscywgTGluZWFyRmlsdGVyIH0gZnJvbSBcInRocmVlXCI7XG5jbGFzcyBSR0JFTG9hZGVyIGV4dGVuZHMgRGF0YVRleHR1cmVMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy50eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgfVxuICAvLyBhZGFwdGVkIGZyb20gaHR0cDovL3d3dy5ncmFwaGljcy5jb3JuZWxsLmVkdS9+Ymp3L3JnYmUuaHRtbFxuICBwYXJzZShidWZmZXIpIHtcbiAgICBjb25zdCBSR0JFX1JFVFVSTl9GQUlMVVJFID0gLTEsIHJnYmVfcmVhZF9lcnJvciA9IDEsIHJnYmVfd3JpdGVfZXJyb3IgPSAyLCByZ2JlX2Zvcm1hdF9lcnJvciA9IDMsIHJnYmVfbWVtb3J5X2Vycm9yID0gNCwgcmdiZV9lcnJvciA9IGZ1bmN0aW9uKHJnYmVfZXJyb3JfY29kZSwgbXNnKSB7XG4gICAgICBzd2l0Y2ggKHJnYmVfZXJyb3JfY29kZSkge1xuICAgICAgICBjYXNlIHJnYmVfcmVhZF9lcnJvcjpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuUkdCRUxvYWRlciBSZWFkIEVycm9yOiBcIiArIChtc2cgfHwgXCJcIikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHJnYmVfd3JpdGVfZXJyb3I6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLlJHQkVMb2FkZXIgV3JpdGUgRXJyb3I6IFwiICsgKG1zZyB8fCBcIlwiKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgcmdiZV9mb3JtYXRfZXJyb3I6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLlJHQkVMb2FkZXIgQmFkIEZpbGUgRm9ybWF0OiBcIiArIChtc2cgfHwgXCJcIikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBjYXNlIHJnYmVfbWVtb3J5X2Vycm9yOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyOiBFcnJvcjogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSR0JFX1JFVFVSTl9GQUlMVVJFO1xuICAgIH0sIFJHQkVfVkFMSURfUFJPR1JBTVRZUEUgPSAxLCBSR0JFX1ZBTElEX0ZPUk1BVCA9IDIsIFJHQkVfVkFMSURfRElNRU5TSU9OUyA9IDQsIE5FV0xJTkUgPSBcIlxcblwiLCBmZ2V0cyA9IGZ1bmN0aW9uKGJ1ZmZlcjIsIGxpbmVMaW1pdCwgY29uc3VtZSkge1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gMTI4O1xuICAgICAgbGluZUxpbWl0ID0gIWxpbmVMaW1pdCA/IDEwMjQgOiBsaW5lTGltaXQ7XG4gICAgICBsZXQgcCA9IGJ1ZmZlcjIucG9zLCBpID0gLTEsIGxlbiA9IDAsIHMgPSBcIlwiLCBjaHVuayA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcjIuc3ViYXJyYXkocCwgcCArIGNodW5rU2l6ZSkpKTtcbiAgICAgIHdoaWxlICgwID4gKGkgPSBjaHVuay5pbmRleE9mKE5FV0xJTkUpKSAmJiBsZW4gPCBsaW5lTGltaXQgJiYgcCA8IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICBzICs9IGNodW5rO1xuICAgICAgICBsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBwICs9IGNodW5rU2l6ZTtcbiAgICAgICAgY2h1bmsgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoYnVmZmVyMi5zdWJhcnJheShwLCBwICsgY2h1bmtTaXplKSkpO1xuICAgICAgfVxuICAgICAgaWYgKC0xIDwgaSkge1xuICAgICAgICBpZiAoZmFsc2UgIT09IGNvbnN1bWUpXG4gICAgICAgICAgYnVmZmVyMi5wb3MgKz0gbGVuICsgaSArIDE7XG4gICAgICAgIHJldHVybiBzICsgY2h1bmsuc2xpY2UoMCwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgUkdCRV9SZWFkSGVhZGVyID0gZnVuY3Rpb24oYnVmZmVyMikge1xuICAgICAgY29uc3QgbWFnaWNfdG9rZW5fcmUgPSAvXiNcXD8oXFxTKykvLCBnYW1tYV9yZSA9IC9eXFxzKkdBTU1BXFxzKj1cXHMqKFxcZCsoXFwuXFxkKyk/KVxccyokLywgZXhwb3N1cmVfcmUgPSAvXlxccypFWFBPU1VSRVxccyo9XFxzKihcXGQrKFxcLlxcZCspPylcXHMqJC8sIGZvcm1hdF9yZSA9IC9eXFxzKkZPUk1BVD0oXFxTKylcXHMqJC8sIGRpbWVuc2lvbnNfcmUgPSAvXlxccypcXC1ZXFxzKyhcXGQrKVxccytcXCtYXFxzKyhcXGQrKVxccyokLywgaGVhZGVyID0ge1xuICAgICAgICB2YWxpZDogMCxcbiAgICAgICAgc3RyaW5nOiBcIlwiLFxuICAgICAgICBjb21tZW50czogXCJcIixcbiAgICAgICAgcHJvZ3JhbXR5cGU6IFwiUkdCRVwiLFxuICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgIGdhbW1hOiAxLFxuICAgICAgICBleHBvc3VyZTogMSxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIGxldCBsaW5lLCBtYXRjaDtcbiAgICAgIGlmIChidWZmZXIyLnBvcyA+PSBidWZmZXIyLmJ5dGVMZW5ndGggfHwgIShsaW5lID0gZmdldHMoYnVmZmVyMikpKSB7XG4gICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfcmVhZF9lcnJvciwgXCJubyBoZWFkZXIgZm91bmRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIShtYXRjaCA9IGxpbmUubWF0Y2gobWFnaWNfdG9rZW5fcmUpKSkge1xuICAgICAgICByZXR1cm4gcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJiYWQgaW5pdGlhbCB0b2tlblwiKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlci52YWxpZCB8PSBSR0JFX1ZBTElEX1BST0dSQU1UWVBFO1xuICAgICAgaGVhZGVyLnByb2dyYW10eXBlID0gbWF0Y2hbMV07XG4gICAgICBoZWFkZXIuc3RyaW5nICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGluZSA9IGZnZXRzKGJ1ZmZlcjIpO1xuICAgICAgICBpZiAoZmFsc2UgPT09IGxpbmUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhlYWRlci5zdHJpbmcgKz0gbGluZSArIFwiXFxuXCI7XG4gICAgICAgIGlmIChcIiNcIiA9PT0gbGluZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICBoZWFkZXIuY29tbWVudHMgKz0gbGluZSArIFwiXFxuXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChnYW1tYV9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIuZ2FtbWEgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGV4cG9zdXJlX3JlKSkge1xuICAgICAgICAgIGhlYWRlci5leHBvc3VyZSA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZm9ybWF0X3JlKSkge1xuICAgICAgICAgIGhlYWRlci52YWxpZCB8PSBSR0JFX1ZBTElEX0ZPUk1BVDtcbiAgICAgICAgICBoZWFkZXIuZm9ybWF0ID0gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChkaW1lbnNpb25zX3JlKSkge1xuICAgICAgICAgIGhlYWRlci52YWxpZCB8PSBSR0JFX1ZBTElEX0RJTUVOU0lPTlM7XG4gICAgICAgICAgaGVhZGVyLmhlaWdodCA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgICAgaGVhZGVyLndpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9GT1JNQVQgJiYgaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9ESU1FTlNJT05TKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCEoaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9GT1JNQVQpKSB7XG4gICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcIm1pc3NpbmcgZm9ybWF0IHNwZWNpZmllclwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRElNRU5TSU9OUykpIHtcbiAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwibWlzc2luZyBpbWFnZSBzaXplIHNwZWNpZmllclwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZWFkZXI7XG4gICAgfSwgUkdCRV9SZWFkUGl4ZWxzX1JMRSA9IGZ1bmN0aW9uKGJ1ZmZlcjIsIHcsIGgpIHtcbiAgICAgIGNvbnN0IHNjYW5saW5lX3dpZHRoID0gdztcbiAgICAgIGlmIChcbiAgICAgICAgLy8gcnVuIGxlbmd0aCBlbmNvZGluZyBpcyBub3QgYWxsb3dlZCBzbyByZWFkIGZsYXRcbiAgICAgICAgc2NhbmxpbmVfd2lkdGggPCA4IHx8IHNjYW5saW5lX3dpZHRoID4gMzI3NjcgfHwgLy8gdGhpcyBmaWxlIGlzIG5vdCBydW4gbGVuZ3RoIGVuY29kZWRcbiAgICAgICAgMiAhPT0gYnVmZmVyMlswXSB8fCAyICE9PSBidWZmZXIyWzFdIHx8IGJ1ZmZlcjJbMl0gJiAxMjhcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMik7XG4gICAgICB9XG4gICAgICBpZiAoc2NhbmxpbmVfd2lkdGggIT09IChidWZmZXIyWzJdIDw8IDggfCBidWZmZXIyWzNdKSkge1xuICAgICAgICByZXR1cm4gcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJ3cm9uZyBzY2FubGluZSB3aWR0aFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGFfcmdiYSA9IG5ldyBVaW50OEFycmF5KDQgKiB3ICogaCk7XG4gICAgICBpZiAoIWRhdGFfcmdiYS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9tZW1vcnlfZXJyb3IsIFwidW5hYmxlIHRvIGFsbG9jYXRlIGJ1ZmZlciBzcGFjZVwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBvZmZzZXQgPSAwLCBwb3MgPSAwO1xuICAgICAgY29uc3QgcHRyX2VuZCA9IDQgKiBzY2FubGluZV93aWR0aDtcbiAgICAgIGNvbnN0IHJnYmVTdGFydCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgY29uc3Qgc2NhbmxpbmVfYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocHRyX2VuZCk7XG4gICAgICBsZXQgbnVtX3NjYW5saW5lcyA9IGg7XG4gICAgICB3aGlsZSAobnVtX3NjYW5saW5lcyA+IDAgJiYgcG9zIDwgYnVmZmVyMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGlmIChwb3MgKyA0ID4gYnVmZmVyMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9yZWFkX2Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZ2JlU3RhcnRbMF0gPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgcmdiZVN0YXJ0WzFdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIHJnYmVTdGFydFsyXSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICByZ2JlU3RhcnRbM10gPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgaWYgKDIgIT0gcmdiZVN0YXJ0WzBdIHx8IDIgIT0gcmdiZVN0YXJ0WzFdIHx8IChyZ2JlU3RhcnRbMl0gPDwgOCB8IHJnYmVTdGFydFszXSkgIT0gc2NhbmxpbmVfd2lkdGgpIHtcbiAgICAgICAgICByZXR1cm4gcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJiYWQgcmdiZSBzY2FubGluZSBmb3JtYXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB0ciA9IDAsIGNvdW50O1xuICAgICAgICB3aGlsZSAocHRyIDwgcHRyX2VuZCAmJiBwb3MgPCBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICBjb3VudCA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICAgIGNvbnN0IGlzRW5jb2RlZFJ1biA9IGNvdW50ID4gMTI4O1xuICAgICAgICAgIGlmIChpc0VuY29kZWRSdW4pXG4gICAgICAgICAgICBjb3VudCAtPSAxMjg7XG4gICAgICAgICAgaWYgKDAgPT09IGNvdW50IHx8IHB0ciArIGNvdW50ID4gcHRyX2VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwiYmFkIHNjYW5saW5lIGRhdGFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0VuY29kZWRSdW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVWYWx1ZSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIHNjYW5saW5lX2J1ZmZlcltwdHIrK10gPSBieXRlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjYW5saW5lX2J1ZmZlci5zZXQoYnVmZmVyMi5zdWJhcnJheShwb3MsIHBvcyArIGNvdW50KSwgcHRyKTtcbiAgICAgICAgICAgIHB0ciArPSBjb3VudDtcbiAgICAgICAgICAgIHBvcyArPSBjb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbCA9IHNjYW5saW5lX3dpZHRoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGxldCBvZmYgPSAwO1xuICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXRdID0gc2NhbmxpbmVfYnVmZmVyW2kgKyBvZmZdO1xuICAgICAgICAgIG9mZiArPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0ICsgMV0gPSBzY2FubGluZV9idWZmZXJbaSArIG9mZl07XG4gICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoO1xuICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAyXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmYgKz0gc2NhbmxpbmVfd2lkdGg7XG4gICAgICAgICAgZGF0YV9yZ2JhW29mZnNldCArIDNdID0gc2NhbmxpbmVfYnVmZmVyW2kgKyBvZmZdO1xuICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB9XG4gICAgICAgIG51bV9zY2FubGluZXMtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhX3JnYmE7XG4gICAgfTtcbiAgICBjb25zdCBSR0JFQnl0ZVRvUkdCRmxvYXQgPSBmdW5jdGlvbihzb3VyY2VBcnJheSwgc291cmNlT2Zmc2V0LCBkZXN0QXJyYXksIGRlc3RPZmZzZXQpIHtcbiAgICAgIGNvbnN0IGUgPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAzXTtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgZSAtIDEyOCkgLyAyNTU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDBdID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMF0gKiBzY2FsZTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMV0gPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAxXSAqIHNjYWxlO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAyXSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDJdICogc2NhbGU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDNdID0gMTtcbiAgICB9O1xuICAgIGNvbnN0IFJHQkVCeXRlVG9SR0JIYWxmID0gZnVuY3Rpb24oc291cmNlQXJyYXksIHNvdXJjZU9mZnNldCwgZGVzdEFycmF5LCBkZXN0T2Zmc2V0KSB7XG4gICAgICBjb25zdCBlID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgM107XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIGUgLSAxMjgpIC8gMjU1O1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAwXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdChNYXRoLm1pbihzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAwXSAqIHNjYWxlLCA2NTUwNCkpO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAxXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdChNYXRoLm1pbihzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAxXSAqIHNjYWxlLCA2NTUwNCkpO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAyXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdChNYXRoLm1pbihzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAyXSAqIHNjYWxlLCA2NTUwNCkpO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAzXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdCgxKTtcbiAgICB9O1xuICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgYnl0ZUFycmF5LnBvcyA9IDA7XG4gICAgY29uc3QgcmdiZV9oZWFkZXJfaW5mbyA9IFJHQkVfUmVhZEhlYWRlcihieXRlQXJyYXkpO1xuICAgIGlmIChSR0JFX1JFVFVSTl9GQUlMVVJFICE9PSByZ2JlX2hlYWRlcl9pbmZvKSB7XG4gICAgICBjb25zdCB3ID0gcmdiZV9oZWFkZXJfaW5mby53aWR0aCwgaCA9IHJnYmVfaGVhZGVyX2luZm8uaGVpZ2h0LCBpbWFnZV9yZ2JhX2RhdGEgPSBSR0JFX1JlYWRQaXhlbHNfUkxFKGJ5dGVBcnJheS5zdWJhcnJheShieXRlQXJyYXkucG9zKSwgdywgaCk7XG4gICAgICBpZiAoUkdCRV9SRVRVUk5fRkFJTFVSRSAhPT0gaW1hZ2VfcmdiYV9kYXRhKSB7XG4gICAgICAgIGxldCBkYXRhLCB0eXBlO1xuICAgICAgICBsZXQgbnVtRWxlbWVudHM7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBudW1FbGVtZW50cyA9IGltYWdlX3JnYmFfZGF0YS5sZW5ndGggLyA0O1xuICAgICAgICAgICAgY29uc3QgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkobnVtRWxlbWVudHMgKiA0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtRWxlbWVudHM7IGorKykge1xuICAgICAgICAgICAgICBSR0JFQnl0ZVRvUkdCRmxvYXQoaW1hZ2VfcmdiYV9kYXRhLCBqICogNCwgZmxvYXRBcnJheSwgaiAqIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IGZsb2F0QXJyYXk7XG4gICAgICAgICAgICB0eXBlID0gRmxvYXRUeXBlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgICAgbnVtRWxlbWVudHMgPSBpbWFnZV9yZ2JhX2RhdGEubGVuZ3RoIC8gNDtcbiAgICAgICAgICAgIGNvbnN0IGhhbGZBcnJheSA9IG5ldyBVaW50MTZBcnJheShudW1FbGVtZW50cyAqIDQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1FbGVtZW50czsgaisrKSB7XG4gICAgICAgICAgICAgIFJHQkVCeXRlVG9SR0JIYWxmKGltYWdlX3JnYmFfZGF0YSwgaiAqIDQsIGhhbGZBcnJheSwgaiAqIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IGhhbGZBcnJheTtcbiAgICAgICAgICAgIHR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyOiB1bnN1cHBvcnRlZCB0eXBlOiBcIiwgdGhpcy50eXBlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgaGVhZGVyOiByZ2JlX2hlYWRlcl9pbmZvLnN0cmluZyxcbiAgICAgICAgICBnYW1tYTogcmdiZV9oZWFkZXJfaW5mby5nYW1tYSxcbiAgICAgICAgICBleHBvc3VyZTogcmdiZV9oZWFkZXJfaW5mby5leHBvc3VyZSxcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNldERhdGFUeXBlKHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGZ1bmN0aW9uIG9uTG9hZENhbGxiYWNrKHRleHR1cmUsIHRleERhdGEpIHtcbiAgICAgIHN3aXRjaCAodGV4dHVyZS50eXBlKSB7XG4gICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgaWYgKFwiY29sb3JTcGFjZVwiIGluIHRleHR1cmUpXG4gICAgICAgICAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBcInNyZ2ItbGluZWFyXCI7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IDNlMztcbiAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgICAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgICAgIHRleHR1cmUuZmxpcFkgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG9uTG9hZClcbiAgICAgICAgb25Mb2FkKHRleHR1cmUsIHRleERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIubG9hZCh1cmwsIG9uTG9hZENhbGxiYWNrLCBvblByb2dyZXNzLCBvbkVycm9yKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgUkdCRUxvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJHQkVMb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOlsiRGF0YVRleHR1cmVMb2FkZXIiLCJIYWxmRmxvYXRUeXBlIiwiRmxvYXRUeXBlIiwiRGF0YVV0aWxzIiwiTGluZWFyRmlsdGVyIiwiUkdCRUxvYWRlciIsImNvbnN0cnVjdG9yIiwibWFuYWdlciIsInR5cGUiLCJwYXJzZSIsImJ1ZmZlciIsIlJHQkVfUkVUVVJOX0ZBSUxVUkUiLCJyZ2JlX3JlYWRfZXJyb3IiLCJyZ2JlX3dyaXRlX2Vycm9yIiwicmdiZV9mb3JtYXRfZXJyb3IiLCJyZ2JlX21lbW9yeV9lcnJvciIsInJnYmVfZXJyb3IiLCJyZ2JlX2Vycm9yX2NvZGUiLCJtc2ciLCJjb25zb2xlIiwiZXJyb3IiLCJSR0JFX1ZBTElEX1BST0dSQU1UWVBFIiwiUkdCRV9WQUxJRF9GT1JNQVQiLCJSR0JFX1ZBTElEX0RJTUVOU0lPTlMiLCJORVdMSU5FIiwiZmdldHMiLCJidWZmZXIyIiwibGluZUxpbWl0IiwiY29uc3VtZSIsImNodW5rU2l6ZSIsInAiLCJwb3MiLCJpIiwibGVuIiwicyIsImNodW5rIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJVaW50MTZBcnJheSIsInN1YmFycmF5IiwiaW5kZXhPZiIsImJ5dGVMZW5ndGgiLCJsZW5ndGgiLCJzbGljZSIsIlJHQkVfUmVhZEhlYWRlciIsIm1hZ2ljX3Rva2VuX3JlIiwiZ2FtbWFfcmUiLCJleHBvc3VyZV9yZSIsImZvcm1hdF9yZSIsImRpbWVuc2lvbnNfcmUiLCJoZWFkZXIiLCJ2YWxpZCIsInN0cmluZyIsImNvbW1lbnRzIiwicHJvZ3JhbXR5cGUiLCJmb3JtYXQiLCJnYW1tYSIsImV4cG9zdXJlIiwid2lkdGgiLCJoZWlnaHQiLCJsaW5lIiwibWF0Y2giLCJjaGFyQXQiLCJwYXJzZUZsb2F0IiwicGFyc2VJbnQiLCJSR0JFX1JlYWRQaXhlbHNfUkxFIiwidyIsImgiLCJzY2FubGluZV93aWR0aCIsIlVpbnQ4QXJyYXkiLCJkYXRhX3JnYmEiLCJvZmZzZXQiLCJwdHJfZW5kIiwicmdiZVN0YXJ0Iiwic2NhbmxpbmVfYnVmZmVyIiwibnVtX3NjYW5saW5lcyIsInB0ciIsImNvdW50IiwiaXNFbmNvZGVkUnVuIiwiYnl0ZVZhbHVlIiwic2V0IiwibCIsIm9mZiIsIlJHQkVCeXRlVG9SR0JGbG9hdCIsInNvdXJjZUFycmF5Iiwic291cmNlT2Zmc2V0IiwiZGVzdEFycmF5IiwiZGVzdE9mZnNldCIsImUiLCJzY2FsZSIsIk1hdGgiLCJwb3ciLCJSR0JFQnl0ZVRvUkdCSGFsZiIsInRvSGFsZkZsb2F0IiwibWluIiwiYnl0ZUFycmF5IiwicmdiZV9oZWFkZXJfaW5mbyIsImltYWdlX3JnYmFfZGF0YSIsImRhdGEiLCJudW1FbGVtZW50cyIsImZsb2F0QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJqIiwiaGFsZkFycmF5Iiwic2V0RGF0YVR5cGUiLCJ2YWx1ZSIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsIm9uTG9hZENhbGxiYWNrIiwidGV4dHVyZSIsInRleERhdGEiLCJjb2xvclNwYWNlIiwiZW5jb2RpbmciLCJtaW5GaWx0ZXIiLCJtYWdGaWx0ZXIiLCJnZW5lcmF0ZU1pcG1hcHMiLCJmbGlwWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-stdlib/objects/GroundProjectedEnv.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroundProjectedEnv: () => (/* binding */ GroundProjectedEnv)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst isCubeTexture = (def)=>def && def.isCubeTexture;\nclass GroundProjectedEnv extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n    constructor(texture, options){\n        var _a, _b;\n        const isCubeMap = isCubeTexture(texture);\n        const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n        const cubeSize = w / 4;\n        const _lodMax = Math.floor(Math.log2(cubeSize));\n        const _cubeSize = Math.pow(2, _lodMax);\n        const width = 3 * Math.max(_cubeSize, 16 * 7);\n        const height = 4 * _cubeSize;\n        const defines = [\n            isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n            `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n            `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n            `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n        ];\n        const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `;\n        const fragmentShader = defines.join(\"\\n\") + /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n        const uniforms = {\n            map: {\n                value: texture\n            },\n            height: {\n                value: (options == null ? void 0 : options.height) || 15\n            },\n            radius: {\n                value: (options == null ? void 0 : options.radius) || 100\n            }\n        };\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(1, 16);\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms,\n            fragmentShader,\n            vertexShader,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n        });\n        super(geometry, material);\n    }\n    set radius(radius) {\n        this.material.uniforms.radius.value = radius;\n    }\n    get radius() {\n        return this.material.uniforms.radius.value;\n    }\n    set height(height) {\n        this.material.uniforms.height.value = height;\n    }\n    get height() {\n        return this.material.uniforms.height.value;\n    }\n}\n //# sourceMappingURL=GroundProjectedEnv.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL29iamVjdHMvR3JvdW5kUHJvamVjdGVkRW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdGO0FBQ3hGLE1BQU1LLGdCQUFnQixDQUFDQyxNQUFRQSxPQUFPQSxJQUFJRCxhQUFhO0FBQ3ZELE1BQU1FLDJCQUEyQlAsdUNBQUlBO0lBQ25DUSxZQUFZQyxPQUFPLEVBQUVDLE9BQU8sQ0FBRTtRQUM1QixJQUFJQyxJQUFJQztRQUNSLE1BQU1DLFlBQVlSLGNBQWNJO1FBQ2hDLE1BQU1LLElBQUksQ0FBQ0YsS0FBS0MsWUFBWSxDQUFDRixLQUFLRixRQUFRTSxLQUFLLENBQUMsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJSixHQUFHSyxLQUFLLEdBQUdQLFFBQVFNLEtBQUssQ0FBQ0MsS0FBSyxLQUFLLE9BQU9KLEtBQUs7UUFDdEgsTUFBTUssV0FBV0gsSUFBSTtRQUNyQixNQUFNSSxVQUFVQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLElBQUksQ0FBQ0o7UUFDckMsTUFBTUssWUFBWUgsS0FBS0ksR0FBRyxDQUFDLEdBQUdMO1FBQzlCLE1BQU1GLFFBQVEsSUFBSUcsS0FBS0ssR0FBRyxDQUFDRixXQUFXLEtBQUs7UUFDM0MsTUFBTUcsU0FBUyxJQUFJSDtRQUNuQixNQUFNSSxVQUFVO1lBQ2RiLFlBQVksNkJBQTZCO1lBQ3pDLENBQUMsMkJBQTJCLEVBQUUsSUFBSUcsTUFBTSxDQUFDO1lBQ3pDLENBQUMsNEJBQTRCLEVBQUUsSUFBSVMsT0FBTyxDQUFDO1lBQzNDLENBQUMsdUJBQXVCLEVBQUVQLFFBQVEsRUFBRSxDQUFDO1NBQ3RDO1FBQ0QsTUFBTVMsZUFDSixRQUFRLEdBQ1IsQ0FBQzs7Ozs7Ozs7O1FBU0MsQ0FBQztRQUVMLE1BQU1DLGlCQUFpQkYsUUFBUUcsSUFBSSxDQUFDLFFBQVEsUUFBUSxHQUNwRCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBcUVpQixFQUFFQyxTQUFTN0IsMkNBQVFBLENBQUM4QixPQUFPLENBQUMsUUFBUSxRQUFRLE1BQU0sd0JBQXdCLHFCQUFxQjs7UUFFN0csQ0FBQztRQUNMLE1BQU1DLFdBQVc7WUFDZkMsS0FBSztnQkFBRUMsT0FBT3pCO1lBQVE7WUFDdEJnQixRQUFRO2dCQUFFUyxPQUFPLENBQUN4QixXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFRZSxNQUFNLEtBQUs7WUFBRztZQUNuRVUsUUFBUTtnQkFBRUQsT0FBTyxDQUFDeEIsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUXlCLE1BQU0sS0FBSztZQUFJO1FBQ3RFO1FBQ0EsTUFBTUMsV0FBVyxJQUFJbEMsc0RBQW1CQSxDQUFDLEdBQUc7UUFDNUMsTUFBTW1DLFdBQVcsSUFBSWxDLGlEQUFjQSxDQUFDO1lBQ2xDNkI7WUFDQUo7WUFDQUQ7WUFDQVcsTUFBTWxDLDZDQUFVQTtRQUNsQjtRQUNBLEtBQUssQ0FBQ2dDLFVBQVVDO0lBQ2xCO0lBQ0EsSUFBSUYsT0FBT0EsTUFBTSxFQUFFO1FBQ2pCLElBQUksQ0FBQ0UsUUFBUSxDQUFDTCxRQUFRLENBQUNHLE1BQU0sQ0FBQ0QsS0FBSyxHQUFHQztJQUN4QztJQUNBLElBQUlBLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ0UsUUFBUSxDQUFDTCxRQUFRLENBQUNHLE1BQU0sQ0FBQ0QsS0FBSztJQUM1QztJQUNBLElBQUlULE9BQU9BLE1BQU0sRUFBRTtRQUNqQixJQUFJLENBQUNZLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDUCxNQUFNLENBQUNTLEtBQUssR0FBR1Q7SUFDeEM7SUFDQSxJQUFJQSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUNZLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDUCxNQUFNLENBQUNTLEtBQUs7SUFDNUM7QUFDRjtBQUdFLENBQ0YsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JlYXRpdmUtNDA0Ly4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9vYmplY3RzL0dyb3VuZFByb2plY3RlZEVudi5qcz82MGI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1lc2gsIFJFVklTSU9OLCBJY29zYWhlZHJvbkdlb21ldHJ5LCBTaGFkZXJNYXRlcmlhbCwgRG91YmxlU2lkZSB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgaXNDdWJlVGV4dHVyZSA9IChkZWYpID0+IGRlZiAmJiBkZWYuaXNDdWJlVGV4dHVyZTtcbmNsYXNzIEdyb3VuZFByb2plY3RlZEVudiBleHRlbmRzIE1lc2gge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBpc0N1YmVNYXAgPSBpc0N1YmVUZXh0dXJlKHRleHR1cmUpO1xuICAgIGNvbnN0IHcgPSAoX2IgPSBpc0N1YmVNYXAgPyAoX2EgPSB0ZXh0dXJlLmltYWdlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2Eud2lkdGggOiB0ZXh0dXJlLmltYWdlLndpZHRoKSAhPSBudWxsID8gX2IgOiAxMDI0O1xuICAgIGNvbnN0IGN1YmVTaXplID0gdyAvIDQ7XG4gICAgY29uc3QgX2xvZE1heCA9IE1hdGguZmxvb3IoTWF0aC5sb2cyKGN1YmVTaXplKSk7XG4gICAgY29uc3QgX2N1YmVTaXplID0gTWF0aC5wb3coMiwgX2xvZE1heCk7XG4gICAgY29uc3Qgd2lkdGggPSAzICogTWF0aC5tYXgoX2N1YmVTaXplLCAxNiAqIDcpO1xuICAgIGNvbnN0IGhlaWdodCA9IDQgKiBfY3ViZVNpemU7XG4gICAgY29uc3QgZGVmaW5lcyA9IFtcbiAgICAgIGlzQ3ViZU1hcCA/IFwiI2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFXCIgOiBcIlwiLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX1RFWEVMX1dJRFRIICR7MSAvIHdpZHRofWAsXG4gICAgICBgI2RlZmluZSBDVUJFVVZfVEVYRUxfSEVJR0hUICR7MSAvIGhlaWdodH1gLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX01BWF9NSVAgJHtfbG9kTWF4fS4wYFxuICAgIF07XG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG4gICAgICAgIHZvaWQgbWFpbigpIFxuICAgICAgICB7XG4gICAgICAgICAgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSAoIG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApICk7XG4gICAgICAgICAgICB2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG4gICAgICAgIH1cbiAgICAgICAgYFxuICAgICk7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBkZWZpbmVzLmpvaW4oXCJcXG5cIikgKyAvKiBnbHNsICovXG4gICAgYFxuICAgICAgICAjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVZcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBoZWlnaHQ7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgYW5nbGU7XG4gICAgICAgICNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXJDdWJlIG1hcDtcbiAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcbiAgICAgICAgI2VuZGlmXG4gICAgICAgIC8vIEZyb206IGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80dHNCRDdcbiAgICAgICAgZmxvYXQgZGlza0ludGVyc2VjdFdpdGhCYWNrRmFjZUN1bGxpbmcoIHZlYzMgcm8sIHZlYzMgcmQsIHZlYzMgYywgdmVjMyBuLCBmbG9hdCByICkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZsb2F0IGQgPSBkb3QgKCByZCwgbiApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggZCA+IDAuMCApIHsgcmV0dXJuIDFlNjsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2ZWMzICBvID0gcm8gLSBjO1xuICAgICAgICAgICAgZmxvYXQgdCA9IC0gZG90KCBuLCBvICkgLyBkO1xuICAgICAgICAgICAgdmVjMyAgcSA9IG8gKyByZCAqIHQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAoIGRvdCggcSwgcSApIDwgciAqIHIgKSA/IHQgOiAxZTY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL2ludGVyc2VjdG9ycy9pbnRlcnNlY3RvcnMuaHRtXG4gICAgICAgIGZsb2F0IHNwaGVyZUludGVyc2VjdCggdmVjMyBybywgdmVjMyByZCwgdmVjMyBjZSwgZmxvYXQgcmEgKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBvYyA9IHJvIC0gY2U7XG4gICAgICAgICAgICBmbG9hdCBiID0gZG90KCBvYywgcmQgKTtcbiAgICAgICAgICAgIGZsb2F0IGMgPSBkb3QoIG9jLCBvYyApIC0gcmEgKiByYTtcbiAgICAgICAgICAgIGZsb2F0IGggPSBiICogYiAtIGM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBoIDwgMC4wICkgeyByZXR1cm4gLTEuMDsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBoID0gc3FydCggaCApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gLSBiICsgaDtcbiAgICAgICAgfVxuICAgICAgICB2ZWMzIHByb2plY3QoKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBwID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1xuICAgICAgICAgICAgdmVjMyBjYW1Qb3MgPSBjYW1lcmFQb3NpdGlvbjtcbiAgICAgICAgICAgIGNhbVBvcy55IC09IGhlaWdodDtcbiAgICAgICAgICAgIGZsb2F0IGludGVyc2VjdGlvbiA9IHNwaGVyZUludGVyc2VjdCggY2FtUG9zLCBwLCB2ZWMzKCAwLjAgKSwgcmFkaXVzICk7XG4gICAgICAgICAgICBpZiggaW50ZXJzZWN0aW9uID4gMC4wICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZlYzMgaCA9IHZlYzMoIDAuMCwgLSBoZWlnaHQsIDAuMCApO1xuICAgICAgICAgICAgICAgIGZsb2F0IGludGVyc2VjdGlvbjIgPSBkaXNrSW50ZXJzZWN0V2l0aEJhY2tGYWNlQ3VsbGluZyggY2FtUG9zLCBwLCBoLCB2ZWMzKCAwLjAsIDEuMCwgMC4wICksIHJhZGl1cyApO1xuICAgICAgICAgICAgICAgIHAgPSAoIGNhbVBvcyArIG1pbiggaW50ZXJzZWN0aW9uLCBpbnRlcnNlY3Rpb24yICkgKiBwICkgLyByYWRpdXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSB2ZWMzKCAwLjAsIDEuMCwgMC4wICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgICAjaW5jbHVkZSA8Y29tbW9uPlxuICAgICAgICAjaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxuICAgICAgICB2b2lkIG1haW4oKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBwcm9qZWN0ZWRXb3JsZFBvc2l0aW9uID0gcHJvamVjdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxuICAgICAgICAgICAgICAgIHZlYzMgb3V0Y29sb3IgPSB0ZXh0dXJlQ3ViZSggbWFwLCBwcm9qZWN0ZWRXb3JsZFBvc2l0aW9uICkucmdiO1xuICAgICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgICB2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggcHJvamVjdGVkV29ybGRQb3NpdGlvbiApO1xuICAgICAgICAgICAgICAgIHZlYzIgdXYgPSBlcXVpcmVjdFV2KCBkaXJlY3Rpb24gKTtcbiAgICAgICAgICAgICAgICB2ZWMzIG91dGNvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHV2ICkucmdiO1xuICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRjb2xvciwgMS4wICk7XG4gICAgICAgICAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XG4gICAgICAgICAgICAjaW5jbHVkZSA8JHtwYXJzZUludChSRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csIFwiXCIpKSA+PSAxNTQgPyBcImNvbG9yc3BhY2VfZnJhZ21lbnRcIiA6IFwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICBtYXA6IHsgdmFsdWU6IHRleHR1cmUgfSxcbiAgICAgIGhlaWdodDogeyB2YWx1ZTogKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVpZ2h0KSB8fCAxNSB9LFxuICAgICAgcmFkaXVzOiB7IHZhbHVlOiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yYWRpdXMpIHx8IDEwMCB9XG4gICAgfTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBJY29zYWhlZHJvbkdlb21ldHJ5KDEsIDE2KTtcbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBTaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3JtcyxcbiAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgdmVydGV4U2hhZGVyLFxuICAgICAgc2lkZTogRG91YmxlU2lkZVxuICAgIH0pO1xuICAgIHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gIH1cbiAgc2V0IHJhZGl1cyhyYWRpdXMpIHtcbiAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHJhZGl1cztcbiAgfVxuICBnZXQgcmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZTtcbiAgfVxuICBzZXQgaGVpZ2h0KGhlaWdodCkge1xuICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMuaGVpZ2h0LnZhbHVlID0gaGVpZ2h0O1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMuaGVpZ2h0LnZhbHVlO1xuICB9XG59XG5leHBvcnQge1xuICBHcm91bmRQcm9qZWN0ZWRFbnZcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hcm91bmRQcm9qZWN0ZWRFbnYuanMubWFwXG4iXSwibmFtZXMiOlsiTWVzaCIsIlJFVklTSU9OIiwiSWNvc2FoZWRyb25HZW9tZXRyeSIsIlNoYWRlck1hdGVyaWFsIiwiRG91YmxlU2lkZSIsImlzQ3ViZVRleHR1cmUiLCJkZWYiLCJHcm91bmRQcm9qZWN0ZWRFbnYiLCJjb25zdHJ1Y3RvciIsInRleHR1cmUiLCJvcHRpb25zIiwiX2EiLCJfYiIsImlzQ3ViZU1hcCIsInciLCJpbWFnZSIsIndpZHRoIiwiY3ViZVNpemUiLCJfbG9kTWF4IiwiTWF0aCIsImZsb29yIiwibG9nMiIsIl9jdWJlU2l6ZSIsInBvdyIsIm1heCIsImhlaWdodCIsImRlZmluZXMiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsImpvaW4iLCJwYXJzZUludCIsInJlcGxhY2UiLCJ1bmlmb3JtcyIsIm1hcCIsInZhbHVlIiwicmFkaXVzIiwiZ2VvbWV0cnkiLCJtYXRlcmlhbCIsInNpZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key)=>obj[key];\n //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWEsQ0FBQ0MsS0FBS0MsTUFBUUQsR0FBRyxDQUFDQyxJQUFJO0FBR3ZDLENBQ0YsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JlYXRpdmUtNDA0Ly4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi90eXBlcy9oZWxwZXJzLmpzPzJmNGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZ2V0V2l0aEtleSA9IChvYmosIGtleSkgPT4gb2JqW2tleV07XG5leHBvcnQge1xuICBnZXRXaXRoS2V5XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZXRXaXRoS2V5Iiwib2JqIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups)=>{\n    const isIndexed = geometries[0].index !== null;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    const attributes = {};\n    const morphAttributes = {};\n    const morphTargetsRelative = geometries[0].morphTargetsRelative;\n    const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    let offset = 0;\n    geometries.forEach((geom, i)=>{\n        let attributesCount = 0;\n        if (isIndexed !== (geom.index !== null)) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n            return null;\n        }\n        for(let name in geom.attributes){\n            if (!attributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n                return null;\n            }\n            if (attributes[name] === void 0) {\n                attributes[name] = [];\n            }\n            attributes[name].push(geom.attributes[name]);\n            attributesCount++;\n        }\n        if (attributesCount !== attributesUsed.size) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n            return null;\n        }\n        if (morphTargetsRelative !== geom.morphTargetsRelative) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n            return null;\n        }\n        for(let name in geom.morphAttributes){\n            if (!morphAttributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n                return null;\n            }\n            if (morphAttributes[name] === void 0) morphAttributes[name] = [];\n            morphAttributes[name].push(geom.morphAttributes[name]);\n        }\n        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n        mergedGeometry.userData.mergedUserData.push(geom.userData);\n        if (useGroups) {\n            let count;\n            if (geom.index) {\n                count = geom.index.count;\n            } else if (geom.attributes.position !== void 0) {\n                count = geom.attributes.position.count;\n            } else {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n                return null;\n            }\n            mergedGeometry.addGroup(offset, count, i);\n            offset += count;\n        }\n    });\n    if (isIndexed) {\n        let indexOffset = 0;\n        const mergedIndex = [];\n        geometries.forEach((geom)=>{\n            const index = geom.index;\n            for(let j = 0; j < index.count; ++j){\n                mergedIndex.push(index.getX(j) + indexOffset);\n            }\n            indexOffset += geom.attributes.position.count;\n        });\n        mergedGeometry.setIndex(mergedIndex);\n    }\n    for(let name in attributes){\n        const mergedAttribute = mergeBufferAttributes(attributes[name]);\n        if (!mergedAttribute) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n            return null;\n        }\n        mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n    for(let name in morphAttributes){\n        const numMorphTargets = morphAttributes[name][0].length;\n        if (numMorphTargets === 0) break;\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[name] = [];\n        for(let i = 0; i < numMorphTargets; ++i){\n            const morphAttributesToMerge = [];\n            for(let j = 0; j < morphAttributes[name].length; ++j){\n                morphAttributesToMerge.push(morphAttributes[name][j][i]);\n            }\n            const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n            if (!mergedMorphAttribute) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n                return null;\n            }\n            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n        }\n    }\n    return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let itemSize = void 0;\n    let normalized = void 0;\n    let arrayLength = 0;\n    attributes.forEach((attr)=>{\n        if (TypedArray === void 0) {\n            TypedArray = attr.array.constructor;\n        }\n        if (TypedArray !== attr.array.constructor) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n            return null;\n        }\n        if (itemSize === void 0) itemSize = attr.itemSize;\n        if (itemSize !== attr.itemSize) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n            return null;\n        }\n        if (normalized === void 0) normalized = attr.normalized;\n        if (normalized !== attr.normalized) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n            return null;\n        }\n        arrayLength += attr.array.length;\n    });\n    if (TypedArray && itemSize) {\n        const array = new TypedArray(arrayLength);\n        let offset = 0;\n        attributes.forEach((attr)=>{\n            array.set(attr.array, offset);\n            offset += attr.array.length;\n        });\n        return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n    }\n};\nconst interleaveAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let arrayLength = 0;\n    let stride = 0;\n    for(let i = 0, l = attributes.length; i < l; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"AttributeBuffers of different types cannot be interleaved\");\n            return null;\n        }\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n    }\n    const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n    let offset = 0;\n    const res = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    for(let j = 0, l = attributes.length; j < l; j++){\n        const attribute = attributes[j];\n        const itemSize = attribute.itemSize;\n        const count = attribute.count;\n        const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n        res.push(iba);\n        offset += itemSize;\n        for(let c = 0; c < count; c++){\n            for(let k = 0; k < itemSize; k++){\n                const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n                const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n                set(c, get(c));\n            }\n        }\n    }\n    return res;\n};\nfunction estimateBytesUsed(geometry) {\n    let mem = 0;\n    for(let name in geometry.attributes){\n        const attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    const indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n    tolerance = Math.max(tolerance, Number.EPSILON);\n    const hashToIndex = {};\n    const indices = geometry.getIndex();\n    const positions = geometry.getAttribute(\"position\");\n    const vertexCount = indices ? indices.count : positions.count;\n    let nextIndex = 0;\n    const attributeNames = Object.keys(geometry.attributes);\n    const attrArrays = {};\n    const morphAttrsArrays = {};\n    const newIndices = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        attrArrays[name] = [];\n        const morphAttr = geometry.morphAttributes[name];\n        if (morphAttr) {\n            morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(()=>[]);\n        }\n    }\n    const decimalShift = Math.log10(1 / tolerance);\n    const shiftMultiplier = Math.pow(10, decimalShift);\n    for(let i = 0; i < vertexCount; i++){\n        const index = indices ? indices.getX(i) : i;\n        let hash = \"\";\n        for(let j = 0, l = attributeNames.length; j < l; j++){\n            const name = attributeNames[j];\n            const attribute = geometry.getAttribute(name);\n            const itemSize = attribute.itemSize;\n            for(let k = 0; k < itemSize; k++){\n                hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n            }\n        }\n        if (hash in hashToIndex) {\n            newIndices.push(hashToIndex[hash]);\n        } else {\n            for(let j = 0, l = attributeNames.length; j < l; j++){\n                const name = attributeNames[j];\n                const attribute = geometry.getAttribute(name);\n                const morphAttr = geometry.morphAttributes[name];\n                const itemSize = attribute.itemSize;\n                const newarray = attrArrays[name];\n                const newMorphArrays = morphAttrsArrays[name];\n                for(let k = 0; k < itemSize; k++){\n                    const getterFunc = getters[k];\n                    newarray.push(attribute[getterFunc](index));\n                    if (morphAttr) {\n                        for(let m = 0, ml = morphAttr.length; m < ml; m++){\n                            newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n                        }\n                    }\n                }\n            }\n            hashToIndex[hash] = nextIndex;\n            newIndices.push(nextIndex);\n            nextIndex++;\n        }\n    }\n    const result = geometry.clone();\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        const oldAttribute = geometry.getAttribute(name);\n        const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n        const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n        result.setAttribute(name, attribute);\n        if (name in morphAttrsArrays) {\n            for(let j = 0; j < morphAttrsArrays[name].length; j++){\n                const oldMorphAttribute = geometry.morphAttributes[name][j];\n                const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n                const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n                result.morphAttributes[name][j] = morphAttribute;\n            }\n        }\n    }\n    result.setIndex(newIndices);\n    return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n        console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n        return geometry;\n    }\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n        let index = geometry.getIndex();\n        if (index === null) {\n            const indices = [];\n            const position = geometry.getAttribute(\"position\");\n            if (position !== void 0) {\n                for(let i = 0; i < position.count; i++){\n                    indices.push(i);\n                }\n                geometry.setIndex(indices);\n                index = geometry.getIndex();\n            } else {\n                console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n                return geometry;\n            }\n        }\n        const numberOfTriangles = index.count - 2;\n        const newIndices = [];\n        if (index) {\n            if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n                for(let i = 1; i <= numberOfTriangles; i++){\n                    newIndices.push(index.getX(0));\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                }\n            } else {\n                for(let i = 0; i < numberOfTriangles; i++){\n                    if (i % 2 === 0) {\n                        newIndices.push(index.getX(i));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i + 2));\n                    } else {\n                        newIndices.push(index.getX(i + 2));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i));\n                    }\n                }\n            }\n        }\n        if (newIndices.length / 3 !== numberOfTriangles) {\n            console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n        }\n        const newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n        return newGeometry;\n    } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n        return geometry;\n    }\n}\nfunction computeMorphedAttributes(object) {\n    if (object.geometry.isBufferGeometry !== true) {\n        console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n        return null;\n    }\n    const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n        _vA.fromBufferAttribute(attribute, a2);\n        _vB.fromBufferAttribute(attribute, b2);\n        _vC.fromBufferAttribute(attribute, c2);\n        const morphInfluences = object2.morphTargetInfluences;\n        if (// @ts-ignore\n        material2.morphTargets && morphAttribute && morphInfluences) {\n            _morphA.set(0, 0, 0);\n            _morphB.set(0, 0, 0);\n            _morphC.set(0, 0, 0);\n            for(let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++){\n                const influence = morphInfluences[i2];\n                const morph = morphAttribute[i2];\n                if (influence === 0) continue;\n                _tempA.fromBufferAttribute(morph, a2);\n                _tempB.fromBufferAttribute(morph, b2);\n                _tempC.fromBufferAttribute(morph, c2);\n                if (morphTargetsRelative2) {\n                    _morphA.addScaledVector(_tempA, influence);\n                    _morphB.addScaledVector(_tempB, influence);\n                    _morphC.addScaledVector(_tempC, influence);\n                } else {\n                    _morphA.addScaledVector(_tempA.sub(_vA), influence);\n                    _morphB.addScaledVector(_tempB.sub(_vB), influence);\n                    _morphC.addScaledVector(_tempC.sub(_vC), influence);\n                }\n            }\n            _vA.add(_morphA);\n            _vB.add(_morphB);\n            _vC.add(_morphC);\n        }\n        if (object2.isSkinnedMesh) {\n            object2.boneTransform(a2, _vA);\n            object2.boneTransform(b2, _vB);\n            object2.boneTransform(c2, _vC);\n        }\n        modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n    }\n    const geometry = object.geometry;\n    const material = object.material;\n    let a, b, c;\n    const index = geometry.index;\n    const positionAttribute = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const normalAttribute = geometry.attributes.normal;\n    const morphNormal = geometry.morphAttributes.position;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    let i, j, il, jl;\n    let group, groupMaterial;\n    let start, end;\n    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n    if (index !== null) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = index.getX(j);\n                    b = index.getX(j + 1);\n                    c = index.getX(j + 2);\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(index.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = index.getX(i);\n                b = index.getX(i + 1);\n                c = index.getX(i + 2);\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    } else if (positionAttribute !== void 0) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = j;\n                    b = j + 1;\n                    c = j + 2;\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = i;\n                b = i + 1;\n                c = i + 2;\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    }\n    const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n    const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n    return {\n        positionAttribute,\n        normalAttribute,\n        morphedPositionAttribute,\n        morphedNormalAttribute\n    };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n    const creaseDot = Math.cos(creaseAngle);\n    const hashMultiplier = (1 + 1e-10) * 100;\n    const verts = [\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n    ];\n    const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function hashVertex(v) {\n        const x = ~~(v.x * hashMultiplier);\n        const y = ~~(v.y * hashMultiplier);\n        const z = ~~(v.z * hashMultiplier);\n        return `${x},${y},${z}`;\n    }\n    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    const posAttr = resultGeometry.attributes.position;\n    const vertexMap = {};\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            if (!(hash in vertexMap)) {\n                vertexMap[hash] = [];\n            }\n            vertexMap[hash].push(normal);\n        }\n    }\n    const normalArray = new Float32Array(posAttr.count * 3);\n    const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            const otherNormals = vertexMap[hash];\n            tempNorm2.set(0, 0, 0);\n            for(let k = 0, lk = otherNormals.length; k < lk; k++){\n                const otherNorm = otherNormals[k];\n                if (tempNorm.dot(otherNorm) > creaseDot) {\n                    tempNorm2.add(otherNorm);\n                }\n            }\n            tempNorm2.normalize();\n            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n        }\n    }\n    resultGeometry.setAttribute(\"normal\", normAttr);\n    return resultGeometry;\n}\n //# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRCxNQUFNVSx3QkFBd0IsQ0FBQ0MsWUFBWUM7SUFDekMsTUFBTUMsWUFBWUYsVUFBVSxDQUFDLEVBQUUsQ0FBQ0csS0FBSyxLQUFLO0lBQzFDLE1BQU1DLGlCQUFpQixJQUFJQyxJQUFJQyxPQUFPQyxJQUFJLENBQUNQLFVBQVUsQ0FBQyxFQUFFLENBQUNRLFVBQVU7SUFDbkUsTUFBTUMsc0JBQXNCLElBQUlKLElBQUlDLE9BQU9DLElBQUksQ0FBQ1AsVUFBVSxDQUFDLEVBQUUsQ0FBQ1UsZUFBZTtJQUM3RSxNQUFNRixhQUFhLENBQUM7SUFDcEIsTUFBTUUsa0JBQWtCLENBQUM7SUFDekIsTUFBTUMsdUJBQXVCWCxVQUFVLENBQUMsRUFBRSxDQUFDVyxvQkFBb0I7SUFDL0QsTUFBTUMsaUJBQWlCLElBQUl2QixpREFBY0E7SUFDekMsSUFBSXdCLFNBQVM7SUFDYmIsV0FBV2MsT0FBTyxDQUFDLENBQUNDLE1BQU1DO1FBQ3hCLElBQUlDLGtCQUFrQjtRQUN0QixJQUFJZixjQUFlYSxDQUFBQSxLQUFLWixLQUFLLEtBQUssSUFBRyxHQUFJO1lBQ3ZDZSxRQUFRQyxLQUFLLENBQ1gsdUZBQXVGSCxJQUFJO1lBRTdGLE9BQU87UUFDVDtRQUNBLElBQUssSUFBSUksUUFBUUwsS0FBS1AsVUFBVSxDQUFFO1lBQ2hDLElBQUksQ0FBQ0osZUFBZWlCLEdBQUcsQ0FBQ0QsT0FBTztnQkFDN0JGLFFBQVFDLEtBQUssQ0FDWCx1RkFBdUZILElBQUksa0VBQWtFSSxPQUFPO2dCQUV0SyxPQUFPO1lBQ1Q7WUFDQSxJQUFJWixVQUFVLENBQUNZLEtBQUssS0FBSyxLQUFLLEdBQUc7Z0JBQy9CWixVQUFVLENBQUNZLEtBQUssR0FBRyxFQUFFO1lBQ3ZCO1lBQ0FaLFVBQVUsQ0FBQ1ksS0FBSyxD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cy90aHJlZS1zdGRsaWIvdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qcz8xMmU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgVHJpYW5nbGVzRHJhd01vZGUsIFRyaWFuZ2xlRmFuRHJhd01vZGUsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVmVjdG9yMywgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgZ2V0V2l0aEtleSB9IGZyb20gXCIuLi90eXBlcy9oZWxwZXJzLmpzXCI7XG5jb25zdCBtZXJnZUJ1ZmZlckdlb21ldHJpZXMgPSAoZ2VvbWV0cmllcywgdXNlR3JvdXBzKSA9PiB7XG4gIGNvbnN0IGlzSW5kZXhlZCA9IGdlb21ldHJpZXNbMF0uaW5kZXggIT09IG51bGw7XG4gIGNvbnN0IGF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLmF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZ2VvbWV0cmllc1swXS5tb3JwaEF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyaWVzWzBdLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuICBjb25zdCBtZXJnZWRHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tLCBpKSA9PiB7XG4gICAgbGV0IGF0dHJpYnV0ZXNDb3VudCA9IDA7XG4gICAgaWYgKGlzSW5kZXhlZCAhPT0gKGdlb20uaW5kZXggIT09IG51bGwpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gQWxsIGdlb21ldHJpZXMgbXVzdCBoYXZlIGNvbXBhdGlibGUgYXR0cmlidXRlczsgbWFrZSBzdXJlIGluZGV4IGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20uYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFhdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyAnLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgXCInICsgbmFtZSArICdcIiBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20uYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgICBhdHRyaWJ1dGVzQ291bnQrKztcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXNDb3VudCAhPT0gYXR0cmlidXRlc1VzZWQuc2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIE1ha2Ugc3VyZSBhbGwgZ2VvbWV0cmllcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSAhPT0gZ2VvbS5tb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIC5tb3JwaFRhcmdldHNSZWxhdGl2ZSBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20ubW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIW1vcnBoQXR0cmlidXRlc1VzZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuICAubW9ycGhBdHRyaWJ1dGVzIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9PT0gdm9pZCAwKVxuICAgICAgICBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20ubW9ycGhBdHRyaWJ1dGVzW25hbWVdKTtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEgPSBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSB8fCBbXTtcbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YS5wdXNoKGdlb20udXNlckRhdGEpO1xuICAgIGlmICh1c2VHcm91cHMpIHtcbiAgICAgIGxldCBjb3VudDtcbiAgICAgIGlmIChnZW9tLmluZGV4KSB7XG4gICAgICAgIGNvdW50ID0gZ2VvbS5pbmRleC5jb3VudDtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBUaGUgZ2VvbWV0cnkgbXVzdCBoYXZlIGVpdGhlciBhbiBpbmRleCBvciBhIHBvc2l0aW9uIGF0dHJpYnV0ZVwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbWVyZ2VkR2VvbWV0cnkuYWRkR3JvdXAob2Zmc2V0LCBjb3VudCwgaSk7XG4gICAgICBvZmZzZXQgKz0gY291bnQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKGlzSW5kZXhlZCkge1xuICAgIGxldCBpbmRleE9mZnNldCA9IDA7XG4gICAgY29uc3QgbWVyZ2VkSW5kZXggPSBbXTtcbiAgICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20pID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2VvbS5pbmRleDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXguY291bnQ7ICsraikge1xuICAgICAgICBtZXJnZWRJbmRleC5wdXNoKGluZGV4LmdldFgoaikgKyBpbmRleE9mZnNldCk7XG4gICAgICB9XG4gICAgICBpbmRleE9mZnNldCArPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgfSk7XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0SW5kZXgobWVyZ2VkSW5kZXgpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhhdHRyaWJ1dGVzW25hbWVdKTtcbiAgICBpZiAoIW1lcmdlZEF0dHJpYnV0ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgYXR0cmlidXRlLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1lcmdlZEdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBtZXJnZWRBdHRyaWJ1dGUpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhBdHRyaWJ1dGVzW25hbWVdWzBdLmxlbmd0aDtcbiAgICBpZiAobnVtTW9ycGhUYXJnZXRzID09PSAwKVxuICAgICAgYnJlYWs7XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzID0gbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyArK2kpIHtcbiAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UucHVzaChtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal1baV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVyZ2VkTW9ycGhBdHRyaWJ1dGUgPSBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMobW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSk7XG4gICAgICBpZiAoIW1lcmdlZE1vcnBoQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgbW9ycGhBdHRyaWJ1dGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0ucHVzaChtZXJnZWRNb3JwaEF0dHJpYnV0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRHZW9tZXRyeTtcbn07XG5jb25zdCBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGl0ZW1TaXplID0gdm9pZCAwO1xuICBsZXQgbm9ybWFsaXplZCA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgaWYgKFR5cGVkQXJyYXkgPT09IHZvaWQgMCkge1xuICAgICAgVHlwZWRBcnJheSA9IGF0dHIuYXJyYXkuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5hcnJheSBtdXN0IGJlIG9mIGNvbnNpc3RlbnQgYXJyYXkgdHlwZXMgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGl0ZW1TaXplID09PSB2b2lkIDApXG4gICAgICBpdGVtU2l6ZSA9IGF0dHIuaXRlbVNpemU7XG4gICAgaWYgKGl0ZW1TaXplICE9PSBhdHRyLml0ZW1TaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWQgPT09IHZvaWQgMClcbiAgICAgIG5vcm1hbGl6ZWQgPSBhdHRyLm5vcm1hbGl6ZWQ7XG4gICAgaWYgKG5vcm1hbGl6ZWQgIT09IGF0dHIubm9ybWFsaXplZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gIH0pO1xuICBpZiAoVHlwZWRBcnJheSAmJiBpdGVtU2l6ZSkge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYXJyYXlMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgYXJyYXkuc2V0KGF0dHIuYXJyYXksIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgfVxufTtcbmNvbnN0IGludGVybGVhdmVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IFR5cGVkQXJyYXkgPSB2b2lkIDA7XG4gIGxldCBhcnJheUxlbmd0aCA9IDA7XG4gIGxldCBzdHJpZGUgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKVxuICAgICAgVHlwZWRBcnJheSA9IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoVHlwZWRBcnJheSAhPT0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQXR0cmlidXRlQnVmZmVycyBvZiBkaWZmZXJlbnQgdHlwZXMgY2Fubm90IGJlIGludGVybGVhdmVkXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFycmF5TGVuZ3RoICs9IGF0dHJpYnV0ZS5hcnJheS5sZW5ndGg7XG4gICAgc3RyaWRlICs9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgfVxuICBjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCksIHN0cmlkZSk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGNvbnN0IHNldHRlcnMgPSBbXCJzZXRYXCIsIFwic2V0WVwiLCBcInNldFpcIiwgXCJzZXRXXCJdO1xuICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcbiAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICBjb25zdCBjb3VudCA9IGF0dHJpYnV0ZS5jb3VudDtcbiAgICBjb25zdCBpYmEgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXMucHVzaChpYmEpO1xuICAgIG9mZnNldCArPSBpdGVtU2l6ZTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvdW50OyBjKyspIHtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBjb25zdCBzZXQgPSBnZXRXaXRoS2V5KGliYSwgc2V0dGVyc1trXSk7XG4gICAgICAgIGNvbnN0IGdldCA9IGdldFdpdGhLZXkoYXR0cmlidXRlLCBnZXR0ZXJzW2tdKTtcbiAgICAgICAgc2V0KGMsIGdldChjKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gZXN0aW1hdGVCeXRlc1VzZWQoZ2VvbWV0cnkpIHtcbiAgbGV0IG1lbSA9IDA7XG4gIGZvciAobGV0IG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgbWVtICs9IGF0dHIuY291bnQgKiBhdHRyLml0ZW1TaXplICogYXR0ci5hcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgfVxuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgbWVtICs9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50ICogaW5kaWNlcy5pdGVtU2l6ZSAqIGluZGljZXMuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAwO1xuICByZXR1cm4gbWVtO1xufVxuZnVuY3Rpb24gbWVyZ2VWZXJ0aWNlcyhnZW9tZXRyeSwgdG9sZXJhbmNlID0gMWUtNCkge1xuICB0b2xlcmFuY2UgPSBNYXRoLm1heCh0b2xlcmFuY2UsIE51bWJlci5FUFNJTE9OKTtcbiAgY29uc3QgaGFzaFRvSW5kZXggPSB7fTtcbiAgY29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICBjb25zdCB2ZXJ0ZXhDb3VudCA9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50IDogcG9zaXRpb25zLmNvdW50O1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhnZW9tZXRyeS5hdHRyaWJ1dGVzKTtcbiAgY29uc3QgYXR0ckFycmF5cyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJzQXJyYXlzID0ge307XG4gIGNvbnN0IG5ld0luZGljZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGF0dHJBcnJheXNbbmFtZV0gPSBbXTtcbiAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgaWYgKG1vcnBoQXR0cikge1xuICAgICAgbW9ycGhBdHRyc0FycmF5c1tuYW1lXSA9IG5ldyBBcnJheShtb3JwaEF0dHIubGVuZ3RoKS5maWxsKDApLm1hcCgoKSA9PiBbXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxTaGlmdCA9IE1hdGgubG9nMTAoMSAvIHRvbGVyYW5jZSk7XG4gIGNvbnN0IHNoaWZ0TXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBkZWNpbWFsU2hpZnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcbiAgICBjb25zdCBpbmRleCA9IGluZGljZXMgPyBpbmRpY2VzLmdldFgoaSkgOiBpO1xuICAgIGxldCBoYXNoID0gXCJcIjtcbiAgICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgaGFzaCArPSBgJHt+fihhdHRyaWJ1dGVbZ2V0dGVyc1trXV0oaW5kZXgpICogc2hpZnRNdWx0aXBsaWVyKX0sYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc2ggaW4gaGFzaFRvSW5kZXgpIHtcbiAgICAgIG5ld0luZGljZXMucHVzaChoYXNoVG9JbmRleFtoYXNoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tqXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgICBjb25zdCBuZXdhcnJheSA9IGF0dHJBcnJheXNbbmFtZV07XG4gICAgICAgIGNvbnN0IG5ld01vcnBoQXJyYXlzID0gbW9ycGhBdHRyc0FycmF5c1tuYW1lXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgICAgY29uc3QgZ2V0dGVyRnVuYyA9IGdldHRlcnNba107XG4gICAgICAgICAgbmV3YXJyYXkucHVzaChhdHRyaWJ1dGVbZ2V0dGVyRnVuY10oaW5kZXgpKTtcbiAgICAgICAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHIubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuICAgICAgICAgICAgICBuZXdNb3JwaEFycmF5c1ttXS5wdXNoKG1vcnBoQXR0clttXVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFzaFRvSW5kZXhbaGFzaF0gPSBuZXh0SW5kZXg7XG4gICAgICBuZXdJbmRpY2VzLnB1c2gobmV4dEluZGV4KTtcbiAgICAgIG5leHRJbmRleCsrO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICBjb25zdCBvbGRBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IG9sZEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcihhdHRyQXJyYXlzW25hbWVdKTtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlciwgb2xkQXR0cmlidXRlLml0ZW1TaXplLCBvbGRBdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgcmVzdWx0LnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpO1xuICAgIGlmIChuYW1lIGluIG1vcnBoQXR0cnNBcnJheXMpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyc0FycmF5c1tuYW1lXS5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBvbGRNb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXTtcbiAgICAgICAgY29uc3QgYnVmZmVyMiA9IG5ldyBvbGRNb3JwaEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcihtb3JwaEF0dHJzQXJyYXlzW25hbWVdW2pdKTtcbiAgICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcjIsIG9sZE1vcnBoQXR0cmlidXRlLml0ZW1TaXplLCBvbGRNb3JwaEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICAgICAgcmVzdWx0Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXSA9IG1vcnBoQXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXN1bHQuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RyaWFuZ2xlc0RyYXdNb2RlKGdlb21ldHJ5LCBkcmF3TW9kZSkge1xuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlc0RyYXdNb2RlKSB7XG4gICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IEdlb21ldHJ5IGFscmVhZHkgZGVmaW5lZCBhcyB0cmlhbmdsZXMuXCIpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUgfHwgZHJhd01vZGUgPT09IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSkge1xuICAgIGxldCBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICAgICAgaWYgKHBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbi5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGdlb21ldHJ5LnNldEluZGV4KGluZGljZXMpO1xuICAgICAgICBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuZGVmaW5lZCBwb3NpdGlvbiBhdHRyaWJ1dGUuIFByb2Nlc3Npbmcgbm90IHBvc3NpYmxlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZUcmlhbmdsZXMgPSBpbmRleC5jb3VudCAtIDI7XG4gICAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICAgIGlmIChpbmRleCkge1xuICAgICAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG51bWJlck9mVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WCgwKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3SW5kaWNlcy5sZW5ndGggLyAzICE9PSBudW1iZXJPZlRyaWFuZ2xlcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmFibGUgdG8gZ2VuZXJhdGUgY29ycmVjdCBhbW91bnQgb2YgdHJpYW5nbGVzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbmV3R2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICAgIG5ld0dlb21ldHJ5LnNldEluZGV4KG5ld0luZGljZXMpO1xuICAgIG5ld0dlb21ldHJ5LmNsZWFyR3JvdXBzKCk7XG4gICAgcmV0dXJuIG5ld0dlb21ldHJ5O1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5rbm93biBkcmF3IG1vZGU6XCIsIGRyYXdNb2RlKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyhvYmplY3QpIHtcbiAgaWYgKG9iamVjdC5nZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICE9PSB0cnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IEdlb21ldHJ5IGlzIG5vdCBvZiB0eXBlIEJ1ZmZlckdlb21ldHJ5LlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBfdkEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEMgPSBuZXcgVmVjdG9yMygpO1xuICBmdW5jdGlvbiBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEob2JqZWN0MiwgbWF0ZXJpYWwyLCBhdHRyaWJ1dGUsIG1vcnBoQXR0cmlidXRlLCBtb3JwaFRhcmdldHNSZWxhdGl2ZTIsIGEyLCBiMiwgYzIsIG1vZGlmaWVkQXR0cmlidXRlQXJyYXkpIHtcbiAgICBfdkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGEyKTtcbiAgICBfdkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGIyKTtcbiAgICBfdkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGMyKTtcbiAgICBjb25zdCBtb3JwaEluZmx1ZW5jZXMgPSBvYmplY3QyLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcbiAgICBpZiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBtYXRlcmlhbDIubW9ycGhUYXJnZXRzICYmIG1vcnBoQXR0cmlidXRlICYmIG1vcnBoSW5mbHVlbmNlc1xuICAgICkge1xuICAgICAgX21vcnBoQS5zZXQoMCwgMCwgMCk7XG4gICAgICBfbW9ycGhCLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEMuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgaTIgPSAwLCBpbDIgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkyIDwgaWwyOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1tpMl07XG4gICAgICAgIGNvbnN0IG1vcnBoID0gbW9ycGhBdHRyaWJ1dGVbaTJdO1xuICAgICAgICBpZiAoaW5mbHVlbmNlID09PSAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBfdGVtcEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYTIpO1xuICAgICAgICBfdGVtcEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYjIpO1xuICAgICAgICBfdGVtcEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYzIpO1xuICAgICAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUyKSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQiwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMsIGluZmx1ZW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLnN1YihfdkEpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQi5zdWIoX3ZCKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMuc3ViKF92QyksIGluZmx1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF92QS5hZGQoX21vcnBoQSk7XG4gICAgICBfdkIuYWRkKF9tb3JwaEIpO1xuICAgICAgX3ZDLmFkZChfbW9ycGhDKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdDIuaXNTa2lubmVkTWVzaCkge1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGEyLCBfdkEpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGIyLCBfdkIpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGMyLCBfdkMpO1xuICAgIH1cbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDBdID0gX3ZBLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAxXSA9IF92QS55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMl0gPSBfdkEuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDBdID0gX3ZCLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAxXSA9IF92Qi55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMl0gPSBfdkIuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDBdID0gX3ZDLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAxXSA9IF92Qy55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMl0gPSBfdkMuejtcbiAgfVxuICBjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgY29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG4gIGxldCBhLCBiLCBjO1xuICBjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICBjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG5vcm1hbEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuICBjb25zdCBtb3JwaE5vcm1hbCA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICBjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG4gIGxldCBpLCBqLCBpbCwgamw7XG4gIGxldCBncm91cCwgZ3JvdXBNYXRlcmlhbDtcbiAgbGV0IHN0YXJ0LCBlbmQ7XG4gIGNvbnN0IG1vZGlmaWVkUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uQXR0cmlidXRlLmNvdW50ICogcG9zaXRpb25BdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBjb25zdCBtb2RpZmllZE5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsQXR0cmlidXRlLmNvdW50ICogbm9ybWFsQXR0cmlidXRlLml0ZW1TaXplKTtcbiAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcbiAgICAgICAgICBhID0gaW5kZXguZ2V0WChqKTtcbiAgICAgICAgICBiID0gaW5kZXguZ2V0WChqICsgMSk7XG4gICAgICAgICAgYyA9IGluZGV4LmdldFgoaiArIDIpO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgIGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuICAgICAgICBhID0gaW5kZXguZ2V0WChpKTtcbiAgICAgICAgYiA9IGluZGV4LmdldFgoaSArIDEpO1xuICAgICAgICBjID0gaW5kZXguZ2V0WChpICsgMik7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHBvc2l0aW9uQXR0cmlidXRlICE9PSB2b2lkIDApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBqO1xuICAgICAgICAgIGIgPSBqICsgMTtcbiAgICAgICAgICBjID0gaiArIDI7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4ocG9zaXRpb25BdHRyaWJ1dGUuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpO1xuICAgICAgICBiID0gaSArIDE7XG4gICAgICAgIGMgPSBpICsgMjtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobW9kaWZpZWRQb3NpdGlvbiwgMyk7XG4gIGNvbnN0IG1vcnBoZWROb3JtYWxBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZE5vcm1hbCwgMyk7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgbm9ybWFsQXR0cmlidXRlLFxuICAgIG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBtb3JwaGVkTm9ybWFsQXR0cmlidXRlXG4gIH07XG59XG5mdW5jdGlvbiB0b0NyZWFzZWROb3JtYWxzKGdlb21ldHJ5LCBjcmVhc2VBbmdsZSA9IE1hdGguUEkgLyAzKSB7XG4gIGNvbnN0IGNyZWFzZURvdCA9IE1hdGguY29zKGNyZWFzZUFuZ2xlKTtcbiAgY29uc3QgaGFzaE11bHRpcGxpZXIgPSAoMSArIDFlLTEwKSAqIDEwMDtcbiAgY29uc3QgdmVydHMgPSBbbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKV07XG4gIGNvbnN0IHRlbXBWZWMxID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcFZlYzIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wTm9ybSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIGhhc2hWZXJ0ZXgodikge1xuICAgIGNvbnN0IHggPSB+fih2LnggKiBoYXNoTXVsdGlwbGllcik7XG4gICAgY29uc3QgeSA9IH5+KHYueSAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB6ID0gfn4odi56ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIHJldHVybiBgJHt4fSwke3l9LCR7en1gO1xuICB9XG4gIGNvbnN0IHJlc3VsdEdlb21ldHJ5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS50b05vbkluZGV4ZWQoKSA6IGdlb21ldHJ5O1xuICBjb25zdCBwb3NBdHRyID0gcmVzdWx0R2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgdmVydGV4TWFwID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyh0ZW1wVmVjMSwgdGVtcFZlYzIpLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMzsgbisrKSB7XG4gICAgICBjb25zdCB2ZXJ0ID0gdmVydHNbbl07XG4gICAgICBjb25zdCBoYXNoID0gaGFzaFZlcnRleCh2ZXJ0KTtcbiAgICAgIGlmICghKGhhc2ggaW4gdmVydGV4TWFwKSkge1xuICAgICAgICB2ZXJ0ZXhNYXBbaGFzaF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHZlcnRleE1hcFtoYXNoXS5wdXNoKG5vcm1hbCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShwb3NBdHRyLmNvdW50ICogMyk7XG4gIGNvbnN0IG5vcm1BdHRyID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBcnJheSwgMywgZmFsc2UpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaTMgPSAzICogaTtcbiAgICBjb25zdCBhID0gdmVydHNbMF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDApO1xuICAgIGNvbnN0IGIgPSB2ZXJ0c1sxXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMSk7XG4gICAgY29uc3QgYyA9IHZlcnRzWzJdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAyKTtcbiAgICB0ZW1wVmVjMS5zdWJWZWN0b3JzKGMsIGIpO1xuICAgIHRlbXBWZWMyLnN1YlZlY3RvcnMoYSwgYik7XG4gICAgdGVtcE5vcm0uY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgY29uc3Qgb3RoZXJOb3JtYWxzID0gdmVydGV4TWFwW2hhc2hdO1xuICAgICAgdGVtcE5vcm0yLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGsgPSAwLCBsayA9IG90aGVyTm9ybWFscy5sZW5ndGg7IGsgPCBsazsgaysrKSB7XG4gICAgICAgIGNvbnN0IG90aGVyTm9ybSA9IG90aGVyTm9ybWFsc1trXTtcbiAgICAgICAgaWYgKHRlbXBOb3JtLmRvdChvdGhlck5vcm0pID4gY3JlYXNlRG90KSB7XG4gICAgICAgICAgdGVtcE5vcm0yLmFkZChvdGhlck5vcm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wTm9ybTIubm9ybWFsaXplKCk7XG4gICAgICBub3JtQXR0ci5zZXRYWVooaTMgKyBuLCB0ZW1wTm9ybTIueCwgdGVtcE5vcm0yLnksIHRlbXBOb3JtMi56KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0R2VvbWV0cnkuc2V0QXR0cmlidXRlKFwibm9ybWFsXCIsIG5vcm1BdHRyKTtcbiAgcmV0dXJuIHJlc3VsdEdlb21ldHJ5O1xufVxuZXhwb3J0IHtcbiAgY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzLFxuICBlc3RpbWF0ZUJ5dGVzVXNlZCxcbiAgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMsXG4gIG1lcmdlQnVmZmVyQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzLFxuICBtZXJnZVZlcnRpY2VzLFxuICB0b0NyZWFzZWROb3JtYWxzLFxuICB0b1RyaWFuZ2xlc0RyYXdNb2RlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyR2VvbWV0cnlVdGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJCdWZmZXJHZW9tZXRyeSIsIkJ1ZmZlckF0dHJpYnV0ZSIsIkludGVybGVhdmVkQnVmZmVyIiwiSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUiLCJUcmlhbmdsZXNEcmF3TW9kZSIsIlRyaWFuZ2xlRmFuRHJhd01vZGUiLCJUcmlhbmdsZVN0cmlwRHJhd01vZGUiLCJWZWN0b3IzIiwiRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSIsImdldFdpdGhLZXkiLCJtZXJnZUJ1ZmZlckdlb21ldHJpZXMiLCJnZW9tZXRyaWVzIiwidXNlR3JvdXBzIiwiaXNJbmRleGVkIiwiaW5kZXgiLCJhdHRyaWJ1dGVzVXNlZCIsIlNldCIsIk9iamVjdCIsImtleXMiLCJhdHRyaWJ1dGVzIiwibW9ycGhBdHRyaWJ1dGVzVXNlZCIsIm1vcnBoQXR0cmlidXRlcyIsIm1vcnBoVGFyZ2V0c1JlbGF0aXZlIiwibWVyZ2VkR2VvbWV0cnkiLCJvZmZzZXQiLCJmb3JFYWNoIiwiZ2VvbSIsImkiLCJhdHRyaWJ1dGVzQ291bnQiLCJjb25zb2xlIiwiZXJyb3IiLCJuYW1lIiwiaGFzIiwicHVzaCIsInNpemUiLCJ1c2VyRGF0YSIsIm1lcmdlZFVzZXJEYXRhIiwiY291bnQiLCJwb3NpdGlvbiIsImFkZEdyb3VwIiwiaW5kZXhPZmZzZXQiLCJtZXJnZWRJbmRleCIsImoiLCJnZXRYIiwic2V0SW5kZXgiLCJtZXJnZWRBdHRyaWJ1dGUiLCJtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGUiLCJudW1Nb3JwaFRhcmdldHMiLCJsZW5ndGgiLCJtb3JwaEF0dHJpYnV0ZXNUb01lcmdlIiwibWVyZ2VkTW9ycGhBdHRyaWJ1dGUiLCJUeXBlZEFycmF5IiwiaXRlbVNpemUiLCJub3JtYWxpemVkIiwiYXJyYXlMZW5ndGgiLCJhdHRyIiwiYXJyYXkiLCJjb25zdHJ1Y3RvciIsInNldCIsImludGVybGVhdmVBdHRyaWJ1dGVzIiwic3RyaWRlIiwibCIsImF0dHJpYnV0ZSIsImludGVybGVhdmVkQnVmZmVyIiwicmVzIiwiZ2V0dGVycyIsInNldHRlcnMiLCJpYmEiLCJjIiwiayIsImdldCIsImVzdGltYXRlQnl0ZXNVc2VkIiwiZ2VvbWV0cnkiLCJtZW0iLCJnZXRBdHRyaWJ1dGUiLCJCWVRFU19QRVJfRUxFTUVOVCIsImluZGljZXMiLCJnZXRJbmRleCIsIm1lcmdlVmVydGljZXMiLCJ0b2xlcmFuY2UiLCJNYXRoIiwibWF4IiwiTnVtYmVyIiwiRVBTSUxPTiIsImhhc2hUb0luZGV4IiwicG9zaXRpb25zIiwidmVydGV4Q291bnQiLCJuZXh0SW5kZXgiLCJhdHRyaWJ1dGVOYW1lcyIsImF0dHJBcnJheXMiLCJtb3JwaEF0dHJzQXJyYXlzIiwibmV3SW5kaWNlcyIsIm1vcnBoQXR0ciIsIkFycmF5IiwiZmlsbCIsIm1hcCIsImRlY2ltYWxTaGlmdCIsImxvZzEwIiwic2hpZnRNdWx0aXBsaWVyIiwicG93IiwiaGFzaCIsIm5ld2FycmF5IiwibmV3TW9ycGhBcnJheXMiLCJnZXR0ZXJGdW5jIiwibSIsIm1sIiwicmVzdWx0IiwiY2xvbmUiLCJvbGRBdHRyaWJ1dGUiLCJidWZmZXIiLCJvbGRNb3JwaEF0dHJpYnV0ZSIsImJ1ZmZlcjIiLCJtb3JwaEF0dHJpYnV0ZSIsInRvVHJpYW5nbGVzRHJhd01vZGUiLCJkcmF3TW9kZSIsIndhcm4iLCJudW1iZXJPZlRyaWFuZ2xlcyIsIm5ld0dlb21ldHJ5IiwiY2xlYXJHcm91cHMiLCJjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMiLCJvYmplY3QiLCJpc0J1ZmZlckdlb21ldHJ5IiwiX3ZBIiwiX3ZCIiwiX3ZDIiwiX3RlbXBBIiwiX3RlbXBCIiwiX3RlbXBDIiwiX21vcnBoQSIsIl9tb3JwaEIiLCJfbW9ycGhDIiwiX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhIiwib2JqZWN0MiIsIm1hdGVyaWFsMiIsIm1vcnBoVGFyZ2V0c1JlbGF0aXZlMiIsImEyIiwiYjIiLCJjMiIsIm1vZGlmaWVkQXR0cmlidXRlQXJyYXkiLCJmcm9tQnVmZmVyQXR0cmlidXRlIiwibW9ycGhJbmZsdWVuY2VzIiwibW9ycGhUYXJnZXRJbmZsdWVuY2VzIiwibW9ycGhUYXJnZXRzIiwiaTIiLCJpbDIiLCJpbmZsdWVuY2UiLCJtb3JwaCIsImFkZFNjYWxlZFZlY3RvciIsInN1YiIsImFkZCIsImlzU2tpbm5lZE1lc2giLCJib25lVHJhbnNmb3JtIiwieCIsInkiLCJ6IiwibWF0ZXJpYWwiLCJhIiwiYiIsInBvc2l0aW9uQXR0cmlidXRlIiwibW9ycGhQb3NpdGlvbiIsIm5vcm1hbEF0dHJpYnV0ZSIsIm5vcm1hbCIsIm1vcnBoTm9ybWFsIiwiZ3JvdXBzIiwiZHJhd1JhbmdlIiwiaWwiLCJqbCIsImdyb3VwIiwiZ3JvdXBNYXRlcmlhbCIsInN0YXJ0IiwiZW5kIiwibW9kaWZpZWRQb3NpdGlvbiIsIkZsb2F0MzJBcnJheSIsIm1vZGlmaWVkTm9ybWFsIiwiaXNBcnJheSIsIm1hdGVyaWFsSW5kZXgiLCJtaW4iLCJtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUiLCJtb3JwaGVkTm9ybWFsQXR0cmlidXRlIiwidG9DcmVhc2VkTm9ybWFscyIsImNyZWFzZUFuZ2xlIiwiUEkiLCJjcmVhc2VEb3QiLCJjb3MiLCJoYXNoTXVsdGlwbGllciIsInZlcnRzIiwidGVtcFZlYzEiLCJ0ZW1wVmVjMiIsInRlbXBOb3JtIiwidGVtcE5vcm0yIiwiaGFzaFZlcnRleCIsInYiLCJyZXN1bHRHZW9tZXRyeSIsInRvTm9uSW5kZXhlZCIsInBvc0F0dHIiLCJ2ZXJ0ZXhNYXAiLCJpMyIsInN1YlZlY3RvcnMiLCJjcm9zc1ZlY3RvcnMiLCJub3JtYWxpemUiLCJuIiwidmVydCIsIm5vcm1hbEFycmF5Iiwibm9ybUF0dHIiLCJvdGhlck5vcm1hbHMiLCJsayIsIm90aGVyTm9ybSIsImRvdCIsInNldFhZWiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ })

};
;