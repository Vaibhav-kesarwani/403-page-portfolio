"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-text";
exports.ids = ["vendor-chunks/troika-three-text"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-text/dist/troika-three-text.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlyphsGeometry: () => (/* binding */ GlyphsGeometry),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   configureTextBuilder: () => (/* binding */ configureTextBuilder),\n/* harmony export */   createTextDerivedMaterial: () => (/* binding */ createTextDerivedMaterial),\n/* harmony export */   dumpSDFTextures: () => (/* binding */ dumpSDFTextures),\n/* harmony export */   getCaretAtPoint: () => (/* binding */ getCaretAtPoint),\n/* harmony export */   getSelectionRects: () => (/* binding */ getSelectionRects),\n/* harmony export */   preloadFont: () => (/* binding */ preloadFont),\n/* harmony export */   typesetterWorkerModule: () => (/* binding */ typesetterWorkerModule)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! troika-worker-utils */ \"(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\");\n/* harmony import */ var webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgl-sdf-generator */ \"(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\");\n/* harmony import */ var bidi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bidi-js */ \"(ssr)/./node_modules/bidi-js/dist/bidi.mjs\");\n/* harmony import */ var troika_three_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! troika-three-utils */ \"(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\");\n\n\n\n\n\n/**\n * Factory function that creates a self-contained environment for processing text typesetting requests.\n *\n * It is important that this function has no closure dependencies, so that it can be easily injected\n * into the source for a Worker without requiring a build step or complex dependency loading. All its\n * dependencies must be passed in at initialization.\n *\n * @param {function} fontParser - a function that accepts an ArrayBuffer of the font data and returns\n * a standardized structure giving access to the font and its glyphs:\n *   {\n *     unitsPerEm: number,\n *     ascender: number,\n *     descender: number,\n *     capHeight: number,\n *     xHeight: number,\n *     lineGap: number,\n *     forEachGlyph(string, fontSize, letterSpacing, callback) {\n *       //invokes callback for each glyph to render, passing it an object:\n *       callback({\n *         index: number,\n *         advanceWidth: number,\n *         xMin: number,\n *         yMin: number,\n *         xMax: number,\n *         yMax: number,\n *         path: string,\n *         pathCommandCount: number\n *       })\n *     }\n *   }\n * @param {object} bidi - the bidi.js implementation object\n * @param {Object} config\n * @return {Object}\n */ function createTypesetter(fontParser, bidi, config) {\n    const { defaultFontURL } = config;\n    /**\n   * Holds parsed font objects by url\n   */ const fonts = Object.create(null);\n    const INF = Infinity;\n    // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs\n    // eslint-disable-next-line no-misleading-character-class\n    const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;\n    // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces\n    const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;\n    // Incomplete set of characters that allow line breaking after them\n    // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14\n    const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);\n    /**\n   * Load a given font url\n   */ function doLoadFont(url, callback) {\n        function tryLoad() {\n            const onError = (err)=>{\n                console.error(`Failure loading font ${url}${url === defaultFontURL ? \"\" : \"; trying fallback\"}`, err);\n                if (url !== defaultFontURL) {\n                    url = defaultFontURL;\n                    tryLoad();\n                }\n            };\n            try {\n                const request = new XMLHttpRequest();\n                request.open(\"get\", url, true);\n                request.responseType = \"arraybuffer\";\n                request.onload = function() {\n                    if (request.status >= 400) {\n                        onError(new Error(request.statusText));\n                    } else if (request.status > 0) {\n                        try {\n                            const fontObj = fontParser(request.response);\n                            callback(fontObj);\n                        } catch (e) {\n                            onError(e);\n                        }\n                    }\n                };\n                request.onerror = onError;\n                request.send();\n            } catch (err) {\n                onError(err);\n            }\n        }\n        tryLoad();\n    }\n    /**\n   * Load a given font url if needed, invoking a callback when it's loaded. If already\n   * loaded, the callback will be called synchronously.\n   */ function loadFont(fontUrl, callback) {\n        if (!fontUrl) fontUrl = defaultFontURL;\n        let font = fonts[fontUrl];\n        if (font) {\n            // if currently loading font, add to callbacks, otherwise execute immediately\n            if (font.pending) {\n                font.pending.push(callback);\n            } else {\n                callback(font);\n            }\n        } else {\n            fonts[fontUrl] = {\n                pending: [\n                    callback\n                ]\n            };\n            doLoadFont(fontUrl, (fontObj)=>{\n                let callbacks = fonts[fontUrl].pending;\n                fonts[fontUrl] = fontObj;\n                callbacks.forEach((cb)=>cb(fontObj));\n            });\n        }\n    }\n    /**\n   * Main entry point.\n   * Process a text string with given font and formatting parameters, and return all info\n   * necessary to render all its glyphs.\n   */ function typeset({ text = \"\", font = defaultFontURL, sdfGlyphSize = 64, fontSize = 1, letterSpacing = 0, lineHeight = \"normal\", maxWidth = INF, direction, textAlign = \"left\", textIndent = 0, whiteSpace = \"normal\", overflowWrap = \"normal\", anchorX = 0, anchorY = 0, includeCaretPositions = false, chunkedBoundsSize = 8192, colorRanges = null }, callback, metricsOnly = false) {\n        const mainStart = now();\n        const timings = {\n            fontLoad: 0,\n            typesetting: 0\n        };\n        // Ensure newlines are normalized\n        if (text.indexOf(\"\\r\") > -1) {\n            console.info(\"Typesetter: got text with \\\\r chars; normalizing to \\\\n\");\n            text = text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n        }\n        // Ensure we've got numbers not strings\n        fontSize = +fontSize;\n        letterSpacing = +letterSpacing;\n        maxWidth = +maxWidth;\n        lineHeight = lineHeight || \"normal\";\n        textIndent = +textIndent;\n        loadFont(font, (fontObj)=>{\n            const hasMaxWidth = isFinite(maxWidth);\n            let glyphIds = null;\n            let glyphPositions = null;\n            let glyphData = null;\n            let glyphColors = null;\n            let caretPositions = null;\n            let visibleBounds = null;\n            let chunkedBounds = null;\n            let maxLineWidth = 0;\n            let renderableGlyphCount = 0;\n            let canWrap = whiteSpace !== \"nowrap\";\n            const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;\n            timings.fontLoad = now() - mainStart;\n            const typesetStart = now();\n            // Find conversion between native font units and fontSize units; this will already be done\n            // for the gx/gy values below but everything else we'll need to convert\n            const fontSizeMult = fontSize / unitsPerEm;\n            // Determine appropriate value for 'normal' line height based on the font's actual metrics\n            // TODO this does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n            if (lineHeight === \"normal\") {\n                lineHeight = (ascender - descender + lineGap) / unitsPerEm;\n            }\n            // Determine line height and leading adjustments\n            lineHeight = lineHeight * fontSize;\n            const halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;\n            const topBaseline = -(ascender * fontSizeMult + halfLeading);\n            const caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);\n            const caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;\n            // Distribute glyphs into lines based on wrapping\n            let lineXOffset = textIndent;\n            let currentLine = new TextLine();\n            const lines = [\n                currentLine\n            ];\n            fontObj.forEachGlyph(text, fontSize, letterSpacing, (glyphObj, glyphX, charIndex)=>{\n                const char = text.charAt(charIndex);\n                const glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n                const curLineCount = currentLine.count;\n                let nextLine;\n                // Calc isWhitespace and isEmpty once per glyphObj\n                if (!(\"isEmpty\" in glyphObj)) {\n                    glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);\n                    glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);\n                    glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);\n                }\n                if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                    renderableGlyphCount++;\n                }\n                // If a non-whitespace character overflows the max width, we need to soft-wrap\n                if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n                    // If it's the first char after a whitespace, start a new line\n                    if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {\n                        nextLine = new TextLine();\n                        lineXOffset = -glyphX;\n                    } else {\n                        // Back up looking for a whitespace character to wrap at\n                        for(let i = curLineCount; i--;){\n                            // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n                            if (i === 0 && overflowWrap === \"break-word\") {\n                                nextLine = new TextLine();\n                                lineXOffset = -glyphX;\n                                break;\n                            } else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {\n                                nextLine = currentLine.splitAt(i + 1);\n                                const adjustX = nextLine.glyphAt(0).x;\n                                lineXOffset -= adjustX;\n                                for(let j = nextLine.count; j--;){\n                                    nextLine.glyphAt(j).x -= adjustX;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    if (nextLine) {\n                        currentLine.isSoftWrapped = true;\n                        currentLine = nextLine;\n                        lines.push(currentLine);\n                        maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n                    }\n                }\n                let fly = currentLine.glyphAt(currentLine.count);\n                fly.glyphObj = glyphObj;\n                fly.x = glyphX + lineXOffset;\n                fly.width = glyphWidth;\n                fly.charIndex = charIndex;\n                // Handle hard line breaks\n                if (char === \"\\n\") {\n                    currentLine = new TextLine();\n                    lines.push(currentLine);\n                    lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;\n                }\n            });\n            // Calculate width of each line (excluding trailing whitespace) and maximum block width\n            lines.forEach((line)=>{\n                for(let i = line.count; i--;){\n                    let { glyphObj, x, width } = line.glyphAt(i);\n                    if (!glyphObj.isWhitespace) {\n                        line.width = x + width;\n                        if (line.width > maxLineWidth) {\n                            maxLineWidth = line.width;\n                        }\n                        return;\n                    }\n                }\n            });\n            // Find overall position adjustments for anchoring\n            let anchorXOffset = 0;\n            let anchorYOffset = 0;\n            if (anchorX) {\n                if (typeof anchorX === \"number\") {\n                    anchorXOffset = -anchorX;\n                } else if (typeof anchorX === \"string\") {\n                    anchorXOffset = -maxLineWidth * (anchorX === \"left\" ? 0 : anchorX === \"center\" ? 0.5 : anchorX === \"right\" ? 1 : parsePercent(anchorX));\n                }\n            }\n            if (anchorY) {\n                if (typeof anchorY === \"number\") {\n                    anchorYOffset = -anchorY;\n                } else if (typeof anchorY === \"string\") {\n                    let height = lines.length * lineHeight;\n                    anchorYOffset = anchorY === \"top\" ? 0 : anchorY === \"top-baseline\" ? -topBaseline : anchorY === \"top-cap\" ? -topBaseline - capHeight * fontSizeMult : anchorY === \"top-ex\" ? -topBaseline - xHeight * fontSizeMult : anchorY === \"middle\" ? height / 2 : anchorY === \"bottom\" ? height : anchorY === \"bottom-baseline\" ? height - halfLeading + descender * fontSizeMult : parsePercent(anchorY) * height;\n                }\n            }\n            if (!metricsOnly) {\n                // Resolve bidi levels\n                const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);\n                // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n                // collecting all renderable glyphs into a single collection.\n                glyphIds = new Uint16Array(renderableGlyphCount);\n                glyphPositions = new Float32Array(renderableGlyphCount * 2);\n                glyphData = {};\n                visibleBounds = [\n                    INF,\n                    INF,\n                    -INF,\n                    -INF\n                ];\n                chunkedBounds = [];\n                let lineYOffset = topBaseline;\n                if (includeCaretPositions) {\n                    caretPositions = new Float32Array(text.length * 3);\n                }\n                if (colorRanges) {\n                    glyphColors = new Uint8Array(renderableGlyphCount * 3);\n                }\n                let renderableGlyphIndex = 0;\n                let prevCharIndex = -1;\n                let colorCharIndex = -1;\n                let chunk;\n                let currentColor;\n                lines.forEach((line, lineIndex)=>{\n                    let { count: lineGlyphCount, width: lineWidth } = line;\n                    // Ignore empty lines\n                    if (lineGlyphCount > 0) {\n                        // Count trailing whitespaces, we want to ignore these for certain things\n                        let trailingWhitespaceCount = 0;\n                        for(let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;){\n                            trailingWhitespaceCount++;\n                        }\n                        // Apply horizontal alignment adjustments\n                        let lineXOffset = 0;\n                        let justifyAdjust = 0;\n                        if (textAlign === \"center\") {\n                            lineXOffset = (maxLineWidth - lineWidth) / 2;\n                        } else if (textAlign === \"right\") {\n                            lineXOffset = maxLineWidth - lineWidth;\n                        } else if (textAlign === \"justify\" && line.isSoftWrapped) {\n                            // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop\n                            let whitespaceCount = 0;\n                            for(let i = lineGlyphCount - trailingWhitespaceCount; i--;){\n                                if (line.glyphAt(i).glyphObj.isWhitespace) {\n                                    whitespaceCount++;\n                                }\n                            }\n                            justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n                        }\n                        if (justifyAdjust || lineXOffset) {\n                            let justifyOffset = 0;\n                            for(let i = 0; i < lineGlyphCount; i++){\n                                let glyphInfo = line.glyphAt(i);\n                                const glyphObj = glyphInfo.glyphObj;\n                                glyphInfo.x += lineXOffset + justifyOffset;\n                                // Expand non-trailing whitespaces for justify alignment\n                                if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {\n                                    justifyOffset += justifyAdjust;\n                                    glyphInfo.width += justifyAdjust;\n                                }\n                            }\n                        }\n                        // Perform bidi range flipping\n                        const flips = bidi.getReorderSegments(text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex);\n                        for(let fi = 0; fi < flips.length; fi++){\n                            const [start, end] = flips[fi];\n                            // Map start/end string indices to indices in the line\n                            let left = Infinity, right = -Infinity;\n                            for(let i = 0; i < lineGlyphCount; i++){\n                                if (line.glyphAt(i).charIndex >= start) {\n                                    let startInLine = i, endInLine = i;\n                                    for(; endInLine < lineGlyphCount; endInLine++){\n                                        let info = line.glyphAt(endInLine);\n                                        if (info.charIndex > end) {\n                                            break;\n                                        }\n                                        if (endInLine < lineGlyphCount - trailingWhitespaceCount) {\n                                            left = Math.min(left, info.x);\n                                            right = Math.max(right, info.x + info.width);\n                                        }\n                                    }\n                                    for(let j = startInLine; j < endInLine; j++){\n                                        const glyphInfo = line.glyphAt(j);\n                                        glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        // Assemble final data arrays\n                        let glyphObj;\n                        const setGlyphObj = (g)=>glyphObj = g;\n                        for(let i = 0; i < lineGlyphCount; i++){\n                            let glyphInfo = line.glyphAt(i);\n                            glyphObj = glyphInfo.glyphObj;\n                            const glyphId = glyphObj.index;\n                            // Replace mirrored characters in rtl\n                            const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl\n                            if (rtl) {\n                                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);\n                                if (mirrored) {\n                                    fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);\n                                }\n                            }\n                            // Add caret positions\n                            if (includeCaretPositions) {\n                                const { charIndex } = glyphInfo;\n                                const caretLeft = glyphInfo.x + anchorXOffset;\n                                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;\n                                caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft; //start edge x\n                                caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight; //end edge x\n                                caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset; //common bottom y\n                                // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret\n                                // positions for those missing char indices; currently this uses a best-guess by dividing\n                                // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList\n                                // table to get better interior caret positions.\n                                const ligCount = charIndex - prevCharIndex;\n                                if (ligCount > 1) {\n                                    fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                                }\n                                prevCharIndex = charIndex;\n                            }\n                            // Track current color range\n                            if (colorRanges) {\n                                const { charIndex } = glyphInfo;\n                                while(charIndex > colorCharIndex){\n                                    colorCharIndex++;\n                                    if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                                        currentColor = colorRanges[colorCharIndex];\n                                    }\n                                }\n                            }\n                            // Get atlas data for renderable glyphs\n                            if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                                const idx = renderableGlyphIndex++;\n                                // Add this glyph's path data\n                                if (!glyphData[glyphId]) {\n                                    glyphData[glyphId] = {\n                                        path: glyphObj.path,\n                                        pathBounds: [\n                                            glyphObj.xMin,\n                                            glyphObj.yMin,\n                                            glyphObj.xMax,\n                                            glyphObj.yMax\n                                        ]\n                                    };\n                                }\n                                // Determine final glyph position and add to glyphPositions array\n                                const glyphX = glyphInfo.x + anchorXOffset;\n                                const glyphY = lineYOffset + anchorYOffset;\n                                glyphPositions[idx * 2] = glyphX;\n                                glyphPositions[idx * 2 + 1] = glyphY;\n                                // Track total visible bounds\n                                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;\n                                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;\n                                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;\n                                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;\n                                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;\n                                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;\n                                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;\n                                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;\n                                // Track bounding rects for each chunk of N glyphs\n                                if (idx % chunkedBoundsSize === 0) {\n                                    chunk = {\n                                        start: idx,\n                                        end: idx,\n                                        rect: [\n                                            INF,\n                                            INF,\n                                            -INF,\n                                            -INF\n                                        ]\n                                    };\n                                    chunkedBounds.push(chunk);\n                                }\n                                chunk.end++;\n                                const chunkRect = chunk.rect;\n                                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;\n                                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;\n                                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;\n                                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;\n                                // Add to glyph ids array\n                                glyphIds[idx] = glyphId;\n                                // Add colors\n                                if (colorRanges) {\n                                    const start = idx * 3;\n                                    glyphColors[start] = currentColor >> 16 & 255;\n                                    glyphColors[start + 1] = currentColor >> 8 & 255;\n                                    glyphColors[start + 2] = currentColor & 255;\n                                }\n                            }\n                        }\n                    }\n                    // Increment y offset for next line\n                    lineYOffset -= lineHeight;\n                });\n                // Fill in remaining caret positions in case the final character was a ligature\n                if (caretPositions) {\n                    const ligCount = text.length - prevCharIndex;\n                    if (ligCount > 1) {\n                        fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                    }\n                }\n            }\n            // Timing stats\n            timings.typesetting = now() - typesetStart;\n            callback({\n                glyphIds,\n                glyphPositions,\n                glyphData,\n                caretPositions,\n                caretHeight,\n                glyphColors,\n                chunkedBounds,\n                fontSize,\n                unitsPerEm,\n                ascender: ascender * fontSizeMult,\n                descender: descender * fontSizeMult,\n                capHeight: capHeight * fontSizeMult,\n                xHeight: xHeight * fontSizeMult,\n                lineHeight,\n                topBaseline,\n                blockBounds: [\n                    anchorXOffset,\n                    anchorYOffset - lines.length * lineHeight,\n                    anchorXOffset + maxLineWidth,\n                    anchorYOffset\n                ],\n                visibleBounds,\n                timings\n            });\n        });\n    }\n    /**\n   * For a given text string and font parameters, determine the resulting block dimensions\n   * after wrapping for the given maxWidth.\n   * @param args\n   * @param callback\n   */ function measure(args, callback) {\n        typeset(args, (result)=>{\n            const [x0, y0, x1, y1] = result.blockBounds;\n            callback({\n                width: x1 - x0,\n                height: y1 - y0\n            });\n        }, {\n            metricsOnly: true\n        });\n    }\n    function parsePercent(str) {\n        let match = str.match(/^([\\d.]+)%$/);\n        let pct = match ? parseFloat(match[1]) : NaN;\n        return isNaN(pct) ? 0 : pct / 100;\n    }\n    function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {\n        const ligStartX = caretPositions[ligStartIndex * 3];\n        const ligEndX = caretPositions[ligStartIndex * 3 + 1];\n        const ligY = caretPositions[ligStartIndex * 3 + 2];\n        const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;\n        for(let i = 0; i < ligCount; i++){\n            const startIndex = (ligStartIndex + i) * 3;\n            caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;\n            caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);\n            caretPositions[startIndex + 2] = ligY;\n        }\n    }\n    function now() {\n        return (self.performance || Date).now();\n    }\n    // Array-backed structure for a single line's glyphs data\n    function TextLine() {\n        this.data = [];\n    }\n    const textLineProps = [\n        \"glyphObj\",\n        \"x\",\n        \"width\",\n        \"charIndex\"\n    ];\n    TextLine.prototype = {\n        width: 0,\n        isSoftWrapped: false,\n        get count () {\n            return Math.ceil(this.data.length / textLineProps.length);\n        },\n        glyphAt (i) {\n            let fly = TextLine.flyweight;\n            fly.data = this.data;\n            fly.index = i;\n            return fly;\n        },\n        splitAt (i) {\n            let newLine = new TextLine();\n            newLine.data = this.data.splice(i * textLineProps.length);\n            return newLine;\n        }\n    };\n    TextLine.flyweight = textLineProps.reduce((obj, prop, i, all)=>{\n        Object.defineProperty(obj, prop, {\n            get () {\n                return this.data[this.index * textLineProps.length + i];\n            },\n            set (val) {\n                this.data[this.index * textLineProps.length + i] = val;\n            }\n        });\n        return obj;\n    }, {\n        data: null,\n        index: 0\n    });\n    return {\n        typeset,\n        measure,\n        loadFont\n    };\n}\nconst now = ()=>(self.performance || Date).now();\nconst mainThreadGenerator = /*#__PURE__*/ (0,webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\nlet warned;\n/**\n * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a\n * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF\n * generation when supported.\n */ function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {\n    // Allow opt-out\n    if (!useWebGL) {\n        return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);\n    }\n    // Attempt GPU-accelerated generation first\n    return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(null, (err)=>{\n        // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers\n        if (!warned) {\n            console.warn(`WebGL SDF generation failed, falling back to JS`, err);\n            warned = true;\n        }\n        return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);\n    });\n}\nconst queue = [];\nconst chunkTimeBudget = 5; // ms\nlet timer = 0;\nfunction nextChunk() {\n    const start = now();\n    while(queue.length && now() - start < chunkTimeBudget){\n        queue.shift()();\n    }\n    timer = queue.length ? setTimeout(nextChunk, 0) : 0;\n}\n/**\n * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded\n * macrotask chunks to allow render frames to execute in between.\n */ const generateSDF_GL = (...args)=>{\n    return new Promise((resolve, reject)=>{\n        queue.push(()=>{\n            const start = now();\n            try {\n                mainThreadGenerator.webgl.generateIntoCanvas(...args);\n                resolve({\n                    timing: now() - start\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n        if (!timer) {\n            timer = setTimeout(nextChunk, 0);\n        }\n    });\n};\nconst threadCount = 4; // how many workers to spawn\nconst idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds\nconst threads = {};\nlet callNum = 0;\n/**\n * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism\n */ function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {\n    const workerId = \"TroikaTextSDFGenerator_JS_\" + callNum++ % threadCount;\n    let thread = threads[workerId];\n    if (!thread) {\n        thread = threads[workerId] = {\n            workerModule: (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n                name: workerId,\n                workerId,\n                dependencies: [\n                    webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n                    now\n                ],\n                init (_createSDFGenerator, now) {\n                    const generate = _createSDFGenerator().javascript.generate;\n                    return function(...args) {\n                        const start = now();\n                        const textureData = generate(...args);\n                        return {\n                            textureData,\n                            timing: now() - start\n                        };\n                    };\n                },\n                getTransferables (result) {\n                    return [\n                        result.textureData.buffer\n                    ];\n                }\n            }),\n            requests: 0,\n            idleTimer: null\n        };\n    }\n    thread.requests++;\n    clearTimeout(thread.idleTimer);\n    return thread.workerModule(width, height, path, viewBox, distance, exponent).then(({ textureData, timing })=>{\n        // copy result data into the canvas\n        const start = now();\n        // expand single-channel data into rgba\n        const imageData = new Uint8Array(textureData.length * 4);\n        for(let i = 0; i < textureData.length; i++){\n            imageData[i * 4 + channel] = textureData[i];\n        }\n        mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << 3 - channel);\n        timing += now() - start;\n        // clean up workers after a while\n        if (--thread.requests === 0) {\n            thread.idleTimer = setTimeout(()=>{\n                (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.terminateWorker)(workerId);\n            }, idleTimeout);\n        }\n        return {\n            timing\n        };\n    });\n}\nfunction warmUpSDFCanvas(canvas) {\n    if (!canvas._warm) {\n        mainThreadGenerator.webgl.isSupported(canvas);\n        canvas._warm = true;\n    }\n}\nconst resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;\n/*!\nCustom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.\nOriginal MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE\n*/ function typrFactory() {\n    return  true && (self.window = self), function(r) {\n        var e = {\n            parse: function(r) {\n                var t = e._bin, a = new Uint8Array(r);\n                if (\"ttcf\" == t.readASCII(a, 0, 4)) {\n                    var n = 4;\n                    t.readUshort(a, n), n += 2, t.readUshort(a, n), n += 2;\n                    var o = t.readUint(a, n);\n                    n += 4;\n                    for(var s = [], i = 0; i < o; i++){\n                        var h = t.readUint(a, n);\n                        n += 4, s.push(e._readFont(a, h));\n                    }\n                    return s;\n                }\n                return [\n                    e._readFont(a, 0)\n                ];\n            },\n            _readFont: function(r, t) {\n                var a = e._bin, n = t;\n                a.readFixed(r, t), t += 4;\n                var o = a.readUshort(r, t);\n                t += 2, a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2;\n                for(var s = [\n                    \"cmap\",\n                    \"head\",\n                    \"hhea\",\n                    \"maxp\",\n                    \"hmtx\",\n                    \"name\",\n                    \"OS/2\",\n                    \"post\",\n                    \"loca\",\n                    \"glyf\",\n                    \"kern\",\n                    \"CFF \",\n                    \"GPOS\",\n                    \"GSUB\",\n                    \"SVG \"\n                ], i = {\n                    _data: r,\n                    _offset: n\n                }, h = {}, f = 0; f < o; f++){\n                    var d = a.readASCII(r, t, 4);\n                    t += 4, a.readUint(r, t), t += 4;\n                    var u = a.readUint(r, t);\n                    t += 4;\n                    var l = a.readUint(r, t);\n                    t += 4, h[d] = {\n                        offset: u,\n                        length: l\n                    };\n                }\n                for(f = 0; f < s.length; f++){\n                    var v = s[f];\n                    h[v] && (i[v.trim()] = e[v.trim()].parse(r, h[v].offset, h[v].length, i));\n                }\n                return i;\n            },\n            _tabOffset: function(r, t, a) {\n                for(var n = e._bin, o = n.readUshort(r, a + 4), s = a + 12, i = 0; i < o; i++){\n                    var h = n.readASCII(r, s, 4);\n                    s += 4, n.readUint(r, s), s += 4;\n                    var f = n.readUint(r, s);\n                    if (s += 4, n.readUint(r, s), s += 4, h == t) return f;\n                }\n                return 0;\n            }\n        };\n        e._bin = {\n            readFixed: function(r, e) {\n                return (r[e] << 8 | r[e + 1]) + (r[e + 2] << 8 | r[e + 3]) / 65540;\n            },\n            readF2dot14: function(r, t) {\n                return e._bin.readShort(r, t) / 16384;\n            },\n            readInt: function(r, t) {\n                return e._bin._view(r).getInt32(t);\n            },\n            readInt8: function(r, t) {\n                return e._bin._view(r).getInt8(t);\n            },\n            readShort: function(r, t) {\n                return e._bin._view(r).getInt16(t);\n            },\n            readUshort: function(r, t) {\n                return e._bin._view(r).getUint16(t);\n            },\n            readUshorts: function(r, t, a) {\n                for(var n = [], o = 0; o < a; o++)n.push(e._bin.readUshort(r, t + 2 * o));\n                return n;\n            },\n            readUint: function(r, t) {\n                return e._bin._view(r).getUint32(t);\n            },\n            readUint64: function(r, t) {\n                return 4294967296 * e._bin.readUint(r, t) + e._bin.readUint(r, t + 4);\n            },\n            readASCII: function(r, e, t) {\n                for(var a = \"\", n = 0; n < t; n++)a += String.fromCharCode(r[e + n]);\n                return a;\n            },\n            readUnicode: function(r, e, t) {\n                for(var a = \"\", n = 0; n < t; n++){\n                    var o = r[e++] << 8 | r[e++];\n                    a += String.fromCharCode(o);\n                }\n                return a;\n            },\n            _tdec:  false ? 0 : null,\n            readUTF8: function(r, t, a) {\n                var n = e._bin._tdec;\n                return n && 0 == t && a == r.length ? n.decode(r) : e._bin.readASCII(r, t, a);\n            },\n            readBytes: function(r, e, t) {\n                for(var a = [], n = 0; n < t; n++)a.push(r[e + n]);\n                return a;\n            },\n            readASCIIArray: function(r, e, t) {\n                for(var a = [], n = 0; n < t; n++)a.push(String.fromCharCode(r[e + n]));\n                return a;\n            },\n            _view: function(r) {\n                return r._dataView || (r._dataView = r.buffer ? new DataView(r.buffer, r.byteOffset, r.byteLength) : new DataView(new Uint8Array(r).buffer));\n            }\n        }, e._lctf = {}, e._lctf.parse = function(r, t, a, n, o) {\n            var s = e._bin, i = {}, h = t;\n            s.readFixed(r, t), t += 4;\n            var f = s.readUshort(r, t);\n            t += 2;\n            var d = s.readUshort(r, t);\n            t += 2;\n            var u = s.readUshort(r, t);\n            return t += 2, i.scriptList = e._lctf.readScriptList(r, h + f), i.featureList = e._lctf.readFeatureList(r, h + d), i.lookupList = e._lctf.readLookupList(r, h + u, o), i;\n        }, e._lctf.readLookupList = function(r, t, a) {\n            var n = e._bin, o = t, s = [], i = n.readUshort(r, t);\n            t += 2;\n            for(var h = 0; h < i; h++){\n                var f = n.readUshort(r, t);\n                t += 2;\n                var d = e._lctf.readLookupTable(r, o + f, a);\n                s.push(d);\n            }\n            return s;\n        }, e._lctf.readLookupTable = function(r, t, a) {\n            var n = e._bin, o = t, s = {\n                tabs: []\n            };\n            s.ltype = n.readUshort(r, t), t += 2, s.flag = n.readUshort(r, t), t += 2;\n            var i = n.readUshort(r, t);\n            t += 2;\n            for(var h = s.ltype, f = 0; f < i; f++){\n                var d = n.readUshort(r, t);\n                t += 2;\n                var u = a(r, h, o + d, s);\n                s.tabs.push(u);\n            }\n            return s;\n        }, e._lctf.numOfOnes = function(r) {\n            for(var e = 0, t = 0; t < 32; t++)0 != (r >>> t & 1) && e++;\n            return e;\n        }, e._lctf.readClassDef = function(r, t) {\n            var a = e._bin, n = [], o = a.readUshort(r, t);\n            if (t += 2, 1 == o) {\n                var s = a.readUshort(r, t);\n                t += 2;\n                var i = a.readUshort(r, t);\n                t += 2;\n                for(var h = 0; h < i; h++)n.push(s + h), n.push(s + h), n.push(a.readUshort(r, t)), t += 2;\n            }\n            if (2 == o) {\n                var f = a.readUshort(r, t);\n                t += 2;\n                for(h = 0; h < f; h++)n.push(a.readUshort(r, t)), t += 2, n.push(a.readUshort(r, t)), t += 2, n.push(a.readUshort(r, t)), t += 2;\n            }\n            return n;\n        }, e._lctf.getInterval = function(r, e) {\n            for(var t = 0; t < r.length; t += 3){\n                var a = r[t], n = r[t + 1];\n                if (r[t + 2], a <= e && e <= n) return t;\n            }\n            return -1;\n        }, e._lctf.readCoverage = function(r, t) {\n            var a = e._bin, n = {};\n            n.fmt = a.readUshort(r, t), t += 2;\n            var o = a.readUshort(r, t);\n            return t += 2, 1 == n.fmt && (n.tab = a.readUshorts(r, t, o)), 2 == n.fmt && (n.tab = a.readUshorts(r, t, 3 * o)), n;\n        }, e._lctf.coverageIndex = function(r, t) {\n            var a = r.tab;\n            if (1 == r.fmt) return a.indexOf(t);\n            if (2 == r.fmt) {\n                var n = e._lctf.getInterval(a, t);\n                if (-1 != n) return a[n + 2] + (t - a[n]);\n            }\n            return -1;\n        }, e._lctf.readFeatureList = function(r, t) {\n            var a = e._bin, n = t, o = [], s = a.readUshort(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = a.readASCII(r, t, 4);\n                t += 4;\n                var f = a.readUshort(r, t);\n                t += 2;\n                var d = e._lctf.readFeatureTable(r, n + f);\n                d.tag = h.trim(), o.push(d);\n            }\n            return o;\n        }, e._lctf.readFeatureTable = function(r, t) {\n            var a = e._bin, n = t, o = {}, s = a.readUshort(r, t);\n            t += 2, s > 0 && (o.featureParams = n + s);\n            var i = a.readUshort(r, t);\n            t += 2, o.tab = [];\n            for(var h = 0; h < i; h++)o.tab.push(a.readUshort(r, t + 2 * h));\n            return o;\n        }, e._lctf.readScriptList = function(r, t) {\n            var a = e._bin, n = t, o = {}, s = a.readUshort(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = a.readASCII(r, t, 4);\n                t += 4;\n                var f = a.readUshort(r, t);\n                t += 2, o[h.trim()] = e._lctf.readScriptTable(r, n + f);\n            }\n            return o;\n        }, e._lctf.readScriptTable = function(r, t) {\n            var a = e._bin, n = t, o = {}, s = a.readUshort(r, t);\n            t += 2, o.default = e._lctf.readLangSysTable(r, n + s);\n            var i = a.readUshort(r, t);\n            t += 2;\n            for(var h = 0; h < i; h++){\n                var f = a.readASCII(r, t, 4);\n                t += 4;\n                var d = a.readUshort(r, t);\n                t += 2, o[f.trim()] = e._lctf.readLangSysTable(r, n + d);\n            }\n            return o;\n        }, e._lctf.readLangSysTable = function(r, t) {\n            var a = e._bin, n = {};\n            a.readUshort(r, t), t += 2, n.reqFeature = a.readUshort(r, t), t += 2;\n            var o = a.readUshort(r, t);\n            return t += 2, n.features = a.readUshorts(r, t, o), n;\n        }, e.CFF = {}, e.CFF.parse = function(r, t, a) {\n            var n = e._bin;\n            (r = new Uint8Array(r.buffer, t, a))[t = 0], r[++t], r[++t], r[++t], t++;\n            var o = [];\n            t = e.CFF.readIndex(r, t, o);\n            for(var s = [], i = 0; i < o.length - 1; i++)s.push(n.readASCII(r, t + o[i], o[i + 1] - o[i]));\n            t += o[o.length - 1];\n            var h = [];\n            t = e.CFF.readIndex(r, t, h);\n            var f = [];\n            for(i = 0; i < h.length - 1; i++)f.push(e.CFF.readDict(r, t + h[i], t + h[i + 1]));\n            t += h[h.length - 1];\n            var d = f[0], u = [];\n            t = e.CFF.readIndex(r, t, u);\n            var l = [];\n            for(i = 0; i < u.length - 1; i++)l.push(n.readASCII(r, t + u[i], u[i + 1] - u[i]));\n            if (t += u[u.length - 1], e.CFF.readSubrs(r, t, d), d.CharStrings) {\n                t = d.CharStrings;\n                u = [];\n                t = e.CFF.readIndex(r, t, u);\n                var v = [];\n                for(i = 0; i < u.length - 1; i++)v.push(n.readBytes(r, t + u[i], u[i + 1] - u[i]));\n                d.CharStrings = v;\n            }\n            if (d.ROS) {\n                t = d.FDArray;\n                var c = [];\n                t = e.CFF.readIndex(r, t, c), d.FDArray = [];\n                for(i = 0; i < c.length - 1; i++){\n                    var p = e.CFF.readDict(r, t + c[i], t + c[i + 1]);\n                    e.CFF._readFDict(r, p, l), d.FDArray.push(p);\n                }\n                t += c[c.length - 1], t = d.FDSelect, d.FDSelect = [];\n                var U = r[t];\n                if (t++, 3 != U) throw U;\n                var g = n.readUshort(r, t);\n                t += 2;\n                for(i = 0; i < g + 1; i++)d.FDSelect.push(n.readUshort(r, t), r[t + 2]), t += 3;\n            }\n            return d.Encoding && (d.Encoding = e.CFF.readEncoding(r, d.Encoding, d.CharStrings.length)), d.charset && (d.charset = e.CFF.readCharset(r, d.charset, d.CharStrings.length)), e.CFF._readFDict(r, d, l), d;\n        }, e.CFF._readFDict = function(r, t, a) {\n            var n;\n            for(var o in t.Private && (n = t.Private[1], t.Private = e.CFF.readDict(r, n, n + t.Private[0]), t.Private.Subrs && e.CFF.readSubrs(r, n + t.Private.Subrs, t.Private)), t)-1 != [\n                \"FamilyName\",\n                \"FontName\",\n                \"FullName\",\n                \"Notice\",\n                \"version\",\n                \"Copyright\"\n            ].indexOf(o) && (t[o] = a[t[o] - 426 + 35]);\n        }, e.CFF.readSubrs = function(r, t, a) {\n            var n = e._bin, o = [];\n            t = e.CFF.readIndex(r, t, o);\n            var s, i = o.length;\n            s = i < 1240 ? 107 : i < 33900 ? 1131 : 32768, a.Bias = s, a.Subrs = [];\n            for(var h = 0; h < o.length - 1; h++)a.Subrs.push(n.readBytes(r, t + o[h], o[h + 1] - o[h]));\n        }, e.CFF.tableSE = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n            7,\n            8,\n            9,\n            10,\n            11,\n            12,\n            13,\n            14,\n            15,\n            16,\n            17,\n            18,\n            19,\n            20,\n            21,\n            22,\n            23,\n            24,\n            25,\n            26,\n            27,\n            28,\n            29,\n            30,\n            31,\n            32,\n            33,\n            34,\n            35,\n            36,\n            37,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            46,\n            47,\n            48,\n            49,\n            50,\n            51,\n            52,\n            53,\n            54,\n            55,\n            56,\n            57,\n            58,\n            59,\n            60,\n            61,\n            62,\n            63,\n            64,\n            65,\n            66,\n            67,\n            68,\n            69,\n            70,\n            71,\n            72,\n            73,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            82,\n            83,\n            84,\n            85,\n            86,\n            87,\n            88,\n            89,\n            90,\n            91,\n            92,\n            93,\n            94,\n            95,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            96,\n            97,\n            98,\n            99,\n            100,\n            101,\n            102,\n            103,\n            104,\n            105,\n            106,\n            107,\n            108,\n            109,\n            110,\n            0,\n            111,\n            112,\n            113,\n            114,\n            0,\n            115,\n            116,\n            117,\n            118,\n            119,\n            120,\n            121,\n            122,\n            0,\n            123,\n            0,\n            124,\n            125,\n            126,\n            127,\n            128,\n            129,\n            130,\n            131,\n            0,\n            132,\n            133,\n            0,\n            134,\n            135,\n            136,\n            137,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            138,\n            0,\n            139,\n            0,\n            0,\n            0,\n            0,\n            140,\n            141,\n            142,\n            143,\n            0,\n            0,\n            0,\n            0,\n            0,\n            144,\n            0,\n            0,\n            0,\n            145,\n            0,\n            0,\n            146,\n            147,\n            148,\n            149,\n            0,\n            0,\n            0,\n            0\n        ], e.CFF.glyphByUnicode = function(r, e) {\n            for(var t = 0; t < r.charset.length; t++)if (r.charset[t] == e) return t;\n            return -1;\n        }, e.CFF.glyphBySE = function(r, t) {\n            return t < 0 || t > 255 ? -1 : e.CFF.glyphByUnicode(r, e.CFF.tableSE[t]);\n        }, e.CFF.readEncoding = function(r, t, a) {\n            e._bin;\n            var n = [\n                \".notdef\"\n            ], o = r[t];\n            if (t++, 0 != o) throw \"error: unknown encoding format: \" + o;\n            var s = r[t];\n            t++;\n            for(var i = 0; i < s; i++)n.push(r[t + i]);\n            return n;\n        }, e.CFF.readCharset = function(r, t, a) {\n            var n = e._bin, o = [\n                \".notdef\"\n            ], s = r[t];\n            if (t++, 0 == s) for(var i = 0; i < a; i++){\n                var h = n.readUshort(r, t);\n                t += 2, o.push(h);\n            }\n            else {\n                if (1 != s && 2 != s) throw \"error: format: \" + s;\n                for(; o.length < a;){\n                    h = n.readUshort(r, t);\n                    t += 2;\n                    var f = 0;\n                    1 == s ? (f = r[t], t++) : (f = n.readUshort(r, t), t += 2);\n                    for(i = 0; i <= f; i++)o.push(h), h++;\n                }\n            }\n            return o;\n        }, e.CFF.readIndex = function(r, t, a) {\n            var n = e._bin, o = n.readUshort(r, t) + 1, s = r[t += 2];\n            if (t++, 1 == s) for(var i = 0; i < o; i++)a.push(r[t + i]);\n            else if (2 == s) for(i = 0; i < o; i++)a.push(n.readUshort(r, t + 2 * i));\n            else if (3 == s) for(i = 0; i < o; i++)a.push(16777215 & n.readUint(r, t + 3 * i - 1));\n            else if (1 != o) throw \"unsupported offset size: \" + s + \", count: \" + o;\n            return (t += o * s) - 1;\n        }, e.CFF.getCharString = function(r, t, a) {\n            var n = e._bin, o = r[t], s = r[t + 1];\n            r[t + 2], r[t + 3], r[t + 4];\n            var i = 1, h = null, f = null;\n            o <= 20 && (h = o, i = 1), 12 == o && (h = 100 * o + s, i = 2), 21 <= o && o <= 27 && (h = o, i = 1), 28 == o && (f = n.readShort(r, t + 1), i = 3), 29 <= o && o <= 31 && (h = o, i = 1), 32 <= o && o <= 246 && (f = o - 139, i = 1), 247 <= o && o <= 250 && (f = 256 * (o - 247) + s + 108, i = 2), 251 <= o && o <= 254 && (f = 256 * -(o - 251) - s - 108, i = 2), 255 == o && (f = n.readInt(r, t + 1) / 65535, i = 5), a.val = null != f ? f : \"o\" + h, a.size = i;\n        }, e.CFF.readCharString = function(r, t, a) {\n            for(var n = t + a, o = e._bin, s = []; t < n;){\n                var i = r[t], h = r[t + 1];\n                r[t + 2], r[t + 3], r[t + 4];\n                var f = 1, d = null, u = null;\n                i <= 20 && (d = i, f = 1), 12 == i && (d = 100 * i + h, f = 2), 19 != i && 20 != i || (d = i, f = 2), 21 <= i && i <= 27 && (d = i, f = 1), 28 == i && (u = o.readShort(r, t + 1), f = 3), 29 <= i && i <= 31 && (d = i, f = 1), 32 <= i && i <= 246 && (u = i - 139, f = 1), 247 <= i && i <= 250 && (u = 256 * (i - 247) + h + 108, f = 2), 251 <= i && i <= 254 && (u = 256 * -(i - 251) - h - 108, f = 2), 255 == i && (u = o.readInt(r, t + 1) / 65535, f = 5), s.push(null != u ? u : \"o\" + d), t += f;\n            }\n            return s;\n        }, e.CFF.readDict = function(r, t, a) {\n            for(var n = e._bin, o = {}, s = []; t < a;){\n                var i = r[t], h = r[t + 1];\n                r[t + 2], r[t + 3], r[t + 4];\n                var f = 1, d = null, u = null;\n                if (28 == i && (u = n.readShort(r, t + 1), f = 3), 29 == i && (u = n.readInt(r, t + 1), f = 5), 32 <= i && i <= 246 && (u = i - 139, f = 1), 247 <= i && i <= 250 && (u = 256 * (i - 247) + h + 108, f = 2), 251 <= i && i <= 254 && (u = 256 * -(i - 251) - h - 108, f = 2), 255 == i) throw u = n.readInt(r, t + 1) / 65535, f = 5, \"unknown number\";\n                if (30 == i) {\n                    var l = [];\n                    for(f = 1;;){\n                        var v = r[t + f];\n                        f++;\n                        var c = v >> 4, p = 15 & v;\n                        if (15 != c && l.push(c), 15 != p && l.push(p), 15 == p) break;\n                    }\n                    for(var U = \"\", g = [\n                        0,\n                        1,\n                        2,\n                        3,\n                        4,\n                        5,\n                        6,\n                        7,\n                        8,\n                        9,\n                        \".\",\n                        \"e\",\n                        \"e-\",\n                        \"reserved\",\n                        \"-\",\n                        \"endOfNumber\"\n                    ], S = 0; S < l.length; S++)U += g[l[S]];\n                    u = parseFloat(U);\n                }\n                if (i <= 21) {\n                    if (d = [\n                        \"version\",\n                        \"Notice\",\n                        \"FullName\",\n                        \"FamilyName\",\n                        \"Weight\",\n                        \"FontBBox\",\n                        \"BlueValues\",\n                        \"OtherBlues\",\n                        \"FamilyBlues\",\n                        \"FamilyOtherBlues\",\n                        \"StdHW\",\n                        \"StdVW\",\n                        \"escape\",\n                        \"UniqueID\",\n                        \"XUID\",\n                        \"charset\",\n                        \"Encoding\",\n                        \"CharStrings\",\n                        \"Private\",\n                        \"Subrs\",\n                        \"defaultWidthX\",\n                        \"nominalWidthX\"\n                    ][i], f = 1, 12 == i) d = [\n                        \"Copyright\",\n                        \"isFixedPitch\",\n                        \"ItalicAngle\",\n                        \"UnderlinePosition\",\n                        \"UnderlineThickness\",\n                        \"PaintType\",\n                        \"CharstringType\",\n                        \"FontMatrix\",\n                        \"StrokeWidth\",\n                        \"BlueScale\",\n                        \"BlueShift\",\n                        \"BlueFuzz\",\n                        \"StemSnapH\",\n                        \"StemSnapV\",\n                        \"ForceBold\",\n                        0,\n                        0,\n                        \"LanguageGroup\",\n                        \"ExpansionFactor\",\n                        \"initialRandomSeed\",\n                        \"SyntheticBase\",\n                        \"PostScript\",\n                        \"BaseFontName\",\n                        \"BaseFontBlend\",\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        \"ROS\",\n                        \"CIDFontVersion\",\n                        \"CIDFontRevision\",\n                        \"CIDFontType\",\n                        \"CIDCount\",\n                        \"UIDBase\",\n                        \"FDArray\",\n                        \"FDSelect\",\n                        \"FontName\"\n                    ][h], f = 2;\n                }\n                null != d ? (o[d] = 1 == s.length ? s[0] : s, s = []) : s.push(u), t += f;\n            }\n            return o;\n        }, e.cmap = {}, e.cmap.parse = function(r, t, a) {\n            r = new Uint8Array(r.buffer, t, a), t = 0;\n            var n = e._bin, o = {};\n            n.readUshort(r, t), t += 2;\n            var s = n.readUshort(r, t);\n            t += 2;\n            var i = [];\n            o.tables = [];\n            for(var h = 0; h < s; h++){\n                var f = n.readUshort(r, t);\n                t += 2;\n                var d = n.readUshort(r, t);\n                t += 2;\n                var u = n.readUint(r, t);\n                t += 4;\n                var l = \"p\" + f + \"e\" + d, v = i.indexOf(u);\n                if (-1 == v) {\n                    var c;\n                    v = o.tables.length, i.push(u);\n                    var p = n.readUshort(r, u);\n                    0 == p ? c = e.cmap.parse0(r, u) : 4 == p ? c = e.cmap.parse4(r, u) : 6 == p ? c = e.cmap.parse6(r, u) : 12 == p ? c = e.cmap.parse12(r, u) : console.debug(\"unknown format: \" + p, f, d, u), o.tables.push(c);\n                }\n                if (null != o[l]) throw \"multiple tables for one platform+encoding\";\n                o[l] = v;\n            }\n            return o;\n        }, e.cmap.parse0 = function(r, t) {\n            var a = e._bin, n = {};\n            n.format = a.readUshort(r, t), t += 2;\n            var o = a.readUshort(r, t);\n            t += 2, a.readUshort(r, t), t += 2, n.map = [];\n            for(var s = 0; s < o - 6; s++)n.map.push(r[t + s]);\n            return n;\n        }, e.cmap.parse4 = function(r, t) {\n            var a = e._bin, n = t, o = {};\n            o.format = a.readUshort(r, t), t += 2;\n            var s = a.readUshort(r, t);\n            t += 2, a.readUshort(r, t), t += 2;\n            var i = a.readUshort(r, t);\n            t += 2;\n            var h = i / 2;\n            o.searchRange = a.readUshort(r, t), t += 2, o.entrySelector = a.readUshort(r, t), t += 2, o.rangeShift = a.readUshort(r, t), t += 2, o.endCount = a.readUshorts(r, t, h), t += 2 * h, t += 2, o.startCount = a.readUshorts(r, t, h), t += 2 * h, o.idDelta = [];\n            for(var f = 0; f < h; f++)o.idDelta.push(a.readShort(r, t)), t += 2;\n            for(o.idRangeOffset = a.readUshorts(r, t, h), t += 2 * h, o.glyphIdArray = []; t < n + s;)o.glyphIdArray.push(a.readUshort(r, t)), t += 2;\n            return o;\n        }, e.cmap.parse6 = function(r, t) {\n            var a = e._bin, n = {};\n            n.format = a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2, a.readUshort(r, t), t += 2, n.firstCode = a.readUshort(r, t), t += 2;\n            var o = a.readUshort(r, t);\n            t += 2, n.glyphIdArray = [];\n            for(var s = 0; s < o; s++)n.glyphIdArray.push(a.readUshort(r, t)), t += 2;\n            return n;\n        }, e.cmap.parse12 = function(r, t) {\n            var a = e._bin, n = {};\n            n.format = a.readUshort(r, t), t += 2, t += 2, a.readUint(r, t), t += 4, a.readUint(r, t), t += 4;\n            var o = a.readUint(r, t);\n            t += 4, n.groups = [];\n            for(var s = 0; s < o; s++){\n                var i = t + 12 * s, h = a.readUint(r, i + 0), f = a.readUint(r, i + 4), d = a.readUint(r, i + 8);\n                n.groups.push([\n                    h,\n                    f,\n                    d\n                ]);\n            }\n            return n;\n        }, e.glyf = {}, e.glyf.parse = function(r, e, t, a) {\n            for(var n = [], o = 0; o < a.maxp.numGlyphs; o++)n.push(null);\n            return n;\n        }, e.glyf._parseGlyf = function(r, t) {\n            var a = e._bin, n = r._data, o = e._tabOffset(n, \"glyf\", r._offset) + r.loca[t];\n            if (r.loca[t] == r.loca[t + 1]) return null;\n            var s = {};\n            if (s.noc = a.readShort(n, o), o += 2, s.xMin = a.readShort(n, o), o += 2, s.yMin = a.readShort(n, o), o += 2, s.xMax = a.readShort(n, o), o += 2, s.yMax = a.readShort(n, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax) return null;\n            if (s.noc > 0) {\n                s.endPts = [];\n                for(var i = 0; i < s.noc; i++)s.endPts.push(a.readUshort(n, o)), o += 2;\n                var h = a.readUshort(n, o);\n                if (o += 2, n.length - o < h) return null;\n                s.instructions = a.readBytes(n, o, h), o += h;\n                var f = s.endPts[s.noc - 1] + 1;\n                s.flags = [];\n                for(i = 0; i < f; i++){\n                    var d = n[o];\n                    if (o++, s.flags.push(d), 0 != (8 & d)) {\n                        var u = n[o];\n                        o++;\n                        for(var l = 0; l < u; l++)s.flags.push(d), i++;\n                    }\n                }\n                s.xs = [];\n                for(i = 0; i < f; i++){\n                    var v = 0 != (2 & s.flags[i]), c = 0 != (16 & s.flags[i]);\n                    v ? (s.xs.push(c ? n[o] : -n[o]), o++) : c ? s.xs.push(0) : (s.xs.push(a.readShort(n, o)), o += 2);\n                }\n                s.ys = [];\n                for(i = 0; i < f; i++){\n                    v = 0 != (4 & s.flags[i]), c = 0 != (32 & s.flags[i]);\n                    v ? (s.ys.push(c ? n[o] : -n[o]), o++) : c ? s.ys.push(0) : (s.ys.push(a.readShort(n, o)), o += 2);\n                }\n                var p = 0, U = 0;\n                for(i = 0; i < f; i++)p += s.xs[i], U += s.ys[i], s.xs[i] = p, s.ys[i] = U;\n            } else {\n                var g;\n                s.parts = [];\n                do {\n                    g = a.readUshort(n, o), o += 2;\n                    var S = {\n                        m: {\n                            a: 1,\n                            b: 0,\n                            c: 0,\n                            d: 1,\n                            tx: 0,\n                            ty: 0\n                        },\n                        p1: -1,\n                        p2: -1\n                    };\n                    if (s.parts.push(S), S.glyphIndex = a.readUshort(n, o), o += 2, 1 & g) {\n                        var m = a.readShort(n, o);\n                        o += 2;\n                        var b = a.readShort(n, o);\n                        o += 2;\n                    } else {\n                        m = a.readInt8(n, o);\n                        o++;\n                        b = a.readInt8(n, o);\n                        o++;\n                    }\n                    2 & g ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g ? (S.m.a = S.m.d = a.readF2dot14(n, o), o += 2) : 64 & g ? (S.m.a = a.readF2dot14(n, o), o += 2, S.m.d = a.readF2dot14(n, o), o += 2) : 128 & g && (S.m.a = a.readF2dot14(n, o), o += 2, S.m.b = a.readF2dot14(n, o), o += 2, S.m.c = a.readF2dot14(n, o), o += 2, S.m.d = a.readF2dot14(n, o), o += 2);\n                }while (32 & g);\n                if (256 & g) {\n                    var y = a.readUshort(n, o);\n                    o += 2, s.instr = [];\n                    for(i = 0; i < y; i++)s.instr.push(n[o]), o++;\n                }\n            }\n            return s;\n        }, e.GPOS = {}, e.GPOS.parse = function(r, t, a, n) {\n            return e._lctf.parse(r, t, a, n, e.GPOS.subt);\n        }, e.GPOS.subt = function(r, t, a, n) {\n            var o = e._bin, s = a, i = {};\n            if (i.fmt = o.readUshort(r, a), a += 2, 1 == t || 2 == t || 3 == t || 7 == t || 8 == t && i.fmt <= 2) {\n                var h = o.readUshort(r, a);\n                a += 2, i.coverage = e._lctf.readCoverage(r, h + s);\n            }\n            if (1 == t && 1 == i.fmt) {\n                var f = o.readUshort(r, a);\n                a += 2;\n                var d = e._lctf.numOfOnes(f);\n                0 != f && (i.pos = e.GPOS.readValueRecord(r, a, f));\n            } else if (2 == t && i.fmt >= 1 && i.fmt <= 2) {\n                f = o.readUshort(r, a);\n                a += 2;\n                var u = o.readUshort(r, a);\n                a += 2;\n                d = e._lctf.numOfOnes(f);\n                var l = e._lctf.numOfOnes(u);\n                if (1 == i.fmt) {\n                    i.pairsets = [];\n                    var v = o.readUshort(r, a);\n                    a += 2;\n                    for(var c = 0; c < v; c++){\n                        var p = s + o.readUshort(r, a);\n                        a += 2;\n                        var U = o.readUshort(r, p);\n                        p += 2;\n                        for(var g = [], S = 0; S < U; S++){\n                            var m = o.readUshort(r, p);\n                            p += 2, 0 != f && (x = e.GPOS.readValueRecord(r, p, f), p += 2 * d), 0 != u && (P = e.GPOS.readValueRecord(r, p, u), p += 2 * l), g.push({\n                                gid2: m,\n                                val1: x,\n                                val2: P\n                            });\n                        }\n                        i.pairsets.push(g);\n                    }\n                }\n                if (2 == i.fmt) {\n                    var b = o.readUshort(r, a);\n                    a += 2;\n                    var y = o.readUshort(r, a);\n                    a += 2;\n                    var F = o.readUshort(r, a);\n                    a += 2;\n                    var _ = o.readUshort(r, a);\n                    a += 2, i.classDef1 = e._lctf.readClassDef(r, s + b), i.classDef2 = e._lctf.readClassDef(r, s + y), i.matrix = [];\n                    for(c = 0; c < F; c++){\n                        var C = [];\n                        for(S = 0; S < _; S++){\n                            var x = null, P = null;\n                            0 != f && (x = e.GPOS.readValueRecord(r, a, f), a += 2 * d), 0 != u && (P = e.GPOS.readValueRecord(r, a, u), a += 2 * l), C.push({\n                                val1: x,\n                                val2: P\n                            });\n                        }\n                        i.matrix.push(C);\n                    }\n                }\n            } else {\n                if (9 == t && 1 == i.fmt) {\n                    var I = o.readUshort(r, a);\n                    a += 2;\n                    var w = o.readUint(r, a);\n                    if (a += 4, 9 == n.ltype) n.ltype = I;\n                    else if (n.ltype != I) throw \"invalid extension substitution\";\n                    return e.GPOS.subt(r, n.ltype, s + w);\n                }\n                console.debug(\"unsupported GPOS table LookupType\", t, \"format\", i.fmt);\n            }\n            return i;\n        }, e.GPOS.readValueRecord = function(r, t, a) {\n            var n = e._bin, o = [];\n            return o.push(1 & a ? n.readShort(r, t) : 0), t += 1 & a ? 2 : 0, o.push(2 & a ? n.readShort(r, t) : 0), t += 2 & a ? 2 : 0, o.push(4 & a ? n.readShort(r, t) : 0), t += 4 & a ? 2 : 0, o.push(8 & a ? n.readShort(r, t) : 0), t += 8 & a ? 2 : 0, o;\n        }, e.GSUB = {}, e.GSUB.parse = function(r, t, a, n) {\n            return e._lctf.parse(r, t, a, n, e.GSUB.subt);\n        }, e.GSUB.subt = function(r, t, a, n) {\n            var o = e._bin, s = a, i = {};\n            if (i.fmt = o.readUshort(r, a), a += 2, 1 != t && 4 != t && 5 != t && 6 != t) return null;\n            if (1 == t || 4 == t || 5 == t && i.fmt <= 2 || 6 == t && i.fmt <= 2) {\n                var h = o.readUshort(r, a);\n                a += 2, i.coverage = e._lctf.readCoverage(r, s + h);\n            }\n            if (1 == t && i.fmt >= 1 && i.fmt <= 2) {\n                if (1 == i.fmt) i.delta = o.readShort(r, a), a += 2;\n                else if (2 == i.fmt) {\n                    var f = o.readUshort(r, a);\n                    a += 2, i.newg = o.readUshorts(r, a, f), a += 2 * i.newg.length;\n                }\n            } else if (4 == t) {\n                i.vals = [];\n                f = o.readUshort(r, a);\n                a += 2;\n                for(var d = 0; d < f; d++){\n                    var u = o.readUshort(r, a);\n                    a += 2, i.vals.push(e.GSUB.readLigatureSet(r, s + u));\n                }\n            } else if (5 == t && 2 == i.fmt) {\n                if (2 == i.fmt) {\n                    var l = o.readUshort(r, a);\n                    a += 2, i.cDef = e._lctf.readClassDef(r, s + l), i.scset = [];\n                    var v = o.readUshort(r, a);\n                    a += 2;\n                    for(d = 0; d < v; d++){\n                        var c = o.readUshort(r, a);\n                        a += 2, i.scset.push(0 == c ? null : e.GSUB.readSubClassSet(r, s + c));\n                    }\n                }\n            } else if (6 == t && 3 == i.fmt) {\n                if (3 == i.fmt) {\n                    for(d = 0; d < 3; d++){\n                        f = o.readUshort(r, a);\n                        a += 2;\n                        for(var p = [], U = 0; U < f; U++)p.push(e._lctf.readCoverage(r, s + o.readUshort(r, a + 2 * U)));\n                        a += 2 * f, 0 == d && (i.backCvg = p), 1 == d && (i.inptCvg = p), 2 == d && (i.ahedCvg = p);\n                    }\n                    f = o.readUshort(r, a);\n                    a += 2, i.lookupRec = e.GSUB.readSubstLookupRecords(r, a, f);\n                }\n            } else {\n                if (7 == t && 1 == i.fmt) {\n                    var g = o.readUshort(r, a);\n                    a += 2;\n                    var S = o.readUint(r, a);\n                    if (a += 4, 9 == n.ltype) n.ltype = g;\n                    else if (n.ltype != g) throw \"invalid extension substitution\";\n                    return e.GSUB.subt(r, n.ltype, s + S);\n                }\n                console.debug(\"unsupported GSUB table LookupType\", t, \"format\", i.fmt);\n            }\n            return i;\n        }, e.GSUB.readSubClassSet = function(r, t) {\n            var a = e._bin.readUshort, n = t, o = [], s = a(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = a(r, t);\n                t += 2, o.push(e.GSUB.readSubClassRule(r, n + h));\n            }\n            return o;\n        }, e.GSUB.readSubClassRule = function(r, t) {\n            var a = e._bin.readUshort, n = {}, o = a(r, t), s = a(r, t += 2);\n            t += 2, n.input = [];\n            for(var i = 0; i < o - 1; i++)n.input.push(a(r, t)), t += 2;\n            return n.substLookupRecords = e.GSUB.readSubstLookupRecords(r, t, s), n;\n        }, e.GSUB.readSubstLookupRecords = function(r, t, a) {\n            for(var n = e._bin.readUshort, o = [], s = 0; s < a; s++)o.push(n(r, t), n(r, t + 2)), t += 4;\n            return o;\n        }, e.GSUB.readChainSubClassSet = function(r, t) {\n            var a = e._bin, n = t, o = [], s = a.readUshort(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = a.readUshort(r, t);\n                t += 2, o.push(e.GSUB.readChainSubClassRule(r, n + h));\n            }\n            return o;\n        }, e.GSUB.readChainSubClassRule = function(r, t) {\n            for(var a = e._bin, n = {}, o = [\n                \"backtrack\",\n                \"input\",\n                \"lookahead\"\n            ], s = 0; s < o.length; s++){\n                var i = a.readUshort(r, t);\n                t += 2, 1 == s && i--, n[o[s]] = a.readUshorts(r, t, i), t += 2 * n[o[s]].length;\n            }\n            i = a.readUshort(r, t);\n            return t += 2, n.subst = a.readUshorts(r, t, 2 * i), t += 2 * n.subst.length, n;\n        }, e.GSUB.readLigatureSet = function(r, t) {\n            var a = e._bin, n = t, o = [], s = a.readUshort(r, t);\n            t += 2;\n            for(var i = 0; i < s; i++){\n                var h = a.readUshort(r, t);\n                t += 2, o.push(e.GSUB.readLigature(r, n + h));\n            }\n            return o;\n        }, e.GSUB.readLigature = function(r, t) {\n            var a = e._bin, n = {\n                chain: []\n            };\n            n.nglyph = a.readUshort(r, t), t += 2;\n            var o = a.readUshort(r, t);\n            t += 2;\n            for(var s = 0; s < o - 1; s++)n.chain.push(a.readUshort(r, t)), t += 2;\n            return n;\n        }, e.head = {}, e.head.parse = function(r, t, a) {\n            var n = e._bin, o = {};\n            return n.readFixed(r, t), t += 4, o.fontRevision = n.readFixed(r, t), t += 4, n.readUint(r, t), t += 4, n.readUint(r, t), t += 4, o.flags = n.readUshort(r, t), t += 2, o.unitsPerEm = n.readUshort(r, t), t += 2, o.created = n.readUint64(r, t), t += 8, o.modified = n.readUint64(r, t), t += 8, o.xMin = n.readShort(r, t), t += 2, o.yMin = n.readShort(r, t), t += 2, o.xMax = n.readShort(r, t), t += 2, o.yMax = n.readShort(r, t), t += 2, o.macStyle = n.readUshort(r, t), t += 2, o.lowestRecPPEM = n.readUshort(r, t), t += 2, o.fontDirectionHint = n.readShort(r, t), t += 2, o.indexToLocFormat = n.readShort(r, t), t += 2, o.glyphDataFormat = n.readShort(r, t), t += 2, o;\n        }, e.hhea = {}, e.hhea.parse = function(r, t, a) {\n            var n = e._bin, o = {};\n            return n.readFixed(r, t), t += 4, o.ascender = n.readShort(r, t), t += 2, o.descender = n.readShort(r, t), t += 2, o.lineGap = n.readShort(r, t), t += 2, o.advanceWidthMax = n.readUshort(r, t), t += 2, o.minLeftSideBearing = n.readShort(r, t), t += 2, o.minRightSideBearing = n.readShort(r, t), t += 2, o.xMaxExtent = n.readShort(r, t), t += 2, o.caretSlopeRise = n.readShort(r, t), t += 2, o.caretSlopeRun = n.readShort(r, t), t += 2, o.caretOffset = n.readShort(r, t), t += 2, t += 8, o.metricDataFormat = n.readShort(r, t), t += 2, o.numberOfHMetrics = n.readUshort(r, t), t += 2, o;\n        }, e.hmtx = {}, e.hmtx.parse = function(r, t, a, n) {\n            for(var o = e._bin, s = {\n                aWidth: [],\n                lsBearing: []\n            }, i = 0, h = 0, f = 0; f < n.maxp.numGlyphs; f++)f < n.hhea.numberOfHMetrics && (i = o.readUshort(r, t), t += 2, h = o.readShort(r, t), t += 2), s.aWidth.push(i), s.lsBearing.push(h);\n            return s;\n        }, e.kern = {}, e.kern.parse = function(r, t, a, n) {\n            var o = e._bin, s = o.readUshort(r, t);\n            if (t += 2, 1 == s) return e.kern.parseV1(r, t - 2, a, n);\n            var i = o.readUshort(r, t);\n            t += 2;\n            for(var h = {\n                glyph1: [],\n                rval: []\n            }, f = 0; f < i; f++){\n                t += 2;\n                a = o.readUshort(r, t);\n                t += 2;\n                var d = o.readUshort(r, t);\n                t += 2;\n                var u = d >>> 8;\n                if (0 != (u &= 15)) throw \"unknown kern table format: \" + u;\n                t = e.kern.readFormat0(r, t, h);\n            }\n            return h;\n        }, e.kern.parseV1 = function(r, t, a, n) {\n            var o = e._bin;\n            o.readFixed(r, t), t += 4;\n            var s = o.readUint(r, t);\n            t += 4;\n            for(var i = {\n                glyph1: [],\n                rval: []\n            }, h = 0; h < s; h++){\n                o.readUint(r, t), t += 4;\n                var f = o.readUshort(r, t);\n                t += 2, o.readUshort(r, t), t += 2;\n                var d = f >>> 8;\n                if (0 != (d &= 15)) throw \"unknown kern table format: \" + d;\n                t = e.kern.readFormat0(r, t, i);\n            }\n            return i;\n        }, e.kern.readFormat0 = function(r, t, a) {\n            var n = e._bin, o = -1, s = n.readUshort(r, t);\n            t += 2, n.readUshort(r, t), t += 2, n.readUshort(r, t), t += 2, n.readUshort(r, t), t += 2;\n            for(var i = 0; i < s; i++){\n                var h = n.readUshort(r, t);\n                t += 2;\n                var f = n.readUshort(r, t);\n                t += 2;\n                var d = n.readShort(r, t);\n                t += 2, h != o && (a.glyph1.push(h), a.rval.push({\n                    glyph2: [],\n                    vals: []\n                }));\n                var u = a.rval[a.rval.length - 1];\n                u.glyph2.push(f), u.vals.push(d), o = h;\n            }\n            return t;\n        }, e.loca = {}, e.loca.parse = function(r, t, a, n) {\n            var o = e._bin, s = [], i = n.head.indexToLocFormat, h = n.maxp.numGlyphs + 1;\n            if (0 == i) for(var f = 0; f < h; f++)s.push(o.readUshort(r, t + (f << 1)) << 1);\n            if (1 == i) for(f = 0; f < h; f++)s.push(o.readUint(r, t + (f << 2)));\n            return s;\n        }, e.maxp = {}, e.maxp.parse = function(r, t, a) {\n            var n = e._bin, o = {}, s = n.readUint(r, t);\n            return t += 4, o.numGlyphs = n.readUshort(r, t), t += 2, 65536 == s && (o.maxPoints = n.readUshort(r, t), t += 2, o.maxContours = n.readUshort(r, t), t += 2, o.maxCompositePoints = n.readUshort(r, t), t += 2, o.maxCompositeContours = n.readUshort(r, t), t += 2, o.maxZones = n.readUshort(r, t), t += 2, o.maxTwilightPoints = n.readUshort(r, t), t += 2, o.maxStorage = n.readUshort(r, t), t += 2, o.maxFunctionDefs = n.readUshort(r, t), t += 2, o.maxInstructionDefs = n.readUshort(r, t), t += 2, o.maxStackElements = n.readUshort(r, t), t += 2, o.maxSizeOfInstructions = n.readUshort(r, t), t += 2, o.maxComponentElements = n.readUshort(r, t), t += 2, o.maxComponentDepth = n.readUshort(r, t), t += 2), o;\n        }, e.name = {}, e.name.parse = function(r, t, a) {\n            var n = e._bin, o = {};\n            n.readUshort(r, t), t += 2;\n            var s = n.readUshort(r, t);\n            t += 2, n.readUshort(r, t);\n            for(var i, h = [\n                \"copyright\",\n                \"fontFamily\",\n                \"fontSubfamily\",\n                \"ID\",\n                \"fullName\",\n                \"version\",\n                \"postScriptName\",\n                \"trademark\",\n                \"manufacturer\",\n                \"designer\",\n                \"description\",\n                \"urlVendor\",\n                \"urlDesigner\",\n                \"licence\",\n                \"licenceURL\",\n                \"---\",\n                \"typoFamilyName\",\n                \"typoSubfamilyName\",\n                \"compatibleFull\",\n                \"sampleText\",\n                \"postScriptCID\",\n                \"wwsFamilyName\",\n                \"wwsSubfamilyName\",\n                \"lightPalette\",\n                \"darkPalette\"\n            ], f = t += 2, d = 0; d < s; d++){\n                var u = n.readUshort(r, t);\n                t += 2;\n                var l = n.readUshort(r, t);\n                t += 2;\n                var v = n.readUshort(r, t);\n                t += 2;\n                var c = n.readUshort(r, t);\n                t += 2;\n                var p = n.readUshort(r, t);\n                t += 2;\n                var U = n.readUshort(r, t);\n                t += 2;\n                var g, S = h[c], m = f + 12 * s + U;\n                if (0 == u) g = n.readUnicode(r, m, p / 2);\n                else if (3 == u && 0 == l) g = n.readUnicode(r, m, p / 2);\n                else if (0 == l) g = n.readASCII(r, m, p);\n                else if (1 == l) g = n.readUnicode(r, m, p / 2);\n                else if (3 == l) g = n.readUnicode(r, m, p / 2);\n                else {\n                    if (1 != u) throw \"unknown encoding \" + l + \", platformID: \" + u;\n                    g = n.readASCII(r, m, p), console.debug(\"reading unknown MAC encoding \" + l + \" as ASCII\");\n                }\n                var b = \"p\" + u + \",\" + v.toString(16);\n                null == o[b] && (o[b] = {}), o[b][void 0 !== S ? S : c] = g, o[b]._lang = v;\n            }\n            for(var y in o)if (null != o[y].postScriptName && 1033 == o[y]._lang) return o[y];\n            for(var y in o)if (null != o[y].postScriptName && 0 == o[y]._lang) return o[y];\n            for(var y in o)if (null != o[y].postScriptName && 3084 == o[y]._lang) return o[y];\n            for(var y in o)if (null != o[y].postScriptName) return o[y];\n            for(var y in o){\n                i = y;\n                break;\n            }\n            return console.debug(\"returning name table with languageID \" + o[i]._lang), o[i];\n        }, e[\"OS/2\"] = {}, e[\"OS/2\"].parse = function(r, t, a) {\n            var n = e._bin.readUshort(r, t);\n            t += 2;\n            var o = {};\n            if (0 == n) e[\"OS/2\"].version0(r, t, o);\n            else if (1 == n) e[\"OS/2\"].version1(r, t, o);\n            else if (2 == n || 3 == n || 4 == n) e[\"OS/2\"].version2(r, t, o);\n            else {\n                if (5 != n) throw \"unknown OS/2 table version: \" + n;\n                e[\"OS/2\"].version5(r, t, o);\n            }\n            return o;\n        }, e[\"OS/2\"].version0 = function(r, t, a) {\n            var n = e._bin;\n            return a.xAvgCharWidth = n.readShort(r, t), t += 2, a.usWeightClass = n.readUshort(r, t), t += 2, a.usWidthClass = n.readUshort(r, t), t += 2, a.fsType = n.readUshort(r, t), t += 2, a.ySubscriptXSize = n.readShort(r, t), t += 2, a.ySubscriptYSize = n.readShort(r, t), t += 2, a.ySubscriptXOffset = n.readShort(r, t), t += 2, a.ySubscriptYOffset = n.readShort(r, t), t += 2, a.ySuperscriptXSize = n.readShort(r, t), t += 2, a.ySuperscriptYSize = n.readShort(r, t), t += 2, a.ySuperscriptXOffset = n.readShort(r, t), t += 2, a.ySuperscriptYOffset = n.readShort(r, t), t += 2, a.yStrikeoutSize = n.readShort(r, t), t += 2, a.yStrikeoutPosition = n.readShort(r, t), t += 2, a.sFamilyClass = n.readShort(r, t), t += 2, a.panose = n.readBytes(r, t, 10), t += 10, a.ulUnicodeRange1 = n.readUint(r, t), t += 4, a.ulUnicodeRange2 = n.readUint(r, t), t += 4, a.ulUnicodeRange3 = n.readUint(r, t), t += 4, a.ulUnicodeRange4 = n.readUint(r, t), t += 4, a.achVendID = [\n                n.readInt8(r, t),\n                n.readInt8(r, t + 1),\n                n.readInt8(r, t + 2),\n                n.readInt8(r, t + 3)\n            ], t += 4, a.fsSelection = n.readUshort(r, t), t += 2, a.usFirstCharIndex = n.readUshort(r, t), t += 2, a.usLastCharIndex = n.readUshort(r, t), t += 2, a.sTypoAscender = n.readShort(r, t), t += 2, a.sTypoDescender = n.readShort(r, t), t += 2, a.sTypoLineGap = n.readShort(r, t), t += 2, a.usWinAscent = n.readUshort(r, t), t += 2, a.usWinDescent = n.readUshort(r, t), t += 2;\n        }, e[\"OS/2\"].version1 = function(r, t, a) {\n            var n = e._bin;\n            return t = e[\"OS/2\"].version0(r, t, a), a.ulCodePageRange1 = n.readUint(r, t), t += 4, a.ulCodePageRange2 = n.readUint(r, t), t += 4;\n        }, e[\"OS/2\"].version2 = function(r, t, a) {\n            var n = e._bin;\n            return t = e[\"OS/2\"].version1(r, t, a), a.sxHeight = n.readShort(r, t), t += 2, a.sCapHeight = n.readShort(r, t), t += 2, a.usDefault = n.readUshort(r, t), t += 2, a.usBreak = n.readUshort(r, t), t += 2, a.usMaxContext = n.readUshort(r, t), t += 2;\n        }, e[\"OS/2\"].version5 = function(r, t, a) {\n            var n = e._bin;\n            return t = e[\"OS/2\"].version2(r, t, a), a.usLowerOpticalPointSize = n.readUshort(r, t), t += 2, a.usUpperOpticalPointSize = n.readUshort(r, t), t += 2;\n        }, e.post = {}, e.post.parse = function(r, t, a) {\n            var n = e._bin, o = {};\n            return o.version = n.readFixed(r, t), t += 4, o.italicAngle = n.readFixed(r, t), t += 4, o.underlinePosition = n.readShort(r, t), t += 2, o.underlineThickness = n.readShort(r, t), t += 2, o;\n        }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function(r, e) {\n            var t = r.cmap, a = -1;\n            if (null != t.p0e4 ? a = t.p0e4 : null != t.p3e1 ? a = t.p3e1 : null != t.p1e0 ? a = t.p1e0 : null != t.p0e3 && (a = t.p0e3), -1 == a) throw \"no familiar platform and encoding!\";\n            var n = t.tables[a];\n            if (0 == n.format) return e >= n.map.length ? 0 : n.map[e];\n            if (4 == n.format) {\n                for(var o = -1, s = 0; s < n.endCount.length; s++)if (e <= n.endCount[s]) {\n                    o = s;\n                    break;\n                }\n                if (-1 == o) return 0;\n                if (n.startCount[o] > e) return 0;\n                return 65535 & (0 != n.idRangeOffset[o] ? n.glyphIdArray[e - n.startCount[o] + (n.idRangeOffset[o] >> 1) - (n.idRangeOffset.length - o)] : e + n.idDelta[o]);\n            }\n            if (12 == n.format) {\n                if (e > n.groups[n.groups.length - 1][1]) return 0;\n                for(s = 0; s < n.groups.length; s++){\n                    var i = n.groups[s];\n                    if (i[0] <= e && e <= i[1]) return i[2] + (e - i[0]);\n                }\n                return 0;\n            }\n            throw \"unknown cmap table format \" + n.format;\n        }, e.U.glyphToPath = function(r, t) {\n            var a = {\n                cmds: [],\n                crds: []\n            };\n            if (r.SVG && r.SVG.entries[t]) {\n                var n = r.SVG.entries[t];\n                return null == n ? a : (\"string\" == typeof n && (n = e.SVG.toPath(n), r.SVG.entries[t] = n), n);\n            }\n            if (r.CFF) {\n                var o = {\n                    x: 0,\n                    y: 0,\n                    stack: [],\n                    nStems: 0,\n                    haveWidth: !1,\n                    width: r.CFF.Private ? r.CFF.Private.defaultWidthX : 0,\n                    open: !1\n                }, s = r.CFF, i = r.CFF.Private;\n                if (s.ROS) {\n                    for(var h = 0; s.FDSelect[h + 2] <= t;)h += 2;\n                    i = s.FDArray[s.FDSelect[h + 1]].Private;\n                }\n                e.U._drawCFF(r.CFF.CharStrings[t], o, s, i, a);\n            } else r.glyf && e.U._drawGlyf(t, r, a);\n            return a;\n        }, e.U._drawGlyf = function(r, t, a) {\n            var n = t.glyf[r];\n            null == n && (n = t.glyf[r] = e.glyf._parseGlyf(t, r)), null != n && (n.noc > -1 ? e.U._simpleGlyph(n, a) : e.U._compoGlyph(n, t, a));\n        }, e.U._simpleGlyph = function(r, t) {\n            for(var a = 0; a < r.noc; a++){\n                for(var n = 0 == a ? 0 : r.endPts[a - 1] + 1, o = r.endPts[a], s = n; s <= o; s++){\n                    var i = s == n ? o : s - 1, h = s == o ? n : s + 1, f = 1 & r.flags[s], d = 1 & r.flags[i], u = 1 & r.flags[h], l = r.xs[s], v = r.ys[s];\n                    if (s == n) if (f) {\n                        if (!d) {\n                            e.U.P.moveTo(t, l, v);\n                            continue;\n                        }\n                        e.U.P.moveTo(t, r.xs[i], r.ys[i]);\n                    } else d ? e.U.P.moveTo(t, r.xs[i], r.ys[i]) : e.U.P.moveTo(t, (r.xs[i] + l) / 2, (r.ys[i] + v) / 2);\n                    f ? d && e.U.P.lineTo(t, l, v) : u ? e.U.P.qcurveTo(t, l, v, r.xs[h], r.ys[h]) : e.U.P.qcurveTo(t, l, v, (l + r.xs[h]) / 2, (v + r.ys[h]) / 2);\n                }\n                e.U.P.closePath(t);\n            }\n        }, e.U._compoGlyph = function(r, t, a) {\n            for(var n = 0; n < r.parts.length; n++){\n                var o = {\n                    cmds: [],\n                    crds: []\n                }, s = r.parts[n];\n                e.U._drawGlyf(s.glyphIndex, t, o);\n                for(var i = s.m, h = 0; h < o.crds.length; h += 2){\n                    var f = o.crds[h], d = o.crds[h + 1];\n                    a.crds.push(f * i.a + d * i.b + i.tx), a.crds.push(f * i.c + d * i.d + i.ty);\n                }\n                for(h = 0; h < o.cmds.length; h++)a.cmds.push(o.cmds[h]);\n            }\n        }, e.U._getGlyphClass = function(r, t) {\n            var a = e._lctf.getInterval(t, r);\n            return -1 == a ? 0 : t[a + 2];\n        }, e.U.getPairAdjustment = function(r, t, a) {\n            var n = !1;\n            if (r.GPOS) for(var o = r.GPOS, s = o.lookupList, i = o.featureList, h = [], f = 0; f < i.length; f++){\n                var d = i[f];\n                if (\"kern\" == d.tag) {\n                    n = !0;\n                    for(var u = 0; u < d.tab.length; u++)if (!h[d.tab[u]]) {\n                        h[d.tab[u]] = !0;\n                        for(var l = s[d.tab[u]], v = 0; v < l.tabs.length; v++)if (null != l.tabs[v]) {\n                            var c, p = l.tabs[v];\n                            if (!p.coverage || -1 != (c = e._lctf.coverageIndex(p.coverage, t))) {\n                                if (1 == l.ltype) ;\n                                else if (2 == l.ltype) {\n                                    var U = null;\n                                    if (1 == p.fmt) {\n                                        var g = p.pairsets[c];\n                                        for(f = 0; f < g.length; f++)g[f].gid2 == a && (U = g[f]);\n                                    } else if (2 == p.fmt) {\n                                        var S = e.U._getGlyphClass(t, p.classDef1), m = e.U._getGlyphClass(a, p.classDef2);\n                                        U = p.matrix[S][m];\n                                    }\n                                    if (U) {\n                                        var b = 0;\n                                        return U.val1 && U.val1[2] && (b += U.val1[2]), U.val2 && U.val2[0] && (b += U.val2[0]), b;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (r.kern && !n) {\n                var y = r.kern.glyph1.indexOf(t);\n                if (-1 != y) {\n                    var F = r.kern.rval[y].glyph2.indexOf(a);\n                    if (-1 != F) return r.kern.rval[y].vals[F];\n                }\n            }\n            return 0;\n        }, e.U._applySubs = function(r, t, a, n) {\n            for(var o = r.length - t - 1, s = 0; s < a.tabs.length; s++)if (null != a.tabs[s]) {\n                var i, h = a.tabs[s];\n                if (!h.coverage || -1 != (i = e._lctf.coverageIndex(h.coverage, r[t]))) {\n                    if (1 == a.ltype) r[t], 1 == h.fmt ? r[t] = r[t] + h.delta : r[t] = h.newg[i];\n                    else if (4 == a.ltype) for(var f = h.vals[i], d = 0; d < f.length; d++){\n                        var u = f[d], l = u.chain.length;\n                        if (!(l > o)) {\n                            for(var v = !0, c = 0, p = 0; p < l; p++){\n                                for(; -1 == r[t + c + (1 + p)];)c++;\n                                u.chain[p] != r[t + c + (1 + p)] && (v = !1);\n                            }\n                            if (v) {\n                                r[t] = u.nglyph;\n                                for(p = 0; p < l + c; p++)r[t + p + 1] = -1;\n                                break;\n                            }\n                        }\n                    }\n                    else if (5 == a.ltype && 2 == h.fmt) for(var U = e._lctf.getInterval(h.cDef, r[t]), g = h.cDef[U + 2], S = h.scset[g], m = 0; m < S.length; m++){\n                        var b = S[m], y = b.input;\n                        if (!(y.length > o)) {\n                            for(v = !0, p = 0; p < y.length; p++){\n                                var F = e._lctf.getInterval(h.cDef, r[t + 1 + p]);\n                                if (-1 == U && h.cDef[F + 2] != y[p]) {\n                                    v = !1;\n                                    break;\n                                }\n                            }\n                            if (v) {\n                                var _ = b.substLookupRecords;\n                                for(d = 0; d < _.length; d += 2)_[d], _[d + 1];\n                            }\n                        }\n                    }\n                    else if (6 == a.ltype && 3 == h.fmt) {\n                        if (!e.U._glsCovered(r, h.backCvg, t - h.backCvg.length)) continue;\n                        if (!e.U._glsCovered(r, h.inptCvg, t)) continue;\n                        if (!e.U._glsCovered(r, h.ahedCvg, t + h.inptCvg.length)) continue;\n                        var C = h.lookupRec;\n                        for(m = 0; m < C.length; m += 2){\n                            U = C[m];\n                            var x = n[C[m + 1]];\n                            e.U._applySubs(r, t + U, x, n);\n                        }\n                    }\n                }\n            }\n        }, e.U._glsCovered = function(r, t, a) {\n            for(var n = 0; n < t.length; n++){\n                if (-1 == e._lctf.coverageIndex(t[n], r[a + n])) return !1;\n            }\n            return !0;\n        }, e.U.glyphsToPath = function(r, t, a) {\n            for(var n = {\n                cmds: [],\n                crds: []\n            }, o = 0, s = 0; s < t.length; s++){\n                var i = t[s];\n                if (-1 != i) {\n                    for(var h = s < t.length - 1 && -1 != t[s + 1] ? t[s + 1] : 0, f = e.U.glyphToPath(r, i), d = 0; d < f.crds.length; d += 2)n.crds.push(f.crds[d] + o), n.crds.push(f.crds[d + 1]);\n                    a && n.cmds.push(a);\n                    for(d = 0; d < f.cmds.length; d++)n.cmds.push(f.cmds[d]);\n                    a && n.cmds.push(\"X\"), o += r.hmtx.aWidth[i], s < t.length - 1 && (o += e.U.getPairAdjustment(r, i, h));\n                }\n            }\n            return n;\n        }, e.U.P = {}, e.U.P.moveTo = function(r, e, t) {\n            r.cmds.push(\"M\"), r.crds.push(e, t);\n        }, e.U.P.lineTo = function(r, e, t) {\n            r.cmds.push(\"L\"), r.crds.push(e, t);\n        }, e.U.P.curveTo = function(r, e, t, a, n, o, s) {\n            r.cmds.push(\"C\"), r.crds.push(e, t, a, n, o, s);\n        }, e.U.P.qcurveTo = function(r, e, t, a, n) {\n            r.cmds.push(\"Q\"), r.crds.push(e, t, a, n);\n        }, e.U.P.closePath = function(r) {\n            r.cmds.push(\"Z\");\n        }, e.U._drawCFF = function(r, t, a, n, o) {\n            for(var s = t.stack, i = t.nStems, h = t.haveWidth, f = t.width, d = t.open, u = 0, l = t.x, v = t.y, c = 0, p = 0, U = 0, g = 0, S = 0, m = 0, b = 0, y = 0, F = 0, _ = 0, C = {\n                val: 0,\n                size: 0\n            }; u < r.length;){\n                e.CFF.getCharString(r, u, C);\n                var x = C.val;\n                if (u += C.size, \"o1\" == x || \"o18\" == x) s.length % 2 != 0 && !h && (f = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = !0;\n                else if (\"o3\" == x || \"o23\" == x) {\n                    s.length % 2 != 0 && !h && (f = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = !0;\n                } else if (\"o4\" == x) s.length > 1 && !h && (f = s.shift() + n.nominalWidthX, h = !0), d && e.U.P.closePath(o), v += s.pop(), e.U.P.moveTo(o, l, v), d = !0;\n                else if (\"o5\" == x) for(; s.length > 0;)l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);\n                else if (\"o6\" == x || \"o7\" == x) for(var P = s.length, I = \"o6\" == x, w = 0; w < P; w++){\n                    var O = s.shift();\n                    I ? l += O : v += O, I = !I, e.U.P.lineTo(o, l, v);\n                }\n                else if (\"o8\" == x || \"o24\" == x) {\n                    P = s.length;\n                    for(var T = 0; T + 6 <= P;)c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v), T += 6;\n                    \"o24\" == x && (l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v));\n                } else {\n                    if (\"o11\" == x) break;\n                    if (\"o1234\" == x || \"o1235\" == x || \"o1236\" == x || \"o1237\" == x) \"o1234\" == x && (p = v, U = (c = l + s.shift()) + s.shift(), _ = g = p + s.shift(), m = g, y = v, l = (b = (S = (F = U + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, _), e.U.P.curveTo(o, S, m, b, y, l, v)), \"o1235\" == x && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), F = U + s.shift(), _ = g + s.shift(), S = F + s.shift(), m = _ + s.shift(), b = S + s.shift(), y = m + s.shift(), l = b + s.shift(), v = y + s.shift(), s.shift(), e.U.P.curveTo(o, c, p, U, g, F, _), e.U.P.curveTo(o, S, m, b, y, l, v)), \"o1236\" == x && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), _ = g = p + s.shift(), m = g, b = (S = (F = U + s.shift()) + s.shift()) + s.shift(), y = m + s.shift(), l = b + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, _), e.U.P.curveTo(o, S, m, b, y, l, v)), \"o1237\" == x && (c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), F = U + s.shift(), _ = g + s.shift(), S = F + s.shift(), m = _ + s.shift(), b = S + s.shift(), y = m + s.shift(), Math.abs(b - l) > Math.abs(y - v) ? l = b + s.shift() : v = y + s.shift(), e.U.P.curveTo(o, c, p, U, g, F, _), e.U.P.curveTo(o, S, m, b, y, l, v));\n                    else if (\"o14\" == x) {\n                        if (s.length > 0 && !h && (f = s.shift() + a.nominalWidthX, h = !0), 4 == s.length) {\n                            var k = s.shift(), G = s.shift(), D = s.shift(), B = s.shift(), L = e.CFF.glyphBySE(a, D), R = e.CFF.glyphBySE(a, B);\n                            e.U._drawCFF(a.CharStrings[L], t, a, n, o), t.x = k, t.y = G, e.U._drawCFF(a.CharStrings[R], t, a, n, o);\n                        }\n                        d && (e.U.P.closePath(o), d = !1);\n                    } else if (\"o19\" == x || \"o20\" == x) {\n                        s.length % 2 != 0 && !h && (f = s.shift() + n.nominalWidthX), i += s.length >> 1, s.length = 0, h = !0, u += i + 7 >> 3;\n                    } else if (\"o21\" == x) s.length > 2 && !h && (f = s.shift() + n.nominalWidthX, h = !0), v += s.pop(), l += s.pop(), d && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), d = !0;\n                    else if (\"o22\" == x) s.length > 1 && !h && (f = s.shift() + n.nominalWidthX, h = !0), l += s.pop(), d && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), d = !0;\n                    else if (\"o25\" == x) {\n                        for(; s.length > 6;)l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);\n                        c = l + s.shift(), p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v);\n                    } else if (\"o26\" == x) for(s.length % 2 && (l += s.shift()); s.length > 0;)c = l, p = v + s.shift(), l = U = c + s.shift(), v = (g = p + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p, U, g, l, v);\n                    else if (\"o27\" == x) for(s.length % 2 && (v += s.shift()); s.length > 0;)p = v, U = (c = l + s.shift()) + s.shift(), g = p + s.shift(), l = U + s.shift(), v = g, e.U.P.curveTo(o, c, p, U, g, l, v);\n                    else if (\"o10\" == x || \"o29\" == x) {\n                        var A = \"o10\" == x ? n : a;\n                        if (0 == s.length) console.debug(\"error: empty stack\");\n                        else {\n                            var W = s.pop(), M = A.Subrs[W + A.Bias];\n                            t.x = l, t.y = v, t.nStems = i, t.haveWidth = h, t.width = f, t.open = d, e.U._drawCFF(M, t, a, n, o), l = t.x, v = t.y, i = t.nStems, h = t.haveWidth, f = t.width, d = t.open;\n                        }\n                    } else if (\"o30\" == x || \"o31\" == x) {\n                        var V = s.length, N = (T = 0, \"o31\" == x);\n                        for(T += V - (P = -3 & V); T < P;)N ? (p = v, U = (c = l + s.shift()) + s.shift(), v = (g = p + s.shift()) + s.shift(), P - T == 5 ? (l = U + s.shift(), T++) : l = U, N = !1) : (c = l, p = v + s.shift(), U = c + s.shift(), g = p + s.shift(), l = U + s.shift(), P - T == 5 ? (v = g + s.shift(), T++) : v = g, N = !0), e.U.P.curveTo(o, c, p, U, g, l, v), T += 4;\n                    } else {\n                        if (\"o\" == (x + \"\").charAt(0)) throw console.debug(\"Unknown operation: \" + x, r), x;\n                        s.push(x);\n                    }\n                }\n            }\n            t.x = l, t.y = v, t.nStems = i, t.haveWidth = h, t.width = f, t.open = d;\n        };\n        var t = e, a = {\n            Typr: t\n        };\n        return r.Typr = t, r.default = a, Object.defineProperty(r, \"__esModule\", {\n            value: !0\n        }), r;\n    }({}).Typr;\n}\n/*!\nCustom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate\n(https://github.com/101arrowz/fflate) for use in Troika text rendering. \nOriginal licenses apply: \n- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)\n- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n*/ function woff2otfFactory() {\n    return function(r) {\n        var e = Uint8Array, n = Uint16Array, t = Uint32Array, a = new e([\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            1,\n            1,\n            1,\n            2,\n            2,\n            2,\n            2,\n            3,\n            3,\n            3,\n            3,\n            4,\n            4,\n            4,\n            4,\n            5,\n            5,\n            5,\n            5,\n            0,\n            0,\n            0,\n            0\n        ]), i = new e([\n            0,\n            0,\n            0,\n            0,\n            1,\n            1,\n            2,\n            2,\n            3,\n            3,\n            4,\n            4,\n            5,\n            5,\n            6,\n            6,\n            7,\n            7,\n            8,\n            8,\n            9,\n            9,\n            10,\n            10,\n            11,\n            11,\n            12,\n            12,\n            13,\n            13,\n            0,\n            0\n        ]), o = new e([\n            16,\n            17,\n            18,\n            0,\n            8,\n            7,\n            9,\n            6,\n            10,\n            5,\n            11,\n            4,\n            12,\n            3,\n            13,\n            2,\n            14,\n            1,\n            15\n        ]), f = function(r, e) {\n            for(var a = new n(31), i = 0; i < 31; ++i)a[i] = e += 1 << r[i - 1];\n            var o = new t(a[30]);\n            for(i = 1; i < 30; ++i)for(var f = a[i]; f < a[i + 1]; ++f)o[f] = f - a[i] << 5 | i;\n            return [\n                a,\n                o\n            ];\n        }, u = f(a, 2), v = u[0], s = u[1];\n        v[28] = 258, s[258] = 28;\n        for(var l = f(i, 0)[0], c = new n(32768), g = 0; g < 32768; ++g){\n            var h = (43690 & g) >>> 1 | (21845 & g) << 1;\n            h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c[g] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;\n        }\n        var w = function(r, e, t) {\n            for(var a = r.length, i = 0, o = new n(e); i < a; ++i)++o[r[i] - 1];\n            var f, u = new n(e);\n            for(i = 0; i < e; ++i)u[i] = u[i - 1] + o[i - 1] << 1;\n            if (t) {\n                f = new n(1 << e);\n                var v = 15 - e;\n                for(i = 0; i < a; ++i)if (r[i]) for(var s = i << 4 | r[i], l = e - r[i], g = u[r[i] - 1]++ << l, h = g | (1 << l) - 1; g <= h; ++g)f[c[g] >>> v] = s;\n            } else for(f = new n(a), i = 0; i < a; ++i)r[i] && (f[i] = c[u[r[i] - 1]++] >>> 15 - r[i]);\n            return f;\n        }, d = new e(288);\n        for(g = 0; g < 144; ++g)d[g] = 8;\n        for(g = 144; g < 256; ++g)d[g] = 9;\n        for(g = 256; g < 280; ++g)d[g] = 7;\n        for(g = 280; g < 288; ++g)d[g] = 8;\n        var m = new e(32);\n        for(g = 0; g < 32; ++g)m[g] = 5;\n        var b = w(d, 9, 1), p = w(m, 5, 1), y = function(r) {\n            for(var e = r[0], n = 1; n < r.length; ++n)r[n] > e && (e = r[n]);\n            return e;\n        }, L = function(r, e, n) {\n            var t = e / 8 | 0;\n            return (r[t] | r[t + 1] << 8) >> (7 & e) & n;\n        }, U = function(r, e) {\n            var n = e / 8 | 0;\n            return (r[n] | r[n + 1] << 8 | r[n + 2] << 16) >> (7 & e);\n        }, k = [\n            \"unexpected EOF\",\n            \"invalid block type\",\n            \"invalid length/literal\",\n            \"invalid distance\",\n            \"stream finished\",\n            \"no stream handler\",\n            ,\n            \"no callback\",\n            \"invalid UTF-8 data\",\n            \"extra field too long\",\n            \"date not in range 1980-2099\",\n            \"filename too long\",\n            \"stream finishing\",\n            \"invalid zip data\"\n        ], T = function(r, e, n) {\n            var t = new Error(e || k[r]);\n            if (t.code = r, Error.captureStackTrace && Error.captureStackTrace(t, T), !n) throw t;\n            return t;\n        }, O = function(r, f, u) {\n            var s = r.length;\n            if (!s || u && !u.l && s < 5) return f || new e(0);\n            var c = !f || u, g = !u || u.i;\n            u || (u = {}), f || (f = new e(3 * s));\n            var h, d = function(r) {\n                var n = f.length;\n                if (r > n) {\n                    var t = new e(Math.max(2 * n, r));\n                    t.set(f), f = t;\n                }\n            }, m = u.f || 0, k = u.p || 0, O = u.b || 0, A = u.l, x = u.d, E = u.m, D = u.n, M = 8 * s;\n            do {\n                if (!A) {\n                    u.f = m = L(r, k, 1);\n                    var S = L(r, k + 1, 3);\n                    if (k += 3, !S) {\n                        var V = r[(I = ((h = k) / 8 | 0) + (7 & h && 1) + 4) - 4] | r[I - 3] << 8, _ = I + V;\n                        if (_ > s) {\n                            g && T(0);\n                            break;\n                        }\n                        c && d(O + V), f.set(r.subarray(I, _), O), u.b = O += V, u.p = k = 8 * _;\n                        continue;\n                    }\n                    if (1 == S) A = b, x = p, E = 9, D = 5;\n                    else if (2 == S) {\n                        var j = L(r, k, 31) + 257, z = L(r, k + 10, 15) + 4, C = j + L(r, k + 5, 31) + 1;\n                        k += 14;\n                        for(var F = new e(C), P = new e(19), q = 0; q < z; ++q)P[o[q]] = L(r, k + 3 * q, 7);\n                        k += 3 * z;\n                        var B = y(P), G = (1 << B) - 1, H = w(P, B, 1);\n                        for(q = 0; q < C;){\n                            var I, J = H[L(r, k, G)];\n                            if (k += 15 & J, (I = J >>> 4) < 16) F[q++] = I;\n                            else {\n                                var K = 0, N = 0;\n                                for(16 == I ? (N = 3 + L(r, k, 3), k += 2, K = F[q - 1]) : 17 == I ? (N = 3 + L(r, k, 7), k += 3) : 18 == I && (N = 11 + L(r, k, 127), k += 7); N--;)F[q++] = K;\n                            }\n                        }\n                        var Q = F.subarray(0, j), R = F.subarray(j);\n                        E = y(Q), D = y(R), A = w(Q, E, 1), x = w(R, D, 1);\n                    } else T(1);\n                    if (k > M) {\n                        g && T(0);\n                        break;\n                    }\n                }\n                c && d(O + 131072);\n                for(var W = (1 << E) - 1, X = (1 << D) - 1, Y = k;; Y = k){\n                    var Z = (K = A[U(r, k) & W]) >>> 4;\n                    if ((k += 15 & K) > M) {\n                        g && T(0);\n                        break;\n                    }\n                    if (K || T(2), Z < 256) f[O++] = Z;\n                    else {\n                        if (256 == Z) {\n                            Y = k, A = null;\n                            break;\n                        }\n                        var $ = Z - 254;\n                        if (Z > 264) {\n                            var rr = a[q = Z - 257];\n                            $ = L(r, k, (1 << rr) - 1) + v[q], k += rr;\n                        }\n                        var er = x[U(r, k) & X], nr = er >>> 4;\n                        er || T(3), k += 15 & er;\n                        R = l[nr];\n                        if (nr > 3) {\n                            rr = i[nr];\n                            R += U(r, k) & (1 << rr) - 1, k += rr;\n                        }\n                        if (k > M) {\n                            g && T(0);\n                            break;\n                        }\n                        c && d(O + 131072);\n                        for(var tr = O + $; O < tr; O += 4)f[O] = f[O - R], f[O + 1] = f[O + 1 - R], f[O + 2] = f[O + 2 - R], f[O + 3] = f[O + 3 - R];\n                        O = tr;\n                    }\n                }\n                u.l = A, u.p = Y, u.b = O, A && (m = 1, u.m = E, u.d = x, u.n = D);\n            }while (!m);\n            return O == f.length ? f : function(r, a, i) {\n                (null == a || a < 0) && (a = 0), (null == i || i > r.length) && (i = r.length);\n                var o = new (r instanceof n ? n : r instanceof t ? t : e)(i - a);\n                return o.set(r.subarray(a, i)), o;\n            }(f, 0, O);\n        }, A = new e(0);\n        var x = \"undefined\" != typeof TextDecoder && new TextDecoder;\n        try {\n            x.decode(A, {\n                stream: !0\n            }), 1;\n        } catch (r) {}\n        return r.convert_streams = function(r) {\n            var e = new DataView(r), n = 0;\n            function t() {\n                var r = e.getUint16(n);\n                return n += 2, r;\n            }\n            function a() {\n                var r = e.getUint32(n);\n                return n += 4, r;\n            }\n            function i(r) {\n                m.setUint16(b, r), b += 2;\n            }\n            function o(r) {\n                m.setUint32(b, r), b += 4;\n            }\n            for(var f = {\n                signature: a(),\n                flavor: a(),\n                length: a(),\n                numTables: t(),\n                reserved: t(),\n                totalSfntSize: a(),\n                majorVersion: t(),\n                minorVersion: t(),\n                metaOffset: a(),\n                metaLength: a(),\n                metaOrigLength: a(),\n                privOffset: a(),\n                privLength: a()\n            }, u = 0; Math.pow(2, u) <= f.numTables;)u++;\n            u--;\n            for(var v = 16 * Math.pow(2, u), s = 16 * f.numTables - v, l = 12, c = [], g = 0; g < f.numTables; g++)c.push({\n                tag: a(),\n                offset: a(),\n                compLength: a(),\n                origLength: a(),\n                origChecksum: a()\n            }), l += 16;\n            var h, w = new Uint8Array(12 + 16 * c.length + c.reduce(function(r, e) {\n                return r + e.origLength + 4;\n            }, 0)), d = w.buffer, m = new DataView(d), b = 0;\n            return o(f.flavor), i(f.numTables), i(v), i(u), i(s), c.forEach(function(r) {\n                o(r.tag), o(r.origChecksum), o(l), o(r.origLength), r.outOffset = l, (l += r.origLength) % 4 != 0 && (l += 4 - l % 4);\n            }), c.forEach(function(e) {\n                var n, t = r.slice(e.offset, e.offset + e.compLength);\n                if (e.compLength != e.origLength) {\n                    var a = new Uint8Array(e.origLength);\n                    n = new Uint8Array(t, 2), O(n, a);\n                } else a = new Uint8Array(t);\n                w.set(a, e.outOffset);\n                var i = 0;\n                (l = e.outOffset + e.origLength) % 4 != 0 && (i = 4 - l % 4), w.set(new Uint8Array(i).buffer, e.outOffset + e.origLength), h = l + i;\n            }), d.slice(0, h);\n        }, Object.defineProperty(r, \"__esModule\", {\n            value: !0\n        }), r;\n    }({}).convert_streams;\n}\n/**\n * A factory wrapper parsing a font file using Typr.\n * Also adds support for WOFF files (not WOFF2).\n */ function parserFactory(Typr, woff2otf) {\n    const cmdArgLengths = {\n        M: 2,\n        L: 2,\n        Q: 4,\n        C: 6,\n        Z: 0\n    };\n    // {joinType: \"skip+step,...\"}\n    const joiningTypeRawData = {\n        \"C\": \"18g,ca,368,1kz\",\n        \"D\": \"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\n        \"R\": \"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\n        \"L\": \"x9u,jff,a,fd,jv\",\n        \"T\": \"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"\n    };\n    const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,\n    let joiningTypeMap;\n    function getCharJoiningType(ch) {\n        if (!joiningTypeMap) {\n            const m = {\n                R: JT_RIGHT,\n                L: JT_LEFT,\n                D: JT_DUAL,\n                C: JT_JOIN_CAUSING,\n                U: JT_NON_JOINING,\n                T: JT_TRANSPARENT\n            };\n            joiningTypeMap = new Map();\n            for(let type in joiningTypeRawData){\n                let lastCode = 0;\n                joiningTypeRawData[type].split(\",\").forEach((range)=>{\n                    let [skip, step] = range.split(\"+\");\n                    skip = parseInt(skip, 36);\n                    step = step ? parseInt(step, 36) : 0;\n                    joiningTypeMap.set(lastCode += skip, m[type]);\n                    for(let i = step; i--;){\n                        joiningTypeMap.set(++lastCode, m[type]);\n                    }\n                });\n            }\n        }\n        return joiningTypeMap.get(ch) || JT_NON_JOINING;\n    }\n    const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;\n    const formsToFeatures = [\n        null,\n        \"isol\",\n        \"init\",\n        \"fina\",\n        \"medi\"\n    ];\n    function detectJoiningForms(str) {\n        // This implements the algorithm described here:\n        // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md\n        const joiningForms = new Uint8Array(str.length);\n        let prevJoiningType = JT_NON_JOINING;\n        let prevForm = ISOL;\n        let prevIndex = -1;\n        for(let i = 0; i < str.length; i++){\n            const code = str.codePointAt(i);\n            let joiningType = getCharJoiningType(code) | 0;\n            let form = ISOL;\n            if (joiningType & JT_TRANSPARENT) {\n                continue;\n            }\n            if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {\n                if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {\n                    form = FINA;\n                    // isol->init, fina->medi\n                    if (prevForm === ISOL || prevForm === FINA) {\n                        joiningForms[prevIndex]++;\n                    }\n                } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {\n                    // medi->fina, init->isol\n                    if (prevForm === INIT || prevForm === MEDI) {\n                        joiningForms[prevIndex]--;\n                    }\n                }\n            } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {\n                // medi->fina, init->isol\n                if (prevForm === INIT || prevForm === MEDI) {\n                    joiningForms[prevIndex]--;\n                }\n            }\n            prevForm = joiningForms[i] = form;\n            prevJoiningType = joiningType;\n            prevIndex = i;\n            if (code > 0xffff) i++;\n        }\n        // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))\n        // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))\n        // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))\n        return joiningForms;\n    }\n    function stringToGlyphs(font, str) {\n        const glyphIds = [];\n        for(let i = 0; i < str.length; i++){\n            const cc = str.codePointAt(i);\n            if (cc > 0xffff) i++;\n            glyphIds.push(Typr.U.codeToGlyph(font, cc));\n        }\n        const gsub = font[\"GSUB\"];\n        if (gsub) {\n            const { lookupList, featureList } = gsub;\n            let joiningForms;\n            const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;\n            const usedLookups = [];\n            featureList.forEach((feature)=>{\n                if (supportedFeatures.test(feature.tag)) {\n                    for(let ti = 0; ti < feature.tab.length; ti++){\n                        if (usedLookups[feature.tab[ti]]) continue;\n                        usedLookups[feature.tab[ti]] = true;\n                        const tab = lookupList[feature.tab[ti]];\n                        const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);\n                        if (isJoiningFeature && !joiningForms) {\n                            joiningForms = detectJoiningForms(str);\n                        }\n                        for(let ci = 0; ci < glyphIds.length; ci++){\n                            if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {\n                                Typr.U._applySubs(glyphIds, ci, tab, lookupList);\n                            }\n                        }\n                    }\n                }\n            });\n        }\n        return glyphIds;\n    }\n    function firstNum(...args) {\n        for(let i = 0; i < args.length; i++){\n            if (typeof args[i] === \"number\") {\n                return args[i];\n            }\n        }\n    }\n    function wrapFontObj(typrFont) {\n        const glyphMap = Object.create(null);\n        const os2 = typrFont[\"OS/2\"];\n        const hhea = typrFont.hhea;\n        const unitsPerEm = typrFont.head.unitsPerEm;\n        const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);\n        const fontObj = {\n            unitsPerEm,\n            ascender,\n            descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),\n            capHeight: firstNum(os2 && os2.sCapHeight, ascender),\n            xHeight: firstNum(os2 && os2.sxHeight, ascender),\n            lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),\n            forEachGlyph (text, fontSize, letterSpacing, callback) {\n                let glyphX = 0;\n                const fontScale = 1 / fontObj.unitsPerEm * fontSize;\n                const glyphIndices = stringToGlyphs(typrFont, text);\n                let charIndex = 0;\n                let prevGlyphIndex = -1;\n                glyphIndices.forEach((glyphIndex, i)=>{\n                    // Typr returns a glyph index per string codepoint, with -1s in place of those that\n                    // were omitted due to ligature substitution. So we can track original index in the\n                    // string via simple increment, and skip everything else when seeing a -1.\n                    if (glyphIndex !== -1) {\n                        let glyphObj = glyphMap[glyphIndex];\n                        if (!glyphObj) {\n                            const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphIndex);\n                            // Build path string\n                            let path = \"\";\n                            let crdsIdx = 0;\n                            for(let i = 0, len = cmds.length; i < len; i++){\n                                const numArgs = cmdArgLengths[cmds[i]];\n                                path += cmds[i];\n                                for(let j = 1; j <= numArgs; j++){\n                                    path += (j > 1 ? \",\" : \"\") + crds[crdsIdx++];\n                                }\n                            }\n                            // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't\n                            // normalize the two, so it's simplest just to iterate ourselves.\n                            let xMin, yMin, xMax, yMax;\n                            if (crds.length) {\n                                xMin = yMin = Infinity;\n                                xMax = yMax = -Infinity;\n                                for(let i = 0, len = crds.length; i < len; i += 2){\n                                    let x = crds[i];\n                                    let y = crds[i + 1];\n                                    if (x < xMin) xMin = x;\n                                    if (y < yMin) yMin = y;\n                                    if (x > xMax) xMax = x;\n                                    if (y > yMax) yMax = y;\n                                }\n                            } else {\n                                xMin = xMax = yMin = yMax = 0;\n                            }\n                            glyphObj = glyphMap[glyphIndex] = {\n                                index: glyphIndex,\n                                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],\n                                xMin,\n                                yMin,\n                                xMax,\n                                yMax,\n                                path,\n                                pathCommandCount: cmds.length\n                            };\n                        }\n                        // Kerning\n                        if (prevGlyphIndex !== -1) {\n                            glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;\n                        }\n                        callback.call(null, glyphObj, glyphX, charIndex);\n                        if (glyphObj.advanceWidth) {\n                            glyphX += glyphObj.advanceWidth * fontScale;\n                        }\n                        if (letterSpacing) {\n                            glyphX += letterSpacing * fontSize;\n                        }\n                        prevGlyphIndex = glyphIndex;\n                    }\n                    charIndex += text.codePointAt(charIndex) > 0xffff ? 2 : 1;\n                });\n                return glyphX;\n            }\n        };\n        return fontObj;\n    }\n    return function parse(buffer) {\n        // Look to see if we have a WOFF file and convert it if so:\n        const peek = new Uint8Array(buffer, 0, 4);\n        const tag = Typr._bin.readASCII(peek, 0, 4);\n        if (tag === \"wOFF\") {\n            buffer = woff2otf(buffer);\n        } else if (tag === \"wOF2\") {\n            throw new Error(\"woff2 fonts not supported\");\n        }\n        return wrapFontObj(Typr.parse(buffer)[0]);\n    };\n}\nconst workerModule = /*#__PURE__*/ (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n    name: \"Typr Font Parser\",\n    dependencies: [\n        typrFactory,\n        woff2otfFactory,\n        parserFactory\n    ],\n    init (typrFactory, woff2otfFactory, parserFactory) {\n        const Typr = typrFactory();\n        const woff2otf = woff2otfFactory();\n        return parserFactory(Typr, woff2otf);\n    }\n});\nconst CONFIG = {\n    defaultFontURL: \"https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff\",\n    sdfGlyphSize: 64,\n    sdfMargin: 1 / 16,\n    sdfExponent: 9,\n    textureWidth: 2048\n};\nconst tempColor = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Color();\nlet hasRequested = false;\nfunction now$1() {\n    return (self.performance || Date).now();\n}\n/**\n * Customizes the text builder configuration. This must be called prior to the first font processing\n * request, and applies to all fonts.\n *\n * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n *                 requests, in case none is specified or the specifiede font fails to load or parse.\n *                 Defaults to \"Roboto Regular\" from Google Fonts.\n * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)\n *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n *                 to 64 which is generally a good balance of size and quality.\n * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent\n *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer\n *                 the glyph's path, with lower precision further away. Defaults to 9.\n * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's\n *                 path, as a percentage of the SDF width. A larger margin increases the quality of\n *                 extruded glyph outlines, but decreases the precision available for the glyph itself.\n *                 Defaults to 1/16th of the glyph size.\n * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n *                 2048 which is a safe maximum texture dimension according to the stats at\n *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of\n *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to\n *                 increase the glyph size and/or have an extraordinary number of glyphs.\n */ function configureTextBuilder(config) {\n    if (hasRequested) {\n        console.warn(\"configureTextBuilder called after first font request; will be ignored.\");\n    } else {\n        assign(CONFIG, config);\n    }\n}\n/**\n * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for\n * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.\n *\n *   {\n *     [sdfGlyphSize]: {\n *       glyphCount: number,\n *       sdfGlyphSize: number,\n *       sdfTexture: Texture,\n *       sdfCanvas: HTMLCanvasElement,\n *       contextLost: boolean,\n *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>\n *     }\n *   }\n */ const atlases = Object.create(null);\n/**\n * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n * @property {object} parameters - The normalized input arguments to the render call.\n * @property {Texture} sdfTexture - The SDF atlas texture.\n * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.\n * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.\n * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.\n * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.\n * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is\n *           three elements: the starting X, the ending X, and the bottom Y for the caret.\n * @property {number} [caretHeight] - An appropriate height for all selection carets.\n * @property {number} ascender - The font's ascender metric.\n * @property {number} descender - The font's descender metric.\n * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.\n * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.\n * @property {number} lineHeight - The final computed lineHeight measurement.\n * @property {number} topBaseline - The y position of the top line's baseline.\n * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is\n *           equivalent to the dimensions of a block-level text element in CSS.\n * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.\n * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n *           generation, typesetting, etc.\n * @frozen\n */ /**\n * @callback getTextRenderInfo~callback\n * @param {TroikaTextRenderInfo} textRenderInfo\n */ /**\n * Main entry point for requesting the data needed to render a text string with given font parameters.\n * This is an asynchronous call, performing most of the logic in a web worker thread.\n * @param {object} args\n * @param {getTextRenderInfo~callback} callback\n */ function getTextRenderInfo(args, callback) {\n    hasRequested = true;\n    args = assign({}, args);\n    const totalStart = now$1();\n    // Apply default font here to avoid a 'null' atlas, and convert relative\n    // URLs to absolute so they can be resolved in the worker\n    args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);\n    // Normalize text to a string\n    args.text = \"\" + args.text;\n    args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n    // Normalize colors\n    if (args.colorRanges != null) {\n        let colors = {};\n        for(let key in args.colorRanges){\n            if (args.colorRanges.hasOwnProperty(key)) {\n                let val = args.colorRanges[key];\n                if (typeof val !== \"number\") {\n                    val = tempColor.set(val).getHex();\n                }\n                colors[key] = val;\n            }\n        }\n        args.colorRanges = colors;\n    }\n    Object.freeze(args);\n    // Init the atlas if needed\n    const { textureWidth, sdfExponent } = CONFIG;\n    const { sdfGlyphSize } = args;\n    const glyphsPerRow = textureWidth / sdfGlyphSize * 4;\n    let atlas = atlases[sdfGlyphSize];\n    if (!atlas) {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = textureWidth;\n        canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs\n        atlas = atlases[sdfGlyphSize] = {\n            glyphCount: 0,\n            sdfGlyphSize,\n            sdfCanvas: canvas,\n            sdfTexture: new three__WEBPACK_IMPORTED_MODULE_3__.Texture(canvas, undefined, undefined, undefined, three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter),\n            contextLost: false,\n            glyphsByFont: new Map()\n        };\n        atlas.sdfTexture.generateMipmaps = false;\n        initContextLossHandling(atlas);\n    }\n    const { sdfTexture, sdfCanvas } = atlas;\n    let fontGlyphs = atlas.glyphsByFont.get(args.font);\n    if (!fontGlyphs) {\n        atlas.glyphsByFont.set(args.font, fontGlyphs = new Map());\n    }\n    // Issue request to the typesetting engine in the worker\n    typesetInWorker(args).then((result)=>{\n        const { glyphIds, glyphPositions, fontSize, unitsPerEm, timings } = result;\n        const neededSDFs = [];\n        const glyphBounds = new Float32Array(glyphIds.length * 4);\n        const fontSizeMult = fontSize / unitsPerEm;\n        let boundsIdx = 0;\n        let positionsIdx = 0;\n        const quadsStart = now$1();\n        glyphIds.forEach((glyphId, i)=>{\n            let glyphInfo = fontGlyphs.get(glyphId);\n            // If this is a glyphId not seen before, add it to the atlas\n            if (!glyphInfo) {\n                const { path, pathBounds } = result.glyphData[glyphId];\n                // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.\n                // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain\n                // useful interpolated values and will be ignored anyway.\n                const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);\n                const atlasIndex = atlas.glyphCount++;\n                const sdfViewBox = [\n                    pathBounds[0] - fontUnitsMargin,\n                    pathBounds[1] - fontUnitsMargin,\n                    pathBounds[2] + fontUnitsMargin,\n                    pathBounds[3] + fontUnitsMargin\n                ];\n                fontGlyphs.set(glyphId, glyphInfo = {\n                    path,\n                    atlasIndex,\n                    sdfViewBox\n                });\n                // Collect those that need SDF generation\n                neededSDFs.push(glyphInfo);\n            }\n            // Calculate bounds for renderable quads\n            // TODO can we get this back off the main thread?\n            const { sdfViewBox } = glyphInfo;\n            const posX = glyphPositions[positionsIdx++];\n            const posY = glyphPositions[positionsIdx++];\n            glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;\n            glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;\n            glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;\n            glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;\n            // Convert glyphId to SDF index for the shader\n            glyphIds[i] = glyphInfo.atlasIndex;\n        });\n        timings.quads = (timings.quads || 0) + (now$1() - quadsStart);\n        const sdfStart = now$1();\n        timings.sdf = {};\n        // Grow the texture height by power of 2 if needed\n        const currentHeight = sdfCanvas.height;\n        const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);\n        const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));\n        if (neededHeight > currentHeight) {\n            // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over\n            console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);\n            resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);\n            // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it\n            sdfTexture.dispose();\n        }\n        Promise.all(neededSDFs.map((glyphInfo)=>generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing })=>{\n                timings.sdf[glyphInfo.atlasIndex] = timing;\n            }))).then(()=>{\n            if (neededSDFs.length && !atlas.contextLost) {\n                safariPre15Workaround(atlas);\n                sdfTexture.needsUpdate = true;\n            }\n            timings.sdfTotal = now$1() - sdfStart;\n            timings.total = now$1() - totalStart;\n            // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)\n            // Invoke callback with the text layout arrays and updated texture\n            callback(Object.freeze({\n                parameters: args,\n                sdfTexture,\n                sdfGlyphSize,\n                sdfExponent,\n                glyphBounds,\n                glyphAtlasIndices: glyphIds,\n                glyphColors: result.glyphColors,\n                caretPositions: result.caretPositions,\n                caretHeight: result.caretHeight,\n                chunkedBounds: result.chunkedBounds,\n                ascender: result.ascender,\n                descender: result.descender,\n                lineHeight: result.lineHeight,\n                capHeight: result.capHeight,\n                xHeight: result.xHeight,\n                topBaseline: result.topBaseline,\n                blockBounds: result.blockBounds,\n                visibleBounds: result.visibleBounds,\n                timings: result.timings\n            }));\n        });\n    });\n    // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is\n    // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets\n    // a head start on that process before SDFs actually start getting processed.\n    Promise.resolve().then(()=>{\n        if (!atlas.contextLost) {\n            warmUpSDFCanvas(sdfCanvas);\n        }\n    });\n}\nfunction generateGlyphSDF({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {\n    if (contextLost) {\n        // If the context is lost there's nothing we can do, just quit silently and let it\n        // get regenerated when the context is restored\n        return Promise.resolve({\n            timing: -1\n        });\n    }\n    const { textureWidth, sdfExponent } = CONFIG;\n    const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);\n    const squareIndex = Math.floor(atlasIndex / 4);\n    const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;\n    const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;\n    const channel = atlasIndex % 4;\n    return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU);\n}\nfunction initContextLossHandling(atlas) {\n    const canvas = atlas.sdfCanvas;\n    /*\n  // Begin context loss simulation\n  if (!window.WebGLDebugUtils) {\n    let script = document.getElementById('WebGLDebugUtilsScript')\n    if (!script) {\n      script = document.createElement('script')\n      script.id = 'WebGLDebugUtils'\n      document.head.appendChild(script)\n      script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'\n    }\n    script.addEventListener('load', () => {\n      initContextLossHandling(atlas)\n    })\n    return\n  }\n  window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)\n  canvas.loseContextInNCalls(500)\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    canvas.loseContextInNCalls(5000)\n  })\n  // End context loss simulation\n  */ canvas.addEventListener(\"webglcontextlost\", (event)=>{\n        console.log(\"Context Lost\", event);\n        event.preventDefault();\n        atlas.contextLost = true;\n    });\n    canvas.addEventListener(\"webglcontextrestored\", (event)=>{\n        console.log(\"Context Restored\", event);\n        atlas.contextLost = false;\n        // Regenerate all glyphs into the restored canvas:\n        const promises = [];\n        atlas.glyphsByFont.forEach((glyphMap)=>{\n            glyphMap.forEach((glyph)=>{\n                promises.push(generateGlyphSDF(glyph, atlas, true));\n            });\n        });\n        Promise.all(promises).then(()=>{\n            safariPre15Workaround(atlas);\n            atlas.sdfTexture.needsUpdate = true;\n        });\n    });\n}\n/**\n * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n * needed fonts and glyphs up front along with other assets.\n *\n * @param {object} options\n * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n *        be loaded.\n * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n *        to specify ligature sequences in addition to their individual characters to get all\n *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.\n * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n *        specified `characters`.\n * @param {function} callback - A function that will be called when the preloading is complete.\n */ function preloadFont({ font, characters, sdfGlyphSize }, callback) {\n    let text = Array.isArray(characters) ? characters.join(\"\\n\") : \"\" + characters;\n    getTextRenderInfo({\n        font,\n        sdfGlyphSize,\n        text\n    }, callback);\n}\n// Local assign impl so we don't have to import troika-core\nfunction assign(toObj, fromObj) {\n    for(let key in fromObj){\n        if (fromObj.hasOwnProperty(key)) {\n            toObj[key] = fromObj[key];\n        }\n    }\n    return toObj;\n}\n// Utility for making URLs absolute\nlet linkEl;\nfunction toAbsoluteURL(path) {\n    if (!linkEl) {\n        linkEl = typeof document === \"undefined\" ? {} : document.createElement(\"a\");\n    }\n    linkEl.href = path;\n    return linkEl.href;\n}\n/**\n * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround\n * where it reads the pixels out of that canvas and uploads them as a data texture instead, at\n * a slight performance cost.\n */ function safariPre15Workaround(atlas) {\n    // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers\n    // have supported it for a long while so any false positives should be minimal.\n    if (typeof createImageBitmap !== \"function\") {\n        console.info(\"Safari<15: applying SDF canvas workaround\");\n        const { sdfCanvas, sdfTexture } = atlas;\n        const { width, height } = sdfCanvas;\n        const gl = atlas.sdfCanvas.getContext(\"webgl\");\n        let pixels = sdfTexture.image.data;\n        if (!pixels || pixels.length !== width * height * 4) {\n            pixels = new Uint8Array(width * height * 4);\n            sdfTexture.image = {\n                width,\n                height,\n                data: pixels\n            };\n            sdfTexture.flipY = false;\n            sdfTexture.isDataTexture = true;\n        }\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    }\n}\nconst typesetterWorkerModule = /*#__PURE__*/ (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n    name: \"Typesetter\",\n    dependencies: [\n        CONFIG,\n        workerModule,\n        createTypesetter,\n        bidi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n    ],\n    init (config, fontParser, createTypesetter, bidiFactory) {\n        const { defaultFontURL } = config;\n        return createTypesetter(fontParser, bidiFactory(), {\n            defaultFontURL\n        });\n    }\n});\nconst typesetInWorker = /*#__PURE__*/ (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n    name: \"Typesetter\",\n    dependencies: [\n        typesetterWorkerModule\n    ],\n    init (typesetter) {\n        return function(args) {\n            return new Promise((resolve)=>{\n                typesetter.typeset(args, resolve);\n            });\n        };\n    },\n    getTransferables (result) {\n        // Mark array buffers as transferable to avoid cloning during postMessage\n        const transferables = [\n            result.glyphPositions.buffer,\n            result.glyphIds.buffer\n        ];\n        if (result.caretPositions) {\n            transferables.push(result.caretPositions.buffer);\n        }\n        if (result.glyphColors) {\n            transferables.push(result.glyphColors.buffer);\n        }\n        return transferables;\n    }\n});\nfunction dumpSDFTextures() {\n    Object.keys(atlases).forEach((size)=>{\n        const canvas = atlases[size].sdfCanvas;\n        const { width, height } = canvas;\n        console.log(\"%c.\", `\n      background: url(${canvas.toDataURL()});\n      background-size: ${width}px ${height}px;\n      color: transparent;\n      font-size: 0;\n      line-height: ${height}px;\n      padding-left: ${width}px;\n    `);\n    });\n}\nconst templateGeometries = {};\nfunction getTemplateGeometry(detail) {\n    let geom = templateGeometries[detail];\n    if (!geom) {\n        // Geometry is two planes back-to-back, which will always be rendered FrontSide only but\n        // appear as DoubleSide by default. FrontSide/BackSide are emulated using drawRange.\n        // We do it this way to avoid the performance hit of two draw calls for DoubleSide materials\n        // introduced by Three.js in r130 - see https://github.com/mrdoob/three.js/pull/21967\n        const front = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, detail, detail);\n        const back = front.clone();\n        const frontAttrs = front.attributes;\n        const backAttrs = back.attributes;\n        const combined = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const vertCount = frontAttrs.uv.count;\n        for(let i = 0; i < vertCount; i++){\n            backAttrs.position.array[i * 3] *= -1; // flip position x\n            backAttrs.normal.array[i * 3 + 2] *= -1; // flip normal z\n        }\n        [\n            \"position\",\n            \"normal\",\n            \"uv\"\n        ].forEach((name)=>{\n            combined.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute([\n                ...frontAttrs[name].array,\n                ...backAttrs[name].array\n            ], frontAttrs[name].itemSize));\n        });\n        combined.setIndex([\n            ...front.index.array,\n            ...back.index.array.map((n)=>n + vertCount)\n        ]);\n        combined.translate(0.5, 0.5, 0);\n        geom = templateGeometries[detail] = combined;\n    }\n    return geom;\n}\nconst glyphBoundsAttrName = \"aTroikaGlyphBounds\";\nconst glyphIndexAttrName = \"aTroikaGlyphIndex\";\nconst glyphColorAttrName = \"aTroikaGlyphColor\";\n/**\n@class GlyphsGeometry\n\nA specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\nrender the glyphs using GPU instancing of a single quad, rather than constructing a whole\ngeometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n  Where N = number of glyphs...\n\n  Instanced:\n  - position: 4 * 3\n  - index: 2 * 3\n  - normal: 4 * 3\n  - uv: 4 * 2\n  - glyph x/y bounds: N * 4\n  - glyph indices: N * 1\n  = 5N + 38\n\n  Non-instanced:\n  - position: N * 4 * 3\n  - index: N * 2 * 3\n  - normal: N * 4 * 3\n  - uv: N * 4 * 2\n  - glyph indices: N * 1\n  = 39N\n\nA downside of this is the rare-but-possible lack of the instanced arrays extension,\nwhich we could potentially work around with a fallback non-instanced implementation.\n\n*/ class GlyphsGeometry extends three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferGeometry {\n    constructor(){\n        super();\n        this.detail = 1;\n        this.curveRadius = 0;\n        // Define groups for rendering text outline as a separate pass; these will only\n        // be used when the `material` getter returns an array, i.e. outlineWidth > 0.\n        this.groups = [\n            {\n                start: 0,\n                count: Infinity,\n                materialIndex: 0\n            },\n            {\n                start: 0,\n                count: Infinity,\n                materialIndex: 1\n            }\n        ];\n        // Preallocate empty bounding objects\n        this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_3__.Sphere();\n        this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_3__.Box3();\n    }\n    computeBoundingSphere() {\n    // No-op; we'll sync the boundingSphere proactively when needed.\n    }\n    computeBoundingBox() {\n    // No-op; we'll sync the boundingBox proactively when needed.\n    }\n    // Since our base geometry contains triangles for both front and back sides, we can emulate\n    // the \"side\" by restricting the draw range.\n    setSide(side) {\n        const verts = this.getIndex().count;\n        this.setDrawRange(side === three__WEBPACK_IMPORTED_MODULE_3__.BackSide ? verts / 2 : 0, side === three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide ? verts : verts / 2);\n    }\n    set detail(detail) {\n        if (detail !== this._detail) {\n            this._detail = detail;\n            if (typeof detail !== \"number\" || detail < 1) {\n                detail = 1;\n            }\n            let tpl = getTemplateGeometry(detail);\n            [\n                \"position\",\n                \"normal\",\n                \"uv\"\n            ].forEach((attr)=>{\n                this.attributes[attr] = tpl.attributes[attr].clone();\n            });\n            this.setIndex(tpl.getIndex().clone());\n        }\n    }\n    get detail() {\n        return this._detail;\n    }\n    set curveRadius(r) {\n        if (r !== this._curveRadius) {\n            this._curveRadius = r;\n            this._updateBounds();\n        }\n    }\n    get curveRadius() {\n        return this._curveRadius;\n    }\n    /**\n   * Update the geometry for a new set of glyphs.\n   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n   *        the SDF atlas texture.\n   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n   *        used with `applyClipRect` to choose an optimized `instanceCount`.\n   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n   */ updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {\n        // Update the instance attributes\n        updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);\n        updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);\n        updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);\n        this._blockBounds = blockBounds;\n        this._chunkedBounds = chunkedBounds;\n        this.instanceCount = glyphAtlasIndices.length;\n        this._updateBounds();\n    }\n    _updateBounds() {\n        const bounds = this._blockBounds;\n        if (bounds) {\n            const { curveRadius, boundingBox: bbox } = this;\n            if (curveRadius) {\n                const { PI, floor, min, max, sin, cos } = Math;\n                const halfPi = PI / 2;\n                const twoPi = PI * 2;\n                const absR = Math.abs(curveRadius);\n                const leftAngle = bounds[0] / absR;\n                const rightAngle = bounds[2] / absR;\n                const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);\n                const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);\n                const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);\n                bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);\n                bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);\n            } else {\n                bbox.min.set(bounds[0], bounds[1], 0);\n                bbox.max.set(bounds[2], bounds[3], 0);\n            }\n            bbox.getBoundingSphere(this.boundingSphere);\n        }\n    }\n    /**\n   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n   * be clipped anyway.\n   *\n   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n   * but at the expense of much larger attribute buffers (see classdoc above.)\n   *\n   * @param {Vector4} clipRect\n   */ applyClipRect(clipRect) {\n        let count = this.getAttribute(glyphIndexAttrName).count;\n        let chunks = this._chunkedBounds;\n        if (chunks) {\n            for(let i = chunks.length; i--;){\n                count = chunks[i].end;\n                let rect = chunks[i].rect;\n                // note: both rects are l-b-r-t\n                if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n                    break;\n                }\n            }\n        }\n        this.instanceCount = count;\n    }\n}\nfunction updateBufferAttr(geom, attrName, newArray, itemSize) {\n    const attr = geom.getAttribute(attrName);\n    if (newArray) {\n        // If length isn't changing, just update the attribute's array data\n        if (attr && attr.array.length === newArray.length) {\n            attr.array.set(newArray);\n            attr.needsUpdate = true;\n        } else {\n            geom.setAttribute(attrName, new three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferAttribute(newArray, itemSize));\n            // If the new attribute has a different size, we also have to (as of r117) manually clear the\n            // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n            // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n            // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n            // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n            // implies it should be supported. It's possible we need to\n            delete geom._maxInstanceCount; //for r117+, could be fragile\n            geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like\n        }\n    } else if (attr) {\n        geom.deleteAttribute(attrName);\n    }\n}\n// language=GLSL\nconst VERTEX_DEFS = `\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n`;\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst VERTEX_TRANSFORM = `\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n${\"\" /* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the\n  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts\n  on some glyphs (those in the leftmost texture column) on some systems. The exact reason\n  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */ }\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n`;\n// language=GLSL\nconst FRAGMENT_DEFS = `\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  ${\"\" /* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those\n    are linearly interpolated where the encoding is exponential. Look into improving this by rounding\n    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.\n  */ }\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  ${\"\" /*\n    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based\n    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes \n    readability and edge crispness at all sizes and screen resolutions.\n  */ }\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  ${\"\" /* \n  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...\n  // This has potential but currently gives very jagged extensions, maybe due to precision issues?\n  float uvStep = 1.0 / uTroikaSDFGlyphSize;\n  vec2 neighbor1UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  vec2 neighbor2UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);\n  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);\n  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);\n  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);\n  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);\n  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;\n  */ }\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n`;\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst FRAGMENT_TRANSFORM = `\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n`;\n/**\n * Create a material for rendering text, derived from a baseMaterial\n */ function createTextDerivedMaterial(baseMaterial) {\n    const textMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(baseMaterial, {\n        chained: true,\n        extensions: {\n            derivatives: true\n        },\n        uniforms: {\n            uTroikaSDFTexture: {\n                value: null\n            },\n            uTroikaSDFTextureSize: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()\n            },\n            uTroikaSDFGlyphSize: {\n                value: 0\n            },\n            uTroikaSDFExponent: {\n                value: 0\n            },\n            uTroikaTotalBounds: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0, 0, 0, 0)\n            },\n            uTroikaClipRect: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0, 0, 0, 0)\n            },\n            uTroikaDistanceOffset: {\n                value: 0\n            },\n            uTroikaOutlineOpacity: {\n                value: 0\n            },\n            uTroikaFillOpacity: {\n                value: 1\n            },\n            uTroikaPositionOffset: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()\n            },\n            uTroikaCurveRadius: {\n                value: 0\n            },\n            uTroikaBlurRadius: {\n                value: 0\n            },\n            uTroikaStrokeWidth: {\n                value: 0\n            },\n            uTroikaStrokeColor: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Color()\n            },\n            uTroikaStrokeOpacity: {\n                value: 1\n            },\n            uTroikaOrient: {\n                value: new three__WEBPACK_IMPORTED_MODULE_3__.Matrix3()\n            },\n            uTroikaUseGlyphColors: {\n                value: true\n            },\n            uTroikaSDFDebug: {\n                value: false\n            }\n        },\n        vertexDefs: VERTEX_DEFS,\n        vertexTransform: VERTEX_TRANSFORM,\n        fragmentDefs: FRAGMENT_DEFS,\n        fragmentColorTransform: FRAGMENT_TRANSFORM,\n        customRewriter ({ vertexShader, fragmentShader }) {\n            let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n            if (uDiffuseRE.test(fragmentShader)) {\n                // Replace all instances of `diffuse` with our varying\n                fragmentShader = fragmentShader.replace(uDiffuseRE, \"varying vec3 vTroikaGlyphColor\").replace(/\\bdiffuse\\b/g, \"vTroikaGlyphColor\");\n                // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n                if (!uDiffuseRE.test(vertexShader)) {\n                    vertexShader = vertexShader.replace(troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.voidMainRegExp, \"uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n\");\n                }\n            }\n            return {\n                vertexShader,\n                fragmentShader\n            };\n        }\n    });\n    // Force transparency - TODO is this reasonable?\n    textMaterial.transparent = true;\n    Object.defineProperties(textMaterial, {\n        isTroikaTextMaterial: {\n            value: true\n        },\n        // WebGLShadowMap reverses the side of the shadow material by default, which fails\n        // for planes, so here we force the `shadowSide` to always match the main side.\n        shadowSide: {\n            get () {\n                return this.side;\n            },\n            set () {\n            //no-op\n            }\n        }\n    });\n    return textMaterial;\n}\nconst defaultMaterial = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n    color: 0xffffff,\n    side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide,\n    transparent: true\n});\nconst defaultStrokeColor = 0x808080;\nconst tempMat4 = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst tempVec3a = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempVec3b = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempArray = [];\nconst origin = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst defaultOrient = \"+x+y\";\nfunction first(o) {\n    return Array.isArray(o) ? o[0] : o;\n}\nlet getFlatRaycastMesh = ()=>{\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1), defaultMaterial);\n    getFlatRaycastMesh = ()=>mesh;\n    return mesh;\n};\nlet getCurvedRaycastMesh = ()=>{\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, 32, 1), defaultMaterial);\n    getCurvedRaycastMesh = ()=>mesh;\n    return mesh;\n};\nconst syncStartEvent = {\n    type: \"syncstart\"\n};\nconst syncCompleteEvent = {\n    type: \"synccomplete\"\n};\nconst SYNCABLE_PROPS = [\n    \"font\",\n    \"fontSize\",\n    \"letterSpacing\",\n    \"lineHeight\",\n    \"maxWidth\",\n    \"overflowWrap\",\n    \"text\",\n    \"direction\",\n    \"textAlign\",\n    \"textIndent\",\n    \"whiteSpace\",\n    \"anchorX\",\n    \"anchorY\",\n    \"colorRanges\",\n    \"sdfGlyphSize\"\n];\nconst COPYABLE_PROPS = SYNCABLE_PROPS.concat(\"material\", \"color\", \"depthOffset\", \"clipRect\", \"curveRadius\", \"orientation\", \"glyphGeometryDetail\");\n/**\n * @class Text\n *\n * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n * fields (SDF).\n */ class Text extends three__WEBPACK_IMPORTED_MODULE_3__.Mesh {\n    constructor(){\n        const geometry = new GlyphsGeometry();\n        super(geometry, null);\n        // === Text layout properties: === //\n        /**\n     * @member {string} text\n     * The string of text to be rendered.\n     */ this.text = \"\";\n        /**\n     * @member {number|string} anchorX\n     * Defines the horizontal position in the text block that should line up with the local origin.\n     * Can be specified as a numeric x position in local units, a string percentage of the total\n     * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',\n     * or 'right'.\n     */ this.anchorX = 0;\n        /**\n     * @member {number|string} anchorX\n     * Defines the vertical position in the text block that should line up with the local origin.\n     * Can be specified as a numeric y position in local units (note: down is negative y), a string\n     * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:\n     * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.\n     */ this.anchorY = 0;\n        /**\n     * @member {number} curveRadius\n     * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put\n     * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave\n     * curvature, while negative numbers put it behind the text for a convex curvature. The centerline\n     * will be aligned with the text's local origin; you can use `anchorX` to offset it.\n     *\n     * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane\n     * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.\n     */ this.curveRadius = 0;\n        /**\n     * @member {string} direction\n     * Sets the base direction for the text. The default value of \"auto\" will choose a direction based\n     * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.\n     */ this.direction = \"auto\";\n        /**\n     * @member {string} font\n     * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.\n     * Defaults to the Roboto font loaded from Google Fonts.\n     */ this.font = null; //will use default from TextBuilder\n        /**\n     * @member {number} fontSize\n     * The size at which to render the font in local units; corresponds to the em-box height\n     * of the chosen `font`.\n     */ this.fontSize = 0.1;\n        /**\n     * @member {number} letterSpacing\n     * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n     * numbers increase spacing and negative numbers decrease it.\n     */ this.letterSpacing = 0;\n        /**\n     * @member {number|string} lineHeight\n     * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n     * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n     */ this.lineHeight = \"normal\";\n        /**\n     * @member {number} maxWidth\n     * The maximum width of the text block, above which text may start wrapping according to the\n     * `whiteSpace` and `overflowWrap` properties.\n     */ this.maxWidth = Infinity;\n        /**\n     * @member {string} overflowWrap\n     * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n     * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n     * Defaults to `'normal'`.\n     */ this.overflowWrap = \"normal\";\n        /**\n     * @member {string} textAlign\n     * The horizontal alignment of each line of text within the overall text bounding box.\n     */ this.textAlign = \"left\";\n        /**\n     * @member {number} textIndent\n     * Indentation for the first character of a line; see CSS `text-indent`.\n     */ this.textIndent = 0;\n        /**\n     * @member {string} whiteSpace\n     * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n     * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n     * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n     * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n     */ this.whiteSpace = \"normal\";\n        // === Presentation properties: === //\n        /**\n     * @member {THREE.Material} material\n     * Defines a _base_ material to be used when rendering the text. This material will be\n     * automatically replaced with a material derived from it, that adds shader code to\n     * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n     * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n     * of the other mesh materials to gain other features like lighting, texture maps, etc.\n     *\n     * Also see the `color` shortcut property.\n     */ this.material = null;\n        /**\n     * @member {string|number|THREE.Color} color\n     * This is a shortcut for setting the `color` of the text's material. You can use this\n     * if you don't want to specify a whole custom `material`. Also, if you do use a custom\n     * `material`, this color will only be used for this particuar Text instance, even if\n     * that same material instance is shared across multiple Text objects.\n     */ this.color = null;\n        /**\n     * @member {object|null} colorRanges\n     * WARNING: This API is experimental and may change.\n     * This allows more fine-grained control of colors for individual or ranges of characters,\n     * taking precedence over the material's `color`. Its format is an Object whose keys each\n     * define a starting character index for a range, and whose values are the color for each\n     * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n     * any of the strings accepted by `THREE.Color`.\n     */ this.colorRanges = null;\n        /**\n     * @member {number|string} outlineWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means\n     * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.\n     */ this.outlineWidth = 0;\n        /**\n     * @member {string|number|THREE.Color} outlineColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to black.\n     */ this.outlineColor = 0x000000;\n        /**\n     * @member {number} outlineOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to `1`.\n     */ this.outlineOpacity = 1;\n        /**\n     * @member {number|string} outlineBlur\n     * WARNING: This API is experimental and may change.\n     * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is\n     * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */ this.outlineBlur = 0;\n        /**\n     * @member {number|string} outlineOffsetX\n     * WARNING: This API is experimental and may change.\n     * A horizontal offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */ this.outlineOffsetX = 0;\n        /**\n     * @member {number|string} outlineOffsetY\n     * WARNING: This API is experimental and may change.\n     * A vertical offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */ this.outlineOffsetY = 0;\n        /**\n     * @member {number|string} strokeWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */ this.strokeWidth = 0;\n        /**\n     * @member {string|number|THREE.Color} strokeColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.\n     */ this.strokeColor = defaultStrokeColor;\n        /**\n     * @member {number} strokeOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.\n     */ this.strokeOpacity = 1;\n        /**\n     * @member {number} fillOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows\n     * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the\n     * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.\n     */ this.fillOpacity = 1;\n        /**\n     * @member {number} depthOffset\n     * This is a shortcut for setting the material's `polygonOffset` and related properties,\n     * which can be useful in preventing z-fighting when this text is laid on top of another\n     * plane in the scene. Positive numbers are further from the camera, negatives closer.\n     */ this.depthOffset = 0;\n        /**\n     * @member {Array<number>} clipRect\n     * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n     * pixels will be discarded. This can be used for example to clip overflowing text when\n     * `whiteSpace='nowrap'`.\n     */ this.clipRect = null;\n        /**\n     * @member {string} orientation\n     * Defines the axis plane on which the text should be laid out when the mesh has no extra\n     * rotation transform. It is specified as a string with two axes: the horizontal axis with\n     * positive pointing right, and the vertical axis with positive pointing up. By default this\n     * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y\n     * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's\n     * top toward negative z and facing positive y.\n     */ this.orientation = defaultOrient;\n        /**\n     * @member {number} glyphGeometryDetail\n     * Controls number of vertical/horizontal segments that make up each glyph's rectangular\n     * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n     * vertex shader effects, for example.\n     */ this.glyphGeometryDetail = 1;\n        /**\n     * @member {number|null} sdfGlyphSize\n     * The size of each glyph's SDF (signed distance field) used for rendering. This must be a\n     * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n     * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n     * the sharpness of corners and preventing loss of very thin lines, at the expense of\n     * increased memory footprint and longer SDF generation time.\n     */ this.sdfGlyphSize = null;\n        /**\n     * @member {boolean} gpuAccelerateSDF\n     * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,\n     * making it much faster especially for complex glyphs, and falling back to a JavaScript version\n     * executed in web workers when support isn't available. It should automatically detect support,\n     * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS\n     * version if you encounter issues with it.\n     */ this.gpuAccelerateSDF = true;\n        this.debugSDF = false;\n    }\n    /**\n   * Updates the text rendering according to the current text-related configuration properties.\n   * This is an async process, so you can pass in a callback function to be executed when it\n   * finishes.\n   * @param {function} [callback]\n   */ sync(callback) {\n        if (this._needsSync) {\n            this._needsSync = false;\n            // If there's another sync still in progress, queue\n            if (this._isSyncing) {\n                (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n            } else {\n                this._isSyncing = true;\n                this.dispatchEvent(syncStartEvent);\n                getTextRenderInfo({\n                    text: this.text,\n                    font: this.font,\n                    fontSize: this.fontSize || 0.1,\n                    letterSpacing: this.letterSpacing || 0,\n                    lineHeight: this.lineHeight || \"normal\",\n                    maxWidth: this.maxWidth,\n                    direction: this.direction || \"auto\",\n                    textAlign: this.textAlign,\n                    textIndent: this.textIndent,\n                    whiteSpace: this.whiteSpace,\n                    overflowWrap: this.overflowWrap,\n                    anchorX: this.anchorX,\n                    anchorY: this.anchorY,\n                    colorRanges: this.colorRanges,\n                    includeCaretPositions: true,\n                    sdfGlyphSize: this.sdfGlyphSize,\n                    gpuAccelerateSDF: this.gpuAccelerateSDF\n                }, (textRenderInfo)=>{\n                    this._isSyncing = false;\n                    // Save result for later use in onBeforeRender\n                    this._textRenderInfo = textRenderInfo;\n                    // Update the geometry attributes\n                    this.geometry.updateGlyphs(textRenderInfo.glyphBounds, textRenderInfo.glyphAtlasIndices, textRenderInfo.blockBounds, textRenderInfo.chunkedBounds, textRenderInfo.glyphColors);\n                    // If we had extra sync requests queued up, kick it off\n                    const queued = this._queuedSyncs;\n                    if (queued) {\n                        this._queuedSyncs = null;\n                        this._needsSync = true;\n                        this.sync(()=>{\n                            queued.forEach((fn)=>fn && fn());\n                        });\n                    }\n                    this.dispatchEvent(syncCompleteEvent);\n                    if (callback) {\n                        callback();\n                    }\n                });\n            }\n        }\n    }\n    /**\n   * Initiate a sync if needed - note it won't complete until next frame at the\n   * earliest so if possible it's a good idea to call sync() manually as soon as\n   * all the properties have been set.\n   * @override\n   */ onBeforeRender(renderer, scene, camera, geometry, material, group) {\n        this.sync();\n        // This may not always be a text material, e.g. if there's a scene.overrideMaterial present\n        if (material.isTroikaTextMaterial) {\n            this._prepareForRender(material);\n        }\n        // We need to force the material to FrontSide to avoid the double-draw-call performance hit\n        // introduced in Three.js r130: https://github.com/mrdoob/three.js/pull/21967 - The sidedness\n        // is instead applied via drawRange in the GlyphsGeometry.\n        material._hadOwnSide = material.hasOwnProperty(\"side\");\n        this.geometry.setSide(material._actualSide = material.side);\n        material.side = three__WEBPACK_IMPORTED_MODULE_3__.FrontSide;\n    }\n    onAfterRender(renderer, scene, camera, geometry, material, group) {\n        // Restore original material side\n        if (material._hadOwnSide) {\n            material.side = material._actualSide;\n        } else {\n            delete material.side; // back to inheriting from base material\n        }\n    }\n    /**\n   * Shortcut to dispose the geometry specific to this instance.\n   * Note: we don't also dispose the derived material here because if anything else is\n   * sharing the same base material it will result in a pause next frame as the program\n   * is recompiled. Instead users can dispose the base material manually, like normal,\n   * and we'll also dispose the derived material at that time.\n   */ dispose() {\n        this.geometry.dispose();\n    }\n    /**\n   * @property {TroikaTextRenderInfo|null} textRenderInfo\n   * @readonly\n   * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n   * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n   * the asynchrous `sync()` process completes.\n   */ get textRenderInfo() {\n        return this._textRenderInfo || null;\n    }\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    get material() {\n        let derivedMaterial = this._derivedMaterial;\n        const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());\n        if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n            derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);\n            // dispose the derived material when its base material is disposed:\n            baseMaterial.addEventListener(\"dispose\", function onDispose() {\n                baseMaterial.removeEventListener(\"dispose\", onDispose);\n                derivedMaterial.dispose();\n            });\n        }\n        // If text outline is configured, render it as a preliminary draw using Three's multi-material\n        // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi\n        // materials ensures the layers are always rendered consecutively in a consistent order.\n        // Each layer will trigger onBeforeRender with the appropriate material.\n        if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {\n            let outlineMaterial = derivedMaterial._outlineMtl;\n            if (!outlineMaterial) {\n                outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {\n                    id: {\n                        value: derivedMaterial.id + 0.1\n                    }\n                });\n                outlineMaterial.isTextOutlineMaterial = true;\n                outlineMaterial.depthWrite = false;\n                outlineMaterial.map = null; //???\n                derivedMaterial.addEventListener(\"dispose\", function onDispose() {\n                    derivedMaterial.removeEventListener(\"dispose\", onDispose);\n                    outlineMaterial.dispose();\n                });\n            }\n            return [\n                outlineMaterial,\n                derivedMaterial\n            ];\n        } else {\n            return derivedMaterial;\n        }\n    }\n    set material(baseMaterial) {\n        if (baseMaterial && baseMaterial.isTroikaTextMaterial) {\n            this._derivedMaterial = baseMaterial;\n            this._baseMaterial = baseMaterial.baseMaterial;\n        } else {\n            this._baseMaterial = baseMaterial;\n        }\n    }\n    get glyphGeometryDetail() {\n        return this.geometry.detail;\n    }\n    set glyphGeometryDetail(detail) {\n        this.geometry.detail = detail;\n    }\n    get curveRadius() {\n        return this.geometry.curveRadius;\n    }\n    set curveRadius(r) {\n        this.geometry.curveRadius = r;\n    }\n    // Create and update material for shadows upon request:\n    get customDepthMaterial() {\n        return first(this.material).getDepthMaterial();\n    }\n    get customDistanceMaterial() {\n        return first(this.material).getDistanceMaterial();\n    }\n    _prepareForRender(material) {\n        const isOutline = material.isTextOutlineMaterial;\n        const uniforms = material.uniforms;\n        const textInfo = this.textRenderInfo;\n        if (textInfo) {\n            const { sdfTexture, blockBounds } = textInfo;\n            uniforms.uTroikaSDFTexture.value = sdfTexture;\n            uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n            uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n            uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;\n            uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);\n            uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;\n            let distanceOffset = 0;\n            let blurRadius = 0;\n            let strokeWidth = 0;\n            let fillOpacity;\n            let strokeOpacity;\n            let strokeColor;\n            let offsetX = 0;\n            let offsetY = 0;\n            if (isOutline) {\n                let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;\n                distanceOffset = this._parsePercent(outlineWidth) || 0;\n                blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);\n                fillOpacity = outlineOpacity;\n                offsetX = this._parsePercent(outlineOffsetX) || 0;\n                offsetY = this._parsePercent(outlineOffsetY) || 0;\n            } else {\n                strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);\n                if (strokeWidth) {\n                    strokeColor = this.strokeColor;\n                    uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);\n                    strokeOpacity = this.strokeOpacity;\n                    if (strokeOpacity == null) strokeOpacity = 1;\n                }\n                fillOpacity = this.fillOpacity;\n            }\n            uniforms.uTroikaDistanceOffset.value = distanceOffset;\n            uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);\n            uniforms.uTroikaBlurRadius.value = blurRadius;\n            uniforms.uTroikaStrokeWidth.value = strokeWidth;\n            uniforms.uTroikaStrokeOpacity.value = strokeOpacity;\n            uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;\n            uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;\n            let clipRect = this.clipRect;\n            if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {\n                uniforms.uTroikaClipRect.value.fromArray(clipRect);\n            } else {\n                // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines\n                const pad = (this.fontSize || 0.1) * 100;\n                uniforms.uTroikaClipRect.value.set(blockBounds[0] - pad, blockBounds[1] - pad, blockBounds[2] + pad, blockBounds[3] + pad);\n            }\n            this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n        }\n        uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n        material.polygonOffset = !!this.depthOffset;\n        material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n        // Shortcut for setting material color via `color` prop on the mesh; this is\n        // applied only to the derived material to avoid mutating a shared base material.\n        const color = isOutline ? this.outlineColor || 0 : this.color;\n        if (color == null) {\n            delete material.color; //inherit from base\n        } else {\n            const colorObj = material.hasOwnProperty(\"color\") ? material.color : material.color = new three__WEBPACK_IMPORTED_MODULE_3__.Color();\n            if (color !== colorObj._input || typeof color === \"object\") {\n                colorObj.set(colorObj._input = color);\n            }\n        }\n        // base orientation\n        let orient = this.orientation || defaultOrient;\n        if (orient !== material._orientation) {\n            let rotMat = uniforms.uTroikaOrient.value;\n            orient = orient.replace(/[^-+xyz]/g, \"\");\n            let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n            if (match) {\n                let [, hSign, hAxis, vSign, vAxis] = match;\n                tempVec3a.set(0, 0, 0)[hAxis] = hSign === \"-\" ? 1 : -1;\n                tempVec3b.set(0, 0, 0)[vAxis] = vSign === \"-\" ? -1 : 1;\n                tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n                rotMat.setFromMatrix4(tempMat4);\n            } else {\n                rotMat.identity();\n            }\n            material._orientation = orient;\n        }\n    }\n    _parsePercent(value) {\n        if (typeof value === \"string\") {\n            let match = value.match(/^(-?[\\d.]+)%$/);\n            let pct = match ? parseFloat(match[1]) : NaN;\n            value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;\n        }\n        return value;\n    }\n    /**\n   * Translate a point in local space to an x/y in the text plane.\n   */ localPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n        target.copy(position); //simple non-curved case is 1:1\n        const r = this.curveRadius;\n        if (r) {\n            target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);\n        }\n        return target;\n    }\n    /**\n   * Translate a point in world space to an x/y in the text plane.\n   */ worldPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n        tempVec3a.copy(position);\n        return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target);\n    }\n    /**\n   * @override Custom raycasting to test against the whole text block's max rectangular bounds\n   * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n   */ raycast(raycaster, intersects) {\n        const { textRenderInfo, curveRadius } = this;\n        if (textRenderInfo) {\n            const bounds = textRenderInfo.blockBounds;\n            const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();\n            const geom = raycastMesh.geometry;\n            const { position, uv } = geom.attributes;\n            for(let i = 0; i < uv.count; i++){\n                let x = bounds[0] + uv.getX(i) * (bounds[2] - bounds[0]);\n                const y = bounds[1] + uv.getY(i) * (bounds[3] - bounds[1]);\n                let z = 0;\n                if (curveRadius) {\n                    z = curveRadius - Math.cos(x / curveRadius) * curveRadius;\n                    x = Math.sin(x / curveRadius) * curveRadius;\n                }\n                position.setXYZ(i, x, y, z);\n            }\n            geom.boundingSphere = this.geometry.boundingSphere;\n            geom.boundingBox = this.geometry.boundingBox;\n            raycastMesh.matrixWorld = this.matrixWorld;\n            raycastMesh.material.side = this.material.side;\n            tempArray.length = 0;\n            raycastMesh.raycast(raycaster, tempArray);\n            for(let i = 0; i < tempArray.length; i++){\n                tempArray[i].object = this;\n                intersects.push(tempArray[i]);\n            }\n        }\n    }\n    copy(source) {\n        // Prevent copying the geometry reference so we don't end up sharing attributes between instances\n        const geom = this.geometry;\n        super.copy(source);\n        this.geometry = geom;\n        COPYABLE_PROPS.forEach((prop)=>{\n            this[prop] = source[prop];\n        });\n        return this;\n    }\n    clone() {\n        return new this.constructor().copy(this);\n    }\n}\n// Create setters for properties that affect text layout:\nSYNCABLE_PROPS.forEach((prop)=>{\n    const privateKey = \"_private_\" + prop;\n    Object.defineProperty(Text.prototype, prop, {\n        get () {\n            return this[privateKey];\n        },\n        set (value) {\n            if (value !== this[privateKey]) {\n                this[privateKey] = value;\n                this._needsSync = true;\n            }\n        }\n    });\n});\n//=== Utility functions for dealing with carets and selection ranges ===//\n/**\n * @typedef {object} TextCaret\n * @property {number} x - x position of the caret\n * @property {number} y - y position of the caret's bottom\n * @property {number} height - height of the caret\n * @property {number} charIndex - the index in the original input string of this caret's target\n *   character; the caret will be for the position _before_ that character.\n */ /**\n * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n * @param {number} x\n * @param {number} y\n * @return {TextCaret | null}\n */ function getCaretAtPoint(textRenderInfo, x, y) {\n    let closestCaret = null;\n    const { caretHeight } = textRenderInfo;\n    const caretsByRow = groupCaretsByRow(textRenderInfo);\n    // Find nearest row by y first\n    let closestRowY = Infinity;\n    caretsByRow.forEach((carets, rowY)=>{\n        if (Math.abs(y - (rowY + caretHeight / 2)) < Math.abs(y - (closestRowY + caretHeight / 2))) {\n            closestRowY = rowY;\n        }\n    });\n    // Then find closest caret by x within that row\n    caretsByRow.get(closestRowY).forEach((caret)=>{\n        if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n            closestCaret = caret;\n        }\n    });\n    return closestCaret;\n}\nconst _rectsCache = new WeakMap();\n/**\n * Given start and end character indexes, return a list of rectangles covering all the\n * characters within that selection.\n * @param {TroikaTextRenderInfo} textRenderInfo\n * @param {number} start - index of the first char in the selection\n * @param {number} end - index of the first char after the selection\n * @return {Array<{left, top, right, bottom}> | null}\n */ function getSelectionRects(textRenderInfo, start, end) {\n    let rects;\n    if (textRenderInfo) {\n        // Check cache - textRenderInfo is frozen so it's safe to cache based on it\n        let prevResult = _rectsCache.get(textRenderInfo);\n        if (prevResult && prevResult.start === start && prevResult.end === end) {\n            return prevResult.rects;\n        }\n        const { caretPositions, caretHeight } = textRenderInfo;\n        // Normalize\n        if (end < start) {\n            const s = start;\n            start = end;\n            end = s;\n        }\n        start = Math.max(start, 0);\n        end = Math.min(end, caretPositions.length + 1);\n        // Build list of rects, expanding the current rect for all characters in a run and starting\n        // a new rect whenever reaching a new line or a new bidi direction\n        rects = [];\n        let currentRect = null;\n        for(let i = start; i < end; i++){\n            const x1 = caretPositions[i * 3];\n            const x2 = caretPositions[i * 3 + 1];\n            const left = Math.min(x1, x2);\n            const right = Math.max(x1, x2);\n            const bottom = caretPositions[i * 3 + 2];\n            if (!currentRect || bottom !== currentRect.bottom || left > currentRect.right || right < currentRect.left) {\n                currentRect = {\n                    left: Infinity,\n                    right: -Infinity,\n                    bottom: bottom,\n                    top: bottom + caretHeight\n                };\n                rects.push(currentRect);\n            }\n            currentRect.left = Math.min(left, currentRect.left);\n            currentRect.right = Math.max(right, currentRect.right);\n        }\n        // Merge any overlapping rects, e.g. those formed by adjacent bidi runs\n        rects.sort((a, b)=>b.bottom - a.bottom || a.left - b.left);\n        for(let i = rects.length - 1; i-- > 0;){\n            const rectA = rects[i];\n            const rectB = rects[i + 1];\n            if (rectA.bottom === rectB.bottom && rectA.left <= rectB.right && rectA.right >= rectB.left) {\n                rectB.left = Math.min(rectB.left, rectA.left);\n                rectB.right = Math.max(rectB.right, rectA.right);\n                rects.splice(i, 1);\n            }\n        }\n        _rectsCache.set(textRenderInfo, {\n            start,\n            end,\n            rects\n        });\n    }\n    return rects;\n}\nconst _caretsByRowCache = new WeakMap();\nfunction groupCaretsByRow(textRenderInfo) {\n    // textRenderInfo is frozen so it's safe to cache based on it\n    let caretsByRow = _caretsByRowCache.get(textRenderInfo);\n    if (!caretsByRow) {\n        const { caretPositions, caretHeight } = textRenderInfo;\n        caretsByRow = new Map();\n        for(let i = 0; i < caretPositions.length; i += 3){\n            const rowY = caretPositions[i + 2];\n            let rowCarets = caretsByRow.get(rowY);\n            if (!rowCarets) {\n                caretsByRow.set(rowY, rowCarets = []);\n            }\n            rowCarets.push({\n                x: caretPositions[i],\n                y: rowY,\n                height: caretHeight,\n                charIndex: i / 3\n            });\n            // Add one more caret after the final char\n            if (i + 3 >= caretPositions.length) {\n                rowCarets.push({\n                    x: caretPositions[i + 1],\n                    y: rowY,\n                    height: caretHeight,\n                    charIndex: i / 3 + 1\n                });\n            }\n        }\n    }\n    _caretsByRowCache.set(textRenderInfo, caretsByRow);\n    return caretsByRow;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb1I7QUFDMU07QUFDckI7QUFDbkI7QUFDeUM7QUFFM0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlDQyxHQUNELFNBQVMwQixpQkFBaUJDLFVBQVUsRUFBRUMsSUFBSSxFQUFFQyxNQUFNO0lBRWhELE1BQU0sRUFDSkMsY0FBYyxFQUNmLEdBQUdEO0lBRUo7O0dBRUMsR0FDRCxNQUFNRSxRQUFRQyxPQUFPQyxNQUFNLENBQUM7SUFFNUIsTUFBTUMsTUFBTUM7SUFFWixnR0FBZ0c7SUFDaEcseURBQXlEO0lBQ3pELE1BQU1DLDBCQUEwQjtJQUVoQyx1R0FBdUc7SUFDdkcsTUFBTUMseUJBQXlCLENBQUMsYUFBYSxDQUFDO0lBRTlDLG1FQUFtRTtJQUNuRSxrSEFBa0g7SUFDbEgsTUFBTUMsb0JBQW9CLElBQUlDLE9BQU8sQ0FBQyxFQUFFRix1QkFBdUIsc0VBQXNFLENBQUM7SUFFdEk7O0dBRUMsR0FDRCxTQUFTRyxXQUFXQyxHQUFHLEVBQUVDLFFBQVE7UUFDL0IsU0FBU0M7WUFDUCxNQUFNQyxVQUFVQyxDQUFBQTtnQkFDZEMsUUFBUUMsS0FBSyxDQUFDLENBQUMscUJBQXFCLEVBQUVOLElBQUksRUFBRUEsUUFBUVgsaUJBQWlCLEtBQUssb0JBQW9CLENBQUMsRUFBRWU7Z0JBQ2pHLElBQUlKLFFBQVFYLGdCQUFnQjtvQkFDMUJXLE1BQU1YO29CQUNOYTtnQkFDRjtZQUNGO1lBQ0EsSUFBSTtnQkFDRixNQUFNSyxVQUFVLElBQUlDO2dCQUNwQkQsUUFBUUUsSUFBSSxDQUFDLE9BQU9ULEtBQUs7Z0JBQ3pCTyxRQUFRRyxZQUFZLEdBQUc7Z0JBQ3ZCSCxRQUFRSSxNQUFNLEdBQUc7b0JBQ2YsSUFBSUosUUFBUUssTUFBTSxJQUFJLEtBQUs7d0JBQ3pCVCxRQUFR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WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUU7WUFBRTtZQUFFO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUU7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFFO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFFO1lBQUk7WUFBRTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBRTtZQUFJO1lBQUk7WUFBRTtZQUFJO1lBQUk7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QztnQkFDYm1GLEdBQUcvQyxjQUFjLENBQUM0QyxFQUFFO2dCQUNwQitHLEdBQUc2d0I7Z0JBQ0hoM0IsUUFBUXhDO2dCQUNSVyxXQUFXaUIsSUFBSTtZQUNqQjtZQUNBLDBDQUEwQztZQUMxQyxJQUFJQSxJQUFJLEtBQUs1QyxlQUFleUQsTUFBTSxFQUFFO2dCQUNsQzgzQixVQUFVMzlCLElBQUksQ0FBQztvQkFDYm1GLEdBQUcvQyxjQUFjLENBQUM0QyxJQUFJLEVBQUU7b0JBQ3hCK0csR0FBRzZ3QjtvQkFDSGgzQixRQUFReEM7b0JBQ1JXLFdBQVdpQixJQUFJLElBQUk7Z0JBQ3JCO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EwNEIsa0JBQWtCcHlCLEdBQUcsQ0FBQzBzQixnQkFBZ0J3RTtJQUN0QyxPQUFPQTtBQUNUO0FBRTJLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JlYXRpdmUtNDA0Ly4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS10ZXh0L2Rpc3QvdHJvaWthLXRocmVlLXRleHQuZXNtLmpzP2QwZGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dHVyZSwgTGluZWFyRmlsdGVyLCBDb2xvciwgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksIFNwaGVyZSwgQm94MywgQmFja1NpZGUsIERvdWJsZVNpZGUsIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSwgUGxhbmVHZW9tZXRyeSwgQnVmZmVyR2VvbWV0cnksIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsIFZlY3RvcjIsIFZlY3RvcjQsIE1hdHJpeDMsIE1lc2gsIEZyb250U2lkZSwgTWVzaEJhc2ljTWF0ZXJpYWwsIE1hdHJpeDQsIFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyB0ZXJtaW5hdGVXb3JrZXIsIGRlZmluZVdvcmtlck1vZHVsZSB9IGZyb20gJ3Ryb2lrYS13b3JrZXItdXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVNERkdlbmVyYXRvciBmcm9tICd3ZWJnbC1zZGYtZ2VuZXJhdG9yJztcbmltcG9ydCBiaWRpRmFjdG9yeSBmcm9tICdiaWRpLWpzJztcbmltcG9ydCB7IGNyZWF0ZURlcml2ZWRNYXRlcmlhbCwgdm9pZE1haW5SZWdFeHAgfSBmcm9tICd0cm9pa2EtdGhyZWUtdXRpbHMnO1xuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc2VsZi1jb250YWluZWQgZW52aXJvbm1lbnQgZm9yIHByb2Nlc3NpbmcgdGV4dCB0eXBlc2V0dGluZyByZXF1ZXN0cy5cbiAqXG4gKiBJdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhcyBubyBjbG9zdXJlIGRlcGVuZGVuY2llcywgc28gdGhhdCBpdCBjYW4gYmUgZWFzaWx5IGluamVjdGVkXG4gKiBpbnRvIHRoZSBzb3VyY2UgZm9yIGEgV29ya2VyIHdpdGhvdXQgcmVxdWlyaW5nIGEgYnVpbGQgc3RlcCBvciBjb21wbGV4IGRlcGVuZGVuY3kgbG9hZGluZy4gQWxsIGl0c1xuICogZGVwZW5kZW5jaWVzIG11c3QgYmUgcGFzc2VkIGluIGF0IGluaXRpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZvbnRQYXJzZXIgLSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhbiBBcnJheUJ1ZmZlciBvZiB0aGUgZm9udCBkYXRhIGFuZCByZXR1cm5zXG4gKiBhIHN0YW5kYXJkaXplZCBzdHJ1Y3R1cmUgZ2l2aW5nIGFjY2VzcyB0byB0aGUgZm9udCBhbmQgaXRzIGdseXBoczpcbiAqICAge1xuICogICAgIHVuaXRzUGVyRW06IG51bWJlcixcbiAqICAgICBhc2NlbmRlcjogbnVtYmVyLFxuICogICAgIGRlc2NlbmRlcjogbnVtYmVyLFxuICogICAgIGNhcEhlaWdodDogbnVtYmVyLFxuICogICAgIHhIZWlnaHQ6IG51bWJlcixcbiAqICAgICBsaW5lR2FwOiBudW1iZXIsXG4gKiAgICAgZm9yRWFjaEdseXBoKHN0cmluZywgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAvL2ludm9rZXMgY2FsbGJhY2sgZm9yIGVhY2ggZ2x5cGggdG8gcmVuZGVyLCBwYXNzaW5nIGl0IGFuIG9iamVjdDpcbiAqICAgICAgIGNhbGxiYWNrKHtcbiAqICAgICAgICAgaW5kZXg6IG51bWJlcixcbiAqICAgICAgICAgYWR2YW5jZVdpZHRoOiBudW1iZXIsXG4gKiAgICAgICAgIHhNaW46IG51bWJlcixcbiAqICAgICAgICAgeU1pbjogbnVtYmVyLFxuICogICAgICAgICB4TWF4OiBudW1iZXIsXG4gKiAgICAgICAgIHlNYXg6IG51bWJlcixcbiAqICAgICAgICAgcGF0aDogc3RyaW5nLFxuICogICAgICAgICBwYXRoQ29tbWFuZENvdW50OiBudW1iZXJcbiAqICAgICAgIH0pXG4gKiAgICAgfVxuICogICB9XG4gKiBAcGFyYW0ge29iamVjdH0gYmlkaSAtIHRoZSBiaWRpLmpzIGltcGxlbWVudGF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVUeXBlc2V0dGVyKGZvbnRQYXJzZXIsIGJpZGksIGNvbmZpZykge1xuXG4gIGNvbnN0IHtcbiAgICBkZWZhdWx0Rm9udFVSTFxuICB9ID0gY29uZmlnO1xuXG4gIC8qKlxuICAgKiBIb2xkcyBwYXJzZWQgZm9udCBvYmplY3RzIGJ5IHVybFxuICAgKi9cbiAgY29uc3QgZm9udHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGNvbnN0IElORiA9IEluZmluaXR5O1xuXG4gIC8vIFNldCBvZiBVbmljb2RlIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgY2hhcmFjdGVycywgdGhlc2Ugd2lsbCBub3QgcHJvZHVjZSB2aXNpYmxlIGdseXBoc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3NcbiAgY29uc3QgREVGQVVMVF9JR05PUkFCTEVfQ0hBUlMgPSAvW1xcdTAwQURcXHUwMzRGXFx1MDYxQ1xcdTExNUYtXFx1MTE2MFxcdTE3QjQtXFx1MTdCNVxcdTE4MEItXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2RlxcdTMxNjRcXHVGRTAwLVxcdUZFMEZcXHVGRUZGXFx1RkZBMFxcdUZGRjAtXFx1RkZGOF0vO1xuXG4gIC8vIFRoaXMgcmVnZXggKGluc3RlYWQgb2YgL1xccy8pIGFsbG93cyB1cyB0byBzZWxlY3QgYWxsIHdoaXRlc3BhY2UgRVhDRVBUIGZvciBub24tYnJlYWtpbmcgd2hpdGUgc3BhY2VzXG4gIGNvbnN0IGxpbmVCcmVha2luZ1doaXRlU3BhY2UgPSBgW15cXFxcU1xcXFx1MDBBMF1gO1xuXG4gIC8vIEluY29tcGxldGUgc2V0IG9mIGNoYXJhY3RlcnMgdGhhdCBhbGxvdyBsaW5lIGJyZWFraW5nIGFmdGVyIHRoZW1cbiAgLy8gSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgY29uc2lkZXIgYSBmdWxsIFVuaWNvZGUgbGluZSBicmVha2luZyBhbGdvcml0aG0gaW1wbDogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjE0XG4gIGNvbnN0IEJSRUFLX0FGVEVSX0NIQVJTID0gbmV3IFJlZ0V4cChgJHtsaW5lQnJlYWtpbmdXaGl0ZVNwYWNlfXxbXFxcXC1cXFxcdTAwN0NcXFxcdTAwQURcXFxcdTIwMTBcXFxcdTIwMTItXFxcXHUyMDE0XFxcXHUyMDI3XFxcXHUyMDU2XFxcXHUyRTE3XFxcXHUyRTQwXWApO1xuXG4gIC8qKlxuICAgKiBMb2FkIGEgZ2l2ZW4gZm9udCB1cmxcbiAgICovXG4gIGZ1bmN0aW9uIGRvTG9hZEZvbnQodXJsLCBjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIHRyeUxvYWQoKSB7XG4gICAgICBjb25zdCBvbkVycm9yID0gZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbHVyZSBsb2FkaW5nIGZvbnQgJHt1cmx9JHt1cmwgPT09IGRlZmF1bHRGb250VVJMID8gJycgOiAnOyB0cnlpbmcgZmFsbGJhY2snfWAsIGVycik7XG4gICAgICAgIGlmICh1cmwgIT09IGRlZmF1bHRGb250VVJMKSB7XG4gICAgICAgICAgdXJsID0gZGVmYXVsdEZvbnRVUkw7XG4gICAgICAgICAgdHJ5TG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ2dldCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzID4gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgZm9udE9iaiA9IGZvbnRQYXJzZXIocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGZvbnRPYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeUxvYWQoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIExvYWQgYSBnaXZlbiBmb250IHVybCBpZiBuZWVkZWQsIGludm9raW5nIGEgY2FsbGJhY2sgd2hlbiBpdCdzIGxvYWRlZC4gSWYgYWxyZWFkeVxuICAgKiBsb2FkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICAgKi9cbiAgZnVuY3Rpb24gbG9hZEZvbnQoZm9udFVybCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWZvbnRVcmwpIGZvbnRVcmwgPSBkZWZhdWx0Rm9udFVSTDtcbiAgICBsZXQgZm9udCA9IGZvbnRzW2ZvbnRVcmxdO1xuICAgIGlmIChmb250KSB7XG4gICAgICAvLyBpZiBjdXJyZW50bHkgbG9hZGluZyBmb250LCBhZGQgdG8gY2FsbGJhY2tzLCBvdGhlcndpc2UgZXhlY3V0ZSBpbW1lZGlhdGVseVxuICAgICAgaWYgKGZvbnQucGVuZGluZykge1xuICAgICAgICBmb250LnBlbmRpbmcucHVzaChjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhmb250KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9udHNbZm9udFVybF0gPSB7cGVuZGluZzogW2NhbGxiYWNrXX07XG4gICAgICBkb0xvYWRGb250KGZvbnRVcmwsIGZvbnRPYmogPT4ge1xuICAgICAgICBsZXQgY2FsbGJhY2tzID0gZm9udHNbZm9udFVybF0ucGVuZGluZztcbiAgICAgICAgZm9udHNbZm9udFVybF0gPSBmb250T2JqO1xuICAgICAgICBjYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYihmb250T2JqKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBNYWluIGVudHJ5IHBvaW50LlxuICAgKiBQcm9jZXNzIGEgdGV4dCBzdHJpbmcgd2l0aCBnaXZlbiBmb250IGFuZCBmb3JtYXR0aW5nIHBhcmFtZXRlcnMsIGFuZCByZXR1cm4gYWxsIGluZm9cbiAgICogbmVjZXNzYXJ5IHRvIHJlbmRlciBhbGwgaXRzIGdseXBocy5cbiAgICovXG4gIGZ1bmN0aW9uIHR5cGVzZXQoXG4gICAge1xuICAgICAgdGV4dD0nJyxcbiAgICAgIGZvbnQ9ZGVmYXVsdEZvbnRVUkwsXG4gICAgICBzZGZHbHlwaFNpemU9NjQsXG4gICAgICBmb250U2l6ZT0xLFxuICAgICAgbGV0dGVyU3BhY2luZz0wLFxuICAgICAgbGluZUhlaWdodD0nbm9ybWFsJyxcbiAgICAgIG1heFdpZHRoPUlORixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRleHRBbGlnbj0nbGVmdCcsXG4gICAgICB0ZXh0SW5kZW50PTAsXG4gICAgICB3aGl0ZVNwYWNlPSdub3JtYWwnLFxuICAgICAgb3ZlcmZsb3dXcmFwPSdub3JtYWwnLFxuICAgICAgYW5jaG9yWCA9IDAsXG4gICAgICBhbmNob3JZID0gMCxcbiAgICAgIGluY2x1ZGVDYXJldFBvc2l0aW9ucz1mYWxzZSxcbiAgICAgIGNodW5rZWRCb3VuZHNTaXplPTgxOTIsXG4gICAgICBjb2xvclJhbmdlcz1udWxsXG4gICAgfSxcbiAgICBjYWxsYmFjayxcbiAgICBtZXRyaWNzT25seT1mYWxzZVxuICApIHtcbiAgICBjb25zdCBtYWluU3RhcnQgPSBub3coKTtcbiAgICBjb25zdCB0aW1pbmdzID0ge2ZvbnRMb2FkOiAwLCB0eXBlc2V0dGluZzogMH07XG5cbiAgICAvLyBFbnN1cmUgbmV3bGluZXMgYXJlIG5vcm1hbGl6ZWRcbiAgICBpZiAodGV4dC5pbmRleE9mKCdcXHInKSA+IC0xKSB7XG4gICAgICBjb25zb2xlLmluZm8oJ1R5cGVzZXR0ZXI6IGdvdCB0ZXh0IHdpdGggXFxcXHIgY2hhcnM7IG5vcm1hbGl6aW5nIHRvIFxcXFxuJyk7XG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJyk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHdlJ3ZlIGdvdCBudW1iZXJzIG5vdCBzdHJpbmdzXG4gICAgZm9udFNpemUgPSArZm9udFNpemU7XG4gICAgbGV0dGVyU3BhY2luZyA9ICtsZXR0ZXJTcGFjaW5nO1xuICAgIG1heFdpZHRoID0gK21heFdpZHRoO1xuICAgIGxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0IHx8ICdub3JtYWwnO1xuICAgIHRleHRJbmRlbnQgPSArdGV4dEluZGVudDtcblxuICAgIGxvYWRGb250KGZvbnQsIGZvbnRPYmogPT4ge1xuICAgICAgY29uc3QgaGFzTWF4V2lkdGggPSBpc0Zpbml0ZShtYXhXaWR0aCk7XG4gICAgICBsZXQgZ2x5cGhJZHMgPSBudWxsO1xuICAgICAgbGV0IGdseXBoUG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGxldCBnbHlwaERhdGEgPSBudWxsO1xuICAgICAgbGV0IGdseXBoQ29sb3JzID0gbnVsbDtcbiAgICAgIGxldCBjYXJldFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBsZXQgdmlzaWJsZUJvdW5kcyA9IG51bGw7XG4gICAgICBsZXQgY2h1bmtlZEJvdW5kcyA9IG51bGw7XG4gICAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICAgIGxldCByZW5kZXJhYmxlR2x5cGhDb3VudCA9IDA7XG4gICAgICBsZXQgY2FuV3JhcCA9IHdoaXRlU3BhY2UgIT09ICdub3dyYXAnO1xuICAgICAgY29uc3Qge2FzY2VuZGVyLCBkZXNjZW5kZXIsIHVuaXRzUGVyRW0sIGxpbmVHYXAsIGNhcEhlaWdodCwgeEhlaWdodH0gPSBmb250T2JqO1xuICAgICAgdGltaW5ncy5mb250TG9hZCA9IG5vdygpIC0gbWFpblN0YXJ0O1xuICAgICAgY29uc3QgdHlwZXNldFN0YXJ0ID0gbm93KCk7XG5cbiAgICAgIC8vIEZpbmQgY29udmVyc2lvbiBiZXR3ZWVuIG5hdGl2ZSBmb250IHVuaXRzIGFuZCBmb250U2l6ZSB1bml0czsgdGhpcyB3aWxsIGFscmVhZHkgYmUgZG9uZVxuICAgICAgLy8gZm9yIHRoZSBneC9neSB2YWx1ZXMgYmVsb3cgYnV0IGV2ZXJ5dGhpbmcgZWxzZSB3ZSdsbCBuZWVkIHRvIGNvbnZlcnRcbiAgICAgIGNvbnN0IGZvbnRTaXplTXVsdCA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGFwcHJvcHJpYXRlIHZhbHVlIGZvciAnbm9ybWFsJyBsaW5lIGhlaWdodCBiYXNlZCBvbiB0aGUgZm9udCdzIGFjdHVhbCBtZXRyaWNzXG4gICAgICAvLyBUT0RPIHRoaXMgZG9lcyBub3QgZ3VhcmFudGVlIGluZGl2aWR1YWwgZ2x5cGhzIHdvbid0IGV4Y2VlZCB0aGUgbGluZSBoZWlnaHQsIGUuZy4gUm9ib3RvOyBzaG91bGQgd2UgdXNlIHlNaW4vTWF4IGluc3RlYWQ/XG4gICAgICBpZiAobGluZUhlaWdodCA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgbGluZUhlaWdodCA9IChhc2NlbmRlciAtIGRlc2NlbmRlciArIGxpbmVHYXApIC8gdW5pdHNQZXJFbTtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGxpbmUgaGVpZ2h0IGFuZCBsZWFkaW5nIGFkanVzdG1lbnRzXG4gICAgICBsaW5lSGVpZ2h0ID0gbGluZUhlaWdodCAqIGZvbnRTaXplO1xuICAgICAgY29uc3QgaGFsZkxlYWRpbmcgPSAobGluZUhlaWdodCAtIChhc2NlbmRlciAtIGRlc2NlbmRlcikgKiBmb250U2l6ZU11bHQpIC8gMjtcbiAgICAgIGNvbnN0IHRvcEJhc2VsaW5lID0gLShhc2NlbmRlciAqIGZvbnRTaXplTXVsdCArIGhhbGZMZWFkaW5nKTtcbiAgICAgIGNvbnN0IGNhcmV0SGVpZ2h0ID0gTWF0aC5taW4obGluZUhlaWdodCwgKGFzY2VuZGVyIC0gZGVzY2VuZGVyKSAqIGZvbnRTaXplTXVsdCk7XG4gICAgICBjb25zdCBjYXJldEJvdHRvbU9mZnNldCA9IChhc2NlbmRlciArIGRlc2NlbmRlcikgLyAyICogZm9udFNpemVNdWx0IC0gY2FyZXRIZWlnaHQgLyAyO1xuXG4gICAgICAvLyBEaXN0cmlidXRlIGdseXBocyBpbnRvIGxpbmVzIGJhc2VkIG9uIHdyYXBwaW5nXG4gICAgICBsZXQgbGluZVhPZmZzZXQgPSB0ZXh0SW5kZW50O1xuICAgICAgbGV0IGN1cnJlbnRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICBjb25zdCBsaW5lcyA9IFtjdXJyZW50TGluZV07XG5cbiAgICAgIGZvbnRPYmouZm9yRWFjaEdseXBoKHRleHQsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nLCAoZ2x5cGhPYmosIGdseXBoWCwgY2hhckluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0LmNoYXJBdChjaGFySW5kZXgpO1xuICAgICAgICBjb25zdCBnbHlwaFdpZHRoID0gZ2x5cGhPYmouYWR2YW5jZVdpZHRoICogZm9udFNpemVNdWx0O1xuICAgICAgICBjb25zdCBjdXJMaW5lQ291bnQgPSBjdXJyZW50TGluZS5jb3VudDtcbiAgICAgICAgbGV0IG5leHRMaW5lO1xuXG4gICAgICAgIC8vIENhbGMgaXNXaGl0ZXNwYWNlIGFuZCBpc0VtcHR5IG9uY2UgcGVyIGdseXBoT2JqXG4gICAgICAgIGlmICghKCdpc0VtcHR5JyBpbiBnbHlwaE9iaikpIHtcbiAgICAgICAgICBnbHlwaE9iai5pc1doaXRlc3BhY2UgPSAhIWNoYXIgJiYgbmV3IFJlZ0V4cChsaW5lQnJlYWtpbmdXaGl0ZVNwYWNlKS50ZXN0KGNoYXIpO1xuICAgICAgICAgIGdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIgPSAhIWNoYXIgJiYgQlJFQUtfQUZURVJfQ0hBUlMudGVzdChjaGFyKTtcbiAgICAgICAgICBnbHlwaE9iai5pc0VtcHR5ID0gZ2x5cGhPYmoueE1pbiA9PT0gZ2x5cGhPYmoueE1heCB8fCBnbHlwaE9iai55TWluID09PSBnbHlwaE9iai55TWF4IHx8IERFRkFVTFRfSUdOT1JBQkxFX0NIQVJTLnRlc3QoY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgIWdseXBoT2JqLmlzRW1wdHkpIHtcbiAgICAgICAgICByZW5kZXJhYmxlR2x5cGhDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIgb3ZlcmZsb3dzIHRoZSBtYXggd2lkdGgsIHdlIG5lZWQgdG8gc29mdC13cmFwXG4gICAgICAgIGlmIChjYW5XcmFwICYmIGhhc01heFdpZHRoICYmICFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgZ2x5cGhYICsgZ2x5cGhXaWR0aCArIGxpbmVYT2Zmc2V0ID4gbWF4V2lkdGggJiYgY3VyTGluZUNvdW50KSB7XG4gICAgICAgICAgLy8gSWYgaXQncyB0aGUgZmlyc3QgY2hhciBhZnRlciBhIHdoaXRlc3BhY2UsIHN0YXJ0IGEgbmV3IGxpbmVcbiAgICAgICAgICBpZiAoY3VycmVudExpbmUuZ2x5cGhBdChjdXJMaW5lQ291bnQgLSAxKS5nbHlwaE9iai5jYW5CcmVha0FmdGVyKSB7XG4gICAgICAgICAgICBuZXh0TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtZ2x5cGhYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBCYWNrIHVwIGxvb2tpbmcgZm9yIGEgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgdG8gd3JhcCBhdFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGN1ckxpbmVDb3VudDsgaS0tOykge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBnb3QgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHRoZXJlJ3Mgbm8gc29mdCBicmVhayBwb2ludDsgbWFrZSBoYXJkIGJyZWFrIGlmIG92ZXJmbG93V3JhcD0nYnJlYWstd29yZCdcbiAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgb3ZlcmZsb3dXcmFwID09PSAnYnJlYWstd29yZCcpIHtcbiAgICAgICAgICAgICAgICBuZXh0TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gLWdseXBoWDtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEZvdW5kIGEgc29mdCBicmVhayBwb2ludDsgbW92ZSBhbGwgY2hhcnMgc2luY2UgaXQgdG8gYSBuZXcgbGluZVxuICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50TGluZS5nbHlwaEF0KGkpLmdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBuZXh0TGluZSA9IGN1cnJlbnRMaW5lLnNwbGl0QXQoaSArIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdFggPSBuZXh0TGluZS5nbHlwaEF0KDApLng7XG4gICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgLT0gYWRqdXN0WDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gbmV4dExpbmUuY291bnQ7IGotLTspIHtcbiAgICAgICAgICAgICAgICAgIG5leHRMaW5lLmdseXBoQXQoaikueCAtPSBhZGp1c3RYO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0TGluZSkge1xuICAgICAgICAgICAgY3VycmVudExpbmUuaXNTb2Z0V3JhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IG5leHRMaW5lO1xuICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBtYXhXaWR0aDsgLy9hZnRlciBzb2Z0IHdyYXBwaW5nIHVzZSBtYXhXaWR0aCBhcyBjYWxjdWxhdGVkIHdpZHRoXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZseSA9IGN1cnJlbnRMaW5lLmdseXBoQXQoY3VycmVudExpbmUuY291bnQpO1xuICAgICAgICBmbHkuZ2x5cGhPYmogPSBnbHlwaE9iajtcbiAgICAgICAgZmx5LnggPSBnbHlwaFggKyBsaW5lWE9mZnNldDtcbiAgICAgICAgZmx5LndpZHRoID0gZ2x5cGhXaWR0aDtcbiAgICAgICAgZmx5LmNoYXJJbmRleCA9IGNoYXJJbmRleDtcblxuICAgICAgICAvLyBIYW5kbGUgaGFyZCBsaW5lIGJyZWFrc1xuICAgICAgICBpZiAoY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBjdXJyZW50TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gLShnbHlwaFggKyBnbHlwaFdpZHRoICsgKGxldHRlclNwYWNpbmcgKiBmb250U2l6ZSkpICsgdGV4dEluZGVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBvZiBlYWNoIGxpbmUgKGV4Y2x1ZGluZyB0cmFpbGluZyB3aGl0ZXNwYWNlKSBhbmQgbWF4aW11bSBibG9jayB3aWR0aFxuICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxpbmUuY291bnQ7IGktLTspIHtcbiAgICAgICAgICBsZXQge2dseXBoT2JqLCB4LCB3aWR0aH0gPSBsaW5lLmdseXBoQXQoaSk7XG4gICAgICAgICAgaWYgKCFnbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIGxpbmUud2lkdGggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICBpZiAobGluZS53aWR0aCA+IG1heExpbmVXaWR0aCkge1xuICAgICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBsaW5lLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gRmluZCBvdmVyYWxsIHBvc2l0aW9uIGFkanVzdG1lbnRzIGZvciBhbmNob3JpbmdcbiAgICAgIGxldCBhbmNob3JYT2Zmc2V0ID0gMDtcbiAgICAgIGxldCBhbmNob3JZT2Zmc2V0ID0gMDtcbiAgICAgIGlmIChhbmNob3JYKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yWCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhbmNob3JYT2Zmc2V0ID0gLWFuY2hvclg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFuY2hvclggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYW5jaG9yWE9mZnNldCA9IC1tYXhMaW5lV2lkdGggKiAoXG4gICAgICAgICAgICBhbmNob3JYID09PSAnbGVmdCcgPyAwIDpcbiAgICAgICAgICAgIGFuY2hvclggPT09ICdjZW50ZXInID8gMC41IDpcbiAgICAgICAgICAgIGFuY2hvclggPT09ICdyaWdodCcgPyAxIDpcbiAgICAgICAgICAgIHBhcnNlUGVyY2VudChhbmNob3JYKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbmNob3JZKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yWSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0ID0gLWFuY2hvclk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFuY2hvclkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbGV0IGhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgYW5jaG9yWU9mZnNldCA9IGFuY2hvclkgPT09ICd0b3AnID8gMCA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWJhc2VsaW5lJyA/IC10b3BCYXNlbGluZSA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWNhcCcgPyAtdG9wQmFzZWxpbmUgLSBjYXBIZWlnaHQgKiBmb250U2l6ZU11bHQgOlxuICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1leCcgPyAtdG9wQmFzZWxpbmUgLSB4SGVpZ2h0ICogZm9udFNpemVNdWx0IDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdtaWRkbGUnID8gaGVpZ2h0IC8gMiA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAnYm90dG9tJyA/IGhlaWdodCA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAnYm90dG9tLWJhc2VsaW5lJyA/IGhlaWdodCAtIGhhbGZMZWFkaW5nICsgZGVzY2VuZGVyICogZm9udFNpemVNdWx0IDpcbiAgICAgICAgICAgIHBhcnNlUGVyY2VudChhbmNob3JZKSAqIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW1ldHJpY3NPbmx5KSB7XG4gICAgICAgIC8vIFJlc29sdmUgYmlkaSBsZXZlbHNcbiAgICAgICAgY29uc3QgYmlkaUxldmVsc1Jlc3VsdCA9IGJpZGkuZ2V0RW1iZWRkaW5nTGV2ZWxzKHRleHQsIGRpcmVjdGlvbik7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGxpbmUsIGFwcGx5aW5nIGFsaWdubWVudCBvZmZzZXRzLCBhZGRpbmcgZWFjaCBnbHlwaCB0byB0aGUgYXRsYXMsIGFuZFxuICAgICAgICAvLyBjb2xsZWN0aW5nIGFsbCByZW5kZXJhYmxlIGdseXBocyBpbnRvIGEgc2luZ2xlIGNvbGxlY3Rpb24uXG4gICAgICAgIGdseXBoSWRzID0gbmV3IFVpbnQxNkFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50KTtcbiAgICAgICAgZ2x5cGhQb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50ICogMik7XG4gICAgICAgIGdseXBoRGF0YSA9IHt9O1xuICAgICAgICB2aXNpYmxlQm91bmRzID0gW0lORiwgSU5GLCAtSU5GLCAtSU5GXTtcbiAgICAgICAgY2h1bmtlZEJvdW5kcyA9IFtdO1xuICAgICAgICBsZXQgbGluZVlPZmZzZXQgPSB0b3BCYXNlbGluZTtcbiAgICAgICAgaWYgKGluY2x1ZGVDYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgIGNhcmV0UG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSh0ZXh0Lmxlbmd0aCAqIDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgIGdseXBoQ29sb3JzID0gbmV3IFVpbnQ4QXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQgKiAzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVuZGVyYWJsZUdseXBoSW5kZXggPSAwO1xuICAgICAgICBsZXQgcHJldkNoYXJJbmRleCA9IC0xO1xuICAgICAgICBsZXQgY29sb3JDaGFySW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICBsZXQgY3VycmVudENvbG9yO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lLCBsaW5lSW5kZXgpID0+IHtcbiAgICAgICAgICBsZXQge2NvdW50OmxpbmVHbHlwaENvdW50LCB3aWR0aDpsaW5lV2lkdGh9ID0gbGluZTtcblxuICAgICAgICAgIC8vIElnbm9yZSBlbXB0eSBsaW5lc1xuICAgICAgICAgIGlmIChsaW5lR2x5cGhDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIENvdW50IHRyYWlsaW5nIHdoaXRlc3BhY2VzLCB3ZSB3YW50IHRvIGlnbm9yZSB0aGVzZSBmb3IgY2VydGFpbiB0aGluZ3NcbiAgICAgICAgICAgIGxldCB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGluZUdseXBoQ291bnQ7IGktLSAmJiBsaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouaXNXaGl0ZXNwYWNlOykge1xuICAgICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBob3Jpem9udGFsIGFsaWdubWVudCBhZGp1c3RtZW50c1xuICAgICAgICAgICAgbGV0IGxpbmVYT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxldCBqdXN0aWZ5QWRqdXN0ID0gMDtcbiAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aCkgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnknICYmIGxpbmUuaXNTb2Z0V3JhcHBlZCkge1xuICAgICAgICAgICAgICAvLyBjb3VudCBub24tdHJhaWxpbmcgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLCBhbmQgd2UnbGwgYWRqdXN0IHRoZSBvZmZzZXRzIHBlciBjaGFyYWN0ZXIgaW4gdGhlIG5leHQgbG9vcFxuICAgICAgICAgICAgICBsZXQgd2hpdGVzcGFjZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQ7IGktLTspIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5nbHlwaEF0KGkpLmdseXBoT2JqLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGp1c3RpZnlBZGp1c3QgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoKSAvIHdoaXRlc3BhY2VDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqdXN0aWZ5QWRqdXN0IHx8IGxpbmVYT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGxldCBqdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdseXBoSW5mbyA9IGxpbmUuZ2x5cGhBdChpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaE9iaiA9IGdseXBoSW5mby5nbHlwaE9iajtcbiAgICAgICAgICAgICAgICBnbHlwaEluZm8ueCArPSBsaW5lWE9mZnNldCArIGp1c3RpZnlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIG5vbi10cmFpbGluZyB3aGl0ZXNwYWNlcyBmb3IganVzdGlmeSBhbGlnbm1lbnRcbiAgICAgICAgICAgICAgICBpZiAoanVzdGlmeUFkanVzdCAhPT0gMCAmJiBnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgaSA8IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgIGp1c3RpZnlPZmZzZXQgKz0ganVzdGlmeUFkanVzdDtcbiAgICAgICAgICAgICAgICAgIGdseXBoSW5mby53aWR0aCArPSBqdXN0aWZ5QWRqdXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGJpZGkgcmFuZ2UgZmxpcHBpbmdcbiAgICAgICAgICAgIGNvbnN0IGZsaXBzID0gYmlkaS5nZXRSZW9yZGVyU2VnbWVudHMoXG4gICAgICAgICAgICAgIHRleHQsIGJpZGlMZXZlbHNSZXN1bHQsIGxpbmUuZ2x5cGhBdCgwKS5jaGFySW5kZXgsIGxpbmUuZ2x5cGhBdChsaW5lLmNvdW50IC0gMSkuY2hhckluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9yIChsZXQgZmkgPSAwOyBmaSA8IGZsaXBzLmxlbmd0aDsgZmkrKykge1xuICAgICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBmbGlwc1tmaV07XG4gICAgICAgICAgICAgIC8vIE1hcCBzdGFydC9lbmQgc3RyaW5nIGluZGljZXMgdG8gaW5kaWNlcyBpbiB0aGUgbGluZVxuICAgICAgICAgICAgICBsZXQgbGVmdCA9IEluZmluaXR5LCByaWdodCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuZ2x5cGhBdChpKS5jaGFySW5kZXggPj0gc3RhcnQpIHsgLy8gZ3RlIHRvIGhhbmRsZSByZW1vdmVkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgIGxldCBzdGFydEluTGluZSA9IGksIGVuZEluTGluZSA9IGk7XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgZW5kSW5MaW5lIDwgbGluZUdseXBoQ291bnQ7IGVuZEluTGluZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvID0gbGluZS5nbHlwaEF0KGVuZEluTGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmNoYXJJbmRleCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluTGluZSA8IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQpIHsgLy9kb24ndCBpbmNsdWRlIHRyYWlsaW5nIHdzIGluIGZsaXAgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgaW5mby54KTtcbiAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBpbmZvLnggKyBpbmZvLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0SW5MaW5lOyBqIDwgZW5kSW5MaW5lOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGopO1xuICAgICAgICAgICAgICAgICAgICBnbHlwaEluZm8ueCA9IHJpZ2h0IC0gKGdseXBoSW5mby54ICsgZ2x5cGhJbmZvLndpZHRoIC0gbGVmdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBc3NlbWJsZSBmaW5hbCBkYXRhIGFycmF5c1xuICAgICAgICAgICAgbGV0IGdseXBoT2JqO1xuICAgICAgICAgICAgY29uc3Qgc2V0R2x5cGhPYmogPSBnID0+IGdseXBoT2JqID0gZztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUdseXBoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgICBnbHlwaE9iaiA9IGdseXBoSW5mby5nbHlwaE9iajtcbiAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJZCA9IGdseXBoT2JqLmluZGV4O1xuXG4gICAgICAgICAgICAgIC8vIFJlcGxhY2UgbWlycm9yZWQgY2hhcmFjdGVycyBpbiBydGxcbiAgICAgICAgICAgICAgY29uc3QgcnRsID0gYmlkaUxldmVsc1Jlc3VsdC5sZXZlbHNbZ2x5cGhJbmZvLmNoYXJJbmRleF0gJiAxOyAvL29kZCBsZXZlbCBtZWFucyBydGxcbiAgICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pcnJvcmVkID0gYmlkaS5nZXRNaXJyb3JlZENoYXJhY3Rlcih0ZXh0W2dseXBoSW5mby5jaGFySW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAobWlycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgIGZvbnRPYmouZm9yRWFjaEdseXBoKG1pcnJvcmVkLCAwLCAwLCBzZXRHbHlwaE9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQWRkIGNhcmV0IHBvc2l0aW9uc1xuICAgICAgICAgICAgICBpZiAoaW5jbHVkZUNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qge2NoYXJJbmRleH0gPSBnbHlwaEluZm87XG4gICAgICAgICAgICAgICAgY29uc3QgY2FyZXRMZWZ0ID0gZ2x5cGhJbmZvLnggKyBhbmNob3JYT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhcmV0UmlnaHQgPSBnbHlwaEluZm8ueCArIGdseXBoSW5mby53aWR0aCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogM10gPSBydGwgPyBjYXJldFJpZ2h0IDogY2FyZXRMZWZ0OyAvL3N0YXJ0IGVkZ2UgeFxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zW2NoYXJJbmRleCAqIDMgKyAxXSA9IHJ0bCA/IGNhcmV0TGVmdCA6IGNhcmV0UmlnaHQ7IC8vZW5kIGVkZ2UgeFxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zW2NoYXJJbmRleCAqIDMgKyAyXSA9IGxpbmVZT2Zmc2V0ICsgY2FyZXRCb3R0b21PZmZzZXQgKyBhbmNob3JZT2Zmc2V0OyAvL2NvbW1vbiBib3R0b20geVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2tpcHBlZCBhbnkgY2hhcnMgZnJvbSB0aGUgcHJldmlvdXMgZ2x5cGggKGR1ZSB0byBsaWdhdHVyZSBzdWJzKSwgZmlsbCBpbiBjYXJldFxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9ucyBmb3IgdGhvc2UgbWlzc2luZyBjaGFyIGluZGljZXM7IGN1cnJlbnRseSB0aGlzIHVzZXMgYSBiZXN0LWd1ZXNzIGJ5IGRpdmlkaW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxpZ2F0dXJlJ3Mgd2lkdGggZXZlbmx5LiBJbiB0aGUgZnV0dXJlIHdlIG1heSB0cnkgdG8gdXNlIHRoZSBmb250J3MgTGlnYXR1cmVDYXJldExpc3RcbiAgICAgICAgICAgICAgICAvLyB0YWJsZSB0byBnZXQgYmV0dGVyIGludGVyaW9yIGNhcmV0IHBvc2l0aW9ucy5cbiAgICAgICAgICAgICAgICBjb25zdCBsaWdDb3VudCA9IGNoYXJJbmRleCAtIHByZXZDaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGxpZ0NvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIHByZXZDaGFySW5kZXgsIGxpZ0NvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldkNoYXJJbmRleCA9IGNoYXJJbmRleDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFRyYWNrIGN1cnJlbnQgY29sb3IgcmFuZ2VcbiAgICAgICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qge2NoYXJJbmRleH0gPSBnbHlwaEluZm87XG4gICAgICAgICAgICAgICAgd2hpbGUoY2hhckluZGV4ID4gY29sb3JDaGFySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbG9yQ2hhckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMuaGFzT3duUHJvcGVydHkoY29sb3JDaGFySW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xvciA9IGNvbG9yUmFuZ2VzW2NvbG9yQ2hhckluZGV4XTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBHZXQgYXRsYXMgZGF0YSBmb3IgcmVuZGVyYWJsZSBnbHlwaHNcbiAgICAgICAgICAgICAgaWYgKCFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgIWdseXBoT2JqLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSByZW5kZXJhYmxlR2x5cGhJbmRleCsrO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgZ2x5cGgncyBwYXRoIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAoIWdseXBoRGF0YVtnbHlwaElkXSkge1xuICAgICAgICAgICAgICAgICAgZ2x5cGhEYXRhW2dseXBoSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBnbHlwaE9iai5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXRoQm91bmRzOiBbZ2x5cGhPYmoueE1pbiwgZ2x5cGhPYmoueU1pbiwgZ2x5cGhPYmoueE1heCwgZ2x5cGhPYmoueU1heF1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIGdseXBoIHBvc2l0aW9uIGFuZCBhZGQgdG8gZ2x5cGhQb3NpdGlvbnMgYXJyYXlcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaFggPSBnbHlwaEluZm8ueCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhZID0gbGluZVlPZmZzZXQgKyBhbmNob3JZT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGdseXBoUG9zaXRpb25zW2lkeCAqIDJdID0gZ2x5cGhYO1xuICAgICAgICAgICAgICAgIGdseXBoUG9zaXRpb25zW2lkeCAqIDIgKyAxXSA9IGdseXBoWTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIHRvdGFsIHZpc2libGUgYm91bmRzXG4gICAgICAgICAgICAgICAgY29uc3QgdmlzWDAgPSBnbHlwaFggKyBnbHlwaE9iai54TWluICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc1kwID0gZ2x5cGhZICsgZ2x5cGhPYmoueU1pbiAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNYMSA9IGdseXBoWCArIGdseXBoT2JqLnhNYXggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzWTEgPSBnbHlwaFkgKyBnbHlwaE9iai55TWF4ICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgIGlmICh2aXNYMCA8IHZpc2libGVCb3VuZHNbMF0pIHZpc2libGVCb3VuZHNbMF0gPSB2aXNYMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWTAgPCB2aXNpYmxlQm91bmRzWzFdKSB2aXNpYmxlQm91bmRzWzFdID0gdmlzWTA7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1gxID4gdmlzaWJsZUJvdW5kc1syXSkgdmlzaWJsZUJvdW5kc1syXSA9IHZpc1gxO1xuICAgICAgICAgICAgICAgIGlmICh2aXNZMSA+IHZpc2libGVCb3VuZHNbM10pIHZpc2libGVCb3VuZHNbM10gPSB2aXNZMTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIGJvdW5kaW5nIHJlY3RzIGZvciBlYWNoIGNodW5rIG9mIE4gZ2x5cGhzXG4gICAgICAgICAgICAgICAgaWYgKGlkeCAlIGNodW5rZWRCb3VuZHNTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjaHVuayA9IHtzdGFydDogaWR4LCBlbmQ6IGlkeCwgcmVjdDogW0lORiwgSU5GLCAtSU5GLCAtSU5GXX07XG4gICAgICAgICAgICAgICAgICBjaHVua2VkQm91bmRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaHVuay5lbmQrKztcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1JlY3QgPSBjaHVuay5yZWN0O1xuICAgICAgICAgICAgICAgIGlmICh2aXNYMCA8IGNodW5rUmVjdFswXSkgY2h1bmtSZWN0WzBdID0gdmlzWDA7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1kwIDwgY2h1bmtSZWN0WzFdKSBjaHVua1JlY3RbMV0gPSB2aXNZMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWDEgPiBjaHVua1JlY3RbMl0pIGNodW5rUmVjdFsyXSA9IHZpc1gxO1xuICAgICAgICAgICAgICAgIGlmICh2aXNZMSA+IGNodW5rUmVjdFszXSkgY2h1bmtSZWN0WzNdID0gdmlzWTE7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gZ2x5cGggaWRzIGFycmF5XG4gICAgICAgICAgICAgICAgZ2x5cGhJZHNbaWR4XSA9IGdseXBoSWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgY29sb3JzXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGlkeCAqIDM7XG4gICAgICAgICAgICAgICAgICBnbHlwaENvbG9yc1tzdGFydF0gPSBjdXJyZW50Q29sb3IgPj4gMTYgJiAyNTU7XG4gICAgICAgICAgICAgICAgICBnbHlwaENvbG9yc1tzdGFydCArIDFdID0gY3VycmVudENvbG9yID4+IDggJiAyNTU7XG4gICAgICAgICAgICAgICAgICBnbHlwaENvbG9yc1tzdGFydCArIDJdID0gY3VycmVudENvbG9yICYgMjU1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEluY3JlbWVudCB5IG9mZnNldCBmb3IgbmV4dCBsaW5lXG4gICAgICAgICAgbGluZVlPZmZzZXQgLT0gbGluZUhlaWdodDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmlsbCBpbiByZW1haW5pbmcgY2FyZXQgcG9zaXRpb25zIGluIGNhc2UgdGhlIGZpbmFsIGNoYXJhY3RlciB3YXMgYSBsaWdhdHVyZVxuICAgICAgICBpZiAoY2FyZXRQb3NpdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBsaWdDb3VudCA9IHRleHQubGVuZ3RoIC0gcHJldkNoYXJJbmRleDtcbiAgICAgICAgICBpZiAobGlnQ291bnQgPiAxKSB7XG4gICAgICAgICAgICBmaWxsTGlnYXR1cmVDYXJldFBvc2l0aW9ucyhjYXJldFBvc2l0aW9ucywgcHJldkNoYXJJbmRleCwgbGlnQ291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaW1pbmcgc3RhdHNcbiAgICAgIHRpbWluZ3MudHlwZXNldHRpbmcgPSBub3coKSAtIHR5cGVzZXRTdGFydDtcblxuICAgICAgY2FsbGJhY2soe1xuICAgICAgICBnbHlwaElkcywgLy9mb250IGluZGljZXMgZm9yIGVhY2ggZ2x5cGhcbiAgICAgICAgZ2x5cGhQb3NpdGlvbnMsIC8veCx5IG9mIGVhY2ggZ2x5cGgncyBvcmlnaW4gaW4gbGF5b3V0XG4gICAgICAgIGdseXBoRGF0YSwgLy9kaWN0IGhvbGRpbmcgZGF0YSBhYm91dCBlYWNoIGdseXBoIGFwcGVhcmluZyBpbiB0aGUgdGV4dFxuICAgICAgICBjYXJldFBvc2l0aW9ucywgLy9zdGFydFgsZW5kWCxib3R0b21ZIGNhcmV0IHBvc2l0aW9ucyBmb3IgZWFjaCBjaGFyXG4gICAgICAgIGNhcmV0SGVpZ2h0LCAvL2hlaWdodCBvZiBjdXJzb3IgZnJvbSBib3R0b20gdG8gdG9wXG4gICAgICAgIGdseXBoQ29sb3JzLCAvL2NvbG9yIGZvciBlYWNoIGdseXBoLCBpZiBjb2xvciByYW5nZXMgc3VwcGxpZWRcbiAgICAgICAgY2h1bmtlZEJvdW5kcywgLy90b3RhbCByZWN0cyBwZXIgKG49Y2h1bmtlZEJvdW5kc1NpemUpIGNvbnNlY3V0aXZlIGdseXBoc1xuICAgICAgICBmb250U2l6ZSwgLy9jYWxjdWxhdGVkIGVtIGhlaWdodFxuICAgICAgICB1bml0c1BlckVtLCAvL2ZvbnQgdW5pdHMgcGVyIGVtXG4gICAgICAgIGFzY2VuZGVyOiBhc2NlbmRlciAqIGZvbnRTaXplTXVsdCwgLy9mb250IGFzY2VuZGVyXG4gICAgICAgIGRlc2NlbmRlcjogZGVzY2VuZGVyICogZm9udFNpemVNdWx0LCAvL2ZvbnQgZGVzY2VuZGVyXG4gICAgICAgIGNhcEhlaWdodDogY2FwSGVpZ2h0ICogZm9udFNpemVNdWx0LCAvL2ZvbnQgY2FwLWhlaWdodFxuICAgICAgICB4SGVpZ2h0OiB4SGVpZ2h0ICogZm9udFNpemVNdWx0LCAvL2ZvbnQgeC1oZWlnaHRcbiAgICAgICAgbGluZUhlaWdodCwgLy9jb21wdXRlZCBsaW5lIGhlaWdodFxuICAgICAgICB0b3BCYXNlbGluZSwgLy95IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsaW5lJ3MgYmFzZWxpbmVcbiAgICAgICAgYmxvY2tCb3VuZHM6IFsgLy9ib3VuZHMgZm9yIHRoZSB3aG9sZSBibG9jayBvZiB0ZXh0LCBpbmNsdWRpbmcgdmVydGljYWwgcGFkZGluZyBmb3IgbGluZUhlaWdodFxuICAgICAgICAgIGFuY2hvclhPZmZzZXQsXG4gICAgICAgICAgYW5jaG9yWU9mZnNldCAtIGxpbmVzLmxlbmd0aCAqIGxpbmVIZWlnaHQsXG4gICAgICAgICAgYW5jaG9yWE9mZnNldCArIG1heExpbmVXaWR0aCxcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0XG4gICAgICAgIF0sXG4gICAgICAgIHZpc2libGVCb3VuZHMsIC8vdG90YWwgYm91bmRzIG9mIHZpc2libGUgdGV4dCBwYXRocywgbWF5IGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gYmxvY2tCb3VuZHNcbiAgICAgICAgdGltaW5nc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBGb3IgYSBnaXZlbiB0ZXh0IHN0cmluZyBhbmQgZm9udCBwYXJhbWV0ZXJzLCBkZXRlcm1pbmUgdGhlIHJlc3VsdGluZyBibG9jayBkaW1lbnNpb25zXG4gICAqIGFmdGVyIHdyYXBwaW5nIGZvciB0aGUgZ2l2ZW4gbWF4V2lkdGguXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gbWVhc3VyZShhcmdzLCBjYWxsYmFjaykge1xuICAgIHR5cGVzZXQoYXJncywgKHJlc3VsdCkgPT4ge1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IHJlc3VsdC5ibG9ja0JvdW5kcztcbiAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgd2lkdGg6IHgxIC0geDAsXG4gICAgICAgIGhlaWdodDogeTEgLSB5MFxuICAgICAgfSk7XG4gICAgfSwge21ldHJpY3NPbmx5OiB0cnVlfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBlcmNlbnQoc3RyKSB7XG4gICAgbGV0IG1hdGNoID0gc3RyLm1hdGNoKC9eKFtcXGQuXSspJSQvKTtcbiAgICBsZXQgcGN0ID0gbWF0Y2ggPyBwYXJzZUZsb2F0KG1hdGNoWzFdKSA6IE5hTjtcbiAgICByZXR1cm4gaXNOYU4ocGN0KSA/IDAgOiBwY3QgLyAxMDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zKGNhcmV0UG9zaXRpb25zLCBsaWdTdGFydEluZGV4LCBsaWdDb3VudCkge1xuICAgIGNvbnN0IGxpZ1N0YXJ0WCA9IGNhcmV0UG9zaXRpb25zW2xpZ1N0YXJ0SW5kZXggKiAzXTtcbiAgICBjb25zdCBsaWdFbmRYID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDMgKyAxXTtcbiAgICBjb25zdCBsaWdZID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDMgKyAyXTtcbiAgICBjb25zdCBndWVzc2VkQWR2YW5jZVggPSAobGlnRW5kWCAtIGxpZ1N0YXJ0WCkgLyBsaWdDb3VudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpZ0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSAobGlnU3RhcnRJbmRleCArIGkpICogMztcbiAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXhdID0gbGlnU3RhcnRYICsgZ3Vlc3NlZEFkdmFuY2VYICogaTtcbiAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXggKyAxXSA9IGxpZ1N0YXJ0WCArIGd1ZXNzZWRBZHZhbmNlWCAqIChpICsgMSk7XG4gICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4ICsgMl0gPSBsaWdZO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KClcbiAgfVxuXG4gIC8vIEFycmF5LWJhY2tlZCBzdHJ1Y3R1cmUgZm9yIGEgc2luZ2xlIGxpbmUncyBnbHlwaHMgZGF0YVxuICBmdW5jdGlvbiBUZXh0TGluZSgpIHtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgfVxuICBjb25zdCB0ZXh0TGluZVByb3BzID0gWydnbHlwaE9iaicsICd4JywgJ3dpZHRoJywgJ2NoYXJJbmRleCddO1xuICBUZXh0TGluZS5wcm90b3R5cGUgPSB7XG4gICAgd2lkdGg6IDAsXG4gICAgaXNTb2Z0V3JhcHBlZDogZmFsc2UsXG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRhdGEubGVuZ3RoIC8gdGV4dExpbmVQcm9wcy5sZW5ndGgpXG4gICAgfSxcbiAgICBnbHlwaEF0KGkpIHtcbiAgICAgIGxldCBmbHkgPSBUZXh0TGluZS5mbHl3ZWlnaHQ7XG4gICAgICBmbHkuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGZseS5pbmRleCA9IGk7XG4gICAgICByZXR1cm4gZmx5XG4gICAgfSxcbiAgICBzcGxpdEF0KGkpIHtcbiAgICAgIGxldCBuZXdMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICBuZXdMaW5lLmRhdGEgPSB0aGlzLmRhdGEuc3BsaWNlKGkgKiB0ZXh0TGluZVByb3BzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3TGluZVxuICAgIH1cbiAgfTtcbiAgVGV4dExpbmUuZmx5d2VpZ2h0ID0gdGV4dExpbmVQcm9wcy5yZWR1Y2UoKG9iaiwgcHJvcCwgaSwgYWxsKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuaW5kZXggKiB0ZXh0TGluZVByb3BzLmxlbmd0aCArIGldXG4gICAgICB9LFxuICAgICAgc2V0KHZhbCkge1xuICAgICAgICB0aGlzLmRhdGFbdGhpcy5pbmRleCAqIHRleHRMaW5lUHJvcHMubGVuZ3RoICsgaV0gPSB2YWw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialxuICB9LCB7ZGF0YTogbnVsbCwgaW5kZXg6IDB9KTtcblxuXG4gIHJldHVybiB7XG4gICAgdHlwZXNldCxcbiAgICBtZWFzdXJlLFxuICAgIGxvYWRGb250XG4gIH1cbn1cblxuY29uc3Qgbm93ID0gKCkgPT4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KCk7XG5cbmNvbnN0IG1haW5UaHJlYWRHZW5lcmF0b3IgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNERkdlbmVyYXRvcigpO1xuXG5sZXQgd2FybmVkO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFuIFNERiB0ZXh0dXJlIGltYWdlIGZvciBhIHNpbmdsZSBnbHlwaCBwYXRoLCBwbGFjaW5nIHRoZSByZXN1bHQgaW50byBhIHdlYmdsIGNhbnZhcyBhdCBhXG4gKiBnaXZlbiBsb2NhdGlvbiBhbmQgY2hhbm5lbC4gVXRpbGl6ZXMgdGhlIHdlYmdsLXNkZi1nZW5lcmF0b3IgZXh0ZXJuYWwgcGFja2FnZSBmb3IgR1BVLWFjY2VsZXJhdGVkIFNERlxuICogZ2VuZXJhdGlvbiB3aGVuIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTREYod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwsIHVzZVdlYkdMID0gdHJ1ZSkge1xuICAvLyBBbGxvdyBvcHQtb3V0XG4gIGlmICghdXNlV2ViR0wpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVTREZfSlNfV29ya2VyKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKVxuICB9XG5cbiAgLy8gQXR0ZW1wdCBHUFUtYWNjZWxlcmF0ZWQgZ2VuZXJhdGlvbiBmaXJzdFxuICByZXR1cm4gZ2VuZXJhdGVTREZfR0wod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpLnRoZW4oXG4gICAgbnVsbCxcbiAgICBlcnIgPT4ge1xuICAgICAgLy8gV2ViR0wgZmFpbGVkIGVpdGhlciBkdWUgdG8gYSBoYXJkIGVycm9yIG9yIHVuZXhwZWN0ZWQgcmVzdWx0czsgZmFsbCBiYWNrIHRvIEpTIGluIHdvcmtlcnNcbiAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgV2ViR0wgU0RGIGdlbmVyYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSlNgLCBlcnIpO1xuICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdlbmVyYXRlU0RGX0pTX1dvcmtlcih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbClcbiAgICB9XG4gIClcbn1cblxuY29uc3QgcXVldWUgPSBbXTtcbmNvbnN0IGNodW5rVGltZUJ1ZGdldCA9IDU7IC8vIG1zXG5sZXQgdGltZXIgPSAwO1xuXG5mdW5jdGlvbiBuZXh0Q2h1bmsoKSB7XG4gIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gIHdoaWxlIChxdWV1ZS5sZW5ndGggJiYgbm93KCkgLSBzdGFydCA8IGNodW5rVGltZUJ1ZGdldCkge1xuICAgIHF1ZXVlLnNoaWZ0KCkoKTtcbiAgfVxuICB0aW1lciA9IHF1ZXVlLmxlbmd0aCA/IHNldFRpbWVvdXQobmV4dENodW5rLCAwKSA6IDA7XG59XG5cbi8qKlxuICogV2ViR0wtYmFzZWQgaW1wbGVtZW50YXRpb24gZXhlY3V0ZWQgb24gdGhlIG1haW4gdGhyZWFkLiBSZXF1ZXN0cyBhcmUgZXhlY3V0ZWQgaW4gdGltZS1ib3VuZGVkXG4gKiBtYWNyb3Rhc2sgY2h1bmtzIHRvIGFsbG93IHJlbmRlciBmcmFtZXMgdG8gZXhlY3V0ZSBpbiBiZXR3ZWVuLlxuICovXG5jb25zdCBnZW5lcmF0ZVNERl9HTCA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IG5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbC5nZW5lcmF0ZUludG9DYW52YXMoLi4uYXJncyk7XG4gICAgICAgIHJlc29sdmUoeyB0aW1pbmc6IG5vdygpIC0gc3RhcnQgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF0aW1lcikge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KG5leHRDaHVuaywgMCk7XG4gICAgfVxuICB9KVxufTtcblxuY29uc3QgdGhyZWFkQ291bnQgPSA0OyAvLyBob3cgbWFueSB3b3JrZXJzIHRvIHNwYXduXG5jb25zdCBpZGxlVGltZW91dCA9IDIwMDA7IC8vIHdvcmtlcnMgd2lsbCBiZSB0ZXJtaW5hdGVkIGFmdGVyIGJlaW5nIGlkbGUgdGhpcyBtYW55IG1pbGxpc2Vjb25kc1xuY29uc3QgdGhyZWFkcyA9IHt9O1xubGV0IGNhbGxOdW0gPSAwO1xuXG4vKipcbiAqIEZhbGxiYWNrIEpTLWJhc2VkIGltcGxlbWVudGF0aW9uLCBmYW5uZWQgb3V0IHRvIGEgbnVtYmVyIG9mIHdvcmtlciB0aHJlYWRzIGZvciBwYXJhbGxlbGlzbVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNERl9KU19Xb3JrZXIod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpIHtcbiAgY29uc3Qgd29ya2VySWQgPSAnVHJvaWthVGV4dFNERkdlbmVyYXRvcl9KU18nICsgKChjYWxsTnVtKyspICUgdGhyZWFkQ291bnQpO1xuICBsZXQgdGhyZWFkID0gdGhyZWFkc1t3b3JrZXJJZF07XG4gIGlmICghdGhyZWFkKSB7XG4gICAgdGhyZWFkID0gdGhyZWFkc1t3b3JrZXJJZF0gPSB7XG4gICAgICB3b3JrZXJNb2R1bGU6IGRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgICAgIG5hbWU6IHdvcmtlcklkLFxuICAgICAgICB3b3JrZXJJZCxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICAgICAgY3JlYXRlU0RGR2VuZXJhdG9yLFxuICAgICAgICAgIG5vd1xuICAgICAgICBdLFxuICAgICAgICBpbml0KF9jcmVhdGVTREZHZW5lcmF0b3IsIG5vdykge1xuICAgICAgICAgIGNvbnN0IGdlbmVyYXRlID0gX2NyZWF0ZVNERkdlbmVyYXRvcigpLmphdmFzY3JpcHQuZ2VuZXJhdGU7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG5vdygpO1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZURhdGEgPSBnZW5lcmF0ZSguLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRleHR1cmVEYXRhLFxuICAgICAgICAgICAgICB0aW1pbmc6IG5vdygpIC0gc3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRyYW5zZmVyYWJsZXMocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHQudGV4dHVyZURhdGEuYnVmZmVyXVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHJlcXVlc3RzOiAwLFxuICAgICAgaWRsZVRpbWVyOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHRocmVhZC5yZXF1ZXN0cysrO1xuICBjbGVhclRpbWVvdXQodGhyZWFkLmlkbGVUaW1lcik7XG4gIHJldHVybiB0aHJlYWQud29ya2VyTW9kdWxlKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudClcbiAgICAudGhlbigoeyB0ZXh0dXJlRGF0YSwgdGltaW5nIH0pID0+IHtcbiAgICAgIC8vIGNvcHkgcmVzdWx0IGRhdGEgaW50byB0aGUgY2FudmFzXG4gICAgICBjb25zdCBzdGFydCA9IG5vdygpO1xuICAgICAgLy8gZXhwYW5kIHNpbmdsZS1jaGFubmVsIGRhdGEgaW50byByZ2JhXG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgVWludDhBcnJheSh0ZXh0dXJlRGF0YS5sZW5ndGggKiA0KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dHVyZURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW1hZ2VEYXRhW2kgKiA0ICsgY2hhbm5lbF0gPSB0ZXh0dXJlRGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2xVdGlscy5yZW5kZXJJbWFnZURhdGEoY2FudmFzLCBpbWFnZURhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEgPDwgKDMgLSBjaGFubmVsKSk7XG4gICAgICB0aW1pbmcgKz0gbm93KCkgLSBzdGFydDtcblxuICAgICAgLy8gY2xlYW4gdXAgd29ya2VycyBhZnRlciBhIHdoaWxlXG4gICAgICBpZiAoLS10aHJlYWQucmVxdWVzdHMgPT09IDApIHtcbiAgICAgICAgdGhyZWFkLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB0ZXJtaW5hdGVXb3JrZXIod29ya2VySWQpOyB9LCBpZGxlVGltZW91dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0aW1pbmcgfVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHdhcm1VcFNERkNhbnZhcyhjYW52YXMpIHtcbiAgaWYgKCFjYW52YXMuX3dhcm0pIHtcbiAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsLmlzU3VwcG9ydGVkKGNhbnZhcyk7XG4gICAgY2FudmFzLl93YXJtID0gdHJ1ZTtcbiAgfVxufVxuXG5jb25zdCByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZyA9IG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2xVdGlscy5yZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZztcblxuLyohXG5DdXN0b20gYnVpbGQgb2YgVHlwci50cyAoaHR0cHM6Ly9naXRodWIuY29tL2ZyZWRsaTc0L1R5cHIudHMpIGZvciB1c2UgaW4gVHJvaWthIHRleHQgcmVuZGVyaW5nLlxuT3JpZ2luYWwgTUlUIGxpY2Vuc2UgYXBwbGllczogaHR0cHM6Ly9naXRodWIuY29tL2ZyZWRsaTc0L1R5cHIudHMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbmZ1bmN0aW9uIHR5cHJGYWN0b3J5KCl7cmV0dXJuIFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3cmJihzZWxmLndpbmRvdz1zZWxmKSxmdW5jdGlvbihyKXt2YXIgZT17cGFyc2U6ZnVuY3Rpb24ocil7dmFyIHQ9ZS5fYmluLGE9bmV3IFVpbnQ4QXJyYXkocik7aWYoXCJ0dGNmXCI9PXQucmVhZEFTQ0lJKGEsMCw0KSl7dmFyIG49NDt0LnJlYWRVc2hvcnQoYSxuKSxuKz0yLHQucmVhZFVzaG9ydChhLG4pLG4rPTI7dmFyIG89dC5yZWFkVWludChhLG4pO24rPTQ7Zm9yKHZhciBzPVtdLGk9MDtpPG87aSsrKXt2YXIgaD10LnJlYWRVaW50KGEsbik7bis9NCxzLnB1c2goZS5fcmVhZEZvbnQoYSxoKSk7fXJldHVybiBzfXJldHVybiBbZS5fcmVhZEZvbnQoYSwwKV19LF9yZWFkRm9udDpmdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQ7YS5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTI7Zm9yKHZhciBzPVtcImNtYXBcIixcImhlYWRcIixcImhoZWFcIixcIm1heHBcIixcImhtdHhcIixcIm5hbWVcIixcIk9TLzJcIixcInBvc3RcIixcImxvY2FcIixcImdseWZcIixcImtlcm5cIixcIkNGRiBcIixcIkdQT1NcIixcIkdTVUJcIixcIlNWRyBcIl0saT17X2RhdGE6cixfb2Zmc2V0Om59LGg9e30sZj0wO2Y8bztmKyspe3ZhciBkPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00LGEucmVhZFVpbnQocix0KSx0Kz00O3ZhciB1PWEucmVhZFVpbnQocix0KTt0Kz00O3ZhciBsPWEucmVhZFVpbnQocix0KTt0Kz00LGhbZF09e29mZnNldDp1LGxlbmd0aDpsfTt9Zm9yKGY9MDtmPHMubGVuZ3RoO2YrKyl7dmFyIHY9c1tmXTtoW3ZdJiYoaVt2LnRyaW0oKV09ZVt2LnRyaW0oKV0ucGFyc2UocixoW3ZdLm9mZnNldCxoW3ZdLmxlbmd0aCxpKSk7fXJldHVybiBpfSxfdGFiT2Zmc2V0OmZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLG89bi5yZWFkVXNob3J0KHIsYSs0KSxzPWErMTIsaT0wO2k8bztpKyspe3ZhciBoPW4ucmVhZEFTQ0lJKHIscyw0KTtzKz00LG4ucmVhZFVpbnQocixzKSxzKz00O3ZhciBmPW4ucmVhZFVpbnQocixzKTtpZihzKz00LG4ucmVhZFVpbnQocixzKSxzKz00LGg9PXQpcmV0dXJuIGZ9cmV0dXJuIDB9fTtlLl9iaW49e3JlYWRGaXhlZDpmdW5jdGlvbihyLGUpe3JldHVybiAocltlXTw8OHxyW2UrMV0pKyhyW2UrMl08PDh8cltlKzNdKS82NTU0MH0scmVhZEYyZG90MTQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLnJlYWRTaG9ydChyLHQpLzE2Mzg0fSxyZWFkSW50OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRJbnQzMih0KX0scmVhZEludDg6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldEludDgodCl9LHJlYWRTaG9ydDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0SW50MTYodCl9LHJlYWRVc2hvcnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldFVpbnQxNih0KX0scmVhZFVzaG9ydHM6ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1bXSxvPTA7bzxhO28rKyluLnB1c2goZS5fYmluLnJlYWRVc2hvcnQocix0KzIqbykpO3JldHVybiBufSxyZWFkVWludDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0VWludDMyKHQpfSxyZWFkVWludDY0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIDQyOTQ5NjcyOTYqZS5fYmluLnJlYWRVaW50KHIsdCkrZS5fYmluLnJlYWRVaW50KHIsdCs0KX0scmVhZEFTQ0lJOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9XCJcIixuPTA7bjx0O24rKylhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHJbZStuXSk7cmV0dXJuIGF9LHJlYWRVbmljb2RlOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9XCJcIixuPTA7bjx0O24rKyl7dmFyIG89cltlKytdPDw4fHJbZSsrXTthKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pO31yZXR1cm4gYX0sX3RkZWM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LlRleHREZWNvZGVyP25ldyB3aW5kb3cuVGV4dERlY29kZXI6bnVsbCxyZWFkVVRGODpmdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLl90ZGVjO3JldHVybiBuJiYwPT10JiZhPT1yLmxlbmd0aD9uLmRlY29kZShyKTplLl9iaW4ucmVhZEFTQ0lJKHIsdCxhKX0scmVhZEJ5dGVzOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9W10sbj0wO248dDtuKyspYS5wdXNoKHJbZStuXSk7cmV0dXJuIGF9LHJlYWRBU0NJSUFycmF5OmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9W10sbj0wO248dDtuKyspYS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUocltlK25dKSk7cmV0dXJuIGF9LF92aWV3OmZ1bmN0aW9uKHIpe3JldHVybiByLl9kYXRhVmlld3x8KHIuX2RhdGFWaWV3PXIuYnVmZmVyP25ldyBEYXRhVmlldyhyLmJ1ZmZlcixyLmJ5dGVPZmZzZXQsci5ieXRlTGVuZ3RoKTpuZXcgRGF0YVZpZXcobmV3IFVpbnQ4QXJyYXkocikuYnVmZmVyKSl9fSxlLl9sY3RmPXt9LGUuX2xjdGYucGFyc2U9ZnVuY3Rpb24ocix0LGEsbixvKXt2YXIgcz1lLl9iaW4saT17fSxoPXQ7cy5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBmPXMucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9cy5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1zLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixpLnNjcmlwdExpc3Q9ZS5fbGN0Zi5yZWFkU2NyaXB0TGlzdChyLGgrZiksaS5mZWF0dXJlTGlzdD1lLl9sY3RmLnJlYWRGZWF0dXJlTGlzdChyLGgrZCksaS5sb29rdXBMaXN0PWUuX2xjdGYucmVhZExvb2t1cExpc3QocixoK3UsbyksaX0sZS5fbGN0Zi5yZWFkTG9va3VwTGlzdD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89dCxzPVtdLGk9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXt2YXIgZj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPWUuX2xjdGYucmVhZExvb2t1cFRhYmxlKHIsbytmLGEpO3MucHVzaChkKTt9cmV0dXJuIHN9LGUuX2xjdGYucmVhZExvb2t1cFRhYmxlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz10LHM9e3RhYnM6W119O3MubHR5cGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixzLmZsYWc9bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgaT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD1zLmx0eXBlLGY9MDtmPGk7ZisrKXt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PWEocixoLG8rZCxzKTtzLnRhYnMucHVzaCh1KTt9cmV0dXJuIHN9LGUuX2xjdGYubnVtT2ZPbmVzPWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT0wLHQ9MDt0PDMyO3QrKykwIT0ocj4+PnQmMSkmJmUrKztyZXR1cm4gZX0sZS5fbGN0Zi5yZWFkQ2xhc3NEZWY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1bXSxvPWEucmVhZFVzaG9ydChyLHQpO2lmKHQrPTIsMT09byl7dmFyIHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspbi5wdXNoKHMraCksbi5wdXNoKHMraCksbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO31pZigyPT1vKXt2YXIgZj1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2ZvcihoPTA7aDxmO2grKyluLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTIsbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yLG4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9Mjt9cmV0dXJuIG59LGUuX2xjdGYuZ2V0SW50ZXJ2YWw9ZnVuY3Rpb24ocixlKXtmb3IodmFyIHQ9MDt0PHIubGVuZ3RoO3QrPTMpe3ZhciBhPXJbdF0sbj1yW3QrMV07aWYoclt0KzJdLGE8PWUmJmU8PW4pcmV0dXJuIHR9cmV0dXJuIC0xfSxlLl9sY3RmLnJlYWRDb3ZlcmFnZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm10PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsMT09bi5mbXQmJihuLnRhYj1hLnJlYWRVc2hvcnRzKHIsdCxvKSksMj09bi5mbXQmJihuLnRhYj1hLnJlYWRVc2hvcnRzKHIsdCwzKm8pKSxufSxlLl9sY3RmLmNvdmVyYWdlSW5kZXg9ZnVuY3Rpb24ocix0KXt2YXIgYT1yLnRhYjtpZigxPT1yLmZtdClyZXR1cm4gYS5pbmRleE9mKHQpO2lmKDI9PXIuZm10KXt2YXIgbj1lLl9sY3RmLmdldEludGVydmFsKGEsdCk7aWYoLTEhPW4pcmV0dXJuIGFbbisyXSsodC1hW25dKX1yZXR1cm4gLTF9LGUuX2xjdGYucmVhZEZlYXR1cmVMaXN0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZj1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPWUuX2xjdGYucmVhZEZlYXR1cmVUYWJsZShyLG4rZik7ZC50YWc9aC50cmltKCksby5wdXNoKGQpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkRmVhdHVyZVRhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixzPjAmJihvLmZlYXR1cmVQYXJhbXM9bitzKTt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8udGFiPVtdO2Zvcih2YXIgaD0wO2g8aTtoKyspby50YWIucHVzaChhLnJlYWRVc2hvcnQocix0KzIqaCkpO3JldHVybiBvfSxlLl9sY3RmLnJlYWRTY3JpcHRMaXN0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZj1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG9baC50cmltKCldPWUuX2xjdGYucmVhZFNjcmlwdFRhYmxlKHIsbitmKTt9cmV0dXJuIG99LGUuX2xjdGYucmVhZFNjcmlwdFRhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvLmRlZmF1bHQ9ZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlKHIsbitzKTt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspe3ZhciBmPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00O3ZhciBkPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsb1tmLnRyaW0oKV09ZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlKHIsbitkKTt9cmV0dXJuIG99LGUuX2xjdGYucmVhZExhbmdTeXNUYWJsZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O2EucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZXFGZWF0dXJlPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsbi5mZWF0dXJlcz1hLnJlYWRVc2hvcnRzKHIsdCxvKSxufSxlLkNGRj17fSxlLkNGRi5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluOyhyPW5ldyBVaW50OEFycmF5KHIuYnVmZmVyLHQsYSkpW3Q9MF0sclsrK3RdLHJbKyt0XSxyWysrdF0sdCsrO3ZhciBvPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxvKTtmb3IodmFyIHM9W10saT0wO2k8by5sZW5ndGgtMTtpKyspcy5wdXNoKG4ucmVhZEFTQ0lJKHIsdCtvW2ldLG9baSsxXS1vW2ldKSk7dCs9b1tvLmxlbmd0aC0xXTt2YXIgaD1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsaCk7dmFyIGY9W107Zm9yKGk9MDtpPGgubGVuZ3RoLTE7aSsrKWYucHVzaChlLkNGRi5yZWFkRGljdChyLHQraFtpXSx0K2hbaSsxXSkpO3QrPWhbaC5sZW5ndGgtMV07dmFyIGQ9ZlswXSx1PVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCx1KTt2YXIgbD1bXTtmb3IoaT0wO2k8dS5sZW5ndGgtMTtpKyspbC5wdXNoKG4ucmVhZEFTQ0lJKHIsdCt1W2ldLHVbaSsxXS11W2ldKSk7aWYodCs9dVt1Lmxlbmd0aC0xXSxlLkNGRi5yZWFkU3VicnMocix0LGQpLGQuQ2hhclN0cmluZ3Mpe3Q9ZC5DaGFyU3RyaW5nczt1PVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCx1KTt2YXIgdj1bXTtmb3IoaT0wO2k8dS5sZW5ndGgtMTtpKyspdi5wdXNoKG4ucmVhZEJ5dGVzKHIsdCt1W2ldLHVbaSsxXS11W2ldKSk7ZC5DaGFyU3RyaW5ncz12O31pZihkLlJPUyl7dD1kLkZEQXJyYXk7dmFyIGM9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LGMpLGQuRkRBcnJheT1bXTtmb3IoaT0wO2k8Yy5sZW5ndGgtMTtpKyspe3ZhciBwPWUuQ0ZGLnJlYWREaWN0KHIsdCtjW2ldLHQrY1tpKzFdKTtlLkNGRi5fcmVhZEZEaWN0KHIscCxsKSxkLkZEQXJyYXkucHVzaChwKTt9dCs9Y1tjLmxlbmd0aC0xXSx0PWQuRkRTZWxlY3QsZC5GRFNlbGVjdD1bXTt2YXIgVT1yW3RdO2lmKHQrKywzIT1VKXRocm93IFU7dmFyIGc9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IoaT0wO2k8ZysxO2krKylkLkZEU2VsZWN0LnB1c2gobi5yZWFkVXNob3J0KHIsdCksclt0KzJdKSx0Kz0zO31yZXR1cm4gZC5FbmNvZGluZyYmKGQuRW5jb2Rpbmc9ZS5DRkYucmVhZEVuY29kaW5nKHIsZC5FbmNvZGluZyxkLkNoYXJTdHJpbmdzLmxlbmd0aCkpLGQuY2hhcnNldCYmKGQuY2hhcnNldD1lLkNGRi5yZWFkQ2hhcnNldChyLGQuY2hhcnNldCxkLkNoYXJTdHJpbmdzLmxlbmd0aCkpLGUuQ0ZGLl9yZWFkRkRpY3QocixkLGwpLGR9LGUuQ0ZGLl9yZWFkRkRpY3Q9ZnVuY3Rpb24ocix0LGEpe3ZhciBuO2Zvcih2YXIgbyBpbiB0LlByaXZhdGUmJihuPXQuUHJpdmF0ZVsxXSx0LlByaXZhdGU9ZS5DRkYucmVhZERpY3QocixuLG4rdC5Qcml2YXRlWzBdKSx0LlByaXZhdGUuU3VicnMmJmUuQ0ZGLnJlYWRTdWJycyhyLG4rdC5Qcml2YXRlLlN1YnJzLHQuUHJpdmF0ZSkpLHQpLTEhPVtcIkZhbWlseU5hbWVcIixcIkZvbnROYW1lXCIsXCJGdWxsTmFtZVwiLFwiTm90aWNlXCIsXCJ2ZXJzaW9uXCIsXCJDb3B5cmlnaHRcIl0uaW5kZXhPZihvKSYmKHRbb109YVt0W29dLTQyNiszNV0pO30sZS5DRkYucmVhZFN1YnJzPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsbyk7dmFyIHMsaT1vLmxlbmd0aDtzPWk8MTI0MD8xMDc6aTwzMzkwMD8xMTMxOjMyNzY4LGEuQmlhcz1zLGEuU3VicnM9W107Zm9yKHZhciBoPTA7aDxvLmxlbmd0aC0xO2grKylhLlN1YnJzLnB1c2gobi5yZWFkQnl0ZXMocix0K29baF0sb1toKzFdLW9baF0pKTt9LGUuQ0ZGLnRhYmxlU0U9WzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMCwxMTEsMTEyLDExMywxMTQsMCwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDAsMTIzLDAsMTI0LDEyNSwxMjYsMTI3LDEyOCwxMjksMTMwLDEzMSwwLDEzMiwxMzMsMCwxMzQsMTM1LDEzNiwxMzcsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxMzgsMCwxMzksMCwwLDAsMCwxNDAsMTQxLDE0MiwxNDMsMCwwLDAsMCwwLDE0NCwwLDAsMCwxNDUsMCwwLDE0NiwxNDcsMTQ4LDE0OSwwLDAsMCwwXSxlLkNGRi5nbHlwaEJ5VW5pY29kZT1mdW5jdGlvbihyLGUpe2Zvcih2YXIgdD0wO3Q8ci5jaGFyc2V0Lmxlbmd0aDt0KyspaWYoci5jaGFyc2V0W3RdPT1lKXJldHVybiB0O3JldHVybiAtMX0sZS5DRkYuZ2x5cGhCeVNFPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHQ8MHx8dD4yNTU/LTE6ZS5DRkYuZ2x5cGhCeVVuaWNvZGUocixlLkNGRi50YWJsZVNFW3RdKX0sZS5DRkYucmVhZEVuY29kaW5nPWZ1bmN0aW9uKHIsdCxhKXtlLl9iaW47dmFyIG49W1wiLm5vdGRlZlwiXSxvPXJbdF07aWYodCsrLDAhPW8pdGhyb3cgXCJlcnJvcjogdW5rbm93biBlbmNvZGluZyBmb3JtYXQ6IFwiK287dmFyIHM9clt0XTt0Kys7Zm9yKHZhciBpPTA7aTxzO2krKyluLnB1c2goclt0K2ldKTtyZXR1cm4gbn0sZS5DRkYucmVhZENoYXJzZXQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtcIi5ub3RkZWZcIl0scz1yW3RdO2lmKHQrKywwPT1zKWZvcih2YXIgaT0wO2k8YTtpKyspe3ZhciBoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGgpO31lbHNlIHtpZigxIT1zJiYyIT1zKXRocm93IFwiZXJyb3I6IGZvcm1hdDogXCIrcztmb3IoO28ubGVuZ3RoPGE7KXtoPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9MDsxPT1zPyhmPXJbdF0sdCsrKTooZj1uLnJlYWRVc2hvcnQocix0KSx0Kz0yKTtmb3IoaT0wO2k8PWY7aSsrKW8ucHVzaChoKSxoKys7fX1yZXR1cm4gb30sZS5DRkYucmVhZEluZGV4PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1uLnJlYWRVc2hvcnQocix0KSsxLHM9clt0Kz0yXTtpZih0KyssMT09cylmb3IodmFyIGk9MDtpPG87aSsrKWEucHVzaChyW3QraV0pO2Vsc2UgaWYoMj09cylmb3IoaT0wO2k8bztpKyspYS5wdXNoKG4ucmVhZFVzaG9ydChyLHQrMippKSk7ZWxzZSBpZigzPT1zKWZvcihpPTA7aTxvO2krKylhLnB1c2goMTY3NzcyMTUmbi5yZWFkVWludChyLHQrMyppLTEpKTtlbHNlIGlmKDEhPW8pdGhyb3cgXCJ1bnN1cHBvcnRlZCBvZmZzZXQgc2l6ZTogXCIrcytcIiwgY291bnQ6IFwiK287cmV0dXJuICh0Kz1vKnMpLTF9LGUuQ0ZGLmdldENoYXJTdHJpbmc9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXJbdF0scz1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGk9MSxoPW51bGwsZj1udWxsO288PTIwJiYoaD1vLGk9MSksMTI9PW8mJihoPTEwMCpvK3MsaT0yKSwyMTw9byYmbzw9MjcmJihoPW8saT0xKSwyOD09byYmKGY9bi5yZWFkU2hvcnQocix0KzEpLGk9MyksMjk8PW8mJm88PTMxJiYoaD1vLGk9MSksMzI8PW8mJm88PTI0NiYmKGY9by0xMzksaT0xKSwyNDc8PW8mJm88PTI1MCYmKGY9MjU2KihvLTI0NykrcysxMDgsaT0yKSwyNTE8PW8mJm88PTI1NCYmKGY9MjU2Ki0oby0yNTEpLXMtMTA4LGk9MiksMjU1PT1vJiYoZj1uLnJlYWRJbnQocix0KzEpLzY1NTM1LGk9NSksYS52YWw9bnVsbCE9Zj9mOlwib1wiK2gsYS5zaXplPWk7fSxlLkNGRi5yZWFkQ2hhclN0cmluZz1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPXQrYSxvPWUuX2JpbixzPVtdO3Q8bjspe3ZhciBpPXJbdF0saD1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGY9MSxkPW51bGwsdT1udWxsO2k8PTIwJiYoZD1pLGY9MSksMTI9PWkmJihkPTEwMCppK2gsZj0yKSwxOSE9aSYmMjAhPWl8fChkPWksZj0yKSwyMTw9aSYmaTw9MjcmJihkPWksZj0xKSwyOD09aSYmKHU9by5yZWFkU2hvcnQocix0KzEpLGY9MyksMjk8PWkmJmk8PTMxJiYoZD1pLGY9MSksMzI8PWkmJmk8PTI0NiYmKHU9aS0xMzksZj0xKSwyNDc8PWkmJmk8PTI1MCYmKHU9MjU2KihpLTI0NykraCsxMDgsZj0yKSwyNTE8PWkmJmk8PTI1NCYmKHU9MjU2Ki0oaS0yNTEpLWgtMTA4LGY9MiksMjU1PT1pJiYodT1vLnJlYWRJbnQocix0KzEpLzY1NTM1LGY9NSkscy5wdXNoKG51bGwhPXU/dTpcIm9cIitkKSx0Kz1mO31yZXR1cm4gc30sZS5DRkYucmVhZERpY3Q9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1lLl9iaW4sbz17fSxzPVtdO3Q8YTspe3ZhciBpPXJbdF0saD1yW3QrMV07clt0KzJdLHJbdCszXSxyW3QrNF07dmFyIGY9MSxkPW51bGwsdT1udWxsO2lmKDI4PT1pJiYodT1uLnJlYWRTaG9ydChyLHQrMSksZj0zKSwyOT09aSYmKHU9bi5yZWFkSW50KHIsdCsxKSxmPTUpLDMyPD1pJiZpPD0yNDYmJih1PWktMTM5LGY9MSksMjQ3PD1pJiZpPD0yNTAmJih1PTI1NiooaS0yNDcpK2grMTA4LGY9MiksMjUxPD1pJiZpPD0yNTQmJih1PTI1NiotKGktMjUxKS1oLTEwOCxmPTIpLDI1NT09aSl0aHJvdyB1PW4ucmVhZEludChyLHQrMSkvNjU1MzUsZj01LFwidW5rbm93biBudW1iZXJcIjtpZigzMD09aSl7dmFyIGw9W107Zm9yKGY9MTs7KXt2YXIgdj1yW3QrZl07ZisrO3ZhciBjPXY+PjQscD0xNSZ2O2lmKDE1IT1jJiZsLnB1c2goYyksMTUhPXAmJmwucHVzaChwKSwxNT09cClicmVha31mb3IodmFyIFU9XCJcIixnPVswLDEsMiwzLDQsNSw2LDcsOCw5LFwiLlwiLFwiZVwiLFwiZS1cIixcInJlc2VydmVkXCIsXCItXCIsXCJlbmRPZk51bWJlclwiXSxTPTA7UzxsLmxlbmd0aDtTKyspVSs9Z1tsW1NdXTt1PXBhcnNlRmxvYXQoVSk7fWlmKGk8PTIxKWlmKGQ9W1widmVyc2lvblwiLFwiTm90aWNlXCIsXCJGdWxsTmFtZVwiLFwiRmFtaWx5TmFtZVwiLFwiV2VpZ2h0XCIsXCJGb250QkJveFwiLFwiQmx1ZVZhbHVlc1wiLFwiT3RoZXJCbHVlc1wiLFwiRmFtaWx5Qmx1ZXNcIixcIkZhbWlseU90aGVyQmx1ZXNcIixcIlN0ZEhXXCIsXCJTdGRWV1wiLFwiZXNjYXBlXCIsXCJVbmlxdWVJRFwiLFwiWFVJRFwiLFwiY2hhcnNldFwiLFwiRW5jb2RpbmdcIixcIkNoYXJTdHJpbmdzXCIsXCJQcml2YXRlXCIsXCJTdWJyc1wiLFwiZGVmYXVsdFdpZHRoWFwiLFwibm9taW5hbFdpZHRoWFwiXVtpXSxmPTEsMTI9PWkpZD1bXCJDb3B5cmlnaHRcIixcImlzRml4ZWRQaXRjaFwiLFwiSXRhbGljQW5nbGVcIixcIlVuZGVybGluZVBvc2l0aW9uXCIsXCJVbmRlcmxpbmVUaGlja25lc3NcIixcIlBhaW50VHlwZVwiLFwiQ2hhcnN0cmluZ1R5cGVcIixcIkZvbnRNYXRyaXhcIixcIlN0cm9rZVdpZHRoXCIsXCJCbHVlU2NhbGVcIixcIkJsdWVTaGlmdFwiLFwiQmx1ZUZ1enpcIixcIlN0ZW1TbmFwSFwiLFwiU3RlbVNuYXBWXCIsXCJGb3JjZUJvbGRcIiwwLDAsXCJMYW5ndWFnZUdyb3VwXCIsXCJFeHBhbnNpb25GYWN0b3JcIixcImluaXRpYWxSYW5kb21TZWVkXCIsXCJTeW50aGV0aWNCYXNlXCIsXCJQb3N0U2NyaXB0XCIsXCJCYXNlRm9udE5hbWVcIixcIkJhc2VGb250QmxlbmRcIiwwLDAsMCwwLDAsMCxcIlJPU1wiLFwiQ0lERm9udFZlcnNpb25cIixcIkNJREZvbnRSZXZpc2lvblwiLFwiQ0lERm9udFR5cGVcIixcIkNJRENvdW50XCIsXCJVSURCYXNlXCIsXCJGREFycmF5XCIsXCJGRFNlbGVjdFwiLFwiRm9udE5hbWVcIl1baF0sZj0yO251bGwhPWQ/KG9bZF09MT09cy5sZW5ndGg/c1swXTpzLHM9W10pOnMucHVzaCh1KSx0Kz1mO31yZXR1cm4gb30sZS5jbWFwPXt9LGUuY21hcC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7cj1uZXcgVWludDhBcnJheShyLmJ1ZmZlcix0LGEpLHQ9MDt2YXIgbj1lLl9iaW4sbz17fTtuLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGk9W107by50YWJsZXM9W107Zm9yKHZhciBoPTA7aDxzO2grKyl7dmFyIGY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PW4ucmVhZFVpbnQocix0KTt0Kz00O3ZhciBsPVwicFwiK2YrXCJlXCIrZCx2PWkuaW5kZXhPZih1KTtpZigtMT09dil7dmFyIGM7dj1vLnRhYmxlcy5sZW5ndGgsaS5wdXNoKHUpO3ZhciBwPW4ucmVhZFVzaG9ydChyLHUpOzA9PXA/Yz1lLmNtYXAucGFyc2UwKHIsdSk6ND09cD9jPWUuY21hcC5wYXJzZTQocix1KTo2PT1wP2M9ZS5jbWFwLnBhcnNlNihyLHUpOjEyPT1wP2M9ZS5jbWFwLnBhcnNlMTIocix1KTpjb25zb2xlLmRlYnVnKFwidW5rbm93biBmb3JtYXQ6IFwiK3AsZixkLHUpLG8udGFibGVzLnB1c2goYyk7fWlmKG51bGwhPW9bbF0pdGhyb3cgXCJtdWx0aXBsZSB0YWJsZXMgZm9yIG9uZSBwbGF0Zm9ybStlbmNvZGluZ1wiO29bbF09djt9cmV0dXJuIG99LGUuY21hcC5wYXJzZTA9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixuLm1hcD1bXTtmb3IodmFyIHM9MDtzPG8tNjtzKyspbi5tYXAucHVzaChyW3Qrc10pO3JldHVybiBufSxlLmNtYXAucGFyc2U0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9O28uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBpPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGg9aS8yO28uc2VhcmNoUmFuZ2U9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLmVudHJ5U2VsZWN0b3I9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLnJhbmdlU2hpZnQ9YS5yZWFkVXNob3J0KHIsdCksdCs9MixvLmVuZENvdW50PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCx0Kz0yLG8uc3RhcnRDb3VudD1hLnJlYWRVc2hvcnRzKHIsdCxoKSx0Kz0yKmgsby5pZERlbHRhPVtdO2Zvcih2YXIgZj0wO2Y8aDtmKyspby5pZERlbHRhLnB1c2goYS5yZWFkU2hvcnQocix0KSksdCs9Mjtmb3Ioby5pZFJhbmdlT2Zmc2V0PWEucmVhZFVzaG9ydHMocix0LGgpLHQrPTIqaCxvLmdseXBoSWRBcnJheT1bXTt0PG4rczspby5nbHlwaElkQXJyYXkucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9MjtyZXR1cm4gb30sZS5jbWFwLnBhcnNlNj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4uZmlyc3RDb2RlPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9MixuLmdseXBoSWRBcnJheT1bXTtmb3IodmFyIHM9MDtzPG87cysrKW4uZ2x5cGhJZEFycmF5LnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG59LGUuY21hcC5wYXJzZTEyPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mix0Kz0yLGEucmVhZFVpbnQocix0KSx0Kz00LGEucmVhZFVpbnQocix0KSx0Kz00O3ZhciBvPWEucmVhZFVpbnQocix0KTt0Kz00LG4uZ3JvdXBzPVtdO2Zvcih2YXIgcz0wO3M8bztzKyspe3ZhciBpPXQrMTIqcyxoPWEucmVhZFVpbnQocixpKzApLGY9YS5yZWFkVWludChyLGkrNCksZD1hLnJlYWRVaW50KHIsaSs4KTtuLmdyb3Vwcy5wdXNoKFtoLGYsZF0pO31yZXR1cm4gbn0sZS5nbHlmPXt9LGUuZ2x5Zi5wYXJzZT1mdW5jdGlvbihyLGUsdCxhKXtmb3IodmFyIG49W10sbz0wO288YS5tYXhwLm51bUdseXBocztvKyspbi5wdXNoKG51bGwpO3JldHVybiBufSxlLmdseWYuX3BhcnNlR2x5Zj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXIuX2RhdGEsbz1lLl90YWJPZmZzZXQobixcImdseWZcIixyLl9vZmZzZXQpK3IubG9jYVt0XTtpZihyLmxvY2FbdF09PXIubG9jYVt0KzFdKXJldHVybiBudWxsO3ZhciBzPXt9O2lmKHMubm9jPWEucmVhZFNob3J0KG4sbyksbys9MixzLnhNaW49YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueU1pbj1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy54TWF4PWEucmVhZFNob3J0KG4sbyksbys9MixzLnlNYXg9YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueE1pbj49cy54TWF4fHxzLnlNaW4+PXMueU1heClyZXR1cm4gbnVsbDtpZihzLm5vYz4wKXtzLmVuZFB0cz1bXTtmb3IodmFyIGk9MDtpPHMubm9jO2krKylzLmVuZFB0cy5wdXNoKGEucmVhZFVzaG9ydChuLG8pKSxvKz0yO3ZhciBoPWEucmVhZFVzaG9ydChuLG8pO2lmKG8rPTIsbi5sZW5ndGgtbzxoKXJldHVybiBudWxsO3MuaW5zdHJ1Y3Rpb25zPWEucmVhZEJ5dGVzKG4sbyxoKSxvKz1oO3ZhciBmPXMuZW5kUHRzW3Mubm9jLTFdKzE7cy5mbGFncz1bXTtmb3IoaT0wO2k8ZjtpKyspe3ZhciBkPW5bb107aWYobysrLHMuZmxhZ3MucHVzaChkKSwwIT0oOCZkKSl7dmFyIHU9bltvXTtvKys7Zm9yKHZhciBsPTA7bDx1O2wrKylzLmZsYWdzLnB1c2goZCksaSsrO319cy54cz1bXTtmb3IoaT0wO2k8ZjtpKyspe3ZhciB2PTAhPSgyJnMuZmxhZ3NbaV0pLGM9MCE9KDE2JnMuZmxhZ3NbaV0pO3Y/KHMueHMucHVzaChjP25bb106LW5bb10pLG8rKyk6Yz9zLnhzLnB1c2goMCk6KHMueHMucHVzaChhLnJlYWRTaG9ydChuLG8pKSxvKz0yKTt9cy55cz1bXTtmb3IoaT0wO2k8ZjtpKyspe3Y9MCE9KDQmcy5mbGFnc1tpXSksYz0wIT0oMzImcy5mbGFnc1tpXSk7dj8ocy55cy5wdXNoKGM/bltvXTotbltvXSksbysrKTpjP3MueXMucHVzaCgwKToocy55cy5wdXNoKGEucmVhZFNob3J0KG4sbykpLG8rPTIpO312YXIgcD0wLFU9MDtmb3IoaT0wO2k8ZjtpKyspcCs9cy54c1tpXSxVKz1zLnlzW2ldLHMueHNbaV09cCxzLnlzW2ldPVU7fWVsc2Uge3ZhciBnO3MucGFydHM9W107ZG97Zz1hLnJlYWRVc2hvcnQobixvKSxvKz0yO3ZhciBTPXttOnthOjEsYjowLGM6MCxkOjEsdHg6MCx0eTowfSxwMTotMSxwMjotMX07aWYocy5wYXJ0cy5wdXNoKFMpLFMuZ2x5cGhJbmRleD1hLnJlYWRVc2hvcnQobixvKSxvKz0yLDEmZyl7dmFyIG09YS5yZWFkU2hvcnQobixvKTtvKz0yO3ZhciBiPWEucmVhZFNob3J0KG4sbyk7bys9Mjt9ZWxzZSB7bT1hLnJlYWRJbnQ4KG4sbyk7bysrO2I9YS5yZWFkSW50OChuLG8pO28rKzt9MiZnPyhTLm0udHg9bSxTLm0udHk9Yik6KFMucDE9bSxTLnAyPWIpLDgmZz8oUy5tLmE9Uy5tLmQ9YS5yZWFkRjJkb3QxNChuLG8pLG8rPTIpOjY0Jmc/KFMubS5hPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKToxMjgmZyYmKFMubS5hPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5iPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5jPWEucmVhZEYyZG90MTQobixvKSxvKz0yLFMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKTt9d2hpbGUoMzImZyk7aWYoMjU2Jmcpe3ZhciB5PWEucmVhZFVzaG9ydChuLG8pO28rPTIscy5pbnN0cj1bXTtmb3IoaT0wO2k8eTtpKyspcy5pbnN0ci5wdXNoKG5bb10pLG8rKzt9fXJldHVybiBzfSxlLkdQT1M9e30sZS5HUE9TLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3JldHVybiBlLl9sY3RmLnBhcnNlKHIsdCxhLG4sZS5HUE9TLnN1YnQpfSxlLkdQT1Muc3VidD1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1hLGk9e307aWYoaS5mbXQ9by5yZWFkVXNob3J0KHIsYSksYSs9MiwxPT10fHwyPT10fHwzPT10fHw3PT10fHw4PT10JiZpLmZtdDw9Mil7dmFyIGg9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsaCtzKTt9aWYoMT09dCYmMT09aS5mbXQpe3ZhciBmPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIGQ9ZS5fbGN0Zi5udW1PZk9uZXMoZik7MCE9ZiYmKGkucG9zPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixhLGYpKTt9ZWxzZSBpZigyPT10JiZpLmZtdD49MSYmaS5mbXQ8PTIpe2Y9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgdT1vLnJlYWRVc2hvcnQocixhKTthKz0yO2Q9ZS5fbGN0Zi5udW1PZk9uZXMoZik7dmFyIGw9ZS5fbGN0Zi5udW1PZk9uZXModSk7aWYoMT09aS5mbXQpe2kucGFpcnNldHM9W107dmFyIHY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IodmFyIGM9MDtjPHY7YysrKXt2YXIgcD1zK28ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIFU9by5yZWFkVXNob3J0KHIscCk7cCs9Mjtmb3IodmFyIGc9W10sUz0wO1M8VTtTKyspe3ZhciBtPW8ucmVhZFVzaG9ydChyLHApO3ArPTIsMCE9ZiYmKHg9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLHAsZikscCs9MipkKSwwIT11JiYoUD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIscCx1KSxwKz0yKmwpLGcucHVzaCh7Z2lkMjptLHZhbDE6eCx2YWwyOlB9KTt9aS5wYWlyc2V0cy5wdXNoKGcpO319aWYoMj09aS5mbXQpe3ZhciBiPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHk9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgRj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBfPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5jbGFzc0RlZjE9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK2IpLGkuY2xhc3NEZWYyPWUuX2xjdGYucmVhZENsYXNzRGVmKHIscyt5KSxpLm1hdHJpeD1bXTtmb3IoYz0wO2M8RjtjKyspe3ZhciBDPVtdO2ZvcihTPTA7UzxfO1MrKyl7dmFyIHg9bnVsbCxQPW51bGw7MCE9ZiYmKHg9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLGEsZiksYSs9MipkKSwwIT11JiYoUD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIsYSx1KSxhKz0yKmwpLEMucHVzaCh7dmFsMTp4LHZhbDI6UH0pO31pLm1hdHJpeC5wdXNoKEMpO319fWVsc2Uge2lmKDk9PXQmJjE9PWkuZm10KXt2YXIgST1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB3PW8ucmVhZFVpbnQocixhKTtpZihhKz00LDk9PW4ubHR5cGUpbi5sdHlwZT1JO2Vsc2UgaWYobi5sdHlwZSE9SSl0aHJvdyBcImludmFsaWQgZXh0ZW5zaW9uIHN1YnN0aXR1dGlvblwiO3JldHVybiBlLkdQT1Muc3VidChyLG4ubHR5cGUscyt3KX1jb25zb2xlLmRlYnVnKFwidW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSBMb29rdXBUeXBlXCIsdCxcImZvcm1hdFwiLGkuZm10KTt9cmV0dXJuIGl9LGUuR1BPUy5yZWFkVmFsdWVSZWNvcmQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtdO3JldHVybiBvLnB1c2goMSZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9MSZhPzI6MCxvLnB1c2goMiZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9MiZhPzI6MCxvLnB1c2goNCZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9NCZhPzI6MCxvLnB1c2goOCZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9OCZhPzI6MCxvfSxlLkdTVUI9e30sZS5HU1VCLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3JldHVybiBlLl9sY3RmLnBhcnNlKHIsdCxhLG4sZS5HU1VCLnN1YnQpfSxlLkdTVUIuc3VidD1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1hLGk9e307aWYoaS5mbXQ9by5yZWFkVXNob3J0KHIsYSksYSs9MiwxIT10JiY0IT10JiY1IT10JiY2IT10KXJldHVybiBudWxsO2lmKDE9PXR8fDQ9PXR8fDU9PXQmJmkuZm10PD0yfHw2PT10JiZpLmZtdDw9Mil7dmFyIGg9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIscytoKTt9aWYoMT09dCYmaS5mbXQ+PTEmJmkuZm10PD0yKXtpZigxPT1pLmZtdClpLmRlbHRhPW8ucmVhZFNob3J0KHIsYSksYSs9MjtlbHNlIGlmKDI9PWkuZm10KXt2YXIgZj1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkubmV3Zz1vLnJlYWRVc2hvcnRzKHIsYSxmKSxhKz0yKmkubmV3Zy5sZW5ndGg7fX1lbHNlIGlmKDQ9PXQpe2kudmFscz1bXTtmPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7Zm9yKHZhciBkPTA7ZDxmO2QrKyl7dmFyIHU9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLnZhbHMucHVzaChlLkdTVUIucmVhZExpZ2F0dXJlU2V0KHIscyt1KSk7fX1lbHNlIGlmKDU9PXQmJjI9PWkuZm10KXtpZigyPT1pLmZtdCl7dmFyIGw9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNEZWY9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK2wpLGkuc2NzZXQ9W107dmFyIHY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IoZD0wO2Q8djtkKyspe3ZhciBjPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5zY3NldC5wdXNoKDA9PWM/bnVsbDplLkdTVUIucmVhZFN1YkNsYXNzU2V0KHIscytjKSk7fX19ZWxzZSBpZig2PT10JiYzPT1pLmZtdCl7aWYoMz09aS5mbXQpe2ZvcihkPTA7ZDwzO2QrKyl7Zj1vLnJlYWRVc2hvcnQocixhKTthKz0yO2Zvcih2YXIgcD1bXSxVPTA7VTxmO1UrKylwLnB1c2goZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixzK28ucmVhZFVzaG9ydChyLGErMipVKSkpO2ErPTIqZiwwPT1kJiYoaS5iYWNrQ3ZnPXApLDE9PWQmJihpLmlucHRDdmc9cCksMj09ZCYmKGkuYWhlZEN2Zz1wKTt9Zj1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkubG9va3VwUmVjPWUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzKHIsYSxmKTt9fWVsc2Uge2lmKDc9PXQmJjE9PWkuZm10KXt2YXIgZz1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBTPW8ucmVhZFVpbnQocixhKTtpZihhKz00LDk9PW4ubHR5cGUpbi5sdHlwZT1nO2Vsc2UgaWYobi5sdHlwZSE9Zyl0aHJvdyBcImludmFsaWQgZXh0ZW5zaW9uIHN1YnN0aXR1dGlvblwiO3JldHVybiBlLkdTVUIuc3VidChyLG4ubHR5cGUscytTKX1jb25zb2xlLmRlYnVnKFwidW5zdXBwb3J0ZWQgR1NVQiB0YWJsZSBMb29rdXBUeXBlXCIsdCxcImZvcm1hdFwiLGkuZm10KTt9cmV0dXJuIGl9LGUuR1NVQi5yZWFkU3ViQ2xhc3NTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4ucmVhZFVzaG9ydCxuPXQsbz1bXSxzPWEocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEocix0KTt0Kz0yLG8ucHVzaChlLkdTVUIucmVhZFN1YkNsYXNzUnVsZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRTdWJDbGFzc1J1bGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4ucmVhZFVzaG9ydCxuPXt9LG89YShyLHQpLHM9YShyLHQrPTIpO3QrPTIsbi5pbnB1dD1bXTtmb3IodmFyIGk9MDtpPG8tMTtpKyspbi5pbnB1dC5wdXNoKGEocix0KSksdCs9MjtyZXR1cm4gbi5zdWJzdExvb2t1cFJlY29yZHM9ZS5HU1VCLnJlYWRTdWJzdExvb2t1cFJlY29yZHMocix0LHMpLG59LGUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLnJlYWRVc2hvcnQsbz1bXSxzPTA7czxhO3MrKylvLnB1c2gobihyLHQpLG4ocix0KzIpKSx0Kz00O3JldHVybiBvfSxlLkdTVUIucmVhZENoYWluU3ViQ2xhc3NTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1J1bGUocixuK2gpKTt9cmV0dXJuIG99LGUuR1NVQi5yZWFkQ2hhaW5TdWJDbGFzc1J1bGU9ZnVuY3Rpb24ocix0KXtmb3IodmFyIGE9ZS5fYmluLG49e30sbz1bXCJiYWNrdHJhY2tcIixcImlucHV0XCIsXCJsb29rYWhlYWRcIl0scz0wO3M8by5sZW5ndGg7cysrKXt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLDE9PXMmJmktLSxuW29bc11dPWEucmVhZFVzaG9ydHMocix0LGkpLHQrPTIqbltvW3NdXS5sZW5ndGg7fWk9YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsbi5zdWJzdD1hLnJlYWRVc2hvcnRzKHIsdCwyKmkpLHQrPTIqbi5zdWJzdC5sZW5ndGgsbn0sZS5HU1VCLnJlYWRMaWdhdHVyZVNldD1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz1bXSxzPWEucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixvLnB1c2goZS5HU1VCLnJlYWRMaWdhdHVyZShyLG4raCkpO31yZXR1cm4gb30sZS5HU1VCLnJlYWRMaWdhdHVyZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXtjaGFpbjpbXX07bi5uZ2x5cGg9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgcz0wO3M8by0xO3MrKyluLmNoYWluLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG59LGUuaGVhZD17fSxlLmhlYWQucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBuLnJlYWRGaXhlZChyLHQpLHQrPTQsby5mb250UmV2aXNpb249bi5yZWFkRml4ZWQocix0KSx0Kz00LG4ucmVhZFVpbnQocix0KSx0Kz00LG4ucmVhZFVpbnQocix0KSx0Kz00LG8uZmxhZ3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLnVuaXRzUGVyRW09bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLmNyZWF0ZWQ9bi5yZWFkVWludDY0KHIsdCksdCs9OCxvLm1vZGlmaWVkPW4ucmVhZFVpbnQ2NChyLHQpLHQrPTgsby54TWluPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnlNaW49bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueE1heD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby55TWF4PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm1hY1N0eWxlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5sb3dlc3RSZWNQUEVNPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5mb250RGlyZWN0aW9uSGludD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5pbmRleFRvTG9jRm9ybWF0PW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmdseXBoRGF0YUZvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsb30sZS5oaGVhPXt9LGUuaGhlYS5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307cmV0dXJuIG4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLmFzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmRlc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5saW5lR2FwPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmFkdmFuY2VXaWR0aE1heD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWluTGVmdFNpZGVCZWFyaW5nPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLm1pblJpZ2h0U2lkZUJlYXJpbmc9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueE1heEV4dGVudD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldFNsb3BlUmlzZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldFNsb3BlUnVuPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLmNhcmV0T2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9Mix0Kz04LG8ubWV0cmljRGF0YUZvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5udW1iZXJPZkhNZXRyaWNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsb30sZS5obXR4PXt9LGUuaG10eC5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXtmb3IodmFyIG89ZS5fYmluLHM9e2FXaWR0aDpbXSxsc0JlYXJpbmc6W119LGk9MCxoPTAsZj0wO2Y8bi5tYXhwLm51bUdseXBocztmKyspZjxuLmhoZWEubnVtYmVyT2ZITWV0cmljcyYmKGk9by5yZWFkVXNob3J0KHIsdCksdCs9MixoPW8ucmVhZFNob3J0KHIsdCksdCs9Mikscy5hV2lkdGgucHVzaChpKSxzLmxzQmVhcmluZy5wdXNoKGgpO3JldHVybiBzfSxlLmtlcm49e30sZS5rZXJuLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPW8ucmVhZFVzaG9ydChyLHQpO2lmKHQrPTIsMT09cylyZXR1cm4gZS5rZXJuLnBhcnNlVjEocix0LTIsYSxuKTt2YXIgaT1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD17Z2x5cGgxOltdLHJ2YWw6W119LGY9MDtmPGk7ZisrKXt0Kz0yO2E9by5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1vLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PWQ+Pj44O2lmKDAhPSh1Jj0xNSkpdGhyb3cgXCJ1bmtub3duIGtlcm4gdGFibGUgZm9ybWF0OiBcIit1O3Q9ZS5rZXJuLnJlYWRGb3JtYXQwKHIsdCxoKTt9cmV0dXJuIGh9LGUua2Vybi5wYXJzZVYxPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbjtvLnJlYWRGaXhlZChyLHQpLHQrPTQ7dmFyIHM9by5yZWFkVWludChyLHQpO3QrPTQ7Zm9yKHZhciBpPXtnbHlwaDE6W10scnZhbDpbXX0saD0wO2g8cztoKyspe28ucmVhZFVpbnQocix0KSx0Kz00O3ZhciBmPW8ucmVhZFVzaG9ydChyLHQpO3QrPTIsby5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgZD1mPj4+ODtpZigwIT0oZCY9MTUpKXRocm93IFwidW5rbm93biBrZXJuIHRhYmxlIGZvcm1hdDogXCIrZDt0PWUua2Vybi5yZWFkRm9ybWF0MChyLHQsaSk7fXJldHVybiBpfSxlLmtlcm4ucmVhZEZvcm1hdDA9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPS0xLHM9bi5yZWFkVXNob3J0KHIsdCk7dCs9MixuLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5yZWFkVXNob3J0KHIsdCksdCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGQ9bi5yZWFkU2hvcnQocix0KTt0Kz0yLGghPW8mJihhLmdseXBoMS5wdXNoKGgpLGEucnZhbC5wdXNoKHtnbHlwaDI6W10sdmFsczpbXX0pKTt2YXIgdT1hLnJ2YWxbYS5ydmFsLmxlbmd0aC0xXTt1LmdseXBoMi5wdXNoKGYpLHUudmFscy5wdXNoKGQpLG89aDt9cmV0dXJuIHR9LGUubG9jYT17fSxlLmxvY2EucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7dmFyIG89ZS5fYmluLHM9W10saT1uLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdCxoPW4ubWF4cC5udW1HbHlwaHMrMTtpZigwPT1pKWZvcih2YXIgZj0wO2Y8aDtmKyspcy5wdXNoKG8ucmVhZFVzaG9ydChyLHQrKGY8PDEpKTw8MSk7aWYoMT09aSlmb3IoZj0wO2Y8aDtmKyspcy5wdXNoKG8ucmVhZFVpbnQocix0KyhmPDwyKSkpO3JldHVybiBzfSxlLm1heHA9e30sZS5tYXhwLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fSxzPW4ucmVhZFVpbnQocix0KTtyZXR1cm4gdCs9NCxvLm51bUdseXBocz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLDY1NTM2PT1zJiYoby5tYXhQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbnRvdXJzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb3NpdGVQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvc2l0ZUNvbnRvdXJzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhab25lcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4VHdpbGlnaHRQb2ludHM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFN0b3JhZ2U9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heEZ1bmN0aW9uRGVmcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4SW5zdHJ1Y3Rpb25EZWZzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTdGFja0VsZW1lbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTaXplT2ZJbnN0cnVjdGlvbnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heENvbXBvbmVudEVsZW1lbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb25lbnREZXB0aD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yKSxvfSxlLm5hbWU9e30sZS5uYW1lLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtuLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsbi5yZWFkVXNob3J0KHIsdCk7Zm9yKHZhciBpLGg9W1wiY29weXJpZ2h0XCIsXCJmb250RmFtaWx5XCIsXCJmb250U3ViZmFtaWx5XCIsXCJJRFwiLFwiZnVsbE5hbWVcIixcInZlcnNpb25cIixcInBvc3RTY3JpcHROYW1lXCIsXCJ0cmFkZW1hcmtcIixcIm1hbnVmYWN0dXJlclwiLFwiZGVzaWduZXJcIixcImRlc2NyaXB0aW9uXCIsXCJ1cmxWZW5kb3JcIixcInVybERlc2lnbmVyXCIsXCJsaWNlbmNlXCIsXCJsaWNlbmNlVVJMXCIsXCItLS1cIixcInR5cG9GYW1pbHlOYW1lXCIsXCJ0eXBvU3ViZmFtaWx5TmFtZVwiLFwiY29tcGF0aWJsZUZ1bGxcIixcInNhbXBsZVRleHRcIixcInBvc3RTY3JpcHRDSURcIixcInd3c0ZhbWlseU5hbWVcIixcInd3c1N1YmZhbWlseU5hbWVcIixcImxpZ2h0UGFsZXR0ZVwiLFwiZGFya1BhbGV0dGVcIl0sZj10Kz0yLGQ9MDtkPHM7ZCsrKXt2YXIgdT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBsPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIHY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgYz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBwPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIFU9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZyxTPWhbY10sbT1mKzEyKnMrVTtpZigwPT11KWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIGlmKDM9PXUmJjA9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMD09bClnPW4ucmVhZEFTQ0lJKHIsbSxwKTtlbHNlIGlmKDE9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2UgaWYoMz09bClnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSB7aWYoMSE9dSl0aHJvdyBcInVua25vd24gZW5jb2RpbmcgXCIrbCtcIiwgcGxhdGZvcm1JRDogXCIrdTtnPW4ucmVhZEFTQ0lJKHIsbSxwKSxjb25zb2xlLmRlYnVnKFwicmVhZGluZyB1bmtub3duIE1BQyBlbmNvZGluZyBcIitsK1wiIGFzIEFTQ0lJXCIpO312YXIgYj1cInBcIit1K1wiLFwiK3YudG9TdHJpbmcoMTYpO251bGw9PW9bYl0mJihvW2JdPXt9KSxvW2JdW3ZvaWQgMCE9PVM/UzpjXT1nLG9bYl0uX2xhbmc9djt9Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSYmMTAzMz09b1t5XS5fbGFuZylyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lJiYwPT1vW3ldLl9sYW5nKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUmJjMwODQ9PW9beV0uX2xhbmcpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSlyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbyl7aT15O2JyZWFrfXJldHVybiBjb25zb2xlLmRlYnVnKFwicmV0dXJuaW5nIG5hbWUgdGFibGUgd2l0aCBsYW5ndWFnZUlEIFwiK29baV0uX2xhbmcpLG9baV19LGVbXCJPUy8yXCJdPXt9LGVbXCJPUy8yXCJdLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIG89e307aWYoMD09billW1wiT1MvMlwiXS52ZXJzaW9uMChyLHQsbyk7ZWxzZSBpZigxPT1uKWVbXCJPUy8yXCJdLnZlcnNpb24xKHIsdCxvKTtlbHNlIGlmKDI9PW58fDM9PW58fDQ9PW4pZVtcIk9TLzJcIl0udmVyc2lvbjIocix0LG8pO2Vsc2Uge2lmKDUhPW4pdGhyb3cgXCJ1bmtub3duIE9TLzIgdGFibGUgdmVyc2lvbjogXCIrbjtlW1wiT1MvMlwiXS52ZXJzaW9uNShyLHQsbyk7fXJldHVybiBvfSxlW1wiT1MvMlwiXS52ZXJzaW9uMD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiBhLnhBdmdDaGFyV2lkdGg9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEudXNXZWlnaHRDbGFzcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNXaWR0aENsYXNzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5mc1R5cGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRYU2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WVNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFhPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFlPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WFNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WVNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WE9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3VwZXJzY3JpcHRZT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdHJpa2VvdXRTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdHJpa2VvdXRQb3NpdGlvbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zRmFtaWx5Q2xhc3M9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEucGFub3NlPW4ucmVhZEJ5dGVzKHIsdCwxMCksdCs9MTAsYS51bFVuaWNvZGVSYW5nZTE9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTI9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTM9bi5yZWFkVWludChyLHQpLHQrPTQsYS51bFVuaWNvZGVSYW5nZTQ9bi5yZWFkVWludChyLHQpLHQrPTQsYS5hY2hWZW5kSUQ9W24ucmVhZEludDgocix0KSxuLnJlYWRJbnQ4KHIsdCsxKSxuLnJlYWRJbnQ4KHIsdCsyKSxuLnJlYWRJbnQ4KHIsdCszKV0sdCs9NCxhLmZzU2VsZWN0aW9uPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0ZpcnN0Q2hhckluZGV4PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c0xhc3RDaGFySW5kZXg9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnNUeXBvQXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc1R5cG9EZXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc1R5cG9MaW5lR2FwPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzV2luQXNjZW50PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c1dpbkRlc2NlbnQ9bi5yZWFkVXNob3J0KHIsdCksdCs9Mn0sZVtcIk9TLzJcIl0udmVyc2lvbjE9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMChyLHQsYSksYS51bENvZGVQYWdlUmFuZ2UxPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxDb2RlUGFnZVJhbmdlMj1uLnJlYWRVaW50KHIsdCksdCs9NH0sZVtcIk9TLzJcIl0udmVyc2lvbjI9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gdD1lW1wiT1MvMlwiXS52ZXJzaW9uMShyLHQsYSksYS5zeEhlaWdodD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS5zQ2FwSGVpZ2h0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzRGVmYXVsdD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNCcmVhaz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNNYXhDb250ZXh0PW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGVbXCJPUy8yXCJdLnZlcnNpb241PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIHQ9ZVtcIk9TLzJcIl0udmVyc2lvbjIocix0LGEpLGEudXNMb3dlck9wdGljYWxQb2ludFNpemU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzVXBwZXJPcHRpY2FsUG9pbnRTaXplPW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGUucG9zdD17fSxlLnBvc3QucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBvLnZlcnNpb249bi5yZWFkRml4ZWQocix0KSx0Kz00LG8uaXRhbGljQW5nbGU9bi5yZWFkRml4ZWQocix0KSx0Kz00LG8udW5kZXJsaW5lUG9zaXRpb249bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8udW5kZXJsaW5lVGhpY2tuZXNzPW4ucmVhZFNob3J0KHIsdCksdCs9MixvfSxudWxsPT1lJiYoZT17fSksbnVsbD09ZS5VJiYoZS5VPXt9KSxlLlUuY29kZVRvR2x5cGg9ZnVuY3Rpb24ocixlKXt2YXIgdD1yLmNtYXAsYT0tMTtpZihudWxsIT10LnAwZTQ/YT10LnAwZTQ6bnVsbCE9dC5wM2UxP2E9dC5wM2UxOm51bGwhPXQucDFlMD9hPXQucDFlMDpudWxsIT10LnAwZTMmJihhPXQucDBlMyksLTE9PWEpdGhyb3cgXCJubyBmYW1pbGlhciBwbGF0Zm9ybSBhbmQgZW5jb2RpbmchXCI7dmFyIG49dC50YWJsZXNbYV07aWYoMD09bi5mb3JtYXQpcmV0dXJuIGU+PW4ubWFwLmxlbmd0aD8wOm4ubWFwW2VdO2lmKDQ9PW4uZm9ybWF0KXtmb3IodmFyIG89LTEscz0wO3M8bi5lbmRDb3VudC5sZW5ndGg7cysrKWlmKGU8PW4uZW5kQ291bnRbc10pe289czticmVha31pZigtMT09bylyZXR1cm4gMDtpZihuLnN0YXJ0Q291bnRbb10+ZSlyZXR1cm4gMDtyZXR1cm4gNjU1MzUmKDAhPW4uaWRSYW5nZU9mZnNldFtvXT9uLmdseXBoSWRBcnJheVtlLW4uc3RhcnRDb3VudFtvXSsobi5pZFJhbmdlT2Zmc2V0W29dPj4xKS0obi5pZFJhbmdlT2Zmc2V0Lmxlbmd0aC1vKV06ZStuLmlkRGVsdGFbb10pfWlmKDEyPT1uLmZvcm1hdCl7aWYoZT5uLmdyb3Vwc1tuLmdyb3Vwcy5sZW5ndGgtMV1bMV0pcmV0dXJuIDA7Zm9yKHM9MDtzPG4uZ3JvdXBzLmxlbmd0aDtzKyspe3ZhciBpPW4uZ3JvdXBzW3NdO2lmKGlbMF08PWUmJmU8PWlbMV0pcmV0dXJuIGlbMl0rKGUtaVswXSl9cmV0dXJuIDB9dGhyb3cgXCJ1bmtub3duIGNtYXAgdGFibGUgZm9ybWF0IFwiK24uZm9ybWF0fSxlLlUuZ2x5cGhUb1BhdGg9ZnVuY3Rpb24ocix0KXt2YXIgYT17Y21kczpbXSxjcmRzOltdfTtpZihyLlNWRyYmci5TVkcuZW50cmllc1t0XSl7dmFyIG49ci5TVkcuZW50cmllc1t0XTtyZXR1cm4gbnVsbD09bj9hOihcInN0cmluZ1wiPT10eXBlb2YgbiYmKG49ZS5TVkcudG9QYXRoKG4pLHIuU1ZHLmVudHJpZXNbdF09biksbil9aWYoci5DRkYpe3ZhciBvPXt4OjAseTowLHN0YWNrOltdLG5TdGVtczowLGhhdmVXaWR0aDohMSx3aWR0aDpyLkNGRi5Qcml2YXRlP3IuQ0ZGLlByaXZhdGUuZGVmYXVsdFdpZHRoWDowLG9wZW46ITF9LHM9ci5DRkYsaT1yLkNGRi5Qcml2YXRlO2lmKHMuUk9TKXtmb3IodmFyIGg9MDtzLkZEU2VsZWN0W2grMl08PXQ7KWgrPTI7aT1zLkZEQXJyYXlbcy5GRFNlbGVjdFtoKzFdXS5Qcml2YXRlO31lLlUuX2RyYXdDRkYoci5DRkYuQ2hhclN0cmluZ3NbdF0sbyxzLGksYSk7fWVsc2Ugci5nbHlmJiZlLlUuX2RyYXdHbHlmKHQscixhKTtyZXR1cm4gYX0sZS5VLl9kcmF3R2x5Zj1mdW5jdGlvbihyLHQsYSl7dmFyIG49dC5nbHlmW3JdO251bGw9PW4mJihuPXQuZ2x5ZltyXT1lLmdseWYuX3BhcnNlR2x5Zih0LHIpKSxudWxsIT1uJiYobi5ub2M+LTE/ZS5VLl9zaW1wbGVHbHlwaChuLGEpOmUuVS5fY29tcG9HbHlwaChuLHQsYSkpO30sZS5VLl9zaW1wbGVHbHlwaD1mdW5jdGlvbihyLHQpe2Zvcih2YXIgYT0wO2E8ci5ub2M7YSsrKXtmb3IodmFyIG49MD09YT8wOnIuZW5kUHRzW2EtMV0rMSxvPXIuZW5kUHRzW2FdLHM9bjtzPD1vO3MrKyl7dmFyIGk9cz09bj9vOnMtMSxoPXM9PW8/bjpzKzEsZj0xJnIuZmxhZ3Nbc10sZD0xJnIuZmxhZ3NbaV0sdT0xJnIuZmxhZ3NbaF0sbD1yLnhzW3NdLHY9ci55c1tzXTtpZihzPT1uKWlmKGYpe2lmKCFkKXtlLlUuUC5tb3ZlVG8odCxsLHYpO2NvbnRpbnVlfWUuVS5QLm1vdmVUbyh0LHIueHNbaV0sci55c1tpXSk7fWVsc2UgZD9lLlUuUC5tb3ZlVG8odCxyLnhzW2ldLHIueXNbaV0pOmUuVS5QLm1vdmVUbyh0LChyLnhzW2ldK2wpLzIsKHIueXNbaV0rdikvMik7Zj9kJiZlLlUuUC5saW5lVG8odCxsLHYpOnU/ZS5VLlAucWN1cnZlVG8odCxsLHYsci54c1toXSxyLnlzW2hdKTplLlUuUC5xY3VydmVUbyh0LGwsdiwobCtyLnhzW2hdKS8yLCh2K3IueXNbaF0pLzIpO31lLlUuUC5jbG9zZVBhdGgodCk7fX0sZS5VLl9jb21wb0dseXBoPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49MDtuPHIucGFydHMubGVuZ3RoO24rKyl7dmFyIG89e2NtZHM6W10sY3JkczpbXX0scz1yLnBhcnRzW25dO2UuVS5fZHJhd0dseWYocy5nbHlwaEluZGV4LHQsbyk7Zm9yKHZhciBpPXMubSxoPTA7aDxvLmNyZHMubGVuZ3RoO2grPTIpe3ZhciBmPW8uY3Jkc1toXSxkPW8uY3Jkc1toKzFdO2EuY3Jkcy5wdXNoKGYqaS5hK2QqaS5iK2kudHgpLGEuY3Jkcy5wdXNoKGYqaS5jK2QqaS5kK2kudHkpO31mb3IoaD0wO2g8by5jbWRzLmxlbmd0aDtoKyspYS5jbWRzLnB1c2goby5jbWRzW2hdKTt9fSxlLlUuX2dldEdseXBoQ2xhc3M9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9sY3RmLmdldEludGVydmFsKHQscik7cmV0dXJuIC0xPT1hPzA6dFthKzJdfSxlLlUuZ2V0UGFpckFkanVzdG1lbnQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPSExO2lmKHIuR1BPUylmb3IodmFyIG89ci5HUE9TLHM9by5sb29rdXBMaXN0LGk9by5mZWF0dXJlTGlzdCxoPVtdLGY9MDtmPGkubGVuZ3RoO2YrKyl7dmFyIGQ9aVtmXTtpZihcImtlcm5cIj09ZC50YWcpe249ITA7Zm9yKHZhciB1PTA7dTxkLnRhYi5sZW5ndGg7dSsrKWlmKCFoW2QudGFiW3VdXSl7aFtkLnRhYlt1XV09ITA7Zm9yKHZhciBsPXNbZC50YWJbdV1dLHY9MDt2PGwudGFicy5sZW5ndGg7disrKWlmKG51bGwhPWwudGFic1t2XSl7dmFyIGMscD1sLnRhYnNbdl07aWYoIXAuY292ZXJhZ2V8fC0xIT0oYz1lLl9sY3RmLmNvdmVyYWdlSW5kZXgocC5jb3ZlcmFnZSx0KSkpaWYoMT09bC5sdHlwZSk7ZWxzZSBpZigyPT1sLmx0eXBlKXt2YXIgVT1udWxsO2lmKDE9PXAuZm10KXt2YXIgZz1wLnBhaXJzZXRzW2NdO2ZvcihmPTA7ZjxnLmxlbmd0aDtmKyspZ1tmXS5naWQyPT1hJiYoVT1nW2ZdKTt9ZWxzZSBpZigyPT1wLmZtdCl7dmFyIFM9ZS5VLl9nZXRHbHlwaENsYXNzKHQscC5jbGFzc0RlZjEpLG09ZS5VLl9nZXRHbHlwaENsYXNzKGEscC5jbGFzc0RlZjIpO1U9cC5tYXRyaXhbU11bbV07fWlmKFUpe3ZhciBiPTA7cmV0dXJuIFUudmFsMSYmVS52YWwxWzJdJiYoYis9VS52YWwxWzJdKSxVLnZhbDImJlUudmFsMlswXSYmKGIrPVUudmFsMlswXSksYn19fX19fWlmKHIua2VybiYmIW4pe3ZhciB5PXIua2Vybi5nbHlwaDEuaW5kZXhPZih0KTtpZigtMSE9eSl7dmFyIEY9ci5rZXJuLnJ2YWxbeV0uZ2x5cGgyLmluZGV4T2YoYSk7aWYoLTEhPUYpcmV0dXJuIHIua2Vybi5ydmFsW3ldLnZhbHNbRl19fXJldHVybiAwfSxlLlUuX2FwcGx5U3Vicz1mdW5jdGlvbihyLHQsYSxuKXtmb3IodmFyIG89ci5sZW5ndGgtdC0xLHM9MDtzPGEudGFicy5sZW5ndGg7cysrKWlmKG51bGwhPWEudGFic1tzXSl7dmFyIGksaD1hLnRhYnNbc107aWYoIWguY292ZXJhZ2V8fC0xIT0oaT1lLl9sY3RmLmNvdmVyYWdlSW5kZXgoaC5jb3ZlcmFnZSxyW3RdKSkpaWYoMT09YS5sdHlwZSlyW3RdLDE9PWguZm10P3JbdF09clt0XStoLmRlbHRhOnJbdF09aC5uZXdnW2ldO2Vsc2UgaWYoND09YS5sdHlwZSlmb3IodmFyIGY9aC52YWxzW2ldLGQ9MDtkPGYubGVuZ3RoO2QrKyl7dmFyIHU9ZltkXSxsPXUuY2hhaW4ubGVuZ3RoO2lmKCEobD5vKSl7Zm9yKHZhciB2PSEwLGM9MCxwPTA7cDxsO3ArKyl7Zm9yKDstMT09clt0K2MrKDErcCldOyljKys7dS5jaGFpbltwXSE9clt0K2MrKDErcCldJiYodj0hMSk7fWlmKHYpe3JbdF09dS5uZ2x5cGg7Zm9yKHA9MDtwPGwrYztwKyspclt0K3ArMV09LTE7YnJlYWt9fX1lbHNlIGlmKDU9PWEubHR5cGUmJjI9PWguZm10KWZvcih2YXIgVT1lLl9sY3RmLmdldEludGVydmFsKGguY0RlZixyW3RdKSxnPWguY0RlZltVKzJdLFM9aC5zY3NldFtnXSxtPTA7bTxTLmxlbmd0aDttKyspe3ZhciBiPVNbbV0seT1iLmlucHV0O2lmKCEoeS5sZW5ndGg+bykpe2Zvcih2PSEwLHA9MDtwPHkubGVuZ3RoO3ArKyl7dmFyIEY9ZS5fbGN0Zi5nZXRJbnRlcnZhbChoLmNEZWYsclt0KzErcF0pO2lmKC0xPT1VJiZoLmNEZWZbRisyXSE9eVtwXSl7dj0hMTticmVha319aWYodil7dmFyIF89Yi5zdWJzdExvb2t1cFJlY29yZHM7Zm9yKGQ9MDtkPF8ubGVuZ3RoO2QrPTIpX1tkXSxfW2QrMV07fX19ZWxzZSBpZig2PT1hLmx0eXBlJiYzPT1oLmZtdCl7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguYmFja0N2Zyx0LWguYmFja0N2Zy5sZW5ndGgpKWNvbnRpbnVlO2lmKCFlLlUuX2dsc0NvdmVyZWQocixoLmlucHRDdmcsdCkpY29udGludWU7aWYoIWUuVS5fZ2xzQ292ZXJlZChyLGguYWhlZEN2Zyx0K2guaW5wdEN2Zy5sZW5ndGgpKWNvbnRpbnVlO3ZhciBDPWgubG9va3VwUmVjO2ZvcihtPTA7bTxDLmxlbmd0aDttKz0yKXtVPUNbbV07dmFyIHg9bltDW20rMV1dO2UuVS5fYXBwbHlTdWJzKHIsdCtVLHgsbik7fX19fSxlLlUuX2dsc0NvdmVyZWQ9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXtpZigtMT09ZS5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRbbl0sclthK25dKSlyZXR1cm4gITF9cmV0dXJuICEwfSxlLlUuZ2x5cGhzVG9QYXRoPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49e2NtZHM6W10sY3JkczpbXX0sbz0wLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIGk9dFtzXTtpZigtMSE9aSl7Zm9yKHZhciBoPXM8dC5sZW5ndGgtMSYmLTEhPXRbcysxXT90W3MrMV06MCxmPWUuVS5nbHlwaFRvUGF0aChyLGkpLGQ9MDtkPGYuY3Jkcy5sZW5ndGg7ZCs9MiluLmNyZHMucHVzaChmLmNyZHNbZF0rbyksbi5jcmRzLnB1c2goZi5jcmRzW2QrMV0pO2EmJm4uY21kcy5wdXNoKGEpO2ZvcihkPTA7ZDxmLmNtZHMubGVuZ3RoO2QrKyluLmNtZHMucHVzaChmLmNtZHNbZF0pO2EmJm4uY21kcy5wdXNoKFwiWFwiKSxvKz1yLmhtdHguYVdpZHRoW2ldLHM8dC5sZW5ndGgtMSYmKG8rPWUuVS5nZXRQYWlyQWRqdXN0bWVudChyLGksaCkpO319cmV0dXJuIG59LGUuVS5QPXt9LGUuVS5QLm1vdmVUbz1mdW5jdGlvbihyLGUsdCl7ci5jbWRzLnB1c2goXCJNXCIpLHIuY3Jkcy5wdXNoKGUsdCk7fSxlLlUuUC5saW5lVG89ZnVuY3Rpb24ocixlLHQpe3IuY21kcy5wdXNoKFwiTFwiKSxyLmNyZHMucHVzaChlLHQpO30sZS5VLlAuY3VydmVUbz1mdW5jdGlvbihyLGUsdCxhLG4sbyxzKXtyLmNtZHMucHVzaChcIkNcIiksci5jcmRzLnB1c2goZSx0LGEsbixvLHMpO30sZS5VLlAucWN1cnZlVG89ZnVuY3Rpb24ocixlLHQsYSxuKXtyLmNtZHMucHVzaChcIlFcIiksci5jcmRzLnB1c2goZSx0LGEsbik7fSxlLlUuUC5jbG9zZVBhdGg9ZnVuY3Rpb24ocil7ci5jbWRzLnB1c2goXCJaXCIpO30sZS5VLl9kcmF3Q0ZGPWZ1bmN0aW9uKHIsdCxhLG4sbyl7Zm9yKHZhciBzPXQuc3RhY2ssaT10Lm5TdGVtcyxoPXQuaGF2ZVdpZHRoLGY9dC53aWR0aCxkPXQub3Blbix1PTAsbD10Lngsdj10LnksYz0wLHA9MCxVPTAsZz0wLFM9MCxtPTAsYj0wLHk9MCxGPTAsXz0wLEM9e3ZhbDowLHNpemU6MH07dTxyLmxlbmd0aDspe2UuQ0ZGLmdldENoYXJTdHJpbmcocix1LEMpO3ZhciB4PUMudmFsO2lmKHUrPUMuc2l6ZSxcIm8xXCI9PXh8fFwibzE4XCI9PXgpcy5sZW5ndGglMiE9MCYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMDtlbHNlIGlmKFwibzNcIj09eHx8XCJvMjNcIj09eCl7cy5sZW5ndGglMiE9MCYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgpLGkrPXMubGVuZ3RoPj4xLHMubGVuZ3RoPTAsaD0hMDt9ZWxzZSBpZihcIm80XCI9PXgpcy5sZW5ndGg+MSYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksZCYmZS5VLlAuY2xvc2VQYXRoKG8pLHYrPXMucG9wKCksZS5VLlAubW92ZVRvKG8sbCx2KSxkPSEwO2Vsc2UgaWYoXCJvNVwiPT14KWZvcig7cy5sZW5ndGg+MDspbCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpO2Vsc2UgaWYoXCJvNlwiPT14fHxcIm83XCI9PXgpZm9yKHZhciBQPXMubGVuZ3RoLEk9XCJvNlwiPT14LHc9MDt3PFA7dysrKXt2YXIgTz1zLnNoaWZ0KCk7ST9sKz1POnYrPU8sST0hSSxlLlUuUC5saW5lVG8obyxsLHYpO31lbHNlIGlmKFwibzhcIj09eHx8XCJvMjRcIj09eCl7UD1zLmxlbmd0aDtmb3IodmFyIFQ9MDtUKzY8PVA7KWM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdiksVCs9NjtcIm8yNFwiPT14JiYobCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpKTt9ZWxzZSB7aWYoXCJvMTFcIj09eClicmVhaztpZihcIm8xMjM0XCI9PXh8fFwibzEyMzVcIj09eHx8XCJvMTIzNlwiPT14fHxcIm8xMjM3XCI9PXgpXCJvMTIzNFwiPT14JiYocD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxfPWc9cCtzLnNoaWZ0KCksbT1nLHk9dixsPShiPShTPShGPVUrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSkrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsXyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzNVwiPT14JiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxGPVUrcy5zaGlmdCgpLF89ZytzLnNoaWZ0KCksUz1GK3Muc2hpZnQoKSxtPV8rcy5zaGlmdCgpLGI9UytzLnNoaWZ0KCkseT1tK3Muc2hpZnQoKSxsPWIrcy5zaGlmdCgpLHY9eStzLnNoaWZ0KCkscy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsXyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzNlwiPT14JiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksXz1nPXArcy5zaGlmdCgpLG09ZyxiPShTPShGPVUrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLGw9YitzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixfKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKSxcIm8xMjM3XCI9PXgmJihjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLEY9VStzLnNoaWZ0KCksXz1nK3Muc2hpZnQoKSxTPUYrcy5zaGlmdCgpLG09XytzLnNoaWZ0KCksYj1TK3Muc2hpZnQoKSx5PW0rcy5zaGlmdCgpLE1hdGguYWJzKGItbCk+TWF0aC5hYnMoeS12KT9sPWIrcy5zaGlmdCgpOnY9eStzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsRixfKSxlLlUuUC5jdXJ2ZVRvKG8sUyxtLGIseSxsLHYpKTtlbHNlIGlmKFwibzE0XCI9PXgpe2lmKHMubGVuZ3RoPjAmJiFoJiYoZj1zLnNoaWZ0KCkrYS5ub21pbmFsV2lkdGhYLGg9ITApLDQ9PXMubGVuZ3RoKXt2YXIgaz1zLnNoaWZ0KCksRz1zLnNoaWZ0KCksRD1zLnNoaWZ0KCksQj1zLnNoaWZ0KCksTD1lLkNGRi5nbHlwaEJ5U0UoYSxEKSxSPWUuQ0ZGLmdseXBoQnlTRShhLEIpO2UuVS5fZHJhd0NGRihhLkNoYXJTdHJpbmdzW0xdLHQsYSxuLG8pLHQueD1rLHQueT1HLGUuVS5fZHJhd0NGRihhLkNoYXJTdHJpbmdzW1JdLHQsYSxuLG8pO31kJiYoZS5VLlAuY2xvc2VQYXRoKG8pLGQ9ITEpO31lbHNlIGlmKFwibzE5XCI9PXh8fFwibzIwXCI9PXgpe3MubGVuZ3RoJTIhPTAmJiFoJiYoZj1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYKSxpKz1zLmxlbmd0aD4+MSxzLmxlbmd0aD0wLGg9ITAsdSs9aSs3Pj4zO31lbHNlIGlmKFwibzIxXCI9PXgpcy5sZW5ndGg+MiYmIWgmJihmPXMuc2hpZnQoKStuLm5vbWluYWxXaWR0aFgsaD0hMCksdis9cy5wb3AoKSxsKz1zLnBvcCgpLGQmJmUuVS5QLmNsb3NlUGF0aChvKSxlLlUuUC5tb3ZlVG8obyxsLHYpLGQ9ITA7ZWxzZSBpZihcIm8yMlwiPT14KXMubGVuZ3RoPjEmJiFoJiYoZj1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYLGg9ITApLGwrPXMucG9wKCksZCYmZS5VLlAuY2xvc2VQYXRoKG8pLGUuVS5QLm1vdmVUbyhvLGwsdiksZD0hMDtlbHNlIGlmKFwibzI1XCI9PXgpe2Zvcig7cy5sZW5ndGg+NjspbCs9cy5zaGlmdCgpLHYrPXMuc2hpZnQoKSxlLlUuUC5saW5lVG8obyxsLHYpO2M9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksbD1VK3Muc2hpZnQoKSx2PWcrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7fWVsc2UgaWYoXCJvMjZcIj09eClmb3Iocy5sZW5ndGglMiYmKGwrPXMuc2hpZnQoKSk7cy5sZW5ndGg+MDspYz1sLHA9ditzLnNoaWZ0KCksbD1VPWMrcy5zaGlmdCgpLHY9KGc9cCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpO2Vsc2UgaWYoXCJvMjdcIj09eClmb3Iocy5sZW5ndGglMiYmKHYrPXMuc2hpZnQoKSk7cy5sZW5ndGg+MDspcD12LFU9KGM9bCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksdj1nLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdik7ZWxzZSBpZihcIm8xMFwiPT14fHxcIm8yOVwiPT14KXt2YXIgQT1cIm8xMFwiPT14P246YTtpZigwPT1zLmxlbmd0aCljb25zb2xlLmRlYnVnKFwiZXJyb3I6IGVtcHR5IHN0YWNrXCIpO2Vsc2Uge3ZhciBXPXMucG9wKCksTT1BLlN1YnJzW1crQS5CaWFzXTt0Lng9bCx0Lnk9dix0Lm5TdGVtcz1pLHQuaGF2ZVdpZHRoPWgsdC53aWR0aD1mLHQub3Blbj1kLGUuVS5fZHJhd0NGRihNLHQsYSxuLG8pLGw9dC54LHY9dC55LGk9dC5uU3RlbXMsaD10LmhhdmVXaWR0aCxmPXQud2lkdGgsZD10Lm9wZW47fX1lbHNlIGlmKFwibzMwXCI9PXh8fFwibzMxXCI9PXgpe3ZhciBWPXMubGVuZ3RoLE49KFQ9MCxcIm8zMVwiPT14KTtmb3IoVCs9Vi0oUD0tMyZWKTtUPFA7KU4/KHA9dixVPShjPWwrcy5zaGlmdCgpKStzLnNoaWZ0KCksdj0oZz1wK3Muc2hpZnQoKSkrcy5zaGlmdCgpLFAtVD09NT8obD1VK3Muc2hpZnQoKSxUKyspOmw9VSxOPSExKTooYz1sLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksUC1UPT01Pyh2PWcrcy5zaGlmdCgpLFQrKyk6dj1nLE49ITApLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLGwsdiksVCs9NDt9ZWxzZSB7aWYoXCJvXCI9PSh4K1wiXCIpLmNoYXJBdCgwKSl0aHJvdyBjb25zb2xlLmRlYnVnKFwiVW5rbm93biBvcGVyYXRpb246IFwiK3gscikseDtzLnB1c2goeCk7fX19dC54PWwsdC55PXYsdC5uU3RlbXM9aSx0LmhhdmVXaWR0aD1oLHQud2lkdGg9Zix0Lm9wZW49ZDt9O3ZhciB0PWUsYT17VHlwcjp0fTtyZXR1cm4gci5UeXByPXQsci5kZWZhdWx0PWEsT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscn0oe30pLlR5cHJ9XG5cbi8qIVxuQ3VzdG9tIGJ1bmRsZSBvZiB3b2ZmMm90ZiAoaHR0cHM6Ly9naXRodWIuY29tL2FydHktbmFtZS93b2ZmMm90Zikgd2l0aCBmZmxhdGVcbihodHRwczovL2dpdGh1Yi5jb20vMTAxYXJyb3d6L2ZmbGF0ZSkgZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuIFxuT3JpZ2luYWwgbGljZW5zZXMgYXBwbHk6IFxuLSBmZmxhdGU6IGh0dHBzOi8vZ2l0aHViLmNvbS8xMDFhcnJvd3ovZmZsYXRlL2Jsb2IvbWFzdGVyL0xJQ0VOU0UgKE1JVClcbi0gd29mZjJvdGYuanM6IGh0dHBzOi8vZ2l0aHViLmNvbS9hcnR5LW5hbWUvd29mZjJvdGYvYmxvYi9tYXN0ZXIvd29mZjJvdGYuanMgKEFwYWNoZTIpXG4qL1xuZnVuY3Rpb24gd29mZjJvdGZGYWN0b3J5KCl7cmV0dXJuIGZ1bmN0aW9uKHIpe3ZhciBlPVVpbnQ4QXJyYXksbj1VaW50MTZBcnJheSx0PVVpbnQzMkFycmF5LGE9bmV3IGUoWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDAsMF0pLGk9bmV3IGUoWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTMsMCwwXSksbz1uZXcgZShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pLGY9ZnVuY3Rpb24ocixlKXtmb3IodmFyIGE9bmV3IG4oMzEpLGk9MDtpPDMxOysraSlhW2ldPWUrPTE8PHJbaS0xXTt2YXIgbz1uZXcgdChhWzMwXSk7Zm9yKGk9MTtpPDMwOysraSlmb3IodmFyIGY9YVtpXTtmPGFbaSsxXTsrK2Ypb1tmXT1mLWFbaV08PDV8aTtyZXR1cm4gW2Esb119LHU9ZihhLDIpLHY9dVswXSxzPXVbMV07dlsyOF09MjU4LHNbMjU4XT0yODtmb3IodmFyIGw9ZihpLDApWzBdLGM9bmV3IG4oMzI3NjgpLGc9MDtnPDMyNzY4OysrZyl7dmFyIGg9KDQzNjkwJmcpPj4+MXwoMjE4NDUmZyk8PDE7aD0oNjE2ODAmKGg9KDUyNDI4JmgpPj4+MnwoMTMxMDcmaCk8PDIpKT4+PjR8KDM4NTUmaCk8PDQsY1tnXT0oKDY1MjgwJmgpPj4+OHwoMjU1JmgpPDw4KT4+PjE7fXZhciB3PWZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9ci5sZW5ndGgsaT0wLG89bmV3IG4oZSk7aTxhOysraSkrK29bcltpXS0xXTt2YXIgZix1PW5ldyBuKGUpO2ZvcihpPTA7aTxlOysraSl1W2ldPXVbaS0xXStvW2ktMV08PDE7aWYodCl7Zj1uZXcgbigxPDxlKTt2YXIgdj0xNS1lO2ZvcihpPTA7aTxhOysraSlpZihyW2ldKWZvcih2YXIgcz1pPDw0fHJbaV0sbD1lLXJbaV0sZz11W3JbaV0tMV0rKzw8bCxoPWd8KDE8PGwpLTE7Zzw9aDsrK2cpZltjW2ddPj4+dl09czt9ZWxzZSBmb3IoZj1uZXcgbihhKSxpPTA7aTxhOysraSlyW2ldJiYoZltpXT1jW3VbcltpXS0xXSsrXT4+PjE1LXJbaV0pO3JldHVybiBmfSxkPW5ldyBlKDI4OCk7Zm9yKGc9MDtnPDE0NDsrK2cpZFtnXT04O2ZvcihnPTE0NDtnPDI1NjsrK2cpZFtnXT05O2ZvcihnPTI1NjtnPDI4MDsrK2cpZFtnXT03O2ZvcihnPTI4MDtnPDI4ODsrK2cpZFtnXT04O3ZhciBtPW5ldyBlKDMyKTtmb3IoZz0wO2c8MzI7KytnKW1bZ109NTt2YXIgYj13KGQsOSwxKSxwPXcobSw1LDEpLHk9ZnVuY3Rpb24ocil7Zm9yKHZhciBlPXJbMF0sbj0xO248ci5sZW5ndGg7KytuKXJbbl0+ZSYmKGU9cltuXSk7cmV0dXJuIGV9LEw9ZnVuY3Rpb24ocixlLG4pe3ZhciB0PWUvOHwwO3JldHVybiAoclt0XXxyW3QrMV08PDgpPj4oNyZlKSZufSxVPWZ1bmN0aW9uKHIsZSl7dmFyIG49ZS84fDA7cmV0dXJuIChyW25dfHJbbisxXTw8OHxyW24rMl08PDE2KT4+KDcmZSl9LGs9W1widW5leHBlY3RlZCBFT0ZcIixcImludmFsaWQgYmxvY2sgdHlwZVwiLFwiaW52YWxpZCBsZW5ndGgvbGl0ZXJhbFwiLFwiaW52YWxpZCBkaXN0YW5jZVwiLFwic3RyZWFtIGZpbmlzaGVkXCIsXCJubyBzdHJlYW0gaGFuZGxlclwiLCxcIm5vIGNhbGxiYWNrXCIsXCJpbnZhbGlkIFVURi04IGRhdGFcIixcImV4dHJhIGZpZWxkIHRvbyBsb25nXCIsXCJkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTlcIixcImZpbGVuYW1lIHRvbyBsb25nXCIsXCJzdHJlYW0gZmluaXNoaW5nXCIsXCJpbnZhbGlkIHppcCBkYXRhXCJdLFQ9ZnVuY3Rpb24ocixlLG4pe3ZhciB0PW5ldyBFcnJvcihlfHxrW3JdKTtpZih0LmNvZGU9cixFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodCxUKSwhbil0aHJvdyB0O3JldHVybiB0fSxPPWZ1bmN0aW9uKHIsZix1KXt2YXIgcz1yLmxlbmd0aDtpZighc3x8dSYmIXUubCYmczw1KXJldHVybiBmfHxuZXcgZSgwKTt2YXIgYz0hZnx8dSxnPSF1fHx1Lmk7dXx8KHU9e30pLGZ8fChmPW5ldyBlKDMqcykpO3ZhciBoLGQ9ZnVuY3Rpb24ocil7dmFyIG49Zi5sZW5ndGg7aWYocj5uKXt2YXIgdD1uZXcgZShNYXRoLm1heCgyKm4scikpO3Quc2V0KGYpLGY9dDt9fSxtPXUuZnx8MCxrPXUucHx8MCxPPXUuYnx8MCxBPXUubCx4PXUuZCxFPXUubSxEPXUubixNPTgqcztkb3tpZighQSl7dS5mPW09TChyLGssMSk7dmFyIFM9TChyLGsrMSwzKTtpZihrKz0zLCFTKXt2YXIgVj1yWyhJPSgoaD1rKS84fDApKyg3JmgmJjEpKzQpLTRdfHJbSS0zXTw8OCxfPUkrVjtpZihfPnMpe2cmJlQoMCk7YnJlYWt9YyYmZChPK1YpLGYuc2V0KHIuc3ViYXJyYXkoSSxfKSxPKSx1LmI9Tys9Vix1LnA9az04Kl87Y29udGludWV9aWYoMT09UylBPWIseD1wLEU9OSxEPTU7ZWxzZSBpZigyPT1TKXt2YXIgaj1MKHIsaywzMSkrMjU3LHo9TChyLGsrMTAsMTUpKzQsQz1qK0wocixrKzUsMzEpKzE7ays9MTQ7Zm9yKHZhciBGPW5ldyBlKEMpLFA9bmV3IGUoMTkpLHE9MDtxPHo7KytxKVBbb1txXV09TChyLGsrMypxLDcpO2srPTMqejt2YXIgQj15KFApLEc9KDE8PEIpLTEsSD13KFAsQiwxKTtmb3IocT0wO3E8Qzspe3ZhciBJLEo9SFtMKHIsayxHKV07aWYoays9MTUmSiwoST1KPj4+NCk8MTYpRltxKytdPUk7ZWxzZSB7dmFyIEs9MCxOPTA7Zm9yKDE2PT1JPyhOPTMrTChyLGssMyksays9MixLPUZbcS0xXSk6MTc9PUk/KE49MytMKHIsayw3KSxrKz0zKToxOD09SSYmKE49MTErTChyLGssMTI3KSxrKz03KTtOLS07KUZbcSsrXT1LO319dmFyIFE9Ri5zdWJhcnJheSgwLGopLFI9Ri5zdWJhcnJheShqKTtFPXkoUSksRD15KFIpLEE9dyhRLEUsMSkseD13KFIsRCwxKTt9ZWxzZSBUKDEpO2lmKGs+TSl7ZyYmVCgwKTticmVha319YyYmZChPKzEzMTA3Mik7Zm9yKHZhciBXPSgxPDxFKS0xLFg9KDE8PEQpLTEsWT1rOztZPWspe3ZhciBaPShLPUFbVShyLGspJlddKT4+PjQ7aWYoKGsrPTE1JkspPk0pe2cmJlQoMCk7YnJlYWt9aWYoS3x8VCgyKSxaPDI1NilmW08rK109WjtlbHNlIHtpZigyNTY9PVope1k9ayxBPW51bGw7YnJlYWt9dmFyICQ9Wi0yNTQ7aWYoWj4yNjQpe3ZhciBycj1hW3E9Wi0yNTddOyQ9TChyLGssKDE8PHJyKS0xKSt2W3FdLGsrPXJyO312YXIgZXI9eFtVKHIsaykmWF0sbnI9ZXI+Pj40O2VyfHxUKDMpLGsrPTE1JmVyO1I9bFtucl07aWYobnI+Myl7cnI9aVtucl07Uis9VShyLGspJigxPDxyciktMSxrKz1ycjt9aWYoaz5NKXtnJiZUKDApO2JyZWFrfWMmJmQoTysxMzEwNzIpO2Zvcih2YXIgdHI9TyskO088dHI7Tys9NClmW09dPWZbTy1SXSxmW08rMV09ZltPKzEtUl0sZltPKzJdPWZbTysyLVJdLGZbTyszXT1mW08rMy1SXTtPPXRyO319dS5sPUEsdS5wPVksdS5iPU8sQSYmKG09MSx1Lm09RSx1LmQ9eCx1Lm49RCk7fXdoaWxlKCFtKTtyZXR1cm4gTz09Zi5sZW5ndGg/ZjpmdW5jdGlvbihyLGEsaSl7KG51bGw9PWF8fGE8MCkmJihhPTApLChudWxsPT1pfHxpPnIubGVuZ3RoKSYmKGk9ci5sZW5ndGgpO3ZhciBvPW5ldyhyIGluc3RhbmNlb2Ygbj9uOnIgaW5zdGFuY2VvZiB0P3Q6ZSkoaS1hKTtyZXR1cm4gby5zZXQoci5zdWJhcnJheShhLGkpKSxvfShmLDAsTyl9LEE9bmV3IGUoMCk7dmFyIHg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyJiZuZXcgVGV4dERlY29kZXI7dHJ5e3guZGVjb2RlKEEse3N0cmVhbTohMH0pLDE7fWNhdGNoKHIpe31yZXR1cm4gci5jb252ZXJ0X3N0cmVhbXM9ZnVuY3Rpb24ocil7dmFyIGU9bmV3IERhdGFWaWV3KHIpLG49MDtmdW5jdGlvbiB0KCl7dmFyIHI9ZS5nZXRVaW50MTYobik7cmV0dXJuIG4rPTIscn1mdW5jdGlvbiBhKCl7dmFyIHI9ZS5nZXRVaW50MzIobik7cmV0dXJuIG4rPTQscn1mdW5jdGlvbiBpKHIpe20uc2V0VWludDE2KGIsciksYis9Mjt9ZnVuY3Rpb24gbyhyKXttLnNldFVpbnQzMihiLHIpLGIrPTQ7fWZvcih2YXIgZj17c2lnbmF0dXJlOmEoKSxmbGF2b3I6YSgpLGxlbmd0aDphKCksbnVtVGFibGVzOnQoKSxyZXNlcnZlZDp0KCksdG90YWxTZm50U2l6ZTphKCksbWFqb3JWZXJzaW9uOnQoKSxtaW5vclZlcnNpb246dCgpLG1ldGFPZmZzZXQ6YSgpLG1ldGFMZW5ndGg6YSgpLG1ldGFPcmlnTGVuZ3RoOmEoKSxwcml2T2Zmc2V0OmEoKSxwcml2TGVuZ3RoOmEoKX0sdT0wO01hdGgucG93KDIsdSk8PWYubnVtVGFibGVzOyl1Kys7dS0tO2Zvcih2YXIgdj0xNipNYXRoLnBvdygyLHUpLHM9MTYqZi5udW1UYWJsZXMtdixsPTEyLGM9W10sZz0wO2c8Zi5udW1UYWJsZXM7ZysrKWMucHVzaCh7dGFnOmEoKSxvZmZzZXQ6YSgpLGNvbXBMZW5ndGg6YSgpLG9yaWdMZW5ndGg6YSgpLG9yaWdDaGVja3N1bTphKCl9KSxsKz0xNjt2YXIgaCx3PW5ldyBVaW50OEFycmF5KDEyKzE2KmMubGVuZ3RoK2MucmVkdWNlKChmdW5jdGlvbihyLGUpe3JldHVybiByK2Uub3JpZ0xlbmd0aCs0fSksMCkpLGQ9dy5idWZmZXIsbT1uZXcgRGF0YVZpZXcoZCksYj0wO3JldHVybiBvKGYuZmxhdm9yKSxpKGYubnVtVGFibGVzKSxpKHYpLGkodSksaShzKSxjLmZvckVhY2goKGZ1bmN0aW9uKHIpe28oci50YWcpLG8oci5vcmlnQ2hlY2tzdW0pLG8obCksbyhyLm9yaWdMZW5ndGgpLHIub3V0T2Zmc2V0PWwsKGwrPXIub3JpZ0xlbmd0aCklNCE9MCYmKGwrPTQtbCU0KTt9KSksYy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbix0PXIuc2xpY2UoZS5vZmZzZXQsZS5vZmZzZXQrZS5jb21wTGVuZ3RoKTtpZihlLmNvbXBMZW5ndGghPWUub3JpZ0xlbmd0aCl7dmFyIGE9bmV3IFVpbnQ4QXJyYXkoZS5vcmlnTGVuZ3RoKTtuPW5ldyBVaW50OEFycmF5KHQsMiksTyhuLGEpO31lbHNlIGE9bmV3IFVpbnQ4QXJyYXkodCk7dy5zZXQoYSxlLm91dE9mZnNldCk7dmFyIGk9MDsobD1lLm91dE9mZnNldCtlLm9yaWdMZW5ndGgpJTQhPTAmJihpPTQtbCU0KSx3LnNldChuZXcgVWludDhBcnJheShpKS5idWZmZXIsZS5vdXRPZmZzZXQrZS5vcmlnTGVuZ3RoKSxoPWwraTt9KSksZC5zbGljZSgwLGgpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyfSh7fSkuY29udmVydF9zdHJlYW1zfVxuXG4vKipcbiAqIEEgZmFjdG9yeSB3cmFwcGVyIHBhcnNpbmcgYSBmb250IGZpbGUgdXNpbmcgVHlwci5cbiAqIEFsc28gYWRkcyBzdXBwb3J0IGZvciBXT0ZGIGZpbGVzIChub3QgV09GRjIpLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlckZhY3RvcnkoVHlwciwgd29mZjJvdGYpIHtcbiAgY29uc3QgY21kQXJnTGVuZ3RocyA9IHtcbiAgICBNOiAyLFxuICAgIEw6IDIsXG4gICAgUTogNCxcbiAgICBDOiA2LFxuICAgIFo6IDBcbiAgfTtcblxuICAvLyB7am9pblR5cGU6IFwic2tpcCtzdGVwLC4uLlwifVxuICBjb25zdCBqb2luaW5nVHlwZVJhd0RhdGEgPSB7XCJDXCI6XCIxOGcsY2EsMzY4LDFrelwiLFwiRFwiOlwiMTdrLDYsMiwyKzQsNStjLDIrNiwyKzEsMTArMSw5K2YsaisxMSwyKzEsYSwyLDIrMSwxNSsyLDMsaisyLDYrMywyKzgsMiwyLDIrMSx3K2EsNCtlLDMrMywyLDMrMiwzKzUsMjMrdywyZis0LDMsMis5LDIsYiwyKzMsMywxays5LDYrMSwzKzEsMisyLDIrZCwzMGcscCt5LDEsMSsxZyxmK3gsMixzZDIrMWQsamYzKzQsZiszLDIrNCwyKzIsYiszLDQyLDIsNCsyLDIrMSwyLDMsdCsxLDlmK3csMixlbCsyLDIrZyxkKzIsMmwsMisxLDUsMysxLDIrMSwyLDMsNiwxNndtKzF2XCIsXCJSXCI6XCIxN20rMywyLDIsNiszLG0sMTUrMiwyKzIsaCtoLDEzLDMrOCwyLDIsMysxLDIscCsxLHgsNSs0LDUsYSwyLDIsMyx1LGMrMixnKzEsNSwyKzEsNCsxLDVqLDYrMSwyLGIsMisyLGYsMisxLDFzKzIsMiwzKzEsNywxZXowLDIsMisxLDQrNCxiLDQsMyxiLDQyLDIrMiw0LDMsMisxLDIsbyszLGFlLGVwLHgsMm8rMiwzKzEsMyw1KzEsNlwiLFwiTFwiOlwieDl1LGpmZixhLGZkLGp2XCIsXCJUXCI6XCI0dCxnaiszMyw3bys0LDErMSw3YysxOCwyLDIrMSwyKzEsMiwyMSthLDIsMWIrayxoLDJ1KzYsMys1LDMrMSwyKzMseSwyLHYrcSwyaythLDFuKzgsYSxwKzMsMis4LDIrMiwyKzQsMTgrMiwzYytlLDIrdiwxaywyLDUrNyw1LDQrNixiKzEsdSwxbiw1KzMsOSxsKzEsciwzKzEsMW0sNSsxLDUrMSwzKzIsNCx2KzEsNCxjKzEsMW0sNSs0LDIrMSw1LGwrMSxuKzUsMiwxbiwzLDIrMyw5LDgrMSxjKzEsdiwxcSxkLDFmLDQsMW0rMiw2KzIsMiszLDgrMSxjKzEsdSwxbiwzLDcsNisxLGwrMSx0KzEsMW0rMSw1KzMsOSxsKzEsdSwyMSw4KzIsMiwyaiwzKzYsZCs3LDJyLDMrOCxjKzUsMjMrMSxzLDIsMiwxaytkLDIrNCwyKzEsNithLDIreixhLDJ2KzMsMis1LDIrMSwzKzEscSsxLDUrMixoKzMsZSwzKzEsNyxnLGprKzIscWIrMix1KzIsdSsxLHYrMSwxdCsxLDIrNiw5LDMrYSxhLDFhKzIsM2MrMSx6LDNiKzIsNSsxLGEsNysyLDY0KzEsMywxbiwyKzYsMiwyLDMrNyw3KzksMywxZCtkLDEsMSsxLDFzKzMsMWQsMis0LDIsNiwxNSs4LGQrMSx4KzMsMysxLDIrMiwxbCwyKzEsNCwyKzIsMW4rNywzKzEsNDkrMiwyK2MsMis2LDUsNyw0KzEsNWorMWwsMis0LGVrLDMrMSxyKzQsMWUrNCw2KzUsMnArYywxKzMsMSwxKzIsMStiLDJkYisyLDN5LDJwK3YsZmYrMywzMCsxLG45eCwxKzIsMis5LHgrMSwyOSsxLDdsLDQsNSxxKzEsNiw0OCsxLHIraCxlLDEzKzcscSthLDFiKzIsMWQsMyszLDMrMSwxNCwxdys1LDMrMSwzKzEsZCw5LDFjLDFnLDIrMiwzKzEsNisxLDIsMTcrMSw5LDZuLDMsNSxmbjUsa2krZixoK2YsNXMsNnkrMixlYSw2Yiw0Nis0LDFhZisyLDIrMSw2KzMsMTUrMiw1LDRtKzEsZnkrMyxhcysxLDRhK2EsNHgsMWorZSwxbCsyLDFlKzMsMysxLDF5KzIsMTErNCwyKzcsMXIsZCsxLDFoKzgsYiszLDMsMm8rMiwzLDIrMSw3LDRoLDQrNyxtKzEsMW0rMSw0LDEyKzYsNCs0LDVnKzcsMysyLDIsbywyZCs1LDIsNSsxLDIrMSw2biszLDcrMSwyKzEscysxLDJlKzcsMywyKzEsMnosMiwzKzUsMiwydSsyLDMrMywyKzQsNzgrOCwyKzEsNzUrMSwyLDUsNDErMywzKzEsNSx4KzksMTUrNSwzKzMsOSxhKzUsMysyLDFiK2MsMisxLGJiKzYsMis1LDIsMmIrbCwzKzYsMisxLDIrMSwzZis1LDQsMisxLDIrNiwyLDIxKzEsNCwyLDlvKzEsNDcwKzgsYXQ0KzQsMW8rNix0NSwxcyszLDJhLGY1bCsxLDIrMyw0M28rMixhKzcsMSs3LDMrNix2KzMsNDUrMiwxajArMWksNSsxZCw5LGYsbis0LDIrZSwxMXQrNiwyK2csMys2LDIrMSwyKzQsN2ErNixjNiszLDE1dCs2LDMyKzYsMSxnemF1LHYrMm4sM2wrNm5cIn07XG5cbiAgY29uc3QgSlRfTEVGVCA9IDEsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIsIGJ1dCBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIuXG4gICAgSlRfUklHSFQgPSAyLCAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGpvaW5zIHdpdGggdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIsIGJ1dCBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLlxuICAgIEpUX0RVQUwgPSA0LCAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGpvaW5zIHdpdGggdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIgYW5kIGpvaW5zIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLlxuICAgIEpUX1RSQU5TUEFSRU5UID0gOCwgLy9pbmRpY2F0ZXMgdGhhdCB0aGUgY2hhcmFjdGVyIGRvZXMgbm90IGpvaW4gd2l0aCBhZGphY2VudCBjaGFyYWN0ZXJzIGFuZCB0aGF0IHRoZSBjaGFyYWN0ZXIgbXVzdCBiZSBza2lwcGVkIG92ZXIgd2hlbiB0aGUgc2hhcGluZyBlbmdpbmUgaXMgZXZhbHVhdGluZyB0aGUgam9pbmluZyBwb3NpdGlvbnMgaW4gYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLiBXaGVuIGEgSlRfVFJBTlNQQVJFTlQgY2hhcmFjdGVyIGlzIGVuY291bnRlcmVkIGluIGEgc2VxdWVuY2UsIHRoZSBKT0lOSU5HX1RZUEUgb2YgdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIgcGFzc2VzIHRocm91Z2guIERpYWNyaXRpY2FsIG1hcmtzIGFyZSBmcmVxdWVudGx5IGFzc2lnbmVkIHRoaXMgdmFsdWUuXG4gICAgSlRfSk9JTl9DQVVTSU5HID0gMTYsIC8vaW5kaWNhdGVzIHRoYXQgdGhlIGNoYXJhY3RlciBmb3JjZXMgdGhlIHVzZSBvZiBqb2luaW5nIGZvcm1zIHdpdGggdGhlIHByZWNlZGluZyBhbmQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzLiBLYXNoaWRhcyBhbmQgdGhlIFplcm8gV2lkdGggSm9pbmVyIChVKzIwMEQpIGFyZSBib3RoIEpPSU5fQ0FVU0lORyBjaGFyYWN0ZXJzLlxuICAgIEpUX05PTl9KT0lOSU5HID0gMzI7IC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgZG9lcyBub3Qgam9pbiB3aXRoIHRoZSBwcmVjZWRpbmcgb3Igd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuLFxuXG4gIGxldCBqb2luaW5nVHlwZU1hcDtcbiAgZnVuY3Rpb24gZ2V0Q2hhckpvaW5pbmdUeXBlKGNoKSB7XG4gICAgaWYgKCFqb2luaW5nVHlwZU1hcCkge1xuICAgICAgY29uc3QgbSA9IHtcbiAgICAgICAgUjogSlRfUklHSFQsXG4gICAgICAgIEw6IEpUX0xFRlQsXG4gICAgICAgIEQ6IEpUX0RVQUwsXG4gICAgICAgIEM6IEpUX0pPSU5fQ0FVU0lORyxcbiAgICAgICAgVTogSlRfTk9OX0pPSU5JTkcsXG4gICAgICAgIFQ6IEpUX1RSQU5TUEFSRU5UXG4gICAgICB9O1xuICAgICAgam9pbmluZ1R5cGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGxldCB0eXBlIGluIGpvaW5pbmdUeXBlUmF3RGF0YSkge1xuICAgICAgICBsZXQgbGFzdENvZGUgPSAwO1xuICAgICAgICBqb2luaW5nVHlwZVJhd0RhdGFbdHlwZV0uc3BsaXQoJywnKS5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgICBsZXQgW3NraXAsIHN0ZXBdID0gcmFuZ2Uuc3BsaXQoJysnKTtcbiAgICAgICAgICBza2lwID0gcGFyc2VJbnQoc2tpcCwzNik7XG4gICAgICAgICAgc3RlcCA9IHN0ZXAgPyBwYXJzZUludChzdGVwLCAzNikgOiAwO1xuICAgICAgICAgIGpvaW5pbmdUeXBlTWFwLnNldChsYXN0Q29kZSArPSBza2lwLCBtW3R5cGVdKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RlcDsgaS0tOykge1xuICAgICAgICAgICAgam9pbmluZ1R5cGVNYXAuc2V0KCsrbGFzdENvZGUsIG1bdHlwZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqb2luaW5nVHlwZU1hcC5nZXQoY2gpIHx8IEpUX05PTl9KT0lOSU5HXG4gIH1cblxuICBjb25zdCBJU09MID0gMSwgSU5JVCA9IDIsIEZJTkEgPSAzLCBNRURJID0gNDtcbiAgY29uc3QgZm9ybXNUb0ZlYXR1cmVzID0gW251bGwsICdpc29sJywgJ2luaXQnLCAnZmluYScsICdtZWRpJ107XG5cbiAgZnVuY3Rpb24gZGV0ZWN0Sm9pbmluZ0Zvcm1zKHN0cikge1xuICAgIC8vIFRoaXMgaW1wbGVtZW50cyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uOHdpbGxpcy9vcGVudHlwZS1zaGFwaW5nLWRvY3VtZW50cy9ibG9iL21hc3Rlci9vcGVudHlwZS1zaGFwaW5nLWFyYWJpYy1nZW5lcmFsLm1kXG4gICAgY29uc3Qgam9pbmluZ0Zvcm1zID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgbGV0IHByZXZKb2luaW5nVHlwZSA9IEpUX05PTl9KT0lOSU5HO1xuICAgIGxldCBwcmV2Rm9ybSA9IElTT0w7XG4gICAgbGV0IHByZXZJbmRleCA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgbGV0IGpvaW5pbmdUeXBlID0gZ2V0Q2hhckpvaW5pbmdUeXBlKGNvZGUpIHwgMDtcbiAgICAgIGxldCBmb3JtID0gSVNPTDtcbiAgICAgIGlmIChqb2luaW5nVHlwZSAmIEpUX1RSQU5TUEFSRU5UKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAocHJldkpvaW5pbmdUeXBlICYgKEpUX0xFRlQgfCBKVF9EVUFMIHwgSlRfSk9JTl9DQVVTSU5HKSkge1xuICAgICAgICBpZiAoam9pbmluZ1R5cGUgJiAoSlRfUklHSFQgfCBKVF9EVUFMIHwgSlRfSk9JTl9DQVVTSU5HKSkge1xuICAgICAgICAgIGZvcm0gPSBGSU5BO1xuICAgICAgICAgIC8vIGlzb2wtPmluaXQsIGZpbmEtPm1lZGlcbiAgICAgICAgICBpZiAocHJldkZvcm0gPT09IElTT0wgfHwgcHJldkZvcm0gPT09IEZJTkEpIHtcbiAgICAgICAgICAgIGpvaW5pbmdGb3Jtc1twcmV2SW5kZXhdKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpvaW5pbmdUeXBlICYgKEpUX0xFRlQgfCBKVF9OT05fSk9JTklORykpIHtcbiAgICAgICAgICAvLyBtZWRpLT5maW5hLCBpbml0LT5pc29sXG4gICAgICAgICAgaWYgKHByZXZGb3JtID09PSBJTklUIHx8IHByZXZGb3JtID09PSBNRURJKSB7XG4gICAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJldkpvaW5pbmdUeXBlICYgKEpUX1JJR0hUIHwgSlRfTk9OX0pPSU5JTkcpKSB7XG4gICAgICAgIC8vIG1lZGktPmZpbmEsIGluaXQtPmlzb2xcbiAgICAgICAgaWYgKHByZXZGb3JtID09PSBJTklUIHx8IHByZXZGb3JtID09PSBNRURJKSB7XG4gICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldkZvcm0gPSBqb2luaW5nRm9ybXNbaV0gPSBmb3JtO1xuICAgICAgcHJldkpvaW5pbmdUeXBlID0gam9pbmluZ1R5cGU7XG4gICAgICBwcmV2SW5kZXggPSBpO1xuICAgICAgaWYgKGNvZGUgPiAweGZmZmYpIGkrKztcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coc3RyLnNwbGl0KCcnKS5tYXAoY2ggPT4gY2guY29kZVBvaW50QXQoMCkudG9TdHJpbmcoMTYpKSlcbiAgICAvLyBjb25zb2xlLmxvZyhzdHIuc3BsaXQoJycpLm1hcChjaCA9PiBnZXRDaGFySm9pbmluZ1R5cGUoY2guY29kZVBvaW50QXQoMCkpKSlcbiAgICAvLyBjb25zb2xlLmxvZyhBcnJheS5mcm9tKGpvaW5pbmdGb3JtcykubWFwKGYgPT4gZm9ybXNUb0ZlYXR1cmVzW2ZdIHx8ICdub25lJykpXG4gICAgcmV0dXJuIGpvaW5pbmdGb3Jtc1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5nVG9HbHlwaHMgKGZvbnQsIHN0cikge1xuICAgIGNvbnN0IGdseXBoSWRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNjID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgaWYgKGNjID4gMHhmZmZmKSBpKys7XG4gICAgICBnbHlwaElkcy5wdXNoKFR5cHIuVS5jb2RlVG9HbHlwaChmb250LCBjYykpO1xuICAgIH1cblxuICAgIGNvbnN0IGdzdWIgPSBmb250WydHU1VCJ107XG4gICAgaWYgKGdzdWIpIHtcbiAgICAgIGNvbnN0IHtsb29rdXBMaXN0LCBmZWF0dXJlTGlzdH0gPSBnc3ViO1xuICAgICAgbGV0IGpvaW5pbmdGb3JtcztcbiAgICAgIGNvbnN0IHN1cHBvcnRlZEZlYXR1cmVzID0gL14ocmxpZ3xsaWdhfG1zZXR8aXNvbHxpbml0fGZpbmF8bWVkaXxoYWxmfHByZXN8Ymx3cykkLztcbiAgICAgIGNvbnN0IHVzZWRMb29rdXBzID0gW107XG4gICAgICBmZWF0dXJlTGlzdC5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgICAgICBpZiAoc3VwcG9ydGVkRmVhdHVyZXMudGVzdChmZWF0dXJlLnRhZykpIHtcbiAgICAgICAgICBmb3IgKGxldCB0aSA9IDA7IHRpIDwgZmVhdHVyZS50YWIubGVuZ3RoOyB0aSsrKSB7XG4gICAgICAgICAgICBpZiAodXNlZExvb2t1cHNbZmVhdHVyZS50YWJbdGldXSkgY29udGludWVcbiAgICAgICAgICAgIHVzZWRMb29rdXBzW2ZlYXR1cmUudGFiW3RpXV0gPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgdGFiID0gbG9va3VwTGlzdFtmZWF0dXJlLnRhYlt0aV1dO1xuICAgICAgICAgICAgY29uc3QgaXNKb2luaW5nRmVhdHVyZSA9IC9eKGlzb2x8aW5pdHxmaW5hfG1lZGkpJC8udGVzdChmZWF0dXJlLnRhZyk7XG4gICAgICAgICAgICBpZiAoaXNKb2luaW5nRmVhdHVyZSAmJiAham9pbmluZ0Zvcm1zKSB7IC8vbGF6eVxuICAgICAgICAgICAgICBqb2luaW5nRm9ybXMgPSBkZXRlY3RKb2luaW5nRm9ybXMoc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGNpID0gMDsgY2kgPCBnbHlwaElkcy5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFqb2luaW5nRm9ybXMgfHwgIWlzSm9pbmluZ0ZlYXR1cmUgfHwgZm9ybXNUb0ZlYXR1cmVzW2pvaW5pbmdGb3Jtc1tjaV1dID09PSBmZWF0dXJlLnRhZykge1xuICAgICAgICAgICAgICAgIFR5cHIuVS5fYXBwbHlTdWJzKGdseXBoSWRzLCBjaSwgdGFiLCBsb29rdXBMaXN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoSWRzXG4gIH1cblxuICBmdW5jdGlvbiBmaXJzdE51bSguLi5hcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcEZvbnRPYmoodHlwckZvbnQpIHtcbiAgICBjb25zdCBnbHlwaE1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBjb25zdCBvczIgPSB0eXByRm9udFsnT1MvMiddO1xuICAgIGNvbnN0IGhoZWEgPSB0eXByRm9udC5oaGVhO1xuICAgIGNvbnN0IHVuaXRzUGVyRW0gPSB0eXByRm9udC5oZWFkLnVuaXRzUGVyRW07XG4gICAgY29uc3QgYXNjZW5kZXIgPSBmaXJzdE51bShvczIgJiYgb3MyLnNUeXBvQXNjZW5kZXIsIGhoZWEgJiYgaGhlYS5hc2NlbmRlciwgdW5pdHNQZXJFbSk7XG5cbiAgICBjb25zdCBmb250T2JqID0ge1xuICAgICAgdW5pdHNQZXJFbSxcbiAgICAgIGFzY2VuZGVyLFxuICAgICAgZGVzY2VuZGVyOiBmaXJzdE51bShvczIgJiYgb3MyLnNUeXBvRGVzY2VuZGVyLCBoaGVhICYmIGhoZWEuZGVzY2VuZGVyLCAwKSxcbiAgICAgIGNhcEhlaWdodDogZmlyc3ROdW0ob3MyICYmIG9zMi5zQ2FwSGVpZ2h0LCBhc2NlbmRlciksXG4gICAgICB4SGVpZ2h0OiBmaXJzdE51bShvczIgJiYgb3MyLnN4SGVpZ2h0LCBhc2NlbmRlciksXG4gICAgICBsaW5lR2FwOiBmaXJzdE51bShvczIgJiYgb3MyLnNUeXBvTGluZUdhcCwgaGhlYSAmJiBoaGVhLmxpbmVHYXApLFxuICAgICAgZm9yRWFjaEdseXBoKHRleHQsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgZ2x5cGhYID0gMDtcbiAgICAgICAgY29uc3QgZm9udFNjYWxlID0gMSAvIGZvbnRPYmoudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgICAgIGNvbnN0IGdseXBoSW5kaWNlcyA9IHN0cmluZ1RvR2x5cGhzKHR5cHJGb250LCB0ZXh0KTtcbiAgICAgICAgbGV0IGNoYXJJbmRleCA9IDA7XG4gICAgICAgIGxldCBwcmV2R2x5cGhJbmRleCA9IC0xO1xuICAgICAgICBnbHlwaEluZGljZXMuZm9yRWFjaCgoZ2x5cGhJbmRleCwgaSkgPT4ge1xuICAgICAgICAgIC8vIFR5cHIgcmV0dXJucyBhIGdseXBoIGluZGV4IHBlciBzdHJpbmcgY29kZXBvaW50LCB3aXRoIC0xcyBpbiBwbGFjZSBvZiB0aG9zZSB0aGF0XG4gICAgICAgICAgLy8gd2VyZSBvbWl0dGVkIGR1ZSB0byBsaWdhdHVyZSBzdWJzdGl0dXRpb24uIFNvIHdlIGNhbiB0cmFjayBvcmlnaW5hbCBpbmRleCBpbiB0aGVcbiAgICAgICAgICAvLyBzdHJpbmcgdmlhIHNpbXBsZSBpbmNyZW1lbnQsIGFuZCBza2lwIGV2ZXJ5dGhpbmcgZWxzZSB3aGVuIHNlZWluZyBhIC0xLlxuICAgICAgICAgIGlmIChnbHlwaEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IGdseXBoT2JqID0gZ2x5cGhNYXBbZ2x5cGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIWdseXBoT2JqKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtjbWRzLCBjcmRzfSA9IFR5cHIuVS5nbHlwaFRvUGF0aCh0eXByRm9udCwgZ2x5cGhJbmRleCk7XG5cbiAgICAgICAgICAgICAgLy8gQnVpbGQgcGF0aCBzdHJpbmdcbiAgICAgICAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgICAgICAgbGV0IGNyZHNJZHggPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY21kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bUFyZ3MgPSBjbWRBcmdMZW5ndGhzW2NtZHNbaV1dO1xuICAgICAgICAgICAgICAgIHBhdGggKz0gY21kc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBudW1BcmdzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHBhdGggKz0gKGogPiAxID8gJywnIDogJycpICsgY3Jkc1tjcmRzSWR4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEZpbmQgZXh0ZW50cyAtIEdseWYgZ2l2ZXMgdGhpcyBpbiBtZXRhZGF0YSBidXQgbm90IENGRiwgYW5kIFR5cHIgZG9lc24ndFxuICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdGhlIHR3bywgc28gaXQncyBzaW1wbGVzdCBqdXN0IHRvIGl0ZXJhdGUgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICBsZXQgeE1pbiwgeU1pbiwgeE1heCwgeU1heDtcbiAgICAgICAgICAgICAgaWYgKGNyZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgeE1pbiA9IHlNaW4gPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB4TWF4ID0geU1heCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgbGV0IHggPSBjcmRzW2ldO1xuICAgICAgICAgICAgICAgICAgbGV0IHkgPSBjcmRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4IDwgeE1pbikgeE1pbiA9IHg7XG4gICAgICAgICAgICAgICAgICBpZiAoeSA8IHlNaW4pIHlNaW4gPSB5O1xuICAgICAgICAgICAgICAgICAgaWYgKHggPiB4TWF4KSB4TWF4ID0geDtcbiAgICAgICAgICAgICAgICAgIGlmICh5ID4geU1heCkgeU1heCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhNaW4gPSB4TWF4ID0geU1pbiA9IHlNYXggPSAwO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ2x5cGhPYmogPSBnbHlwaE1hcFtnbHlwaEluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogZ2x5cGhJbmRleCxcbiAgICAgICAgICAgICAgICBhZHZhbmNlV2lkdGg6IHR5cHJGb250LmhtdHguYVdpZHRoW2dseXBoSW5kZXhdLFxuICAgICAgICAgICAgICAgIHhNaW4sXG4gICAgICAgICAgICAgICAgeU1pbixcbiAgICAgICAgICAgICAgICB4TWF4LFxuICAgICAgICAgICAgICAgIHlNYXgsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBwYXRoQ29tbWFuZENvdW50OiBjbWRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAvLyBmb3JFYWNoUGF0aENvbW1hbmQoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyAgIGxldCBhcmdzSW5kZXggPSAwXG4gICAgICAgICAgICAgICAgLy8gICBjb25zdCBhcmdzQXJyYXkgPSBbXVxuICAgICAgICAgICAgICAgIC8vICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNtZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc3QgbnVtQXJncyA9IGNtZEFyZ0xlbmd0aHNbY21kc1tpXV1cbiAgICAgICAgICAgICAgICAvLyAgICAgYXJnc0FycmF5Lmxlbmd0aCA9IDEgKyBudW1BcmdzXG4gICAgICAgICAgICAgICAgLy8gICAgIGFyZ3NBcnJheVswXSA9IGNtZHNbaV1cbiAgICAgICAgICAgICAgICAvLyAgICAgZm9yIChsZXQgaiA9IDE7IGogPD0gbnVtQXJnczsgaisrKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgYXJnc0FycmF5W2pdID0gY3Jkc1thcmdzSW5kZXgrK11cbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmdzQXJyYXkpXG4gICAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBLZXJuaW5nXG4gICAgICAgICAgICBpZiAocHJldkdseXBoSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgIGdseXBoWCArPSBUeXByLlUuZ2V0UGFpckFkanVzdG1lbnQodHlwckZvbnQsIHByZXZHbHlwaEluZGV4LCBnbHlwaEluZGV4KSAqIGZvbnRTY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBnbHlwaE9iaiwgZ2x5cGhYLCBjaGFySW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoZ2x5cGhPYmouYWR2YW5jZVdpZHRoKSB7XG4gICAgICAgICAgICAgIGdseXBoWCArPSBnbHlwaE9iai5hZHZhbmNlV2lkdGggKiBmb250U2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgICBnbHlwaFggKz0gbGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2R2x5cGhJbmRleCA9IGdseXBoSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYXJJbmRleCArPSAodGV4dC5jb2RlUG9pbnRBdChjaGFySW5kZXgpID4gMHhmZmZmID8gMiA6IDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdseXBoWFxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZm9udE9ialxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhcnNlKGJ1ZmZlcikge1xuICAgIC8vIExvb2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBXT0ZGIGZpbGUgYW5kIGNvbnZlcnQgaXQgaWYgc286XG4gICAgY29uc3QgcGVlayA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCwgNCk7XG4gICAgY29uc3QgdGFnID0gVHlwci5fYmluLnJlYWRBU0NJSShwZWVrLCAwLCA0KTtcbiAgICBpZiAodGFnID09PSAnd09GRicpIHtcbiAgICAgIGJ1ZmZlciA9IHdvZmYyb3RmKGJ1ZmZlcik7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICd3T0YyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b2ZmMiBmb250cyBub3Qgc3VwcG9ydGVkJylcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBGb250T2JqKFR5cHIucGFyc2UoYnVmZmVyKVswXSlcbiAgfVxufVxuXG5cbmNvbnN0IHdvcmtlck1vZHVsZSA9IC8qI19fUFVSRV9fKi9kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBuYW1lOiAnVHlwciBGb250IFBhcnNlcicsXG4gIGRlcGVuZGVuY2llczogW3R5cHJGYWN0b3J5LCB3b2ZmMm90ZkZhY3RvcnksIHBhcnNlckZhY3RvcnldLFxuICBpbml0KHR5cHJGYWN0b3J5LCB3b2ZmMm90ZkZhY3RvcnksIHBhcnNlckZhY3RvcnkpIHtcbiAgICBjb25zdCBUeXByID0gdHlwckZhY3RvcnkoKTtcbiAgICBjb25zdCB3b2ZmMm90ZiA9IHdvZmYyb3RmRmFjdG9yeSgpO1xuICAgIHJldHVybiBwYXJzZXJGYWN0b3J5KFR5cHIsIHdvZmYyb3RmKVxuICB9XG59KTtcblxuY29uc3QgQ09ORklHID0ge1xuICBkZWZhdWx0Rm9udFVSTDogJ2h0dHBzOi8vZm9udHMuZ3N0YXRpYy5jb20vcy9yb2JvdG8vdjE4L0tGT21DbnFFdTkyRnIxTXU0bXhNLndvZmYnLCAvL1JvYm90byBSZWd1bGFyXG4gIHNkZkdseXBoU2l6ZTogNjQsXG4gIHNkZk1hcmdpbjogMSAvIDE2LFxuICBzZGZFeHBvbmVudDogOSxcbiAgdGV4dHVyZVdpZHRoOiAyMDQ4XG59O1xuY29uc3QgdGVtcENvbG9yID0gLyojX19QVVJFX18qL25ldyBDb2xvcigpO1xubGV0IGhhc1JlcXVlc3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBub3ckMSgpIHtcbiAgcmV0dXJuIChzZWxmLnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpXG59XG5cbi8qKlxuICogQ3VzdG9taXplcyB0aGUgdGV4dCBidWlsZGVyIGNvbmZpZ3VyYXRpb24uIFRoaXMgbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG8gdGhlIGZpcnN0IGZvbnQgcHJvY2Vzc2luZ1xuICogcmVxdWVzdCwgYW5kIGFwcGxpZXMgdG8gYWxsIGZvbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZGVmYXVsdEZvbnRVUkwgLSBUaGUgVVJMIG9mIHRoZSBkZWZhdWx0IGZvbnQgdG8gdXNlIGZvciB0ZXh0IHByb2Nlc3NpbmdcbiAqICAgICAgICAgICAgICAgICByZXF1ZXN0cywgaW4gY2FzZSBub25lIGlzIHNwZWNpZmllZCBvciB0aGUgc3BlY2lmaWVkZSBmb250IGZhaWxzIHRvIGxvYWQgb3IgcGFyc2UuXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gXCJSb2JvdG8gUmVndWxhclwiIGZyb20gR29vZ2xlIEZvbnRzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5zZGZHbHlwaFNpemUgLSBUaGUgZGVmYXVsdCBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREYgKHNpZ25lZCBkaXN0YW5jZSBmaWVsZClcbiAqICAgICAgICAgICAgICAgICB0ZXh0dXJlIHVzZWQgZm9yIHJlbmRlcmluZy4gTXVzdCBiZSBhIHBvd2VyLW9mLXR3byBudW1iZXIsIGFuZCBhcHBsaWVzIHRvIGFsbCBmb250cyxcbiAqICAgICAgICAgICAgICAgICBidXQgbm90ZSB0aGF0IHRoaXMgY2FuIGFsc28gYmUgb3ZlcnJpZGRlbiBwZXIgY2FsbCB0byBgZ2V0VGV4dFJlbmRlckluZm8oKWAuXG4gKiAgICAgICAgICAgICAgICAgTGFyZ2VyIHNpemVzIGNhbiBpbXByb3ZlIHRoZSBxdWFsaXR5IG9mIGdseXBoIHJlbmRlcmluZyBieSBpbmNyZWFzaW5nIHRoZSBzaGFycG5lc3NcbiAqICAgICAgICAgICAgICAgICBvZiBjb3JuZXJzIGFuZCBwcmV2ZW50aW5nIGxvc3Mgb2YgdmVyeSB0aGluIGxpbmVzLCBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkuIERlZmF1bHRzXG4gKiAgICAgICAgICAgICAgICAgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHkuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZkV4cG9uZW50IC0gVGhlIGV4cG9uZW50IHVzZWQgd2hlbiBlbmNvZGluZyB0aGUgU0RGIHZhbHVlcy4gQSBoaWdoZXIgZXhwb25lbnRcbiAqICAgICAgICAgICAgICAgICBzaGlmdHMgdGhlIGVuY29kZWQgOC1iaXQgdmFsdWVzIHRvIGFjaGlldmUgaGlnaGVyIHByZWNpc2lvbi9hY2N1cmFjeSBhdCB0ZXhlbHMgbmVhcmVyXG4gKiAgICAgICAgICAgICAgICAgdGhlIGdseXBoJ3MgcGF0aCwgd2l0aCBsb3dlciBwcmVjaXNpb24gZnVydGhlciBhd2F5LiBEZWZhdWx0cyB0byA5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5zZGZNYXJnaW4gLSBIb3cgbXVjaCBzcGFjZSB0byByZXNlcnZlIGluIHRoZSBTREYgYXMgbWFyZ2luIG91dHNpZGUgdGhlIGdseXBoJ3NcbiAqICAgICAgICAgICAgICAgICBwYXRoLCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIFNERiB3aWR0aC4gQSBsYXJnZXIgbWFyZ2luIGluY3JlYXNlcyB0aGUgcXVhbGl0eSBvZlxuICogICAgICAgICAgICAgICAgIGV4dHJ1ZGVkIGdseXBoIG91dGxpbmVzLCBidXQgZGVjcmVhc2VzIHRoZSBwcmVjaXNpb24gYXZhaWxhYmxlIGZvciB0aGUgZ2x5cGggaXRzZWxmLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIDEvMTZ0aCBvZiB0aGUgZ2x5cGggc2l6ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcudGV4dHVyZVdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBTREYgdGV4dHVyZTsgbXVzdCBiZSBhIHBvd2VyIG9mIDIuIERlZmF1bHRzIHRvXG4gKiAgICAgICAgICAgICAgICAgMjA0OCB3aGljaCBpcyBhIHNhZmUgbWF4aW11bSB0ZXh0dXJlIGRpbWVuc2lvbiBhY2NvcmRpbmcgdG8gdGhlIHN0YXRzIGF0XG4gKiAgICAgICAgICAgICAgICAgaHR0cHM6Ly93ZWJnbHN0YXRzLmNvbS93ZWJnbC9wYXJhbWV0ZXIvTUFYX1RFWFRVUkVfU0laRSBhbmQgc2hvdWxkIGFsbG93IGZvciBhXG4gKiAgICAgICAgICAgICAgICAgcmVhc29uYWJseSBsYXJnZSBudW1iZXIgb2YgZ2x5cGhzIChkZWZhdWx0IGdseXBoIHNpemUgb2YgNjReMiBhbmQgc2FmZSB0ZXh0dXJlIHNpemUgb2ZcbiAqICAgICAgICAgICAgICAgICAyMDQ4XjIsIHRpbWVzIDQgY2hhbm5lbHMsIGFsbG93cyBmb3IgNDA5NiBnbHlwaHMuKSBUaGlzIGNhbiBiZSBpbmNyZWFzZWQgaWYgeW91IG5lZWQgdG9cbiAqICAgICAgICAgICAgICAgICBpbmNyZWFzZSB0aGUgZ2x5cGggc2l6ZSBhbmQvb3IgaGF2ZSBhbiBleHRyYW9yZGluYXJ5IG51bWJlciBvZiBnbHlwaHMuXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZVRleHRCdWlsZGVyKGNvbmZpZykge1xuICBpZiAoaGFzUmVxdWVzdGVkKSB7XG4gICAgY29uc29sZS53YXJuKCdjb25maWd1cmVUZXh0QnVpbGRlciBjYWxsZWQgYWZ0ZXIgZmlyc3QgZm9udCByZXF1ZXN0OyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH0gZWxzZSB7XG4gICAgYXNzaWduKENPTkZJRywgY29uZmlnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcG9zaXRvcnkgZm9yIGFsbCBmb250IFNERiBhdGxhcyB0ZXh0dXJlcyBhbmQgdGhlaXIgZ2x5cGggbWFwcGluZ3MuIFRoZXJlIGlzIGEgc2VwYXJhdGUgYXRsYXMgZm9yXG4gKiBlYWNoIHNkZkdseXBoU2l6ZS4gRWFjaCBhdGxhcyBoYXMgYSBzaW5nbGUgVGV4dHVyZSB0aGF0IGhvbGRzIGFsbCBnbHlwaHMgZm9yIGFsbCBmb250cy5cbiAqXG4gKiAgIHtcbiAqICAgICBbc2RmR2x5cGhTaXplXToge1xuICogICAgICAgZ2x5cGhDb3VudDogbnVtYmVyLFxuICogICAgICAgc2RmR2x5cGhTaXplOiBudW1iZXIsXG4gKiAgICAgICBzZGZUZXh0dXJlOiBUZXh0dXJlLFxuICogICAgICAgc2RmQ2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcbiAqICAgICAgIGNvbnRleHRMb3N0OiBib29sZWFuLFxuICogICAgICAgZ2x5cGhzQnlGb250OiBNYXA8Zm9udFVSTCwgTWFwPGdseXBoSUQsIHtwYXRoLCBhdGxhc0luZGV4LCBzZGZWaWV3Qm94fT4+XG4gKiAgICAgfVxuICogICB9XG4gKi9cbmNvbnN0IGF0bGFzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyb2lrYVRleHRSZW5kZXJJbmZvIC0gRm9ybWF0IG9mIHRoZSByZXN1bHQgZnJvbSBgZ2V0VGV4dFJlbmRlckluZm9gLlxuICogQHByb3BlcnR5IHtvYmplY3R9IHBhcmFtZXRlcnMgLSBUaGUgbm9ybWFsaXplZCBpbnB1dCBhcmd1bWVudHMgdG8gdGhlIHJlbmRlciBjYWxsLlxuICogQHByb3BlcnR5IHtUZXh0dXJlfSBzZGZUZXh0dXJlIC0gVGhlIFNERiBhdGxhcyB0ZXh0dXJlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNkZkdseXBoU2l6ZSAtIFRoZSBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREY7IHNlZSBgY29uZmlndXJlVGV4dEJ1aWxkZXJgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNkZkV4cG9uZW50IC0gVGhlIGV4cG9uZW50IHVzZWQgaW4gZW5jb2RpbmcgdGhlIFNERidzIHZhbHVlczsgc2VlIGBjb25maWd1cmVUZXh0QnVpbGRlcmAuXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZ2x5cGhCb3VuZHMgLSBMaXN0IG9mIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBxdWFkIGJvdW5kcyBmb3IgZWFjaCBnbHlwaC5cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEF0bGFzSW5kaWNlcyAtIExpc3QgaG9sZGluZyBlYWNoIGdseXBoJ3MgaW5kZXggaW4gdGhlIFNERiBhdGxhcy5cbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSAtIExpc3QgaG9sZGluZyBlYWNoIGdseXBoJ3MgW3IsIGcsIGJdIGNvbG9yLCBpZiBgY29sb3JSYW5nZXNgIHdhcyBzdXBwbGllZC5cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBbY2FyZXRQb3NpdGlvbnNdIC0gQSBsaXN0IG9mIGNhcmV0IHBvc2l0aW9ucyBmb3IgYWxsIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZzsgZWFjaCBpc1xuICogICAgICAgICAgIHRocmVlIGVsZW1lbnRzOiB0aGUgc3RhcnRpbmcgWCwgdGhlIGVuZGluZyBYLCBhbmQgdGhlIGJvdHRvbSBZIGZvciB0aGUgY2FyZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhcmV0SGVpZ2h0XSAtIEFuIGFwcHJvcHJpYXRlIGhlaWdodCBmb3IgYWxsIHNlbGVjdGlvbiBjYXJldHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYXNjZW5kZXIgLSBUaGUgZm9udCdzIGFzY2VuZGVyIG1ldHJpYy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZXNjZW5kZXIgLSBUaGUgZm9udCdzIGRlc2NlbmRlciBtZXRyaWMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FwSGVpZ2h0IC0gVGhlIGZvbnQncyBjYXAgaGVpZ2h0IG1ldHJpYywgYmFzZWQgb24gdGhlIGhlaWdodCBvZiBMYXRpbiBjYXBpdGFsIGxldHRlcnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0geEhlaWdodCAtIFRoZSBmb250J3MgeCBoZWlnaHQgbWV0cmljLCBiYXNlZCBvbiB0aGUgaGVpZ2h0IG9mIExhdGluIGxvd2VyY2FzZSBsZXR0ZXJzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVIZWlnaHQgLSBUaGUgZmluYWwgY29tcHV0ZWQgbGluZUhlaWdodCBtZWFzdXJlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3BCYXNlbGluZSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSB0b3AgbGluZSdzIGJhc2VsaW5lLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBibG9ja0JvdW5kcyAtIFRoZSB0b3RhbCBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gcmVjdCBvZiB0aGUgd2hvbGUgdGV4dCBibG9jaztcbiAqICAgICAgICAgICB0aGlzIGNhbiBpbmNsdWRlIGV4dHJhIHZlcnRpY2FsIHNwYWNlIGJleW9uZCB0aGUgdmlzaWJsZSBnbHlwaHMgZHVlIHRvIGxpbmVIZWlnaHQsIGFuZCBpc1xuICogICAgICAgICAgIGVxdWl2YWxlbnQgdG8gdGhlIGRpbWVuc2lvbnMgb2YgYSBibG9jay1sZXZlbCB0ZXh0IGVsZW1lbnQgaW4gQ1NTLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSB2aXNpYmxlQm91bmRzIC0gVGhlIHRvdGFsIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSByZWN0IG9mIHRoZSB3aG9sZSB0ZXh0IGJsb2NrO1xuICogICAgICAgICAgIHVubGlrZSBgYmxvY2tCb3VuZHNgIHRoaXMgaXMgdGlnaHRseSB3cmFwcGVkIHRvIHRoZSB2aXNpYmxlIGdseXBoIHBhdGhzLlxuICogQHByb3BlcnR5IHtBcnJheTxvYmplY3Q+fSBjaHVua2VkQm91bmRzIC0gTGlzdCBvZiBib3VuZGluZyByZWN0cyBmb3IgZWFjaCBjb25zZWN1dGl2ZSBzZXQgb2YgTiBnbHlwaHMsXG4gKiAgICAgICAgICAgaW4gdGhlIGZvcm1hdCBge3N0YXJ0Ok4sIGVuZDpOLCByZWN0OlttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXX1gLlxuICogQHByb3BlcnR5IHtvYmplY3R9IHRpbWluZ3MgLSBUaW1pbmcgaW5mbyBmb3IgdmFyaW91cyBwYXJ0cyBvZiB0aGUgcmVuZGVyaW5nIGxvZ2ljIGluY2x1ZGluZyBTREZcbiAqICAgICAgICAgICBnZW5lcmF0aW9uLCB0eXBlc2V0dGluZywgZXRjLlxuICogQGZyb3plblxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGdldFRleHRSZW5kZXJJbmZvfmNhbGxiYWNrXG4gKiBAcGFyYW0ge1Ryb2lrYVRleHRSZW5kZXJJbmZvfSB0ZXh0UmVuZGVySW5mb1xuICovXG5cbi8qKlxuICogTWFpbiBlbnRyeSBwb2ludCBmb3IgcmVxdWVzdGluZyB0aGUgZGF0YSBuZWVkZWQgdG8gcmVuZGVyIGEgdGV4dCBzdHJpbmcgd2l0aCBnaXZlbiBmb250IHBhcmFtZXRlcnMuXG4gKiBUaGlzIGlzIGFuIGFzeW5jaHJvbm91cyBjYWxsLCBwZXJmb3JtaW5nIG1vc3Qgb2YgdGhlIGxvZ2ljIGluIGEgd2ViIHdvcmtlciB0aHJlYWQuXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtnZXRUZXh0UmVuZGVySW5mb35jYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dFJlbmRlckluZm8oYXJncywgY2FsbGJhY2spIHtcbiAgaGFzUmVxdWVzdGVkID0gdHJ1ZTtcbiAgYXJncyA9IGFzc2lnbih7fSwgYXJncyk7XG4gIGNvbnN0IHRvdGFsU3RhcnQgPSBub3ckMSgpO1xuXG4gIC8vIEFwcGx5IGRlZmF1bHQgZm9udCBoZXJlIHRvIGF2b2lkIGEgJ251bGwnIGF0bGFzLCBhbmQgY29udmVydCByZWxhdGl2ZVxuICAvLyBVUkxzIHRvIGFic29sdXRlIHNvIHRoZXkgY2FuIGJlIHJlc29sdmVkIGluIHRoZSB3b3JrZXJcbiAgYXJncy5mb250ID0gdG9BYnNvbHV0ZVVSTChhcmdzLmZvbnQgfHwgQ09ORklHLmRlZmF1bHRGb250VVJMKTtcblxuICAvLyBOb3JtYWxpemUgdGV4dCB0byBhIHN0cmluZ1xuICBhcmdzLnRleHQgPSAnJyArIGFyZ3MudGV4dDtcblxuICBhcmdzLnNkZkdseXBoU2l6ZSA9IGFyZ3Muc2RmR2x5cGhTaXplIHx8IENPTkZJRy5zZGZHbHlwaFNpemU7XG5cbiAgLy8gTm9ybWFsaXplIGNvbG9yc1xuICBpZiAoYXJncy5jb2xvclJhbmdlcyAhPSBudWxsKSB7XG4gICAgbGV0IGNvbG9ycyA9IHt9O1xuICAgIGZvciAobGV0IGtleSBpbiBhcmdzLmNvbG9yUmFuZ2VzKSB7XG4gICAgICBpZiAoYXJncy5jb2xvclJhbmdlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGxldCB2YWwgPSBhcmdzLmNvbG9yUmFuZ2VzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhbCA9IHRlbXBDb2xvci5zZXQodmFsKS5nZXRIZXgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb2xvcnNba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgYXJncy5jb2xvclJhbmdlcyA9IGNvbG9ycztcbiAgfVxuXG4gIE9iamVjdC5mcmVlemUoYXJncyk7XG5cbiAgLy8gSW5pdCB0aGUgYXRsYXMgaWYgbmVlZGVkXG4gIGNvbnN0IHt0ZXh0dXJlV2lkdGgsIHNkZkV4cG9uZW50fSA9IENPTkZJRztcbiAgY29uc3Qge3NkZkdseXBoU2l6ZX0gPSBhcmdzO1xuICBjb25zdCBnbHlwaHNQZXJSb3cgPSAodGV4dHVyZVdpZHRoIC8gc2RmR2x5cGhTaXplICogNCk7XG4gIGxldCBhdGxhcyA9IGF0bGFzZXNbc2RmR2x5cGhTaXplXTtcbiAgaWYgKCFhdGxhcykge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IHRleHR1cmVXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gc2RmR2x5cGhTaXplICogMjU2IC8gZ2x5cGhzUGVyUm93OyAvLyBzdGFydCB0YWxsIGVub3VnaCB0byBmaXQgMjU2IGdseXBoc1xuICAgIGF0bGFzID0gYXRsYXNlc1tzZGZHbHlwaFNpemVdID0ge1xuICAgICAgZ2x5cGhDb3VudDogMCxcbiAgICAgIHNkZkdseXBoU2l6ZSxcbiAgICAgIHNkZkNhbnZhczogY2FudmFzLFxuICAgICAgc2RmVGV4dHVyZTogbmV3IFRleHR1cmUoXG4gICAgICAgIGNhbnZhcyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgTGluZWFyRmlsdGVyLFxuICAgICAgICBMaW5lYXJGaWx0ZXJcbiAgICAgICksXG4gICAgICBjb250ZXh0TG9zdDogZmFsc2UsXG4gICAgICBnbHlwaHNCeUZvbnQ6IG5ldyBNYXAoKVxuICAgIH07XG4gICAgYXRsYXMuc2RmVGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICBpbml0Q29udGV4dExvc3NIYW5kbGluZyhhdGxhcyk7XG4gIH1cblxuICBjb25zdCB7c2RmVGV4dHVyZSwgc2RmQ2FudmFzfSA9IGF0bGFzO1xuICBsZXQgZm9udEdseXBocyA9IGF0bGFzLmdseXBoc0J5Rm9udC5nZXQoYXJncy5mb250KTtcbiAgaWYgKCFmb250R2x5cGhzKSB7XG4gICAgYXRsYXMuZ2x5cGhzQnlGb250LnNldChhcmdzLmZvbnQsIGZvbnRHbHlwaHMgPSBuZXcgTWFwKCkpO1xuICB9XG5cbiAgLy8gSXNzdWUgcmVxdWVzdCB0byB0aGUgdHlwZXNldHRpbmcgZW5naW5lIGluIHRoZSB3b3JrZXJcbiAgdHlwZXNldEluV29ya2VyKGFyZ3MpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICBjb25zdCB7Z2x5cGhJZHMsIGdseXBoUG9zaXRpb25zLCBmb250U2l6ZSwgdW5pdHNQZXJFbSwgdGltaW5nc30gPSByZXN1bHQ7XG4gICAgY29uc3QgbmVlZGVkU0RGcyA9IFtdO1xuICAgIGNvbnN0IGdseXBoQm91bmRzID0gbmV3IEZsb2F0MzJBcnJheShnbHlwaElkcy5sZW5ndGggKiA0KTtcbiAgICBjb25zdCBmb250U2l6ZU11bHQgPSBmb250U2l6ZSAvIHVuaXRzUGVyRW07XG4gICAgbGV0IGJvdW5kc0lkeCA9IDA7XG4gICAgbGV0IHBvc2l0aW9uc0lkeCA9IDA7XG4gICAgY29uc3QgcXVhZHNTdGFydCA9IG5vdyQxKCk7XG4gICAgZ2x5cGhJZHMuZm9yRWFjaCgoZ2x5cGhJZCwgaSkgPT4ge1xuICAgICAgbGV0IGdseXBoSW5mbyA9IGZvbnRHbHlwaHMuZ2V0KGdseXBoSWQpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZ2x5cGhJZCBub3Qgc2VlbiBiZWZvcmUsIGFkZCBpdCB0byB0aGUgYXRsYXNcbiAgICAgIGlmICghZ2x5cGhJbmZvKSB7XG4gICAgICAgIGNvbnN0IHtwYXRoLCBwYXRoQm91bmRzfSA9IHJlc3VsdC5nbHlwaERhdGFbZ2x5cGhJZF07XG5cbiAgICAgICAgLy8gTWFyZ2luIGFyb3VuZCBwYXRoIGVkZ2VzIGluIFNERiwgYmFzZWQgb24gYSBwZXJjZW50YWdlIG9mIHRoZSBnbHlwaCdzIG1heCBkaW1lbnNpb24uXG4gICAgICAgIC8vIE5vdGUgd2UgYWRkIGFuIGV4dHJhIDAuNSBweCBvdmVyIHRoZSBjb25maWd1cmVkIHZhbHVlIGJlY2F1c2UgdGhlIG91dGVyIDAuNSBkb2Vzbid0IGNvbnRhaW5cbiAgICAgICAgLy8gdXNlZnVsIGludGVycG9sYXRlZCB2YWx1ZXMgYW5kIHdpbGwgYmUgaWdub3JlZCBhbnl3YXkuXG4gICAgICAgIGNvbnN0IGZvbnRVbml0c01hcmdpbiA9IE1hdGgubWF4KHBhdGhCb3VuZHNbMl0gLSBwYXRoQm91bmRzWzBdLCBwYXRoQm91bmRzWzNdIC0gcGF0aEJvdW5kc1sxXSlcbiAgICAgICAgICAvIHNkZkdseXBoU2l6ZSAqIChDT05GSUcuc2RmTWFyZ2luICogc2RmR2x5cGhTaXplICsgMC41KTtcblxuICAgICAgICBjb25zdCBhdGxhc0luZGV4ID0gYXRsYXMuZ2x5cGhDb3VudCsrO1xuICAgICAgICBjb25zdCBzZGZWaWV3Qm94ID0gW1xuICAgICAgICAgIHBhdGhCb3VuZHNbMF0gLSBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgICAgcGF0aEJvdW5kc1sxXSAtIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICBwYXRoQm91bmRzWzJdICsgZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgIHBhdGhCb3VuZHNbM10gKyBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgIF07XG4gICAgICAgIGZvbnRHbHlwaHMuc2V0KGdseXBoSWQsIChnbHlwaEluZm8gPSB7IHBhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3ggfSkpO1xuXG4gICAgICAgIC8vIENvbGxlY3QgdGhvc2UgdGhhdCBuZWVkIFNERiBnZW5lcmF0aW9uXG4gICAgICAgIG5lZWRlZFNERnMucHVzaChnbHlwaEluZm8pO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgYm91bmRzIGZvciByZW5kZXJhYmxlIHF1YWRzXG4gICAgICAvLyBUT0RPIGNhbiB3ZSBnZXQgdGhpcyBiYWNrIG9mZiB0aGUgbWFpbiB0aHJlYWQ/XG4gICAgICBjb25zdCB7c2RmVmlld0JveH0gPSBnbHlwaEluZm87XG4gICAgICBjb25zdCBwb3NYID0gZ2x5cGhQb3NpdGlvbnNbcG9zaXRpb25zSWR4KytdO1xuICAgICAgY29uc3QgcG9zWSA9IGdseXBoUG9zaXRpb25zW3Bvc2l0aW9uc0lkeCsrXTtcbiAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1ggKyBzZGZWaWV3Qm94WzBdICogZm9udFNpemVNdWx0O1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWSArIHNkZlZpZXdCb3hbMV0gKiBmb250U2l6ZU11bHQ7XG4gICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NYICsgc2RmVmlld0JveFsyXSAqIGZvbnRTaXplTXVsdDtcbiAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1kgKyBzZGZWaWV3Qm94WzNdICogZm9udFNpemVNdWx0O1xuXG4gICAgICAvLyBDb252ZXJ0IGdseXBoSWQgdG8gU0RGIGluZGV4IGZvciB0aGUgc2hhZGVyXG4gICAgICBnbHlwaElkc1tpXSA9IGdseXBoSW5mby5hdGxhc0luZGV4O1xuICAgIH0pO1xuICAgIHRpbWluZ3MucXVhZHMgPSAodGltaW5ncy5xdWFkcyB8fCAwKSArIChub3ckMSgpIC0gcXVhZHNTdGFydCk7XG5cbiAgICBjb25zdCBzZGZTdGFydCA9IG5vdyQxKCk7XG4gICAgdGltaW5ncy5zZGYgPSB7fTtcblxuICAgIC8vIEdyb3cgdGhlIHRleHR1cmUgaGVpZ2h0IGJ5IHBvd2VyIG9mIDIgaWYgbmVlZGVkXG4gICAgY29uc3QgY3VycmVudEhlaWdodCA9IHNkZkNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgbmVlZGVkUm93cyA9IE1hdGguY2VpbChhdGxhcy5nbHlwaENvdW50IC8gZ2x5cGhzUGVyUm93KTtcbiAgICBjb25zdCBuZWVkZWRIZWlnaHQgPSBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKG5lZWRlZFJvd3MgKiBzZGZHbHlwaFNpemUpKSk7XG4gICAgaWYgKG5lZWRlZEhlaWdodCA+IGN1cnJlbnRIZWlnaHQpIHtcbiAgICAgIC8vIFNpbmNlIHJlc2l6aW5nIHRoZSBjYW52YXMgY2xlYXJzIGl0cyByZW5kZXIgYnVmZmVyLCBpdCBuZWVkcyBzcGVjaWFsIGhhbmRsaW5nIHRvIGNvcHkgdGhlIG9sZCBjb250ZW50cyBvdmVyXG4gICAgICBjb25zb2xlLmluZm8oYEluY3JlYXNpbmcgU0RGIHRleHR1cmUgc2l6ZSAke2N1cnJlbnRIZWlnaHR9LT4ke25lZWRlZEhlaWdodH1gKTtcbiAgICAgIHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nKHNkZkNhbnZhcywgdGV4dHVyZVdpZHRoLCBuZWVkZWRIZWlnaHQpO1xuICAgICAgLy8gQXMgb2YgVGhyZWUgcjEzNiB0ZXh0dXJlcyBjYW5ub3QgYmUgcmVzaXplZCBvbmNlIHRoZXkncmUgYWxsb2NhdGVkIG9uIHRoZSBHUFUsIHdlIG11c3QgZGlzcG9zZSB0byByZWFsbG9jYXRlIGl0XG4gICAgICBzZGZUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICBQcm9taXNlLmFsbChuZWVkZWRTREZzLm1hcChnbHlwaEluZm8gPT5cbiAgICAgIGdlbmVyYXRlR2x5cGhTREYoZ2x5cGhJbmZvLCBhdGxhcywgYXJncy5ncHVBY2NlbGVyYXRlU0RGKS50aGVuKCh7dGltaW5nfSkgPT4ge1xuICAgICAgICB0aW1pbmdzLnNkZltnbHlwaEluZm8uYXRsYXNJbmRleF0gPSB0aW1pbmc7XG4gICAgICB9KVxuICAgICkpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKG5lZWRlZFNERnMubGVuZ3RoICYmICFhdGxhcy5jb250ZXh0TG9zdCkge1xuICAgICAgICBzYWZhcmlQcmUxNVdvcmthcm91bmQoYXRsYXMpO1xuICAgICAgICBzZGZUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRpbWluZ3Muc2RmVG90YWwgPSBub3ckMSgpIC0gc2RmU3RhcnQ7XG4gICAgICB0aW1pbmdzLnRvdGFsID0gbm93JDEoKSAtIHRvdGFsU3RhcnQ7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgU0RGIC0gJHt0aW1pbmdzLnNkZlRvdGFsfSwgVG90YWwgLSAke3RpbWluZ3MudG90YWwgLSB0aW1pbmdzLmZvbnRMb2FkfWApXG5cbiAgICAgIC8vIEludm9rZSBjYWxsYmFjayB3aXRoIHRoZSB0ZXh0IGxheW91dCBhcnJheXMgYW5kIHVwZGF0ZWQgdGV4dHVyZVxuICAgICAgY2FsbGJhY2soT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHBhcmFtZXRlcnM6IGFyZ3MsXG4gICAgICAgIHNkZlRleHR1cmUsXG4gICAgICAgIHNkZkdseXBoU2l6ZSxcbiAgICAgICAgc2RmRXhwb25lbnQsXG4gICAgICAgIGdseXBoQm91bmRzLFxuICAgICAgICBnbHlwaEF0bGFzSW5kaWNlczogZ2x5cGhJZHMsXG4gICAgICAgIGdseXBoQ29sb3JzOiByZXN1bHQuZ2x5cGhDb2xvcnMsXG4gICAgICAgIGNhcmV0UG9zaXRpb25zOiByZXN1bHQuY2FyZXRQb3NpdGlvbnMsXG4gICAgICAgIGNhcmV0SGVpZ2h0OiByZXN1bHQuY2FyZXRIZWlnaHQsXG4gICAgICAgIGNodW5rZWRCb3VuZHM6IHJlc3VsdC5jaHVua2VkQm91bmRzLFxuICAgICAgICBhc2NlbmRlcjogcmVzdWx0LmFzY2VuZGVyLFxuICAgICAgICBkZXNjZW5kZXI6IHJlc3VsdC5kZXNjZW5kZXIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IHJlc3VsdC5saW5lSGVpZ2h0LFxuICAgICAgICBjYXBIZWlnaHQ6IHJlc3VsdC5jYXBIZWlnaHQsXG4gICAgICAgIHhIZWlnaHQ6IHJlc3VsdC54SGVpZ2h0LFxuICAgICAgICB0b3BCYXNlbGluZTogcmVzdWx0LnRvcEJhc2VsaW5lLFxuICAgICAgICBibG9ja0JvdW5kczogcmVzdWx0LmJsb2NrQm91bmRzLFxuICAgICAgICB2aXNpYmxlQm91bmRzOiByZXN1bHQudmlzaWJsZUJvdW5kcyxcbiAgICAgICAgdGltaW5nczogcmVzdWx0LnRpbWluZ3MsXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFdoaWxlIHRoZSB0eXBlc2V0dGluZyByZXF1ZXN0IGlzIGJlaW5nIGhhbmRsZWQsIGdvIGFoZWFkIGFuZCBtYWtlIHN1cmUgdGhlIGF0bGFzIGNhbnZhcyBjb250ZXh0IGlzXG4gIC8vIFwid2FybWVkIHVwXCI7IHRoZSBmaXJzdCByZXF1ZXN0IHdpbGwgYmUgdGhlIGxvbmdlc3QgZHVlIHRvIHNoYWRlciBwcm9ncmFtIGNvbXBpbGF0aW9uIHNvIHRoaXMgZ2V0c1xuICAvLyBhIGhlYWQgc3RhcnQgb24gdGhhdCBwcm9jZXNzIGJlZm9yZSBTREZzIGFjdHVhbGx5IHN0YXJ0IGdldHRpbmcgcHJvY2Vzc2VkLlxuICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAoIWF0bGFzLmNvbnRleHRMb3N0KSB7XG4gICAgICB3YXJtVXBTREZDYW52YXMoc2RmQ2FudmFzKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUdseXBoU0RGKHtwYXRoLCBhdGxhc0luZGV4LCBzZGZWaWV3Qm94fSwge3NkZkdseXBoU2l6ZSwgc2RmQ2FudmFzLCBjb250ZXh0TG9zdH0sIHVzZUdQVSkge1xuICBpZiAoY29udGV4dExvc3QpIHtcbiAgICAvLyBJZiB0aGUgY29udGV4dCBpcyBsb3N0IHRoZXJlJ3Mgbm90aGluZyB3ZSBjYW4gZG8sIGp1c3QgcXVpdCBzaWxlbnRseSBhbmQgbGV0IGl0XG4gICAgLy8gZ2V0IHJlZ2VuZXJhdGVkIHdoZW4gdGhlIGNvbnRleHQgaXMgcmVzdG9yZWRcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt0aW1pbmc6IC0xfSlcbiAgfVxuICBjb25zdCB7dGV4dHVyZVdpZHRoLCBzZGZFeHBvbmVudH0gPSBDT05GSUc7XG4gIGNvbnN0IG1heERpc3QgPSBNYXRoLm1heChzZGZWaWV3Qm94WzJdIC0gc2RmVmlld0JveFswXSwgc2RmVmlld0JveFszXSAtIHNkZlZpZXdCb3hbMV0pO1xuICBjb25zdCBzcXVhcmVJbmRleCA9IE1hdGguZmxvb3IoYXRsYXNJbmRleCAvIDQpO1xuICBjb25zdCB4ID0gc3F1YXJlSW5kZXggJSAodGV4dHVyZVdpZHRoIC8gc2RmR2x5cGhTaXplKSAqIHNkZkdseXBoU2l6ZTtcbiAgY29uc3QgeSA9IE1hdGguZmxvb3Ioc3F1YXJlSW5kZXggLyAodGV4dHVyZVdpZHRoIC8gc2RmR2x5cGhTaXplKSkgKiBzZGZHbHlwaFNpemU7XG4gIGNvbnN0IGNoYW5uZWwgPSBhdGxhc0luZGV4ICUgNDtcbiAgcmV0dXJuIGdlbmVyYXRlU0RGKHNkZkdseXBoU2l6ZSwgc2RmR2x5cGhTaXplLCBwYXRoLCBzZGZWaWV3Qm94LCBtYXhEaXN0LCBzZGZFeHBvbmVudCwgc2RmQ2FudmFzLCB4LCB5LCBjaGFubmVsLCB1c2VHUFUpXG59XG5cbmZ1bmN0aW9uIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGF0bGFzLnNkZkNhbnZhcztcblxuICAvKlxuICAvLyBCZWdpbiBjb250ZXh0IGxvc3Mgc2ltdWxhdGlvblxuICBpZiAoIXdpbmRvdy5XZWJHTERlYnVnVXRpbHMpIHtcbiAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dlYkdMRGVidWdVdGlsc1NjcmlwdCcpXG4gICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgICBzY3JpcHQuaWQgPSAnV2ViR0xEZWJ1Z1V0aWxzJ1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXG4gICAgICBzY3JpcHQuc3JjID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9LaHJvbm9zR3JvdXAvV2ViR0xEZXZlbG9wZXJUb29sc0BiNDJlNzAyL3NyYy9kZWJ1Zy93ZWJnbC1kZWJ1Zy5qcydcbiAgICB9XG4gICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICBpbml0Q29udGV4dExvc3NIYW5kbGluZyhhdGxhcylcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG4gIHdpbmRvdy5XZWJHTERlYnVnVXRpbHMubWFrZUxvc3RDb250ZXh0U2ltdWxhdGluZ0NhbnZhcyhjYW52YXMpXG4gIGNhbnZhcy5sb3NlQ29udGV4dEluTkNhbGxzKDUwMClcbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgKGV2ZW50KSA9PiB7XG4gICAgY2FudmFzLmxvc2VDb250ZXh0SW5OQ2FsbHMoNTAwMClcbiAgfSlcbiAgLy8gRW5kIGNvbnRleHQgbG9zcyBzaW11bGF0aW9uXG4gICovXG5cbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ29udGV4dCBMb3N0JywgZXZlbnQpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgYXRsYXMuY29udGV4dExvc3QgPSB0cnVlO1xuICB9KTtcbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NvbnRleHQgUmVzdG9yZWQnLCBldmVudCk7XG4gICAgYXRsYXMuY29udGV4dExvc3QgPSBmYWxzZTtcbiAgICAvLyBSZWdlbmVyYXRlIGFsbCBnbHlwaHMgaW50byB0aGUgcmVzdG9yZWQgY2FudmFzOlxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgYXRsYXMuZ2x5cGhzQnlGb250LmZvckVhY2goZ2x5cGhNYXAgPT4ge1xuICAgICAgZ2x5cGhNYXAuZm9yRWFjaChnbHlwaCA9PiB7XG4gICAgICAgIHByb21pc2VzLnB1c2goZ2VuZXJhdGVHbHlwaFNERihnbHlwaCwgYXRsYXMsIHRydWUpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcyk7XG4gICAgICBhdGxhcy5zZGZUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUHJlbG9hZCBhIGdpdmVuIGZvbnQgYW5kIG9wdGlvbmFsbHkgcHJlLWdlbmVyYXRlIGdseXBoIFNERnMgZm9yIG9uZSBvciBtb3JlIGNoYXJhY3RlciBzZXF1ZW5jZXMuXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gYXZvaWQgbG9uZyBwYXVzZXMgd2hlbiBmaXJzdCBzaG93aW5nIHRleHQgaW4gYSBzY2VuZSwgYnkgcHJlbG9hZGluZyB0aGVcbiAqIG5lZWRlZCBmb250cyBhbmQgZ2x5cGhzIHVwIGZyb250IGFsb25nIHdpdGggb3RoZXIgYXNzZXRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5mb250IC0gVVJMIG9mIHRoZSBmb250IGZpbGUgdG8gcHJlbG9hZC4gSWYgbm90IGdpdmVuLCB0aGUgZGVmYXVsdCBmb250IHdpbGxcbiAqICAgICAgICBiZSBsb2FkZWQuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gb3B0aW9ucy5jaGFyYWN0ZXJzIC0gT25lIG9yIG1vcmUgY2hhcmFjdGVyIHNlcXVlbmNlcyBmb3Igd2hpY2ggdG8gcHJlLVxuICogICAgICAgIGdlbmVyYXRlIGdseXBoIFNERnMuIE5vdGUgdGhhdCB0aGlzIHdpbGwgaG9ub3IgbGlnYXR1cmUgc3Vic3RpdHV0aW9uLCBzbyB5b3UgbWF5IG5lZWRcbiAqICAgICAgICB0byBzcGVjaWZ5IGxpZ2F0dXJlIHNlcXVlbmNlcyBpbiBhZGRpdGlvbiB0byB0aGVpciBpbmRpdmlkdWFsIGNoYXJhY3RlcnMgdG8gZ2V0IGFsbFxuICogICAgICAgIHBvc3NpYmxlIGdseXBocywgZS5nLiBgW1widFwiLCBcImhcIiwgXCJ0aFwiXWAgdG8gZ2V0IHRoZSBcInRcIiBhbmQgXCJoXCIgZ2x5cGhzIHBsdXMgdGhlIFwidGhcIiBsaWdhdHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNkZkdseXBoU2l6ZSAtIFRoZSBzaXplIGF0IHdoaWNoIHRvIHByZXJlbmRlciB0aGUgU0RGIHRleHR1cmVzIGZvciB0aGVcbiAqICAgICAgICBzcGVjaWZpZWQgYGNoYXJhY3RlcnNgLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgcHJlbG9hZGluZyBpcyBjb21wbGV0ZS5cbiAqL1xuZnVuY3Rpb24gcHJlbG9hZEZvbnQoe2ZvbnQsIGNoYXJhY3RlcnMsIHNkZkdseXBoU2l6ZX0sIGNhbGxiYWNrKSB7XG4gIGxldCB0ZXh0ID0gQXJyYXkuaXNBcnJheShjaGFyYWN0ZXJzKSA/IGNoYXJhY3RlcnMuam9pbignXFxuJykgOiAnJyArIGNoYXJhY3RlcnM7XG4gIGdldFRleHRSZW5kZXJJbmZvKHsgZm9udCwgc2RmR2x5cGhTaXplLCB0ZXh0IH0sIGNhbGxiYWNrKTtcbn1cblxuXG4vLyBMb2NhbCBhc3NpZ24gaW1wbCBzbyB3ZSBkb24ndCBoYXZlIHRvIGltcG9ydCB0cm9pa2EtY29yZVxuZnVuY3Rpb24gYXNzaWduKHRvT2JqLCBmcm9tT2JqKSB7XG4gIGZvciAobGV0IGtleSBpbiBmcm9tT2JqKSB7XG4gICAgaWYgKGZyb21PYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdG9PYmpba2V5XSA9IGZyb21PYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvT2JqXG59XG5cbi8vIFV0aWxpdHkgZm9yIG1ha2luZyBVUkxzIGFic29sdXRlXG5sZXQgbGlua0VsO1xuZnVuY3Rpb24gdG9BYnNvbHV0ZVVSTChwYXRoKSB7XG4gIGlmICghbGlua0VsKSB7XG4gICAgbGlua0VsID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IHt9IDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICB9XG4gIGxpbmtFbC5ocmVmID0gcGF0aDtcbiAgcmV0dXJuIGxpbmtFbC5ocmVmXG59XG5cbi8qKlxuICogU2FmYXJpIDwgdjE1IHNlZW1zIHVuYWJsZSB0byB1c2UgdGhlIFNERiB3ZWJnbCBjYW52YXMgYXMgYSB0ZXh0dXJlLiBUaGlzIGFwcGxpZXMgYSB3b3JrYXJvdW5kXG4gKiB3aGVyZSBpdCByZWFkcyB0aGUgcGl4ZWxzIG91dCBvZiB0aGF0IGNhbnZhcyBhbmQgdXBsb2FkcyB0aGVtIGFzIGEgZGF0YSB0ZXh0dXJlIGluc3RlYWQsIGF0XG4gKiBhIHNsaWdodCBwZXJmb3JtYW5jZSBjb3N0LlxuICovXG5mdW5jdGlvbiBzYWZhcmlQcmUxNVdvcmthcm91bmQoYXRsYXMpIHtcbiAgLy8gVXNlIGNyZWF0ZUltYWdlQml0bWFwIHN1cHBvcnQgYXMgYSBwcm94eSBmb3IgU2FmYXJpPDE1LCBhbGwgb3RoZXIgbWFpbnN0cmVhbSBicm93c2Vyc1xuICAvLyBoYXZlIHN1cHBvcnRlZCBpdCBmb3IgYSBsb25nIHdoaWxlIHNvIGFueSBmYWxzZSBwb3NpdGl2ZXMgc2hvdWxkIGJlIG1pbmltYWwuXG4gIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmluZm8oJ1NhZmFyaTwxNTogYXBwbHlpbmcgU0RGIGNhbnZhcyB3b3JrYXJvdW5kJyk7XG4gICAgY29uc3Qge3NkZkNhbnZhcywgc2RmVGV4dHVyZX0gPSBhdGxhcztcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzZGZDYW52YXM7XG4gICAgY29uc3QgZ2wgPSBhdGxhcy5zZGZDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKTtcbiAgICBsZXQgcGl4ZWxzID0gc2RmVGV4dHVyZS5pbWFnZS5kYXRhO1xuICAgIGlmICghcGl4ZWxzIHx8IHBpeGVscy5sZW5ndGggIT09IHdpZHRoICogaGVpZ2h0ICogNCkge1xuICAgICAgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgIHNkZlRleHR1cmUuaW1hZ2UgPSB7d2lkdGgsIGhlaWdodCwgZGF0YTogcGl4ZWxzfTtcbiAgICAgIHNkZlRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHNkZlRleHR1cmUuaXNEYXRhVGV4dHVyZSA9IHRydWU7XG4gICAgfVxuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgfVxufVxuXG5cbmNvbnN0IHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUgPSAvKiNfX1BVUkVfXyovZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgbmFtZTogJ1R5cGVzZXR0ZXInLFxuICBkZXBlbmRlbmNpZXM6IFtcbiAgICBDT05GSUcsXG4gICAgd29ya2VyTW9kdWxlLFxuICAgIGNyZWF0ZVR5cGVzZXR0ZXIsXG4gICAgYmlkaUZhY3RvcnlcbiAgXSxcbiAgaW5pdChjb25maWcsIGZvbnRQYXJzZXIsIGNyZWF0ZVR5cGVzZXR0ZXIsIGJpZGlGYWN0b3J5KSB7XG4gICAgY29uc3Qge2RlZmF1bHRGb250VVJMfSA9IGNvbmZpZztcbiAgICByZXR1cm4gY3JlYXRlVHlwZXNldHRlcihmb250UGFyc2VyLCBiaWRpRmFjdG9yeSgpLCB7IGRlZmF1bHRGb250VVJMIH0pXG4gIH1cbn0pO1xuXG5jb25zdCB0eXBlc2V0SW5Xb3JrZXIgPSAvKiNfX1BVUkVfXyovZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgbmFtZTogJ1R5cGVzZXR0ZXInLFxuICBkZXBlbmRlbmNpZXM6IFtcbiAgICB0eXBlc2V0dGVyV29ya2VyTW9kdWxlLFxuICBdLFxuICBpbml0KHR5cGVzZXR0ZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJncykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0eXBlc2V0dGVyLnR5cGVzZXQoYXJncywgcmVzb2x2ZSk7XG4gICAgICB9KVxuICAgIH1cbiAgfSxcbiAgZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpIHtcbiAgICAvLyBNYXJrIGFycmF5IGJ1ZmZlcnMgYXMgdHJhbnNmZXJhYmxlIHRvIGF2b2lkIGNsb25pbmcgZHVyaW5nIHBvc3RNZXNzYWdlXG4gICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtcbiAgICAgIHJlc3VsdC5nbHlwaFBvc2l0aW9ucy5idWZmZXIsXG4gICAgICByZXN1bHQuZ2x5cGhJZHMuYnVmZmVyXG4gICAgXTtcbiAgICBpZiAocmVzdWx0LmNhcmV0UG9zaXRpb25zKSB7XG4gICAgICB0cmFuc2ZlcmFibGVzLnB1c2gocmVzdWx0LmNhcmV0UG9zaXRpb25zLmJ1ZmZlcik7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuZ2x5cGhDb2xvcnMpIHtcbiAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChyZXN1bHQuZ2x5cGhDb2xvcnMuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZmVyYWJsZXNcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGR1bXBTREZUZXh0dXJlcygpIHtcbiAgT2JqZWN0LmtleXMoYXRsYXNlcykuZm9yRWFjaChzaXplID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBhdGxhc2VzW3NpemVdLnNkZkNhbnZhcztcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBjYW52YXM7XG4gICAgY29uc29sZS5sb2coXCIlYy5cIiwgYFxuICAgICAgYmFja2dyb3VuZDogdXJsKCR7Y2FudmFzLnRvRGF0YVVSTCgpfSk7XG4gICAgICBiYWNrZ3JvdW5kLXNpemU6ICR7d2lkdGh9cHggJHtoZWlnaHR9cHg7XG4gICAgICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICBmb250LXNpemU6IDA7XG4gICAgICBsaW5lLWhlaWdodDogJHtoZWlnaHR9cHg7XG4gICAgICBwYWRkaW5nLWxlZnQ6ICR7d2lkdGh9cHg7XG4gICAgYCk7XG4gIH0pO1xufVxuXG5jb25zdCB0ZW1wbGF0ZUdlb21ldHJpZXMgPSB7fTtcblxuZnVuY3Rpb24gZ2V0VGVtcGxhdGVHZW9tZXRyeShkZXRhaWwpIHtcbiAgbGV0IGdlb20gPSB0ZW1wbGF0ZUdlb21ldHJpZXNbZGV0YWlsXTtcbiAgaWYgKCFnZW9tKSB7XG4gICAgLy8gR2VvbWV0cnkgaXMgdHdvIHBsYW5lcyBiYWNrLXRvLWJhY2ssIHdoaWNoIHdpbGwgYWx3YXlzIGJlIHJlbmRlcmVkIEZyb250U2lkZSBvbmx5IGJ1dFxuICAgIC8vIGFwcGVhciBhcyBEb3VibGVTaWRlIGJ5IGRlZmF1bHQuIEZyb250U2lkZS9CYWNrU2lkZSBhcmUgZW11bGF0ZWQgdXNpbmcgZHJhd1JhbmdlLlxuICAgIC8vIFdlIGRvIGl0IHRoaXMgd2F5IHRvIGF2b2lkIHRoZSBwZXJmb3JtYW5jZSBoaXQgb2YgdHdvIGRyYXcgY2FsbHMgZm9yIERvdWJsZVNpZGUgbWF0ZXJpYWxzXG4gICAgLy8gaW50cm9kdWNlZCBieSBUaHJlZS5qcyBpbiByMTMwIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMTk2N1xuICAgIGNvbnN0IGZyb250ID0gbmV3IFBsYW5lR2VvbWV0cnkoMSwgMSwgZGV0YWlsLCBkZXRhaWwpO1xuICAgIGNvbnN0IGJhY2sgPSBmcm9udC5jbG9uZSgpO1xuICAgIGNvbnN0IGZyb250QXR0cnMgPSBmcm9udC5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGJhY2tBdHRycyA9IGJhY2suYXR0cmlidXRlcztcbiAgICBjb25zdCBjb21iaW5lZCA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGNvbnN0IHZlcnRDb3VudCA9IGZyb250QXR0cnMudXYuY291bnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0Q291bnQ7IGkrKykge1xuICAgICAgYmFja0F0dHJzLnBvc2l0aW9uLmFycmF5W2kgKiAzXSAqPSAtMTsgLy8gZmxpcCBwb3NpdGlvbiB4XG4gICAgICBiYWNrQXR0cnMubm9ybWFsLmFycmF5W2kgKiAzICsgMl0gKj0gLTE7IC8vIGZsaXAgbm9ybWFsIHpcbiAgICB9XG4gICAgWydwb3NpdGlvbicsICdub3JtYWwnLCAndXYnXS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgY29tYmluZWQuc2V0QXR0cmlidXRlKG5hbWUsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICBbLi4uZnJvbnRBdHRyc1tuYW1lXS5hcnJheSwgLi4uYmFja0F0dHJzW25hbWVdLmFycmF5XSxcbiAgICAgICAgZnJvbnRBdHRyc1tuYW1lXS5pdGVtU2l6ZSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29tYmluZWQuc2V0SW5kZXgoWy4uLmZyb250LmluZGV4LmFycmF5LCAuLi5iYWNrLmluZGV4LmFycmF5Lm1hcChuID0+IG4gKyB2ZXJ0Q291bnQpXSk7XG4gICAgY29tYmluZWQudHJhbnNsYXRlKDAuNSwgMC41LCAwKTtcbiAgICBnZW9tID0gdGVtcGxhdGVHZW9tZXRyaWVzW2RldGFpbF0gPSBjb21iaW5lZDtcbiAgfVxuICByZXR1cm4gZ2VvbVxufVxuXG5jb25zdCBnbHlwaEJvdW5kc0F0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaEJvdW5kcyc7XG5jb25zdCBnbHlwaEluZGV4QXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoSW5kZXgnO1xuY29uc3QgZ2x5cGhDb2xvckF0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaENvbG9yJztcblxuLyoqXG5AY2xhc3MgR2x5cGhzR2VvbWV0cnlcblxuQSBzcGVjaWFsaXplZCBHZW9tZXRyeSBmb3IgcmVuZGVyaW5nIGEgc2V0IG9mIHRleHQgZ2x5cGhzLiBVc2VzIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IHRvXG5yZW5kZXIgdGhlIGdseXBocyB1c2luZyBHUFUgaW5zdGFuY2luZyBvZiBhIHNpbmdsZSBxdWFkLCByYXRoZXIgdGhhbiBjb25zdHJ1Y3RpbmcgYSB3aG9sZVxuZ2VvbWV0cnkgd2l0aCB2ZXJ0aWNlcywgZm9yIG11Y2ggc21hbGxlciBhdHRyaWJ1dGUgYXJyYXlidWZmZXJzIGFjY29yZGluZyB0byB0aGlzIG1hdGg6XG5cbiAgV2hlcmUgTiA9IG51bWJlciBvZiBnbHlwaHMuLi5cblxuICBJbnN0YW5jZWQ6XG4gIC0gcG9zaXRpb246IDQgKiAzXG4gIC0gaW5kZXg6IDIgKiAzXG4gIC0gbm9ybWFsOiA0ICogM1xuICAtIHV2OiA0ICogMlxuICAtIGdseXBoIHgveSBib3VuZHM6IE4gKiA0XG4gIC0gZ2x5cGggaW5kaWNlczogTiAqIDFcbiAgPSA1TiArIDM4XG5cbiAgTm9uLWluc3RhbmNlZDpcbiAgLSBwb3NpdGlvbjogTiAqIDQgKiAzXG4gIC0gaW5kZXg6IE4gKiAyICogM1xuICAtIG5vcm1hbDogTiAqIDQgKiAzXG4gIC0gdXY6IE4gKiA0ICogMlxuICAtIGdseXBoIGluZGljZXM6IE4gKiAxXG4gID0gMzlOXG5cbkEgZG93bnNpZGUgb2YgdGhpcyBpcyB0aGUgcmFyZS1idXQtcG9zc2libGUgbGFjayBvZiB0aGUgaW5zdGFuY2VkIGFycmF5cyBleHRlbnNpb24sXG53aGljaCB3ZSBjb3VsZCBwb3RlbnRpYWxseSB3b3JrIGFyb3VuZCB3aXRoIGEgZmFsbGJhY2sgbm9uLWluc3RhbmNlZCBpbXBsZW1lbnRhdGlvbi5cblxuKi9cbmNsYXNzIEdseXBoc0dlb21ldHJ5IGV4dGVuZHMgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5kZXRhaWwgPSAxO1xuICAgIHRoaXMuY3VydmVSYWRpdXMgPSAwO1xuXG4gICAgLy8gRGVmaW5lIGdyb3VwcyBmb3IgcmVuZGVyaW5nIHRleHQgb3V0bGluZSBhcyBhIHNlcGFyYXRlIHBhc3M7IHRoZXNlIHdpbGwgb25seVxuICAgIC8vIGJlIHVzZWQgd2hlbiB0aGUgYG1hdGVyaWFsYCBnZXR0ZXIgcmV0dXJucyBhbiBhcnJheSwgaS5lLiBvdXRsaW5lV2lkdGggPiAwLlxuICAgIHRoaXMuZ3JvdXBzID0gW1xuICAgICAge3N0YXJ0OiAwLCBjb3VudDogSW5maW5pdHksIG1hdGVyaWFsSW5kZXg6IDB9LFxuICAgICAge3N0YXJ0OiAwLCBjb3VudDogSW5maW5pdHksIG1hdGVyaWFsSW5kZXg6IDF9XG4gICAgXTtcblxuICAgIC8vIFByZWFsbG9jYXRlIGVtcHR5IGJvdW5kaW5nIG9iamVjdHNcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuICB9XG5cbiAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlICgpIHtcbiAgICAvLyBOby1vcDsgd2UnbGwgc3luYyB0aGUgYm91bmRpbmdTcGhlcmUgcHJvYWN0aXZlbHkgd2hlbiBuZWVkZWQuXG4gIH1cblxuICBjb21wdXRlQm91bmRpbmdCb3goKSB7XG4gICAgLy8gTm8tb3A7IHdlJ2xsIHN5bmMgdGhlIGJvdW5kaW5nQm94IHByb2FjdGl2ZWx5IHdoZW4gbmVlZGVkLlxuICB9XG5cbiAgLy8gU2luY2Ugb3VyIGJhc2UgZ2VvbWV0cnkgY29udGFpbnMgdHJpYW5nbGVzIGZvciBib3RoIGZyb250IGFuZCBiYWNrIHNpZGVzLCB3ZSBjYW4gZW11bGF0ZVxuICAvLyB0aGUgXCJzaWRlXCIgYnkgcmVzdHJpY3RpbmcgdGhlIGRyYXcgcmFuZ2UuXG4gIHNldFNpZGUoc2lkZSkge1xuICAgIGNvbnN0IHZlcnRzID0gdGhpcy5nZXRJbmRleCgpLmNvdW50O1xuICAgIHRoaXMuc2V0RHJhd1JhbmdlKHNpZGUgPT09IEJhY2tTaWRlID8gdmVydHMgLyAyIDogMCwgc2lkZSA9PT0gRG91YmxlU2lkZSA/IHZlcnRzIDogdmVydHMgLyAyKTtcbiAgfVxuXG4gIHNldCBkZXRhaWwoZGV0YWlsKSB7XG4gICAgaWYgKGRldGFpbCAhPT0gdGhpcy5fZGV0YWlsKSB7XG4gICAgICB0aGlzLl9kZXRhaWwgPSBkZXRhaWw7XG4gICAgICBpZiAodHlwZW9mIGRldGFpbCAhPT0gJ251bWJlcicgfHwgZGV0YWlsIDwgMSkge1xuICAgICAgICBkZXRhaWwgPSAxO1xuICAgICAgfVxuICAgICAgbGV0IHRwbCA9IGdldFRlbXBsYXRlR2VvbWV0cnkoZGV0YWlsKVxuICAgICAgO1sncG9zaXRpb24nLCAnbm9ybWFsJywgJ3V2J10uZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdID0gdHBsLmF0dHJpYnV0ZXNbYXR0cl0uY2xvbmUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRJbmRleCh0cGwuZ2V0SW5kZXgoKS5jbG9uZSgpKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRldGFpbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGV0YWlsXG4gIH1cblxuICBzZXQgY3VydmVSYWRpdXMocikge1xuICAgIGlmIChyICE9PSB0aGlzLl9jdXJ2ZVJhZGl1cykge1xuICAgICAgdGhpcy5fY3VydmVSYWRpdXMgPSByO1xuICAgICAgdGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gICAgfVxuICB9XG4gIGdldCBjdXJ2ZVJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VydmVSYWRpdXNcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGdlb21ldHJ5IGZvciBhIG5ldyBzZXQgb2YgZ2x5cGhzLlxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZ2x5cGhCb3VuZHMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBwbGFuYXIgYm91bmRzIGZvciBhbGwgZ2x5cGhzXG4gICAqICAgICAgICB0byBiZSByZW5kZXJlZCwgNCBlbnRyaWVzIGZvciBlYWNoIGdseXBoOiB4MSx4Mix5MSx5MVxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZ2x5cGhBdGxhc0luZGljZXMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBpbmRleCBvZiBlYWNoIGdseXBoIHdpdGhpblxuICAgKiAgICAgICAgdGhlIFNERiBhdGxhcyB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBibG9ja0JvdW5kcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBhY3Jvc3MgYWxsIGdseXBoc1xuICAgKiBAcGFyYW0ge0FycmF5fSBbY2h1bmtlZEJvdW5kc10gLSBBbiBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgYm91bmRzIGZvciBlYWNoIGNodW5rIG9mIE5cbiAgICogICAgICAgIGNvbnNlY3V0aXZlIGdseXBoczogYHtzdGFydDpOLCBlbmQ6TiwgcmVjdDpbbWluWCwgbWluWSwgbWF4WCwgbWF4WV19YC4gVGhpcyBjYW4gYmVcbiAgICogICAgICAgIHVzZWQgd2l0aCBgYXBwbHlDbGlwUmVjdGAgdG8gY2hvb3NlIGFuIG9wdGltaXplZCBgaW5zdGFuY2VDb3VudGAuXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSAtIEFuIGFycmF5IGhvbGRpbmcgcixnLGIgdmFsdWVzIGZvciBlYWNoIGdseXBoLlxuICAgKi9cbiAgdXBkYXRlR2x5cGhzKGdseXBoQm91bmRzLCBnbHlwaEF0bGFzSW5kaWNlcywgYmxvY2tCb3VuZHMsIGNodW5rZWRCb3VuZHMsIGdseXBoQ29sb3JzKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBpbnN0YW5jZSBhdHRyaWJ1dGVzXG4gICAgdXBkYXRlQnVmZmVyQXR0cih0aGlzLCBnbHlwaEJvdW5kc0F0dHJOYW1lLCBnbHlwaEJvdW5kcywgNCk7XG4gICAgdXBkYXRlQnVmZmVyQXR0cih0aGlzLCBnbHlwaEluZGV4QXR0ck5hbWUsIGdseXBoQXRsYXNJbmRpY2VzLCAxKTtcbiAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoQ29sb3JBdHRyTmFtZSwgZ2x5cGhDb2xvcnMsIDMpO1xuICAgIHRoaXMuX2Jsb2NrQm91bmRzID0gYmxvY2tCb3VuZHM7XG4gICAgdGhpcy5fY2h1bmtlZEJvdW5kcyA9IGNodW5rZWRCb3VuZHM7XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gZ2x5cGhBdGxhc0luZGljZXMubGVuZ3RoO1xuICAgIHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICB9XG5cbiAgX3VwZGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ibG9ja0JvdW5kcztcbiAgICBpZiAoYm91bmRzKSB7XG4gICAgICBjb25zdCB7IGN1cnZlUmFkaXVzLCBib3VuZGluZ0JveDogYmJveCB9ID0gdGhpcztcbiAgICAgIGlmIChjdXJ2ZVJhZGl1cykge1xuICAgICAgICBjb25zdCB7IFBJLCBmbG9vciwgbWluLCBtYXgsIHNpbiwgY29zIH0gPSBNYXRoO1xuICAgICAgICBjb25zdCBoYWxmUGkgPSBQSSAvIDI7XG4gICAgICAgIGNvbnN0IHR3b1BpID0gUEkgKiAyO1xuICAgICAgICBjb25zdCBhYnNSID0gTWF0aC5hYnMoY3VydmVSYWRpdXMpO1xuICAgICAgICBjb25zdCBsZWZ0QW5nbGUgPSBib3VuZHNbMF0gLyBhYnNSO1xuICAgICAgICBjb25zdCByaWdodEFuZ2xlID0gYm91bmRzWzJdIC8gYWJzUjtcbiAgICAgICAgY29uc3QgbWluWCA9IGZsb29yKChsZWZ0QW5nbGUgKyBoYWxmUGkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSArIGhhbGZQaSkgLyB0d29QaSlcbiAgICAgICAgICA/IC1hYnNSIDogbWluKHNpbihsZWZ0QW5nbGUpICogYWJzUiwgc2luKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgIGNvbnN0IG1heFggPSBmbG9vcigobGVmdEFuZ2xlIC0gaGFsZlBpKSAvIHR3b1BpKSAhPT0gZmxvb3IoKHJpZ2h0QW5nbGUgLSBoYWxmUGkpIC8gdHdvUGkpXG4gICAgICAgICAgPyBhYnNSIDogbWF4KHNpbihsZWZ0QW5nbGUpICogYWJzUiwgc2luKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgIGNvbnN0IG1heFogPSBmbG9vcigobGVmdEFuZ2xlICsgUEkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSArIFBJKSAvIHR3b1BpKVxuICAgICAgICAgID8gYWJzUiAqIDIgOiBtYXgoYWJzUiAtIGNvcyhsZWZ0QW5nbGUpICogYWJzUiwgYWJzUiAtIGNvcyhyaWdodEFuZ2xlKSAqIGFic1IpO1xuICAgICAgICBiYm94Lm1pbi5zZXQobWluWCwgYm91bmRzWzFdLCBjdXJ2ZVJhZGl1cyA8IDAgPyAtbWF4WiA6IDApO1xuICAgICAgICBiYm94Lm1heC5zZXQobWF4WCwgYm91bmRzWzNdLCBjdXJ2ZVJhZGl1cyA8IDAgPyAwIDogbWF4Wik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYm94Lm1pbi5zZXQoYm91bmRzWzBdLCBib3VuZHNbMV0sIDApO1xuICAgICAgICBiYm94Lm1heC5zZXQoYm91bmRzWzJdLCBib3VuZHNbM10sIDApO1xuICAgICAgfVxuICAgICAgYmJveC5nZXRCb3VuZGluZ1NwaGVyZSh0aGlzLmJvdW5kaW5nU3BoZXJlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBjbGlwcGluZyByZWN0LCBhbmQgdGhlIGNodW5rZWRCb3VuZHMgZnJvbSB0aGUgbGFzdCB1cGRhdGVHbHlwaHMgY2FsbCwgY2hvb3NlIHRoZSBsb3dlc3RcbiAgICogYGluc3RhbmNlQ291bnRgIHRoYXQgd2lsbCBzaG93IGFsbCBnbHlwaHMgd2l0aGluIHRoZSBjbGlwcGVkIHZpZXcuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uXG4gICAqIGZvciBsb25nIGJsb2NrcyBvZiB0ZXh0IHRoYXQgYXJlIGNsaXBwZWQsIHRvIHNraXAgdmVydGV4IHNoYWRlciBldmFsdWF0aW9uIGZvciBnbHlwaHMgdGhhdCB3b3VsZFxuICAgKiBiZSBjbGlwcGVkIGFueXdheS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHNpbmNlIGBkcmF3RWxlbWVudHNJbnN0YW5jZWRbQU5HTEVdYCBvbmx5IGFjY2VwdHMgYW4gaW5zdGFuY2UgY291bnQgYW5kIG5vdCBhIHN0YXJ0aW5nXG4gICAqIG9mZnNldCwgdGhpcyBvcHRpbWl6YXRpb24gYmVjb21lcyBsZXNzIGVmZmVjdGl2ZSBhcyB0aGUgY2xpcFJlY3QgbW92ZXMgY2xvc2VyIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAqIHRleHQgYmxvY2suIFdlIGNvdWxkIGZpeCB0aGF0IGJ5IHN3aXRjaGluZyBmcm9tIGluc3RhbmNpbmcgdG8gYSBmdWxsIGdlb21ldHJ5IHdpdGggYSBkcmF3UmFuZ2UsXG4gICAqIGJ1dCBhdCB0aGUgZXhwZW5zZSBvZiBtdWNoIGxhcmdlciBhdHRyaWJ1dGUgYnVmZmVycyAoc2VlIGNsYXNzZG9jIGFib3ZlLilcbiAgICpcbiAgICogQHBhcmFtIHtWZWN0b3I0fSBjbGlwUmVjdFxuICAgKi9cbiAgYXBwbHlDbGlwUmVjdChjbGlwUmVjdCkge1xuICAgIGxldCBjb3VudCA9IHRoaXMuZ2V0QXR0cmlidXRlKGdseXBoSW5kZXhBdHRyTmFtZSkuY291bnQ7XG4gICAgbGV0IGNodW5rcyA9IHRoaXMuX2NodW5rZWRCb3VuZHM7XG4gICAgaWYgKGNodW5rcykge1xuICAgICAgZm9yIChsZXQgaSA9IGNodW5rcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgY291bnQgPSBjaHVua3NbaV0uZW5kO1xuICAgICAgICBsZXQgcmVjdCA9IGNodW5rc1tpXS5yZWN0O1xuICAgICAgICAvLyBub3RlOiBib3RoIHJlY3RzIGFyZSBsLWItci10XG4gICAgICAgIGlmIChyZWN0WzFdIDwgY2xpcFJlY3QudyAmJiByZWN0WzNdID4gY2xpcFJlY3QueSAmJiByZWN0WzBdIDwgY2xpcFJlY3QueiAmJiByZWN0WzJdID4gY2xpcFJlY3QueCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gY291bnQ7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiB1cGRhdGVCdWZmZXJBdHRyKGdlb20sIGF0dHJOYW1lLCBuZXdBcnJheSwgaXRlbVNpemUpIHtcbiAgY29uc3QgYXR0ciA9IGdlb20uZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgaWYgKG5ld0FycmF5KSB7XG4gICAgLy8gSWYgbGVuZ3RoIGlzbid0IGNoYW5naW5nLCBqdXN0IHVwZGF0ZSB0aGUgYXR0cmlidXRlJ3MgYXJyYXkgZGF0YVxuICAgIGlmIChhdHRyICYmIGF0dHIuYXJyYXkubGVuZ3RoID09PSBuZXdBcnJheS5sZW5ndGgpIHtcbiAgICAgIGF0dHIuYXJyYXkuc2V0KG5ld0FycmF5KTtcbiAgICAgIGF0dHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW9tLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShuZXdBcnJheSwgaXRlbVNpemUpKTtcbiAgICAgIC8vIElmIHRoZSBuZXcgYXR0cmlidXRlIGhhcyBhIGRpZmZlcmVudCBzaXplLCB3ZSBhbHNvIGhhdmUgdG8gKGFzIG9mIHIxMTcpIG1hbnVhbGx5IGNsZWFyIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY2FjaGVkIG1heCBpbnN0YW5jZSBjb3VudC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE5NzA2XG4gICAgICAvLyBJdCdzIHVuY2xlYXIgaWYgdGhpcyBpcyBhIHRocmVlanMgYnVnIG9yIGEgdHJ1bHkgdW5zdXBwb3J0ZWQgc2NlbmFyaW87IGRpc2N1c3Npb24gaW5cbiAgICAgIC8vIHRoYXQgdGlja2V0IGlzIGFtYmlndW91cyBhcyB0byB3aGV0aGVyIHJlcGxhY2luZyBhIEJ1ZmZlckF0dHJpYnV0ZSB3aXRoIG9uZSBvZiBhXG4gICAgICAvLyBkaWZmZXJlbnQgc2l6ZSBpcyBzdXBwb3J0ZWQsIGJ1dCBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMTc0MTggc3Ryb25nbHlcbiAgICAgIC8vIGltcGxpZXMgaXQgc2hvdWxkIGJlIHN1cHBvcnRlZC4gSXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvXG4gICAgICBkZWxldGUgZ2VvbS5fbWF4SW5zdGFuY2VDb3VudDsgLy9mb3IgcjExNyssIGNvdWxkIGJlIGZyYWdpbGVcbiAgICAgIGdlb20uZGlzcG9zZSgpOyAvL2ZvciByMTE4KywgbW9yZSByb2J1c3QgZmVlbGluZywgYnV0IG1vcmUgaGVhdnktaGFuZGVkIHRoYW4gSSdkIGxpa2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXR0cikge1xuICAgIGdlb20uZGVsZXRlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgfVxufVxuXG4vLyBsYW5ndWFnZT1HTFNMXG5jb25zdCBWRVJURVhfREVGUyA9IGBcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIHZlYzQgdVRyb2lrYVRvdGFsQm91bmRzO1xudW5pZm9ybSB2ZWM0IHVUcm9pa2FDbGlwUmVjdDtcbnVuaWZvcm0gbWF0MyB1VHJvaWthT3JpZW50O1xudW5pZm9ybSBib29sIHVUcm9pa2FVc2VHbHlwaENvbG9ycztcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYURpc3RhbmNlT2Zmc2V0O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthQmx1clJhZGl1cztcbnVuaWZvcm0gdmVjMiB1VHJvaWthUG9zaXRpb25PZmZzZXQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FDdXJ2ZVJhZGl1cztcbmF0dHJpYnV0ZSB2ZWM0IGFUcm9pa2FHbHlwaEJvdW5kcztcbmF0dHJpYnV0ZSBmbG9hdCBhVHJvaWthR2x5cGhJbmRleDtcbmF0dHJpYnV0ZSB2ZWMzIGFUcm9pa2FHbHlwaENvbG9yO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaFVWO1xudmFyeWluZyB2ZWM0IHZUcm9pa2FUZXh0dXJlVVZCb3VuZHM7XG52YXJ5aW5nIGZsb2F0IHZUcm9pa2FUZXh0dXJlQ2hhbm5lbDtcbnZhcnlpbmcgdmVjMyB2VHJvaWthR2x5cGhDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhEaW1lbnNpb25zO1xuYDtcblxuLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG5jb25zdCBWRVJURVhfVFJBTlNGT1JNID0gYFxudmVjNCBib3VuZHMgPSBhVHJvaWthR2x5cGhCb3VuZHM7XG5ib3VuZHMueHogKz0gdVRyb2lrYVBvc2l0aW9uT2Zmc2V0Lng7XG5ib3VuZHMueXcgLT0gdVRyb2lrYVBvc2l0aW9uT2Zmc2V0Lnk7XG5cbnZlYzQgb3V0bGluZUJvdW5kcyA9IHZlYzQoXG4gIGJvdW5kcy54eSAtIHVUcm9pa2FEaXN0YW5jZU9mZnNldCAtIHVUcm9pa2FCbHVyUmFkaXVzLFxuICBib3VuZHMuencgKyB1VHJvaWthRGlzdGFuY2VPZmZzZXQgKyB1VHJvaWthQmx1clJhZGl1c1xuKTtcbnZlYzQgY2xpcHBlZEJvdW5kcyA9IHZlYzQoXG4gIGNsYW1wKG91dGxpbmVCb3VuZHMueHksIHVUcm9pa2FDbGlwUmVjdC54eSwgdVRyb2lrYUNsaXBSZWN0Lnp3KSxcbiAgY2xhbXAob3V0bGluZUJvdW5kcy56dywgdVRyb2lrYUNsaXBSZWN0Lnh5LCB1VHJvaWthQ2xpcFJlY3QuencpXG4pO1xuXG52ZWMyIGNsaXBwZWRYWSA9IChtaXgoY2xpcHBlZEJvdW5kcy54eSwgY2xpcHBlZEJvdW5kcy56dywgcG9zaXRpb24ueHkpIC0gYm91bmRzLnh5KSAvIChib3VuZHMuencgLSBib3VuZHMueHkpO1xuXG5wb3NpdGlvbi54eSA9IG1peChib3VuZHMueHksIGJvdW5kcy56dywgY2xpcHBlZFhZKTtcblxudXYgPSAocG9zaXRpb24ueHkgLSB1VHJvaWthVG90YWxCb3VuZHMueHkpIC8gKHVUcm9pa2FUb3RhbEJvdW5kcy56dyAtIHVUcm9pa2FUb3RhbEJvdW5kcy54eSk7XG5cbmZsb2F0IHJhZCA9IHVUcm9pa2FDdXJ2ZVJhZGl1cztcbmlmIChyYWQgIT0gMC4wKSB7XG4gIGZsb2F0IGFuZ2xlID0gcG9zaXRpb24ueCAvIHJhZDtcbiAgcG9zaXRpb24ueHogPSB2ZWMyKHNpbihhbmdsZSkgKiByYWQsIHJhZCAtIGNvcyhhbmdsZSkgKiByYWQpO1xuICBub3JtYWwueHogPSB2ZWMyKHNpbihhbmdsZSksIGNvcyhhbmdsZSkpO1xufVxuICBcbnBvc2l0aW9uID0gdVRyb2lrYU9yaWVudCAqIHBvc2l0aW9uO1xubm9ybWFsID0gdVRyb2lrYU9yaWVudCAqIG5vcm1hbDtcblxudlRyb2lrYUdseXBoVVYgPSBjbGlwcGVkWFkueHk7XG52VHJvaWthR2x5cGhEaW1lbnNpb25zID0gdmVjMihib3VuZHNbMl0gLSBib3VuZHNbMF0sIGJvdW5kc1szXSAtIGJvdW5kc1sxXSk7XG5cbiR7JycvKiBOT1RFOiBpdCBzZWVtcyBpbXBvcnRhbnQgdG8gY2FsY3VsYXRlIHRoZSBnbHlwaCdzIGJvdW5kaW5nIHRleHR1cmUgVVZzIGhlcmUgaW4gdGhlXG4gIHZlcnRleCBzaGFkZXIsIHJhdGhlciB0aGFuIGluIHRoZSBmcmFnbWVudCBzaGFkZXIsIGFzIHRoZSBsYXR0ZXIgZ2l2ZXMgc3RyYW5nZSBhcnRpZmFjdHNcbiAgb24gc29tZSBnbHlwaHMgKHRob3NlIGluIHRoZSBsZWZ0bW9zdCB0ZXh0dXJlIGNvbHVtbikgb24gc29tZSBzeXN0ZW1zLiBUaGUgZXhhY3QgcmVhc29uXG4gIGlzbid0IHVuZGVyc3Rvb2QgYnV0IGRvaW5nIHRoaXMgaGVyZSwgdGhlbiBtaXgoKS1pbmcgaW4gdGhlIGZyYWdtZW50IHNoYWRlciwgc2VlbXMgdG8gd29yay4gKi99XG5mbG9hdCB0eENvbHMgPSB1VHJvaWthU0RGVGV4dHVyZVNpemUueCAvIHVUcm9pa2FTREZHbHlwaFNpemU7XG52ZWMyIHR4VXZQZXJTcXVhcmUgPSB1VHJvaWthU0RGR2x5cGhTaXplIC8gdVRyb2lrYVNERlRleHR1cmVTaXplO1xudmVjMiB0eFN0YXJ0VVYgPSB0eFV2UGVyU3F1YXJlICogdmVjMihcbiAgbW9kKGZsb29yKGFUcm9pa2FHbHlwaEluZGV4IC8gNC4wKSwgdHhDb2xzKSxcbiAgZmxvb3IoZmxvb3IoYVRyb2lrYUdseXBoSW5kZXggLyA0LjApIC8gdHhDb2xzKVxuKTtcbnZUcm9pa2FUZXh0dXJlVVZCb3VuZHMgPSB2ZWM0KHR4U3RhcnRVViwgdmVjMih0eFN0YXJ0VVYpICsgdHhVdlBlclNxdWFyZSk7XG52VHJvaWthVGV4dHVyZUNoYW5uZWwgPSBtb2QoYVRyb2lrYUdseXBoSW5kZXgsIDQuMCk7XG5gO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG5jb25zdCBGUkFHTUVOVF9ERUZTID0gYFxudW5pZm9ybSBzYW1wbGVyMkQgdVRyb2lrYVNERlRleHR1cmU7XG51bmlmb3JtIHZlYzIgdVRyb2lrYVNERlRleHR1cmVTaXplO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGR2x5cGhTaXplO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGRXhwb25lbnQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FEaXN0YW5jZU9mZnNldDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUZpbGxPcGFjaXR5O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthT3V0bGluZU9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FCbHVyUmFkaXVzO1xudW5pZm9ybSB2ZWMzIHVUcm9pa2FTdHJva2VDb2xvcjtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYVN0cm9rZVdpZHRoO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU3Ryb2tlT3BhY2l0eTtcbnVuaWZvcm0gYm9vbCB1VHJvaWthU0RGRGVidWc7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoVVY7XG52YXJ5aW5nIHZlYzQgdlRyb2lrYVRleHR1cmVVVkJvdW5kcztcbnZhcnlpbmcgZmxvYXQgdlRyb2lrYVRleHR1cmVDaGFubmVsO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaERpbWVuc2lvbnM7XG5cbmZsb2F0IHRyb2lrYVNkZlZhbHVlVG9TaWduZWREaXN0YW5jZShmbG9hdCBhbHBoYSkge1xuICAvLyBJbnZlcnNlIG9mIGV4cG9uZW50aWFsIGVuY29kaW5nIGluIHdlYmdsLXNkZi1nZW5lcmF0b3JcbiAgJHsnJy8qIFRPRE8gLSB0aGVyZSdzIHNvbWUgc2xpZ2h0IGluYWNjdXJhY3kgaGVyZSB3aGVuIGRlYWxpbmcgd2l0aCBpbnRlcnBvbGF0ZWQgYWxwaGEgdmFsdWVzOyB0aG9zZVxuICAgIGFyZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgd2hlcmUgdGhlIGVuY29kaW5nIGlzIGV4cG9uZW50aWFsLiBMb29rIGludG8gaW1wcm92aW5nIHRoaXMgYnkgcm91bmRpbmdcbiAgICB0byBuZWFyZXN0IDIgd2hvbGUgdGV4ZWxzLCBkZWNvZGluZyB0aG9zZSBleHBvbmVudGlhbCB2YWx1ZXMsIGFuZCBsaW5lYXJseSBpbnRlcnBvbGF0aW5nIHRoZSByZXN1bHQuXG4gICovfVxuICBmbG9hdCBtYXhEaW1lbnNpb24gPSBtYXgodlRyb2lrYUdseXBoRGltZW5zaW9ucy54LCB2VHJvaWthR2x5cGhEaW1lbnNpb25zLnkpO1xuICBmbG9hdCBhYnNEaXN0ID0gKDEuMCAtIHBvdygyLjAgKiAoYWxwaGEgPiAwLjUgPyAxLjAgLSBhbHBoYSA6IGFscGhhKSwgMS4wIC8gdVRyb2lrYVNERkV4cG9uZW50KSkgKiBtYXhEaW1lbnNpb247XG4gIGZsb2F0IHNpZ25lZERpc3QgPSBhYnNEaXN0ICogKGFscGhhID4gMC41ID8gLTEuMCA6IDEuMCk7XG4gIHJldHVybiBzaWduZWREaXN0O1xufVxuXG5mbG9hdCB0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh2ZWMyIGdseXBoVVYpIHtcbiAgdmVjMiB0ZXh0dXJlVVYgPSBtaXgodlRyb2lrYVRleHR1cmVVVkJvdW5kcy54eSwgdlRyb2lrYVRleHR1cmVVVkJvdW5kcy56dywgZ2x5cGhVVik7XG4gIHZlYzQgcmdiYSA9IHRleHR1cmUyRCh1VHJvaWthU0RGVGV4dHVyZSwgdGV4dHVyZVVWKTtcbiAgZmxvYXQgY2ggPSBmbG9vcih2VHJvaWthVGV4dHVyZUNoYW5uZWwgKyAwLjUpOyAvL05PVEU6IGNhbid0IHVzZSByb3VuZCgpIGluIFdlYkdMMVxuICByZXR1cm4gY2ggPT0gMC4wID8gcmdiYS5yIDogY2ggPT0gMS4wID8gcmdiYS5nIDogY2ggPT0gMi4wID8gcmdiYS5iIDogcmdiYS5hO1xufVxuXG5mbG9hdCB0cm9pa2FHbHlwaFV2VG9EaXN0YW5jZSh2ZWMyIHV2KSB7XG4gIHJldHVybiB0cm9pa2FTZGZWYWx1ZVRvU2lnbmVkRGlzdGFuY2UodHJvaWthR2x5cGhVdlRvU2RmVmFsdWUodXYpKTtcbn1cblxuZmxvYXQgdHJvaWthR2V0QUFEaXN0KCkge1xuICAkeycnLypcbiAgICBXaGVuIHRoZSBzdGFuZGFyZCBkZXJpdmF0aXZlcyBleHRlbnNpb24gaXMgYXZhaWxhYmxlLCB3ZSBjaG9vc2UgYW4gYW50aWFsaWFzaW5nIGFscGhhIHRocmVzaG9sZCBiYXNlZFxuICAgIG9uIHRoZSBwb3RlbnRpYWwgY2hhbmdlIGluIHRoZSBTREYncyBhbHBoYSBmcm9tIHRoaXMgZnJhZ21lbnQgdG8gaXRzIG5laWdoYm9yLiBUaGlzIHN0cmF0ZWd5IG1heGltaXplcyBcbiAgICByZWFkYWJpbGl0eSBhbmQgZWRnZSBjcmlzcG5lc3MgYXQgYWxsIHNpemVzIGFuZCBzY3JlZW4gcmVzb2x1dGlvbnMuXG4gICovfVxuICAjaWYgZGVmaW5lZChHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMpIHx8IF9fVkVSU0lPTl9fID49IDMwMFxuICByZXR1cm4gbGVuZ3RoKGZ3aWR0aCh2VHJvaWthR2x5cGhVViAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpKSAqIDAuNTtcbiAgI2Vsc2VcbiAgcmV0dXJuIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMueCAvIDY0LjA7XG4gICNlbmRpZlxufVxuXG5mbG9hdCB0cm9pa2FHZXRGcmFnRGlzdFZhbHVlKCkge1xuICB2ZWMyIGNsYW1wZWRHbHlwaFVWID0gY2xhbXAodlRyb2lrYUdseXBoVVYsIDAuNSAvIHVUcm9pa2FTREZHbHlwaFNpemUsIDEuMCAtIDAuNSAvIHVUcm9pa2FTREZHbHlwaFNpemUpO1xuICBmbG9hdCBkaXN0YW5jZSA9IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKGNsYW1wZWRHbHlwaFVWKTtcbiBcbiAgLy8gRXh0cmFwb2xhdGUgZGlzdGFuY2Ugd2hlbiBvdXRzaWRlIGJvdW5kczpcbiAgZGlzdGFuY2UgKz0gY2xhbXBlZEdseXBoVVYgPT0gdlRyb2lrYUdseXBoVVYgPyAwLjAgOiBcbiAgICBsZW5ndGgoKHZUcm9pa2FHbHlwaFVWIC0gY2xhbXBlZEdseXBoVVYpICogdlRyb2lrYUdseXBoRGltZW5zaW9ucyk7XG5cbiAgJHsnJy8qIFxuICAvLyBUT0RPIG1vcmUgcmVmaW5lZCBleHRyYXBvbGF0ZWQgZGlzdGFuY2UgYnkgYWRqdXN0aW5nIGZvciBhbmdsZSBvZiBncmFkaWVudCBhdCBlZGdlLi4uXG4gIC8vIFRoaXMgaGFzIHBvdGVudGlhbCBidXQgY3VycmVudGx5IGdpdmVzIHZlcnkgamFnZ2VkIGV4dGVuc2lvbnMsIG1heWJlIGR1ZSB0byBwcmVjaXNpb24gaXNzdWVzP1xuICBmbG9hdCB1dlN0ZXAgPSAxLjAgLyB1VHJvaWthU0RGR2x5cGhTaXplO1xuICB2ZWMyIG5laWdoYm9yMVVWID0gY2xhbXBlZEdseXBoVVYgKyAoXG4gICAgdlRyb2lrYUdseXBoVVYueCAhPSBjbGFtcGVkR2x5cGhVVi54ID8gdmVjMigwLjAsIHV2U3RlcCAqIHNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueSkpIDpcbiAgICB2VHJvaWthR2x5cGhVVi55ICE9IGNsYW1wZWRHbHlwaFVWLnkgPyB2ZWMyKHV2U3RlcCAqIHNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueCksIDAuMCkgOlxuICAgIHZlYzIoMC4wKVxuICApO1xuICB2ZWMyIG5laWdoYm9yMlVWID0gY2xhbXBlZEdseXBoVVYgKyAoXG4gICAgdlRyb2lrYUdseXBoVVYueCAhPSBjbGFtcGVkR2x5cGhVVi54ID8gdmVjMigwLjAsIHV2U3RlcCAqIC1zaWduKDAuNSAtIHZUcm9pa2FHbHlwaFVWLnkpKSA6XG4gICAgdlRyb2lrYUdseXBoVVYueSAhPSBjbGFtcGVkR2x5cGhVVi55ID8gdmVjMih1dlN0ZXAgKiAtc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi54KSwgMC4wKSA6XG4gICAgdmVjMigwLjApXG4gICk7XG4gIGZsb2F0IG5laWdoYm9yMURpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UobmVpZ2hib3IxVVYpO1xuICBmbG9hdCBuZWlnaGJvcjJEaXN0YW5jZSA9IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKG5laWdoYm9yMlVWKTtcbiAgZmxvYXQgZGlzdFRvVW5jbGFtcGVkID0gbGVuZ3RoKCh2VHJvaWthR2x5cGhVViAtIGNsYW1wZWRHbHlwaFVWKSAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpO1xuICBmbG9hdCBkaXN0VG9OZWlnaGJvciA9IGxlbmd0aCgoY2xhbXBlZEdseXBoVVYgLSBuZWlnaGJvcjFVVikgKiB2VHJvaWthR2x5cGhEaW1lbnNpb25zKTtcbiAgZmxvYXQgZ3JhZGllbnRBbmdsZTEgPSBtaW4oYXNpbihhYnMobmVpZ2hib3IxRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBkaXN0VG9OZWlnaGJvciksIFBJIC8gMi4wKTtcbiAgZmxvYXQgZ3JhZGllbnRBbmdsZTIgPSBtaW4oYXNpbihhYnMobmVpZ2hib3IyRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBkaXN0VG9OZWlnaGJvciksIFBJIC8gMi4wKTtcbiAgZGlzdGFuY2UgKz0gKGNvcyhncmFkaWVudEFuZ2xlMSkgKyBjb3MoZ3JhZGllbnRBbmdsZTIpKSAvIDIuMCAqIGRpc3RUb1VuY2xhbXBlZDtcbiAgKi99XG5cbiAgcmV0dXJuIGRpc3RhbmNlO1xufVxuXG5mbG9hdCB0cm9pa2FHZXRFZGdlQWxwaGEoZmxvYXQgZGlzdGFuY2UsIGZsb2F0IGRpc3RhbmNlT2Zmc2V0LCBmbG9hdCBhYURpc3QpIHtcbiAgI2lmIGRlZmluZWQoSVNfREVQVEhfTUFURVJJQUwpIHx8IGRlZmluZWQoSVNfRElTVEFOQ0VfTUFURVJJQUwpXG4gIGZsb2F0IGFscGhhID0gc3RlcCgtZGlzdGFuY2VPZmZzZXQsIC1kaXN0YW5jZSk7XG4gICNlbHNlXG5cbiAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKFxuICAgIGRpc3RhbmNlT2Zmc2V0ICsgYWFEaXN0LFxuICAgIGRpc3RhbmNlT2Zmc2V0IC0gYWFEaXN0LFxuICAgIGRpc3RhbmNlXG4gICk7XG4gICNlbmRpZlxuXG4gIHJldHVybiBhbHBoYTtcbn1cbmA7XG5cbi8vIGxhbmd1YWdlPUdMU0wgcHJlZml4PVwidm9pZCBtYWluKCkge1wiIHN1ZmZpeD1cIn1cIlxuY29uc3QgRlJBR01FTlRfVFJBTlNGT1JNID0gYFxuZmxvYXQgYWFEaXN0ID0gdHJvaWthR2V0QUFEaXN0KCk7XG5mbG9hdCBmcmFnRGlzdGFuY2UgPSB0cm9pa2FHZXRGcmFnRGlzdFZhbHVlKCk7XG5mbG9hdCBlZGdlQWxwaGEgPSB1VHJvaWthU0RGRGVidWcgP1xuICB0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh2VHJvaWthR2x5cGhVVikgOlxuICB0cm9pa2FHZXRFZGdlQWxwaGEoZnJhZ0Rpc3RhbmNlLCB1VHJvaWthRGlzdGFuY2VPZmZzZXQsIG1heChhYURpc3QsIHVUcm9pa2FCbHVyUmFkaXVzKSk7XG5cbiNpZiAhZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgJiYgIWRlZmluZWQoSVNfRElTVEFOQ0VfTUFURVJJQUwpXG52ZWM0IGZpbGxSR0JBID0gZ2xfRnJhZ0NvbG9yO1xuZmlsbFJHQkEuYSAqPSB1VHJvaWthRmlsbE9wYWNpdHk7XG52ZWM0IHN0cm9rZVJHQkEgPSB1VHJvaWthU3Ryb2tlV2lkdGggPT0gMC4wID8gZmlsbFJHQkEgOiB2ZWM0KHVUcm9pa2FTdHJva2VDb2xvciwgdVRyb2lrYVN0cm9rZU9wYWNpdHkpO1xuaWYgKGZpbGxSR0JBLmEgPT0gMC4wKSBmaWxsUkdCQS5yZ2IgPSBzdHJva2VSR0JBLnJnYjtcbmdsX0ZyYWdDb2xvciA9IG1peChmaWxsUkdCQSwgc3Ryb2tlUkdCQSwgc21vb3Roc3RlcChcbiAgLXVUcm9pa2FTdHJva2VXaWR0aCAtIGFhRGlzdCxcbiAgLXVUcm9pa2FTdHJva2VXaWR0aCArIGFhRGlzdCxcbiAgZnJhZ0Rpc3RhbmNlXG4pKTtcbmdsX0ZyYWdDb2xvci5hICo9IGVkZ2VBbHBoYTtcbiNlbmRpZlxuXG5pZiAoZWRnZUFscGhhID09IDAuMCkge1xuICBkaXNjYXJkO1xufVxuYDtcblxuXG4vKipcbiAqIENyZWF0ZSBhIG1hdGVyaWFsIGZvciByZW5kZXJpbmcgdGV4dCwgZGVyaXZlZCBmcm9tIGEgYmFzZU1hdGVyaWFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gIGNvbnN0IHRleHRNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIHtcbiAgICBjaGFpbmVkOiB0cnVlLFxuICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgIGRlcml2YXRpdmVzOiB0cnVlXG4gICAgfSxcbiAgICB1bmlmb3Jtczoge1xuICAgICAgdVRyb2lrYVNERlRleHR1cmU6IHt2YWx1ZTogbnVsbH0sXG4gICAgICB1VHJvaWthU0RGVGV4dHVyZVNpemU6IHt2YWx1ZTogbmV3IFZlY3RvcjIoKX0sXG4gICAgICB1VHJvaWthU0RGR2x5cGhTaXplOiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYVNERkV4cG9uZW50OiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYVRvdGFsQm91bmRzOiB7dmFsdWU6IG5ldyBWZWN0b3I0KDAsMCwwLDApfSxcbiAgICAgIHVUcm9pa2FDbGlwUmVjdDoge3ZhbHVlOiBuZXcgVmVjdG9yNCgwLDAsMCwwKX0sXG4gICAgICB1VHJvaWthRGlzdGFuY2VPZmZzZXQ6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthT3V0bGluZU9wYWNpdHk6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthRmlsbE9wYWNpdHk6IHt2YWx1ZTogMX0sXG4gICAgICB1VHJvaWthUG9zaXRpb25PZmZzZXQ6IHt2YWx1ZTogbmV3IFZlY3RvcjIoKX0sXG4gICAgICB1VHJvaWthQ3VydmVSYWRpdXM6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthQmx1clJhZGl1czoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FTdHJva2VXaWR0aDoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FTdHJva2VDb2xvcjoge3ZhbHVlOiBuZXcgQ29sb3IoKX0sXG4gICAgICB1VHJvaWthU3Ryb2tlT3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgIHVUcm9pa2FPcmllbnQ6IHt2YWx1ZTogbmV3IE1hdHJpeDMoKX0sXG4gICAgICB1VHJvaWthVXNlR2x5cGhDb2xvcnM6IHt2YWx1ZTogdHJ1ZX0sXG4gICAgICB1VHJvaWthU0RGRGVidWc6IHt2YWx1ZTogZmFsc2V9XG4gICAgfSxcbiAgICB2ZXJ0ZXhEZWZzOiBWRVJURVhfREVGUyxcbiAgICB2ZXJ0ZXhUcmFuc2Zvcm06IFZFUlRFWF9UUkFOU0ZPUk0sXG4gICAgZnJhZ21lbnREZWZzOiBGUkFHTUVOVF9ERUZTLFxuICAgIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm06IEZSQUdNRU5UX1RSQU5TRk9STSxcbiAgICBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0pIHtcbiAgICAgIGxldCB1RGlmZnVzZVJFID0gL1xcYnVuaWZvcm1cXHMrdmVjM1xccytkaWZmdXNlXFxiLztcbiAgICAgIGlmICh1RGlmZnVzZVJFLnRlc3QoZnJhZ21lbnRTaGFkZXIpKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiBgZGlmZnVzZWAgd2l0aCBvdXIgdmFyeWluZ1xuICAgICAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyXG4gICAgICAgICAgLnJlcGxhY2UodURpZmZ1c2VSRSwgJ3ZhcnlpbmcgdmVjMyB2VHJvaWthR2x5cGhDb2xvcicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcYmRpZmZ1c2VcXGIvZywgJ3ZUcm9pa2FHbHlwaENvbG9yJyk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmVydGV4IHNoYWRlciBkZWNsYXJlcyB0aGUgdW5pZm9ybSBzbyB3ZSBjYW4gZ3JhYiBpdCBhcyBhIGZhbGxiYWNrXG4gICAgICAgIGlmICghdURpZmZ1c2VSRS50ZXN0KHZlcnRleFNoYWRlcikpIHtcbiAgICAgICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZShcbiAgICAgICAgICAgIHZvaWRNYWluUmVnRXhwLFxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbiQmXFxudlRyb2lrYUdseXBoQ29sb3IgPSB1VHJvaWthVXNlR2x5cGhDb2xvcnMgPyBhVHJvaWthR2x5cGhDb2xvciAvIDI1NS4wIDogZGlmZnVzZTtcXG4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciB9XG4gICAgfVxuICB9KTtcblxuICAvLyBGb3JjZSB0cmFuc3BhcmVuY3kgLSBUT0RPIGlzIHRoaXMgcmVhc29uYWJsZT9cbiAgdGV4dE1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0ZXh0TWF0ZXJpYWwsIHtcbiAgICBpc1Ryb2lrYVRleHRNYXRlcmlhbDoge3ZhbHVlOiB0cnVlfSxcblxuICAgIC8vIFdlYkdMU2hhZG93TWFwIHJldmVyc2VzIHRoZSBzaWRlIG9mIHRoZSBzaGFkb3cgbWF0ZXJpYWwgYnkgZGVmYXVsdCwgd2hpY2ggZmFpbHNcbiAgICAvLyBmb3IgcGxhbmVzLCBzbyBoZXJlIHdlIGZvcmNlIHRoZSBgc2hhZG93U2lkZWAgdG8gYWx3YXlzIG1hdGNoIHRoZSBtYWluIHNpZGUuXG4gICAgc2hhZG93U2lkZToge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWRlXG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICAvL25vLW9wXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGV4dE1hdGVyaWFsXG59XG5cbmNvbnN0IGRlZmF1bHRNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi8gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcbiAgY29sb3I6IDB4ZmZmZmZmLFxuICBzaWRlOiBEb3VibGVTaWRlLFxuICB0cmFuc3BhcmVudDogdHJ1ZVxufSk7XG5jb25zdCBkZWZhdWx0U3Ryb2tlQ29sb3IgPSAweDgwODA4MDtcblxuY29uc3QgdGVtcE1hdDQgPSAvKiNfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCB0ZW1wVmVjM2EgPSAvKiNfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wVmVjM2IgPSAvKiNfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wQXJyYXkgPSBbXTtcbmNvbnN0IG9yaWdpbiA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IGRlZmF1bHRPcmllbnQgPSAnK3greSc7XG5cbmZ1bmN0aW9uIGZpcnN0KG8pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobykgPyBvWzBdIDogb1xufVxuXG5sZXQgZ2V0RmxhdFJheWNhc3RNZXNoID0gKCkgPT4ge1xuICBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gICAgbmV3IFBsYW5lR2VvbWV0cnkoMSwgMSksXG4gICAgZGVmYXVsdE1hdGVyaWFsXG4gICk7XG4gIGdldEZsYXRSYXljYXN0TWVzaCA9ICgpID0+IG1lc2g7XG4gIHJldHVybiBtZXNoXG59O1xubGV0IGdldEN1cnZlZFJheWNhc3RNZXNoID0gKCkgPT4ge1xuICBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gICAgbmV3IFBsYW5lR2VvbWV0cnkoMSwgMSwgMzIsIDEpLFxuICAgIGRlZmF1bHRNYXRlcmlhbFxuICApO1xuICBnZXRDdXJ2ZWRSYXljYXN0TWVzaCA9ICgpID0+IG1lc2g7XG4gIHJldHVybiBtZXNoXG59O1xuXG5jb25zdCBzeW5jU3RhcnRFdmVudCA9IHsgdHlwZTogJ3N5bmNzdGFydCcgfTtcbmNvbnN0IHN5bmNDb21wbGV0ZUV2ZW50ID0geyB0eXBlOiAnc3luY2NvbXBsZXRlJyB9O1xuXG5jb25zdCBTWU5DQUJMRV9QUk9QUyA9IFtcbiAgJ2ZvbnQnLFxuICAnZm9udFNpemUnLFxuICAnbGV0dGVyU3BhY2luZycsXG4gICdsaW5lSGVpZ2h0JyxcbiAgJ21heFdpZHRoJyxcbiAgJ292ZXJmbG93V3JhcCcsXG4gICd0ZXh0JyxcbiAgJ2RpcmVjdGlvbicsXG4gICd0ZXh0QWxpZ24nLFxuICAndGV4dEluZGVudCcsXG4gICd3aGl0ZVNwYWNlJyxcbiAgJ2FuY2hvclgnLFxuICAnYW5jaG9yWScsXG4gICdjb2xvclJhbmdlcycsXG4gICdzZGZHbHlwaFNpemUnXG5dO1xuXG5jb25zdCBDT1BZQUJMRV9QUk9QUyA9IFNZTkNBQkxFX1BST1BTLmNvbmNhdChcbiAgJ21hdGVyaWFsJyxcbiAgJ2NvbG9yJyxcbiAgJ2RlcHRoT2Zmc2V0JyxcbiAgJ2NsaXBSZWN0JyxcbiAgJ2N1cnZlUmFkaXVzJyxcbiAgJ29yaWVudGF0aW9uJyxcbiAgJ2dseXBoR2VvbWV0cnlEZXRhaWwnXG4pO1xuXG4vKipcbiAqIEBjbGFzcyBUZXh0XG4gKlxuICogQSBUaHJlZUpTIE1lc2ggdGhhdCByZW5kZXJzIGEgc3RyaW5nIG9mIHRleHQgb24gYSBwbGFuZSBpbiAzRCBzcGFjZSB1c2luZyBzaWduZWQgZGlzdGFuY2VcbiAqIGZpZWxkcyAoU0RGKS5cbiAqL1xuY2xhc3MgVGV4dCBleHRlbmRzIE1lc2gge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHbHlwaHNHZW9tZXRyeSgpO1xuICAgIHN1cGVyKGdlb21ldHJ5LCBudWxsKTtcblxuICAgIC8vID09PSBUZXh0IGxheW91dCBwcm9wZXJ0aWVzOiA9PT0gLy9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gdGV4dFxuICAgICAqIFRoZSBzdHJpbmcgb2YgdGV4dCB0byBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICB0aGlzLnRleHQgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGFuY2hvclhcbiAgICAgKiBEZWZpbmVzIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIGluIHRoZSB0ZXh0IGJsb2NrIHRoYXQgc2hvdWxkIGxpbmUgdXAgd2l0aCB0aGUgbG9jYWwgb3JpZ2luLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgYSBudW1lcmljIHggcG9zaXRpb24gaW4gbG9jYWwgdW5pdHMsIGEgc3RyaW5nIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsXG4gICAgICogdGV4dCBibG9jayB3aWR0aCBlLmcuIGAnMjUlJ2AsIG9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIGtleXdvcmQgc3RyaW5nczogJ2xlZnQnLCAnY2VudGVyJyxcbiAgICAgKiBvciAncmlnaHQnLlxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBhbmNob3JYXG4gICAgICogRGVmaW5lcyB0aGUgdmVydGljYWwgcG9zaXRpb24gaW4gdGhlIHRleHQgYmxvY2sgdGhhdCBzaG91bGQgbGluZSB1cCB3aXRoIHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBhIG51bWVyaWMgeSBwb3NpdGlvbiBpbiBsb2NhbCB1bml0cyAobm90ZTogZG93biBpcyBuZWdhdGl2ZSB5KSwgYSBzdHJpbmdcbiAgICAgKiBwZXJjZW50YWdlIG9mIHRoZSB0b3RhbCB0ZXh0IGJsb2NrIGhlaWdodCBlLmcuIGAnMjUlJ2AsIG9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIGtleXdvcmQgc3RyaW5nczpcbiAgICAgKiAndG9wJywgJ3RvcC1iYXNlbGluZScsICd0b3AtY2FwJywgJ3RvcC1leCcsICdtaWRkbGUnLCAnYm90dG9tLWJhc2VsaW5lJywgb3IgJ2JvdHRvbScuXG4gICAgICovXG4gICAgdGhpcy5hbmNob3JZID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gY3VydmVSYWRpdXNcbiAgICAgKiBEZWZpbmVzIGEgY3lsaW5kcmljYWwgcmFkaXVzIGFsb25nIHdoaWNoIHRoZSB0ZXh0J3MgcGxhbmUgd2lsbCBiZSBjdXJ2ZWQuIFBvc2l0aXZlIG51bWJlcnMgcHV0XG4gICAgICogdGhlIGN5bGluZGVyJ3MgY2VudGVybGluZSAob3JpZW50ZWQgdmVydGljYWxseSkgdGhhdCBkaXN0YW5jZSBpbiBmcm9udCBvZiB0aGUgdGV4dCwgZm9yIGEgY29uY2F2ZVxuICAgICAqIGN1cnZhdHVyZSwgd2hpbGUgbmVnYXRpdmUgbnVtYmVycyBwdXQgaXQgYmVoaW5kIHRoZSB0ZXh0IGZvciBhIGNvbnZleCBjdXJ2YXR1cmUuIFRoZSBjZW50ZXJsaW5lXG4gICAgICogd2lsbCBiZSBhbGlnbmVkIHdpdGggdGhlIHRleHQncyBsb2NhbCBvcmlnaW47IHlvdSBjYW4gdXNlIGBhbmNob3JYYCB0byBvZmZzZXQgaXQuXG4gICAgICpcbiAgICAgKiBTaW5jZSBlYWNoIGdseXBoIGlzIGJ5IGRlZmF1bHQgcmVuZGVyZWQgd2l0aCBhIHNpbXBsZSBxdWFkLCBlYWNoIGdseXBoIHJlbWFpbnMgYSBmbGF0IHBsYW5lXG4gICAgICogaW50ZXJuYWxseS4gWW91IGNhbiB1c2UgYGdseXBoR2VvbWV0cnlEZXRhaWxgIHRvIGFkZCBtb3JlIHZlcnRpY2VzIGZvciBjdXJ2YXR1cmUgaW5zaWRlIGdseXBocy5cbiAgICAgKi9cbiAgICB0aGlzLmN1cnZlUmFkaXVzID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gZGlyZWN0aW9uXG4gICAgICogU2V0cyB0aGUgYmFzZSBkaXJlY3Rpb24gZm9yIHRoZSB0ZXh0LiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBcImF1dG9cIiB3aWxsIGNob29zZSBhIGRpcmVjdGlvbiBiYXNlZFxuICAgICAqIG9uIHRoZSB0ZXh0J3MgY29udGVudCBhY2NvcmRpbmcgdG8gdGhlIGJpZGkgc3BlYy4gQSB2YWx1ZSBvZiBcImx0clwiIG9yIFwicnRsXCIgd2lsbCBmb3JjZSB0aGUgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIHRoaXMuZGlyZWN0aW9uID0gJ2F1dG8nO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBmb250XG4gICAgICogVVJMIG9mIGEgY3VzdG9tIGZvbnQgdG8gYmUgdXNlZC4gRm9udCBmaWxlcyBjYW4gYmUgaW4gLnR0ZiwgLm90Ziwgb3IgLndvZmYgKG5vdCAud29mZjIpIGZvcm1hdHMuXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIFJvYm90byBmb250IGxvYWRlZCBmcm9tIEdvb2dsZSBGb250cy5cbiAgICAgKi9cbiAgICB0aGlzLmZvbnQgPSBudWxsOyAvL3dpbGwgdXNlIGRlZmF1bHQgZnJvbSBUZXh0QnVpbGRlclxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBmb250U2l6ZVxuICAgICAqIFRoZSBzaXplIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgZm9udCBpbiBsb2NhbCB1bml0czsgY29ycmVzcG9uZHMgdG8gdGhlIGVtLWJveCBoZWlnaHRcbiAgICAgKiBvZiB0aGUgY2hvc2VuIGBmb250YC5cbiAgICAgKi9cbiAgICB0aGlzLmZvbnRTaXplID0gMC4xO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZXR0ZXJTcGFjaW5nXG4gICAgICogU2V0cyBhIHVuaWZvcm0gYWRqdXN0bWVudCB0byBzcGFjaW5nIGJldHdlZW4gbGV0dGVycyBhZnRlciBrZXJuaW5nIGlzIGFwcGxpZWQuIFBvc2l0aXZlXG4gICAgICogbnVtYmVycyBpbmNyZWFzZSBzcGFjaW5nIGFuZCBuZWdhdGl2ZSBudW1iZXJzIGRlY3JlYXNlIGl0LlxuICAgICAqL1xuICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBsaW5lSGVpZ2h0XG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIGVhY2ggbGluZSBvZiB0ZXh0LCBhcyBhIG11bHRpcGxlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byAnbm9ybWFsJ1xuICAgICAqIHdoaWNoIGNob29zZXMgYSByZWFzb25hYmxlIGhlaWdodCBiYXNlZCBvbiB0aGUgY2hvc2VuIGZvbnQncyBhc2NlbmRlci9kZXNjZW5kZXIgbWV0cmljcy5cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVIZWlnaHQgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbWF4V2lkdGhcbiAgICAgKiBUaGUgbWF4aW11bSB3aWR0aCBvZiB0aGUgdGV4dCBibG9jaywgYWJvdmUgd2hpY2ggdGV4dCBtYXkgc3RhcnQgd3JhcHBpbmcgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIGB3aGl0ZVNwYWNlYCBhbmQgYG92ZXJmbG93V3JhcGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICB0aGlzLm1heFdpZHRoID0gSW5maW5pdHk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG92ZXJmbG93V3JhcFxuICAgICAqIERlZmluZXMgaG93IHRleHQgd3JhcHMgaWYgdGhlIGB3aGl0ZVNwYWNlYCBwcm9wZXJ0eSBpcyBgbm9ybWFsYC4gQ2FuIGJlIGVpdGhlciBgJ25vcm1hbCdgXG4gICAgICogdG8gYnJlYWsgYXQgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLCBvciBgJ2JyZWFrLXdvcmQnYCB0byBhbGxvdyBicmVha2luZyB3aXRoaW4gd29yZHMuXG4gICAgICogRGVmYXVsdHMgdG8gYCdub3JtYWwnYC5cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJmbG93V3JhcCA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0QWxpZ25cbiAgICAgKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgZWFjaCBsaW5lIG9mIHRleHQgd2l0aGluIHRoZSBvdmVyYWxsIHRleHQgYm91bmRpbmcgYm94LlxuICAgICAqL1xuICAgIHRoaXMudGV4dEFsaWduID0gJ2xlZnQnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0ZXh0SW5kZW50XG4gICAgICogSW5kZW50YXRpb24gZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBsaW5lOyBzZWUgQ1NTIGB0ZXh0LWluZGVudGAuXG4gICAgICovXG4gICAgdGhpcy50ZXh0SW5kZW50ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gd2hpdGVTcGFjZVxuICAgICAqIERlZmluZXMgd2hldGhlciB0ZXh0IHNob3VsZCB3cmFwIHdoZW4gYSBsaW5lIHJlYWNoZXMgdGhlIGBtYXhXaWR0aGAuIENhblxuICAgICAqIGJlIGVpdGhlciBgJ25vcm1hbCdgICh0aGUgZGVmYXVsdCksIHRvIGFsbG93IHdyYXBwaW5nIGFjY29yZGluZyB0byB0aGUgYG92ZXJmbG93V3JhcGAgcHJvcGVydHksXG4gICAgICogb3IgYCdub3dyYXAnYCB0byBwcmV2ZW50IHdyYXBwaW5nLiBOb3RlIHRoYXQgYCdub3JtYWwnYCBoZXJlIGhvbm9ycyBuZXdsaW5lIGNoYXJhY3RlcnMgdG9cbiAgICAgKiBtYW51YWxseSBicmVhayBsaW5lcywgbWFraW5nIGl0IGJlaGF2ZSBtb3JlIGxpa2UgYCdwcmUtd3JhcCdgIGRvZXMgaW4gQ1NTLlxuICAgICAqL1xuICAgIHRoaXMud2hpdGVTcGFjZSA9ICdub3JtYWwnO1xuXG5cbiAgICAvLyA9PT0gUHJlc2VudGF0aW9uIHByb3BlcnRpZXM6ID09PSAvL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7VEhSRUUuTWF0ZXJpYWx9IG1hdGVyaWFsXG4gICAgICogRGVmaW5lcyBhIF9iYXNlXyBtYXRlcmlhbCB0byBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIHRoZSB0ZXh0LiBUaGlzIG1hdGVyaWFsIHdpbGwgYmVcbiAgICAgKiBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIHdpdGggYSBtYXRlcmlhbCBkZXJpdmVkIGZyb20gaXQsIHRoYXQgYWRkcyBzaGFkZXIgY29kZSB0b1xuICAgICAqIGRlY3JlYXNlIHRoZSBhbHBoYSBmb3IgZWFjaCBmcmFnbWVudCAocGl4ZWwpIG91dHNpZGUgdGhlIHRleHQgZ2x5cGhzLCB3aXRoIGFudGlhbGlhc2luZy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IHdpbGwgZGVyaXZlIGZyb20gYSBzaW1wbGUgd2hpdGUgTWVzaEJhc2ljTWF0ZXJpYWwsIGJ1dCB5b3UgY2FuIHVzZSBhbnlcbiAgICAgKiBvZiB0aGUgb3RoZXIgbWVzaCBtYXRlcmlhbHMgdG8gZ2FpbiBvdGhlciBmZWF0dXJlcyBsaWtlIGxpZ2h0aW5nLCB0ZXh0dXJlIG1hcHMsIGV0Yy5cbiAgICAgKlxuICAgICAqIEFsc28gc2VlIHRoZSBgY29sb3JgIHNob3J0Y3V0IHByb3BlcnR5LlxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcnxUSFJFRS5Db2xvcn0gY29sb3JcbiAgICAgKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIHNldHRpbmcgdGhlIGBjb2xvcmAgb2YgdGhlIHRleHQncyBtYXRlcmlhbC4gWW91IGNhbiB1c2UgdGhpc1xuICAgICAqIGlmIHlvdSBkb24ndCB3YW50IHRvIHNwZWNpZnkgYSB3aG9sZSBjdXN0b20gYG1hdGVyaWFsYC4gQWxzbywgaWYgeW91IGRvIHVzZSBhIGN1c3RvbVxuICAgICAqIGBtYXRlcmlhbGAsIHRoaXMgY29sb3Igd2lsbCBvbmx5IGJlIHVzZWQgZm9yIHRoaXMgcGFydGljdWFyIFRleHQgaW5zdGFuY2UsIGV2ZW4gaWZcbiAgICAgKiB0aGF0IHNhbWUgbWF0ZXJpYWwgaW5zdGFuY2UgaXMgc2hhcmVkIGFjcm9zcyBtdWx0aXBsZSBUZXh0IG9iamVjdHMuXG4gICAgICovXG4gICAgdGhpcy5jb2xvciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R8bnVsbH0gY29sb3JSYW5nZXNcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhpcyBhbGxvd3MgbW9yZSBmaW5lLWdyYWluZWQgY29udHJvbCBvZiBjb2xvcnMgZm9yIGluZGl2aWR1YWwgb3IgcmFuZ2VzIG9mIGNoYXJhY3RlcnMsXG4gICAgICogdGFraW5nIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWF0ZXJpYWwncyBgY29sb3JgLiBJdHMgZm9ybWF0IGlzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGVhY2hcbiAgICAgKiBkZWZpbmUgYSBzdGFydGluZyBjaGFyYWN0ZXIgaW5kZXggZm9yIGEgcmFuZ2UsIGFuZCB3aG9zZSB2YWx1ZXMgYXJlIHRoZSBjb2xvciBmb3IgZWFjaFxuICAgICAqIHJhbmdlLiBUaGUgY29sb3IgdmFsdWUgY2FuIGJlIGEgbnVtZXJpYyBoZXggY29sb3IgdmFsdWUsIGEgYFRIUkVFLkNvbG9yYCBvYmplY3QsIG9yXG4gICAgICogYW55IG9mIHRoZSBzdHJpbmdzIGFjY2VwdGVkIGJ5IGBUSFJFRS5Db2xvcmAuXG4gICAgICovXG4gICAgdGhpcy5jb2xvclJhbmdlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lV2lkdGhcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIHdpZHRoIG9mIGFuIG91dGxpbmUvaGFsbyB0byBiZSBkcmF3biBhcm91bmQgZWFjaCB0ZXh0IGdseXBoIHVzaW5nIHRoZSBgb3V0bGluZUNvbG9yYCBhbmQgYG91dGxpbmVPcGFjaXR5YC5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLlxuICAgICAqIGBcIjEyJVwiYCB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLCB3aGljaCBtZWFuc1xuICAgICAqIG5vIG91dGxpbmUgd2lsbCBiZSBkcmF3biB1bmxlc3MgYW4gYG91dGxpbmVPZmZzZXRYL1lgIG9yIGBvdXRsaW5lQmx1cmAgaXMgc2V0LlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZVdpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IG91dGxpbmVDb2xvclxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgY29sb3Igb2YgdGhlIHRleHQgb3V0bGluZSwgaWYgYG91dGxpbmVXaWR0aGAvYG91dGxpbmVCbHVyYC9gb3V0bGluZU9mZnNldFgvWWAgYXJlIHNldC5cbiAgICAgKiBEZWZhdWx0cyB0byBibGFjay5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVDb2xvciA9IDB4MDAwMDAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBvdXRsaW5lT3BhY2l0eVxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgb3V0bGluZSwgaWYgYG91dGxpbmVXaWR0aGAvYG91dGxpbmVCbHVyYC9gb3V0bGluZU9mZnNldFgvWWAgYXJlIHNldC5cbiAgICAgKiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lT3BhY2l0eSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lQmx1clxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBBIGJsdXIgcmFkaXVzIGFwcGxpZWQgdG8gdGhlIG91dGVyIGVkZ2Ugb2YgdGhlIHRleHQncyBvdXRsaW5lLiBJZiB0aGUgYG91dGxpbmVXaWR0aGAgaXNcbiAgICAgKiB6ZXJvLCB0aGUgYmx1ciB3aWxsIGJlIGFwcGxpZWQgYXQgdGhlIGdseXBoIGVkZ2UsIGxpa2UgQ1NTJ3MgYHRleHQtc2hhZG93YCBibHVyIHJhZGl1cy5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLlxuICAgICAqIGBcIjEyJVwiYCB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZUJsdXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZU9mZnNldFhcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogQSBob3Jpem9udGFsIG9mZnNldCBmb3IgdGhlIHRleHQgb3V0bGluZS5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLiBgXCIxMiVcImBcbiAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZU9mZnNldFggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZU9mZnNldFlcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogQSB2ZXJ0aWNhbCBvZmZzZXQgZm9yIHRoZSB0ZXh0IG91dGxpbmUuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy4gYFwiMTIlXCJgXG4gICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVPZmZzZXRZID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IHN0cm9rZVdpZHRoXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSB3aWR0aCBvZiBhbiBpbm5lciBzdHJva2UgZHJhd24gaW5zaWRlIGVhY2ggdGV4dCBnbHlwaCB1c2luZyB0aGUgYHN0cm9rZUNvbG9yYCBhbmQgYHN0cm9rZU9wYWNpdHlgLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuIGBcIjEyJVwiYFxuICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBzdHJva2VDb2xvclxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgY29sb3Igb2YgdGhlIHRleHQgc3Ryb2tlLCBpZiBgc3Ryb2tlV2lkdGhgIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvLiBEZWZhdWx0cyB0byBncmF5LlxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBkZWZhdWx0U3Ryb2tlQ29sb3I7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHN0cm9rZU9wYWNpdHlcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIHN0cm9rZSwgaWYgYHN0cm9rZVdpZHRoYCBpcyBncmVhdGVyIHRoYW4gemVyby4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZpbGxPcGFjaXR5XG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBnbHlwaCdzIGZpbGwgZnJvbSAwIHRvIDEuIFRoaXMgYmVoYXZlcyBsaWtlIHRoZSBtYXRlcmlhbCdzIGBvcGFjaXR5YCBidXQgYWxsb3dzXG4gICAgICogZ2l2aW5nIHRoZSBmaWxsIGEgZGlmZmVyZW50IG9wYWNpdHkgdGhhbiB0aGUgYHN0cm9rZU9wYWNpdHlgLiBBIGZpbGxPcGFjaXR5IG9mIGAwYCBtYWtlcyB0aGVcbiAgICAgKiBpbnRlcmlvciBvZiB0aGUgZ2x5cGggaW52aXNpYmxlLCBsZWF2aW5nIGp1c3QgdGhlIGBzdHJva2VXaWR0aGAuIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gZGVwdGhPZmZzZXRcbiAgICAgKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIHNldHRpbmcgdGhlIG1hdGVyaWFsJ3MgYHBvbHlnb25PZmZzZXRgIGFuZCByZWxhdGVkIHByb3BlcnRpZXMsXG4gICAgICogd2hpY2ggY2FuIGJlIHVzZWZ1bCBpbiBwcmV2ZW50aW5nIHotZmlnaHRpbmcgd2hlbiB0aGlzIHRleHQgaXMgbGFpZCBvbiB0b3Agb2YgYW5vdGhlclxuICAgICAqIHBsYW5lIGluIHRoZSBzY2VuZS4gUG9zaXRpdmUgbnVtYmVycyBhcmUgZnVydGhlciBmcm9tIHRoZSBjYW1lcmEsIG5lZ2F0aXZlcyBjbG9zZXIuXG4gICAgICovXG4gICAgdGhpcy5kZXB0aE9mZnNldCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtBcnJheTxudW1iZXI+fSBjbGlwUmVjdFxuICAgICAqIElmIHNwZWNpZmllZCwgZGVmaW5lcyBhIGBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV1gIG9mIGEgcmVjdGFuZ2xlIG91dHNpZGUgb2Ygd2hpY2ggYWxsXG4gICAgICogcGl4ZWxzIHdpbGwgYmUgZGlzY2FyZGVkLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBleGFtcGxlIHRvIGNsaXAgb3ZlcmZsb3dpbmcgdGV4dCB3aGVuXG4gICAgICogYHdoaXRlU3BhY2U9J25vd3JhcCdgLlxuICAgICAqL1xuICAgIHRoaXMuY2xpcFJlY3QgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBvcmllbnRhdGlvblxuICAgICAqIERlZmluZXMgdGhlIGF4aXMgcGxhbmUgb24gd2hpY2ggdGhlIHRleHQgc2hvdWxkIGJlIGxhaWQgb3V0IHdoZW4gdGhlIG1lc2ggaGFzIG5vIGV4dHJhXG4gICAgICogcm90YXRpb24gdHJhbnNmb3JtLiBJdCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgd2l0aCB0d28gYXhlczogdGhlIGhvcml6b250YWwgYXhpcyB3aXRoXG4gICAgICogcG9zaXRpdmUgcG9pbnRpbmcgcmlnaHQsIGFuZCB0aGUgdmVydGljYWwgYXhpcyB3aXRoIHBvc2l0aXZlIHBvaW50aW5nIHVwLiBCeSBkZWZhdWx0IHRoaXNcbiAgICAgKiBpcyAnK3greScsIG1lYW5pbmcgdGhlIHRleHQgc2l0cyBvbiB0aGUgeHkgcGxhbmUgd2l0aCB0aGUgdGV4dCdzIHRvcCB0b3dhcmQgcG9zaXRpdmUgeVxuICAgICAqIGFuZCBmYWNpbmcgcG9zaXRpdmUgei4gQSB2YWx1ZSBvZiAnK3gteicgd291bGQgcGxhY2UgaXQgb24gdGhlIHh6IHBsYW5lIHdpdGggdGhlIHRleHQnc1xuICAgICAqIHRvcCB0b3dhcmQgbmVnYXRpdmUgeiBhbmQgZmFjaW5nIHBvc2l0aXZlIHkuXG4gICAgICovXG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IGRlZmF1bHRPcmllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGdseXBoR2VvbWV0cnlEZXRhaWxcbiAgICAgKiBDb250cm9scyBudW1iZXIgb2YgdmVydGljYWwvaG9yaXpvbnRhbCBzZWdtZW50cyB0aGF0IG1ha2UgdXAgZWFjaCBnbHlwaCdzIHJlY3Rhbmd1bGFyXG4gICAgICogcGxhbmUuIERlZmF1bHRzIHRvIDEuIFRoaXMgY2FuIGJlIGluY3JlYXNlZCB0byBwcm92aWRlIG1vcmUgZ2VvbWV0cmljYWwgZGV0YWlsIGZvciBjdXN0b21cbiAgICAgKiB2ZXJ0ZXggc2hhZGVyIGVmZmVjdHMsIGZvciBleGFtcGxlLlxuICAgICAqL1xuICAgIHRoaXMuZ2x5cGhHZW9tZXRyeURldGFpbCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8bnVsbH0gc2RmR2x5cGhTaXplXG4gICAgICogVGhlIHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKSB1c2VkIGZvciByZW5kZXJpbmcuIFRoaXMgbXVzdCBiZSBhXG4gICAgICogcG93ZXItb2YtdHdvIG51bWJlci4gRGVmYXVsdHMgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHlcbiAgICAgKiBmb3IgbW9zdCBmb250cy4gTGFyZ2VyIHNpemVzIGNhbiBpbXByb3ZlIHRoZSBxdWFsaXR5IG9mIGdseXBoIHJlbmRlcmluZyBieSBpbmNyZWFzaW5nXG4gICAgICogdGhlIHNoYXJwbmVzcyBvZiBjb3JuZXJzIGFuZCBwcmV2ZW50aW5nIGxvc3Mgb2YgdmVyeSB0aGluIGxpbmVzLCBhdCB0aGUgZXhwZW5zZSBvZlxuICAgICAqIGluY3JlYXNlZCBtZW1vcnkgZm9vdHByaW50IGFuZCBsb25nZXIgU0RGIGdlbmVyYXRpb24gdGltZS5cbiAgICAgKi9cbiAgICB0aGlzLnNkZkdseXBoU2l6ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBncHVBY2NlbGVyYXRlU0RGXG4gICAgICogV2hlbiBgdHJ1ZWAsIHRoZSBTREYgZ2VuZXJhdGlvbiBwcm9jZXNzIHdpbGwgYmUgR1BVLWFjY2VsZXJhdGVkIHdpdGggV2ViR0wgd2hlbiBwb3NzaWJsZSxcbiAgICAgKiBtYWtpbmcgaXQgbXVjaCBmYXN0ZXIgZXNwZWNpYWxseSBmb3IgY29tcGxleCBnbHlwaHMsIGFuZCBmYWxsaW5nIGJhY2sgdG8gYSBKYXZhU2NyaXB0IHZlcnNpb25cbiAgICAgKiBleGVjdXRlZCBpbiB3ZWIgd29ya2VycyB3aGVuIHN1cHBvcnQgaXNuJ3QgYXZhaWxhYmxlLiBJdCBzaG91bGQgYXV0b21hdGljYWxseSBkZXRlY3Qgc3VwcG9ydCxcbiAgICAgKiBidXQgaXQncyBzdGlsbCBzb21ld2hhdCBleHBlcmltZW50YWwsIHNvIHlvdSBjYW4gc2V0IGl0IHRvIGBmYWxzZWAgdG8gZm9yY2UgaXQgdG8gdXNlIHRoZSBKU1xuICAgICAqIHZlcnNpb24gaWYgeW91IGVuY291bnRlciBpc3N1ZXMgd2l0aCBpdC5cbiAgICAgKi9cbiAgICB0aGlzLmdwdUFjY2VsZXJhdGVTREYgPSB0cnVlO1xuXG4gICAgdGhpcy5kZWJ1Z1NERiA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHRleHQgcmVuZGVyaW5nIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB0ZXh0LXJlbGF0ZWQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgKiBUaGlzIGlzIGFuIGFzeW5jIHByb2Nlc3MsIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaXRcbiAgICogZmluaXNoZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cbiAgICovXG4gIHN5bmMoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fbmVlZHNTeW5jKSB7XG4gICAgICB0aGlzLl9uZWVkc1N5bmMgPSBmYWxzZTtcblxuICAgICAgLy8gSWYgdGhlcmUncyBhbm90aGVyIHN5bmMgc3RpbGwgaW4gcHJvZ3Jlc3MsIHF1ZXVlXG4gICAgICBpZiAodGhpcy5faXNTeW5jaW5nKSB7XG4gICAgICAgICh0aGlzLl9xdWV1ZWRTeW5jcyB8fCAodGhpcy5fcXVldWVkU3luY3MgPSBbXSkpLnB1c2goY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNTeW5jaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN5bmNTdGFydEV2ZW50KTtcblxuICAgICAgICBnZXRUZXh0UmVuZGVySW5mbyh7XG4gICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgIGZvbnQ6IHRoaXMuZm9udCxcbiAgICAgICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSB8fCAwLjEsXG4gICAgICAgICAgbGV0dGVyU3BhY2luZzogdGhpcy5sZXR0ZXJTcGFjaW5nIHx8IDAsXG4gICAgICAgICAgbGluZUhlaWdodDogdGhpcy5saW5lSGVpZ2h0IHx8ICdub3JtYWwnLFxuICAgICAgICAgIG1heFdpZHRoOiB0aGlzLm1heFdpZHRoLFxuICAgICAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24gfHwgJ2F1dG8nLFxuICAgICAgICAgIHRleHRBbGlnbjogdGhpcy50ZXh0QWxpZ24sXG4gICAgICAgICAgdGV4dEluZGVudDogdGhpcy50ZXh0SW5kZW50LFxuICAgICAgICAgIHdoaXRlU3BhY2U6IHRoaXMud2hpdGVTcGFjZSxcbiAgICAgICAgICBvdmVyZmxvd1dyYXA6IHRoaXMub3ZlcmZsb3dXcmFwLFxuICAgICAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yWCxcbiAgICAgICAgICBhbmNob3JZOiB0aGlzLmFuY2hvclksXG4gICAgICAgICAgY29sb3JSYW5nZXM6IHRoaXMuY29sb3JSYW5nZXMsXG4gICAgICAgICAgaW5jbHVkZUNhcmV0UG9zaXRpb25zOiB0cnVlLCAvL1RPRE8gcGFyYW1ldGVyaXplXG4gICAgICAgICAgc2RmR2x5cGhTaXplOiB0aGlzLnNkZkdseXBoU2l6ZSxcbiAgICAgICAgICBncHVBY2NlbGVyYXRlU0RGOiB0aGlzLmdwdUFjY2VsZXJhdGVTREYsXG4gICAgICAgIH0sIHRleHRSZW5kZXJJbmZvID0+IHtcbiAgICAgICAgICB0aGlzLl9pc1N5bmNpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIFNhdmUgcmVzdWx0IGZvciBsYXRlciB1c2UgaW4gb25CZWZvcmVSZW5kZXJcbiAgICAgICAgICB0aGlzLl90ZXh0UmVuZGVySW5mbyA9IHRleHRSZW5kZXJJbmZvO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGVzXG4gICAgICAgICAgdGhpcy5nZW9tZXRyeS51cGRhdGVHbHlwaHMoXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaEJvdW5kcyxcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmdseXBoQXRsYXNJbmRpY2VzLFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uYmxvY2tCb3VuZHMsXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5jaHVua2VkQm91bmRzLFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhDb2xvcnNcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gSWYgd2UgaGFkIGV4dHJhIHN5bmMgcmVxdWVzdHMgcXVldWVkIHVwLCBraWNrIGl0IG9mZlxuICAgICAgICAgIGNvbnN0IHF1ZXVlZCA9IHRoaXMuX3F1ZXVlZFN5bmNzO1xuICAgICAgICAgIGlmIChxdWV1ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlZFN5bmNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICBxdWV1ZWQuZm9yRWFjaChmbiA9PiBmbiAmJiBmbigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChzeW5jQ29tcGxldGVFdmVudCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgc3luYyBpZiBuZWVkZWQgLSBub3RlIGl0IHdvbid0IGNvbXBsZXRlIHVudGlsIG5leHQgZnJhbWUgYXQgdGhlXG4gICAqIGVhcmxpZXN0IHNvIGlmIHBvc3NpYmxlIGl0J3MgYSBnb29kIGlkZWEgdG8gY2FsbCBzeW5jKCkgbWFudWFsbHkgYXMgc29vbiBhc1xuICAgKiBhbGwgdGhlIHByb3BlcnRpZXMgaGF2ZSBiZWVuIHNldC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBvbkJlZm9yZVJlbmRlcihyZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCkge1xuICAgIHRoaXMuc3luYygpO1xuXG4gICAgLy8gVGhpcyBtYXkgbm90IGFsd2F5cyBiZSBhIHRleHQgbWF0ZXJpYWwsIGUuZy4gaWYgdGhlcmUncyBhIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgcHJlc2VudFxuICAgIGlmIChtYXRlcmlhbC5pc1Ryb2lrYVRleHRNYXRlcmlhbCkge1xuICAgICAgdGhpcy5fcHJlcGFyZUZvclJlbmRlcihtYXRlcmlhbCk7XG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byBmb3JjZSB0aGUgbWF0ZXJpYWwgdG8gRnJvbnRTaWRlIHRvIGF2b2lkIHRoZSBkb3VibGUtZHJhdy1jYWxsIHBlcmZvcm1hbmNlIGhpdFxuICAgIC8vIGludHJvZHVjZWQgaW4gVGhyZWUuanMgcjEzMDogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIxOTY3IC0gVGhlIHNpZGVkbmVzc1xuICAgIC8vIGlzIGluc3RlYWQgYXBwbGllZCB2aWEgZHJhd1JhbmdlIGluIHRoZSBHbHlwaHNHZW9tZXRyeS5cbiAgICBtYXRlcmlhbC5faGFkT3duU2lkZSA9IG1hdGVyaWFsLmhhc093blByb3BlcnR5KCdzaWRlJyk7XG4gICAgdGhpcy5nZW9tZXRyeS5zZXRTaWRlKG1hdGVyaWFsLl9hY3R1YWxTaWRlID0gbWF0ZXJpYWwuc2lkZSk7XG4gICAgbWF0ZXJpYWwuc2lkZSA9IEZyb250U2lkZTtcbiAgfVxuXG4gIG9uQWZ0ZXJSZW5kZXIocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXApIHtcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIG1hdGVyaWFsIHNpZGVcbiAgICBpZiAobWF0ZXJpYWwuX2hhZE93blNpZGUpIHtcbiAgICAgIG1hdGVyaWFsLnNpZGUgPSBtYXRlcmlhbC5fYWN0dWFsU2lkZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG1hdGVyaWFsLnNpZGU7IC8vIGJhY2sgdG8gaW5oZXJpdGluZyBmcm9tIGJhc2UgbWF0ZXJpYWxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvcnRjdXQgdG8gZGlzcG9zZSB0aGUgZ2VvbWV0cnkgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICogTm90ZTogd2UgZG9uJ3QgYWxzbyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGhlcmUgYmVjYXVzZSBpZiBhbnl0aGluZyBlbHNlIGlzXG4gICAqIHNoYXJpbmcgdGhlIHNhbWUgYmFzZSBtYXRlcmlhbCBpdCB3aWxsIHJlc3VsdCBpbiBhIHBhdXNlIG5leHQgZnJhbWUgYXMgdGhlIHByb2dyYW1cbiAgICogaXMgcmVjb21waWxlZC4gSW5zdGVhZCB1c2VycyBjYW4gZGlzcG9zZSB0aGUgYmFzZSBtYXRlcmlhbCBtYW51YWxseSwgbGlrZSBub3JtYWwsXG4gICAqIGFuZCB3ZSdsbCBhbHNvIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgYXQgdGhhdCB0aW1lLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge1Ryb2lrYVRleHRSZW5kZXJJbmZvfG51bGx9IHRleHRSZW5kZXJJbmZvXG4gICAqIEByZWFkb25seVxuICAgKiBUaGUgY3VycmVudCBwcm9jZXNzZWQgcmVuZGVyaW5nIGRhdGEgZm9yIHRoaXMgVGV4dE1lc2gsIHJldHVybmVkIGJ5IHRoZSBUZXh0QnVpbGRlciBhZnRlclxuICAgKiBhIGBzeW5jKClgIGNhbGwuIFRoaXMgd2lsbCBiZSBgbnVsbGAgaW5pdGlhbGx5LCBhbmQgbWF5IGJlIHN0YWxlIGZvciBhIHNob3J0IHBlcmlvZCB1bnRpbFxuICAgKiB0aGUgYXN5bmNocm91cyBgc3luYygpYCBwcm9jZXNzIGNvbXBsZXRlcy5cbiAgICovXG4gIGdldCB0ZXh0UmVuZGVySW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dFJlbmRlckluZm8gfHwgbnVsbFxuICB9XG5cbiAgLy8gSGFuZGxlciBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyB0aGUgYmFzZSBtYXRlcmlhbCB3aXRoIG91ciB1cGdyYWRlcy4gV2UgZG8gdGhlIHdyYXBwaW5nXG4gIC8vIGxhemlseSBvbiBfcmVhZF8gcmF0aGVyIHRoYW4gd3JpdGUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd3JhcHBpbmcgb24gdHJhbnNpZW50IHZhbHVlcy5cbiAgZ2V0IG1hdGVyaWFsKCkge1xuICAgIGxldCBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWw7XG4gICAgY29uc3QgYmFzZU1hdGVyaWFsID0gdGhpcy5fYmFzZU1hdGVyaWFsIHx8IHRoaXMuX2RlZmF1bHRNYXRlcmlhbCB8fCAodGhpcy5fZGVmYXVsdE1hdGVyaWFsID0gZGVmYXVsdE1hdGVyaWFsLmNsb25lKCkpO1xuICAgIGlmICghZGVyaXZlZE1hdGVyaWFsIHx8IGRlcml2ZWRNYXRlcmlhbC5iYXNlTWF0ZXJpYWwgIT09IGJhc2VNYXRlcmlhbCkge1xuICAgICAgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsID0gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpO1xuICAgICAgLy8gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCB3aGVuIGl0cyBiYXNlIG1hdGVyaWFsIGlzIGRpc3Bvc2VkOlxuICAgICAgYmFzZU1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25EaXNwb3NlKTtcbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiB0ZXh0IG91dGxpbmUgaXMgY29uZmlndXJlZCwgcmVuZGVyIGl0IGFzIGEgcHJlbGltaW5hcnkgZHJhdyB1c2luZyBUaHJlZSdzIG11bHRpLW1hdGVyaWFsXG4gICAgLy8gZmVhdHVyZSAoc2VlIEdseXBoc0dlb21ldHJ5IHdoaWNoIHNldHMgdXAgYGdyb3Vwc2AgZm9yIHRoaXMgcHVycG9zZSkgRG9pbmcgaXQgd2l0aCBtdWx0aVxuICAgIC8vIG1hdGVyaWFscyBlbnN1cmVzIHRoZSBsYXllcnMgYXJlIGFsd2F5cyByZW5kZXJlZCBjb25zZWN1dGl2ZWx5IGluIGEgY29uc2lzdGVudCBvcmRlci5cbiAgICAvLyBFYWNoIGxheWVyIHdpbGwgdHJpZ2dlciBvbkJlZm9yZVJlbmRlciB3aXRoIHRoZSBhcHByb3ByaWF0ZSBtYXRlcmlhbC5cbiAgICBpZiAodGhpcy5vdXRsaW5lV2lkdGggfHwgdGhpcy5vdXRsaW5lQmx1ciB8fCB0aGlzLm91dGxpbmVPZmZzZXRYIHx8IHRoaXMub3V0bGluZU9mZnNldFkpIHtcbiAgICAgIGxldCBvdXRsaW5lTWF0ZXJpYWwgPSBkZXJpdmVkTWF0ZXJpYWwuX291dGxpbmVNdGw7XG4gICAgICBpZiAoIW91dGxpbmVNYXRlcmlhbCkge1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwgPSBkZXJpdmVkTWF0ZXJpYWwuX291dGxpbmVNdGwgPSBPYmplY3QuY3JlYXRlKGRlcml2ZWRNYXRlcmlhbCwge1xuICAgICAgICAgIGlkOiB7dmFsdWU6IGRlcml2ZWRNYXRlcmlhbC5pZCArIDAuMX1cbiAgICAgICAgfSk7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbC5pc1RleHRPdXRsaW5lTWF0ZXJpYWwgPSB0cnVlO1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwubWFwID0gbnVsbDsgLy8/Pz9cbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgICAgZGVyaXZlZE1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICAgIG91dGxpbmVNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgb3V0bGluZU1hdGVyaWFsLFxuICAgICAgICBkZXJpdmVkTWF0ZXJpYWxcbiAgICAgIF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICAgIH1cbiAgfVxuICBzZXQgbWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gICAgaWYgKGJhc2VNYXRlcmlhbCAmJiBiYXNlTWF0ZXJpYWwuaXNUcm9pa2FUZXh0TWF0ZXJpYWwpIHsgLy9wcmV2ZW50IGRvdWJsZS1kZXJpdmF0aW9uXG4gICAgICB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWwuYmFzZU1hdGVyaWFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGdseXBoR2VvbWV0cnlEZXRhaWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuZGV0YWlsXG4gIH1cbiAgc2V0IGdseXBoR2VvbWV0cnlEZXRhaWwoZGV0YWlsKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5kZXRhaWwgPSBkZXRhaWw7XG4gIH1cblxuICBnZXQgY3VydmVSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuY3VydmVSYWRpdXNcbiAgfVxuICBzZXQgY3VydmVSYWRpdXMocikge1xuICAgIHRoaXMuZ2VvbWV0cnkuY3VydmVSYWRpdXMgPSByO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFuZCB1cGRhdGUgbWF0ZXJpYWwgZm9yIHNoYWRvd3MgdXBvbiByZXF1ZXN0OlxuICBnZXQgY3VzdG9tRGVwdGhNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gZmlyc3QodGhpcy5tYXRlcmlhbCkuZ2V0RGVwdGhNYXRlcmlhbCgpXG4gIH1cbiAgZ2V0IGN1c3RvbURpc3RhbmNlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIGZpcnN0KHRoaXMubWF0ZXJpYWwpLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICB9XG5cbiAgX3ByZXBhcmVGb3JSZW5kZXIobWF0ZXJpYWwpIHtcbiAgICBjb25zdCBpc091dGxpbmUgPSBtYXRlcmlhbC5pc1RleHRPdXRsaW5lTWF0ZXJpYWw7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcbiAgICBjb25zdCB0ZXh0SW5mbyA9IHRoaXMudGV4dFJlbmRlckluZm87XG4gICAgaWYgKHRleHRJbmZvKSB7XG4gICAgICBjb25zdCB7c2RmVGV4dHVyZSwgYmxvY2tCb3VuZHN9ID0gdGV4dEluZm87XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGVGV4dHVyZS52YWx1ZSA9IHNkZlRleHR1cmU7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGVGV4dHVyZVNpemUudmFsdWUuc2V0KHNkZlRleHR1cmUuaW1hZ2Uud2lkdGgsIHNkZlRleHR1cmUuaW1hZ2UuaGVpZ2h0KTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTREZHbHlwaFNpemUudmFsdWUgPSB0ZXh0SW5mby5zZGZHbHlwaFNpemU7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGRXhwb25lbnQudmFsdWUgPSB0ZXh0SW5mby5zZGZFeHBvbmVudDtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FUb3RhbEJvdW5kcy52YWx1ZS5mcm9tQXJyYXkoYmxvY2tCb3VuZHMpO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVVzZUdseXBoQ29sb3JzLnZhbHVlID0gIWlzT3V0bGluZSAmJiAhIXRleHRJbmZvLmdseXBoQ29sb3JzO1xuXG4gICAgICBsZXQgZGlzdGFuY2VPZmZzZXQgPSAwO1xuICAgICAgbGV0IGJsdXJSYWRpdXMgPSAwO1xuICAgICAgbGV0IHN0cm9rZVdpZHRoID0gMDtcbiAgICAgIGxldCBmaWxsT3BhY2l0eTtcbiAgICAgIGxldCBzdHJva2VPcGFjaXR5O1xuICAgICAgbGV0IHN0cm9rZUNvbG9yO1xuICAgICAgbGV0IG9mZnNldFggPSAwO1xuICAgICAgbGV0IG9mZnNldFkgPSAwO1xuXG4gICAgICBpZiAoaXNPdXRsaW5lKSB7XG4gICAgICAgIGxldCB7b3V0bGluZVdpZHRoLCBvdXRsaW5lT2Zmc2V0WCwgb3V0bGluZU9mZnNldFksIG91dGxpbmVCbHVyLCBvdXRsaW5lT3BhY2l0eX0gPSB0aGlzO1xuICAgICAgICBkaXN0YW5jZU9mZnNldCA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lV2lkdGgpIHx8IDA7XG4gICAgICAgIGJsdXJSYWRpdXMgPSBNYXRoLm1heCgwLCB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZUJsdXIpIHx8IDApO1xuICAgICAgICBmaWxsT3BhY2l0eSA9IG91dGxpbmVPcGFjaXR5O1xuICAgICAgICBvZmZzZXRYID0gdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVPZmZzZXRYKSB8fCAwO1xuICAgICAgICBvZmZzZXRZID0gdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVPZmZzZXRZKSB8fCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBNYXRoLm1heCgwLCB0aGlzLl9wYXJzZVBlcmNlbnQodGhpcy5zdHJva2VXaWR0aCkgfHwgMCk7XG4gICAgICAgIGlmIChzdHJva2VXaWR0aCkge1xuICAgICAgICAgIHN0cm9rZUNvbG9yID0gdGhpcy5zdHJva2VDb2xvcjtcbiAgICAgICAgICB1bmlmb3Jtcy51VHJvaWthU3Ryb2tlQ29sb3IudmFsdWUuc2V0KHN0cm9rZUNvbG9yID09IG51bGwgPyBkZWZhdWx0U3Ryb2tlQ29sb3IgOiBzdHJva2VDb2xvcik7XG4gICAgICAgICAgc3Ryb2tlT3BhY2l0eSA9IHRoaXMuc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgICBpZiAoc3Ryb2tlT3BhY2l0eSA9PSBudWxsKSBzdHJva2VPcGFjaXR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmaWxsT3BhY2l0eSA9IHRoaXMuZmlsbE9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FEaXN0YW5jZU9mZnNldC52YWx1ZSA9IGRpc3RhbmNlT2Zmc2V0O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVBvc2l0aW9uT2Zmc2V0LnZhbHVlLnNldChvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FCbHVyUmFkaXVzLnZhbHVlID0gYmx1clJhZGl1cztcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTdHJva2VXaWR0aC52YWx1ZSA9IHN0cm9rZVdpZHRoO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZU9wYWNpdHkudmFsdWUgPSBzdHJva2VPcGFjaXR5O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYUZpbGxPcGFjaXR5LnZhbHVlID0gZmlsbE9wYWNpdHkgPT0gbnVsbCA/IDEgOiBmaWxsT3BhY2l0eTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FDdXJ2ZVJhZGl1cy52YWx1ZSA9IHRoaXMuY3VydmVSYWRpdXMgfHwgMDtcblxuICAgICAgbGV0IGNsaXBSZWN0ID0gdGhpcy5jbGlwUmVjdDtcbiAgICAgIGlmIChjbGlwUmVjdCAmJiBBcnJheS5pc0FycmF5KGNsaXBSZWN0KSAmJiBjbGlwUmVjdC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlLmZyb21BcnJheShjbGlwUmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBjbGlwcGluZyAtIGNob29zZSBhIGZpbml0ZSByZWN0IHRoYXQgc2hvdWxkbid0IGV2ZXIgYmUgcmVhY2hlZCBieSBvdmVyZmxvd2luZyBnbHlwaHMgb3Igb3V0bGluZXNcbiAgICAgICAgY29uc3QgcGFkID0gKHRoaXMuZm9udFNpemUgfHwgMC4xKSAqIDEwMDtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlLnNldChcbiAgICAgICAgICBibG9ja0JvdW5kc1swXSAtIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1sxXSAtIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1syXSArIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1szXSArIHBhZFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5nZW9tZXRyeS5hcHBseUNsaXBSZWN0KHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZSk7XG4gICAgfVxuICAgIHVuaWZvcm1zLnVUcm9pa2FTREZEZWJ1Zy52YWx1ZSA9ICEhdGhpcy5kZWJ1Z1NERjtcbiAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gISF0aGlzLmRlcHRoT2Zmc2V0O1xuICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgPSB0aGlzLmRlcHRoT2Zmc2V0IHx8IDA7XG5cbiAgICAvLyBTaG9ydGN1dCBmb3Igc2V0dGluZyBtYXRlcmlhbCBjb2xvciB2aWEgYGNvbG9yYCBwcm9wIG9uIHRoZSBtZXNoOyB0aGlzIGlzXG4gICAgLy8gYXBwbGllZCBvbmx5IHRvIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvIGF2b2lkIG11dGF0aW5nIGEgc2hhcmVkIGJhc2UgbWF0ZXJpYWwuXG4gICAgY29uc3QgY29sb3IgPSBpc091dGxpbmUgPyAodGhpcy5vdXRsaW5lQ29sb3IgfHwgMCkgOiB0aGlzLmNvbG9yO1xuXG4gICAgaWYgKGNvbG9yID09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSBtYXRlcmlhbC5jb2xvcjsgLy9pbmhlcml0IGZyb20gYmFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb2xvck9iaiA9IG1hdGVyaWFsLmhhc093blByb3BlcnR5KCdjb2xvcicpID8gbWF0ZXJpYWwuY29sb3IgOiAobWF0ZXJpYWwuY29sb3IgPSBuZXcgQ29sb3IoKSk7XG4gICAgICBpZiAoY29sb3IgIT09IGNvbG9yT2JqLl9pbnB1dCB8fCB0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbG9yT2JqLnNldChjb2xvck9iai5faW5wdXQgPSBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYmFzZSBvcmllbnRhdGlvblxuICAgIGxldCBvcmllbnQgPSB0aGlzLm9yaWVudGF0aW9uIHx8IGRlZmF1bHRPcmllbnQ7XG4gICAgaWYgKG9yaWVudCAhPT0gbWF0ZXJpYWwuX29yaWVudGF0aW9uKSB7XG4gICAgICBsZXQgcm90TWF0ID0gdW5pZm9ybXMudVRyb2lrYU9yaWVudC52YWx1ZTtcbiAgICAgIG9yaWVudCA9IG9yaWVudC5yZXBsYWNlKC9bXi0reHl6XS9nLCAnJyk7XG4gICAgICBsZXQgbWF0Y2ggPSBvcmllbnQgIT09IGRlZmF1bHRPcmllbnQgJiYgb3JpZW50Lm1hdGNoKC9eKFstK10pKFt4eXpdKShbLStdKShbeHl6XSkkLyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IFssIGhTaWduLCBoQXhpcywgdlNpZ24sIHZBeGlzXSA9IG1hdGNoO1xuICAgICAgICB0ZW1wVmVjM2Euc2V0KDAsIDAsIDApW2hBeGlzXSA9IGhTaWduID09PSAnLScgPyAxIDogLTE7XG4gICAgICAgIHRlbXBWZWMzYi5zZXQoMCwgMCwgMClbdkF4aXNdID0gdlNpZ24gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgdGVtcE1hdDQubG9va0F0KG9yaWdpbiwgdGVtcFZlYzNhLmNyb3NzKHRlbXBWZWMzYiksIHRlbXBWZWMzYik7XG4gICAgICAgIHJvdE1hdC5zZXRGcm9tTWF0cml4NCh0ZW1wTWF0NCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3RNYXQuaWRlbnRpdHkoKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsLl9vcmllbnRhdGlvbiA9IG9yaWVudDtcbiAgICB9XG4gIH1cblxuICBfcGFyc2VQZXJjZW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKC0/W1xcZC5dKyklJC8pO1xuICAgICAgbGV0IHBjdCA9IG1hdGNoID8gcGFyc2VGbG9hdChtYXRjaFsxXSkgOiBOYU47XG4gICAgICB2YWx1ZSA9IChpc05hTihwY3QpID8gMCA6IHBjdCAvIDEwMCkgKiB0aGlzLmZvbnRTaXplO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgYSBwb2ludCBpbiBsb2NhbCBzcGFjZSB0byBhbiB4L3kgaW4gdGhlIHRleHQgcGxhbmUuXG4gICAqL1xuICBsb2NhbFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG4gICAgdGFyZ2V0LmNvcHkocG9zaXRpb24pOyAvL3NpbXBsZSBub24tY3VydmVkIGNhc2UgaXMgMToxXG4gICAgY29uc3QgciA9IHRoaXMuY3VydmVSYWRpdXM7XG4gICAgaWYgKHIpIHsgLy9mbGF0dGVuIHRoZSBjdXJ2ZVxuICAgICAgdGFyZ2V0LnggPSBNYXRoLmF0YW4yKHBvc2l0aW9uLngsIE1hdGguYWJzKHIpIC0gTWF0aC5hYnMocG9zaXRpb24ueikpICogTWF0aC5hYnMocik7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgYSBwb2ludCBpbiB3b3JsZCBzcGFjZSB0byBhbiB4L3kgaW4gdGhlIHRleHQgcGxhbmUuXG4gICAqL1xuICB3b3JsZFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG4gICAgdGVtcFZlYzNhLmNvcHkocG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzLmxvY2FsUG9zaXRpb25Ub1RleHRDb29yZHModGhpcy53b3JsZFRvTG9jYWwodGVtcFZlYzNhKSwgdGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZSBDdXN0b20gcmF5Y2FzdGluZyB0byB0ZXN0IGFnYWluc3QgdGhlIHdob2xlIHRleHQgYmxvY2sncyBtYXggcmVjdGFuZ3VsYXIgYm91bmRzXG4gICAqIFRPRE8gaXMgdGhlcmUgYW55IHJlYXNvbiB0byBtYWtlIHRoaXMgbW9yZSBncmFudWxhciwgbGlrZSB3aXRoaW4gaW5kaXZpZHVhbCBsaW5lIG9yIGdseXBoIHJlY3RzP1xuICAgKi9cbiAgcmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpIHtcbiAgICBjb25zdCB7dGV4dFJlbmRlckluZm8sIGN1cnZlUmFkaXVzfSA9IHRoaXM7XG4gICAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICBjb25zdCBib3VuZHMgPSB0ZXh0UmVuZGVySW5mby5ibG9ja0JvdW5kcztcbiAgICAgIGNvbnN0IHJheWNhc3RNZXNoID0gY3VydmVSYWRpdXMgPyBnZXRDdXJ2ZWRSYXljYXN0TWVzaCgpIDogZ2V0RmxhdFJheWNhc3RNZXNoKCk7XG4gICAgICBjb25zdCBnZW9tID0gcmF5Y2FzdE1lc2guZ2VvbWV0cnk7XG4gICAgICBjb25zdCB7cG9zaXRpb24sIHV2fSA9IGdlb20uYXR0cmlidXRlcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXYuY291bnQ7IGkrKykge1xuICAgICAgICBsZXQgeCA9IGJvdW5kc1swXSArICh1di5nZXRYKGkpICogKGJvdW5kc1syXSAtIGJvdW5kc1swXSkpO1xuICAgICAgICBjb25zdCB5ID0gYm91bmRzWzFdICsgKHV2LmdldFkoaSkgKiAoYm91bmRzWzNdIC0gYm91bmRzWzFdKSk7XG4gICAgICAgIGxldCB6ID0gMDtcbiAgICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgICAgeiA9IGN1cnZlUmFkaXVzIC0gTWF0aC5jb3MoeCAvIGN1cnZlUmFkaXVzKSAqIGN1cnZlUmFkaXVzO1xuICAgICAgICAgIHggPSBNYXRoLnNpbih4IC8gY3VydmVSYWRpdXMpICogY3VydmVSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24uc2V0WFlaKGksIHgsIHksIHopO1xuICAgICAgfVxuICAgICAgZ2VvbS5ib3VuZGluZ1NwaGVyZSA9IHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmU7XG4gICAgICBnZW9tLmJvdW5kaW5nQm94ID0gdGhpcy5nZW9tZXRyeS5ib3VuZGluZ0JveDtcbiAgICAgIHJheWNhc3RNZXNoLm1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcbiAgICAgIHJheWNhc3RNZXNoLm1hdGVyaWFsLnNpZGUgPSB0aGlzLm1hdGVyaWFsLnNpZGU7XG4gICAgICB0ZW1wQXJyYXkubGVuZ3RoID0gMDtcbiAgICAgIHJheWNhc3RNZXNoLnJheWNhc3QocmF5Y2FzdGVyLCB0ZW1wQXJyYXkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGVtcEFycmF5W2ldLm9iamVjdCA9IHRoaXM7XG4gICAgICAgIGludGVyc2VjdHMucHVzaCh0ZW1wQXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvcHkoc291cmNlKSB7XG4gICAgLy8gUHJldmVudCBjb3B5aW5nIHRoZSBnZW9tZXRyeSByZWZlcmVuY2Ugc28gd2UgZG9uJ3QgZW5kIHVwIHNoYXJpbmcgYXR0cmlidXRlcyBiZXR3ZWVuIGluc3RhbmNlc1xuICAgIGNvbnN0IGdlb20gPSB0aGlzLmdlb21ldHJ5O1xuICAgIHN1cGVyLmNvcHkoc291cmNlKTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbTtcblxuICAgIENPUFlBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICB0aGlzW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpXG4gIH1cbn1cblxuXG4vLyBDcmVhdGUgc2V0dGVycyBmb3IgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0ZXh0IGxheW91dDpcblNZTkNBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSAnX3ByaXZhdGVfJyArIHByb3A7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgcHJvcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3ByaXZhdGVLZXldXG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdGhpc1twcml2YXRlS2V5XSkge1xuICAgICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pO1xuXG4vLz09PSBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIGNhcmV0cyBhbmQgc2VsZWN0aW9uIHJhbmdlcyA9PT0vL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRleHRDYXJldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSB4IHBvc2l0aW9uIG9mIHRoZSBjYXJldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSB5IHBvc2l0aW9uIG9mIHRoZSBjYXJldCdzIGJvdHRvbVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIGhlaWdodCBvZiB0aGUgY2FyZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaGFySW5kZXggLSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZyBvZiB0aGlzIGNhcmV0J3MgdGFyZ2V0XG4gKiAgIGNoYXJhY3RlcjsgdGhlIGNhcmV0IHdpbGwgYmUgZm9yIHRoZSBwb3NpdGlvbiBfYmVmb3JlXyB0aGF0IGNoYXJhY3Rlci5cbiAqL1xuXG4vKipcbiAqIEdpdmVuIGEgbG9jYWwgeC95IGNvb3JkaW5hdGUgaW4gdGhlIHRleHQgYmxvY2sgcGxhbmUsIGZpbmQgdGhlIG5lYXJlc3QgY2FyZXQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge1Ryb2lrYVRleHRSZW5kZXJJbmZvfSB0ZXh0UmVuZGVySW5mbyAtIGEgcmVzdWx0IG9iamVjdCBmcm9tIFRleHRCdWlsZGVyI2dldFRleHRSZW5kZXJJbmZvXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge1RleHRDYXJldCB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldENhcmV0QXRQb2ludCh0ZXh0UmVuZGVySW5mbywgeCwgeSkge1xuICBsZXQgY2xvc2VzdENhcmV0ID0gbnVsbDtcbiAgY29uc3Qge2NhcmV0SGVpZ2h0fSA9IHRleHRSZW5kZXJJbmZvO1xuICBjb25zdCBjYXJldHNCeVJvdyA9IGdyb3VwQ2FyZXRzQnlSb3codGV4dFJlbmRlckluZm8pO1xuXG4gIC8vIEZpbmQgbmVhcmVzdCByb3cgYnkgeSBmaXJzdFxuICBsZXQgY2xvc2VzdFJvd1kgPSBJbmZpbml0eTtcbiAgY2FyZXRzQnlSb3cuZm9yRWFjaCgoY2FyZXRzLCByb3dZKSA9PiB7XG4gICAgaWYgKE1hdGguYWJzKHkgLSAocm93WSArIGNhcmV0SGVpZ2h0IC8gMikpIDwgTWF0aC5hYnMoeSAtIChjbG9zZXN0Um93WSArIGNhcmV0SGVpZ2h0IC8gMikpKSB7XG4gICAgICBjbG9zZXN0Um93WSA9IHJvd1k7XG4gICAgfVxuICB9KTtcblxuICAvLyBUaGVuIGZpbmQgY2xvc2VzdCBjYXJldCBieSB4IHdpdGhpbiB0aGF0IHJvd1xuICBjYXJldHNCeVJvdy5nZXQoY2xvc2VzdFJvd1kpLmZvckVhY2goY2FyZXQgPT4ge1xuICAgIGlmICghY2xvc2VzdENhcmV0IHx8IE1hdGguYWJzKHggLSBjYXJldC54KSA8IE1hdGguYWJzKHggLSBjbG9zZXN0Q2FyZXQueCkpIHtcbiAgICAgIGNsb3Nlc3RDYXJldCA9IGNhcmV0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbG9zZXN0Q2FyZXRcbn1cblxuXG5jb25zdCBfcmVjdHNDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogR2l2ZW4gc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXIgaW5kZXhlcywgcmV0dXJuIGEgbGlzdCBvZiByZWN0YW5nbGVzIGNvdmVyaW5nIGFsbCB0aGVcbiAqIGNoYXJhY3RlcnMgd2l0aGluIHRoYXQgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGluIHRoZSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhciBhZnRlciB0aGUgc2VsZWN0aW9uXG4gKiBAcmV0dXJuIHtBcnJheTx7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfT4gfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25SZWN0cyh0ZXh0UmVuZGVySW5mbywgc3RhcnQsIGVuZCkge1xuICBsZXQgcmVjdHM7XG4gIGlmICh0ZXh0UmVuZGVySW5mbykge1xuICAgIC8vIENoZWNrIGNhY2hlIC0gdGV4dFJlbmRlckluZm8gaXMgZnJvemVuIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSBiYXNlZCBvbiBpdFxuICAgIGxldCBwcmV2UmVzdWx0ID0gX3JlY3RzQ2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgICBpZiAocHJldlJlc3VsdCAmJiBwcmV2UmVzdWx0LnN0YXJ0ID09PSBzdGFydCAmJiBwcmV2UmVzdWx0LmVuZCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gcHJldlJlc3VsdC5yZWN0c1xuICAgIH1cblxuICAgIGNvbnN0IHtjYXJldFBvc2l0aW9ucywgY2FyZXRIZWlnaHR9ID0gdGV4dFJlbmRlckluZm87XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgIGNvbnN0IHMgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgZW5kID0gcztcbiAgICB9XG4gICAgc3RhcnQgPSBNYXRoLm1heChzdGFydCwgMCk7XG4gICAgZW5kID0gTWF0aC5taW4oZW5kLCBjYXJldFBvc2l0aW9ucy5sZW5ndGggKyAxKTtcblxuICAgIC8vIEJ1aWxkIGxpc3Qgb2YgcmVjdHMsIGV4cGFuZGluZyB0aGUgY3VycmVudCByZWN0IGZvciBhbGwgY2hhcmFjdGVycyBpbiBhIHJ1biBhbmQgc3RhcnRpbmdcbiAgICAvLyBhIG5ldyByZWN0IHdoZW5ldmVyIHJlYWNoaW5nIGEgbmV3IGxpbmUgb3IgYSBuZXcgYmlkaSBkaXJlY3Rpb25cbiAgICByZWN0cyA9IFtdO1xuICAgIGxldCBjdXJyZW50UmVjdCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IHgxID0gY2FyZXRQb3NpdGlvbnNbaSAqIDNdO1xuICAgICAgY29uc3QgeDIgPSBjYXJldFBvc2l0aW9uc1tpICogMyArIDFdO1xuICAgICAgY29uc3QgbGVmdCA9IE1hdGgubWluKHgxLCB4Mik7XG4gICAgICBjb25zdCByaWdodCA9IE1hdGgubWF4KHgxLCB4Mik7XG4gICAgICBjb25zdCBib3R0b20gPSBjYXJldFBvc2l0aW9uc1tpICogMyArIDJdO1xuICAgICAgaWYgKCFjdXJyZW50UmVjdCB8fCBib3R0b20gIT09IGN1cnJlbnRSZWN0LmJvdHRvbSB8fCBsZWZ0ID4gY3VycmVudFJlY3QucmlnaHQgfHwgcmlnaHQgPCBjdXJyZW50UmVjdC5sZWZ0KSB7XG4gICAgICAgIGN1cnJlbnRSZWN0ID0ge1xuICAgICAgICAgIGxlZnQ6IEluZmluaXR5LFxuICAgICAgICAgIHJpZ2h0OiAtSW5maW5pdHksXG4gICAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgICAgdG9wOiBib3R0b20gKyBjYXJldEhlaWdodFxuICAgICAgICB9O1xuICAgICAgICByZWN0cy5wdXNoKGN1cnJlbnRSZWN0KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSZWN0LmxlZnQgPSBNYXRoLm1pbihsZWZ0LCBjdXJyZW50UmVjdC5sZWZ0KTtcbiAgICAgIGN1cnJlbnRSZWN0LnJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIGN1cnJlbnRSZWN0LnJpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBNZXJnZSBhbnkgb3ZlcmxhcHBpbmcgcmVjdHMsIGUuZy4gdGhvc2UgZm9ybWVkIGJ5IGFkamFjZW50IGJpZGkgcnVuc1xuICAgIHJlY3RzLnNvcnQoKGEsIGIpID0+IGIuYm90dG9tIC0gYS5ib3R0b20gfHwgYS5sZWZ0IC0gYi5sZWZ0KTtcbiAgICBmb3IgKGxldCBpID0gcmVjdHMubGVuZ3RoIC0gMTsgaS0tID4gMDspIHtcbiAgICAgIGNvbnN0IHJlY3RBID0gcmVjdHNbaV07XG4gICAgICBjb25zdCByZWN0QiA9IHJlY3RzW2kgKyAxXTtcbiAgICAgIGlmIChyZWN0QS5ib3R0b20gPT09IHJlY3RCLmJvdHRvbSAmJiByZWN0QS5sZWZ0IDw9IHJlY3RCLnJpZ2h0ICYmIHJlY3RBLnJpZ2h0ID49IHJlY3RCLmxlZnQpIHtcbiAgICAgICAgcmVjdEIubGVmdCA9IE1hdGgubWluKHJlY3RCLmxlZnQsIHJlY3RBLmxlZnQpO1xuICAgICAgICByZWN0Qi5yaWdodCA9IE1hdGgubWF4KHJlY3RCLnJpZ2h0LCByZWN0QS5yaWdodCk7XG4gICAgICAgIHJlY3RzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVjdHNDYWNoZS5zZXQodGV4dFJlbmRlckluZm8sIHtzdGFydCwgZW5kLCByZWN0c30pO1xuICB9XG4gIHJldHVybiByZWN0c1xufVxuXG5jb25zdCBfY2FyZXRzQnlSb3dDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIGdyb3VwQ2FyZXRzQnlSb3codGV4dFJlbmRlckluZm8pIHtcbiAgLy8gdGV4dFJlbmRlckluZm8gaXMgZnJvemVuIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSBiYXNlZCBvbiBpdFxuICBsZXQgY2FyZXRzQnlSb3cgPSBfY2FyZXRzQnlSb3dDYWNoZS5nZXQodGV4dFJlbmRlckluZm8pO1xuICBpZiAoIWNhcmV0c0J5Um93KSB7XG4gICAgY29uc3Qge2NhcmV0UG9zaXRpb25zLCBjYXJldEhlaWdodH0gPSB0ZXh0UmVuZGVySW5mbztcbiAgICBjYXJldHNCeVJvdyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhcmV0UG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBjb25zdCByb3dZID0gY2FyZXRQb3NpdGlvbnNbaSArIDJdO1xuICAgICAgbGV0IHJvd0NhcmV0cyA9IGNhcmV0c0J5Um93LmdldChyb3dZKTtcbiAgICAgIGlmICghcm93Q2FyZXRzKSB7XG4gICAgICAgIGNhcmV0c0J5Um93LnNldChyb3dZLCByb3dDYXJldHMgPSBbXSk7XG4gICAgICB9XG4gICAgICByb3dDYXJldHMucHVzaCh7XG4gICAgICAgIHg6IGNhcmV0UG9zaXRpb25zW2ldLFxuICAgICAgICB5OiByb3dZLFxuICAgICAgICBoZWlnaHQ6IGNhcmV0SGVpZ2h0LFxuICAgICAgICBjaGFySW5kZXg6IGkgLyAzXG4gICAgICB9KTtcbiAgICAgIC8vIEFkZCBvbmUgbW9yZSBjYXJldCBhZnRlciB0aGUgZmluYWwgY2hhclxuICAgICAgaWYgKGkgKyAzID49IGNhcmV0UG9zaXRpb25zLmxlbmd0aCkge1xuICAgICAgICByb3dDYXJldHMucHVzaCh7XG4gICAgICAgICAgeDogY2FyZXRQb3NpdGlvbnNbaSArIDFdLFxuICAgICAgICAgIHk6IHJvd1ksXG4gICAgICAgICAgaGVpZ2h0OiBjYXJldEhlaWdodCxcbiAgICAgICAgICBjaGFySW5kZXg6IGkgLyAzICsgMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NhcmV0c0J5Um93Q2FjaGUuc2V0KHRleHRSZW5kZXJJbmZvLCBjYXJldHNCeVJvdyk7XG4gIHJldHVybiBjYXJldHNCeVJvd1xufVxuXG5leHBvcnQgeyBHbHlwaHNHZW9tZXRyeSwgVGV4dCwgY29uZmlndXJlVGV4dEJ1aWxkZXIsIGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwsIGR1bXBTREZUZXh0dXJlcywgZ2V0Q2FyZXRBdFBvaW50LCBnZXRTZWxlY3Rpb25SZWN0cywgcHJlbG9hZEZvbnQsIHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUgfTtcbiJdLCJuYW1lcyI6WyJUZXh0dXJlIiwiTGluZWFyRmlsdGVyIiwiQ29sb3IiLCJJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSIsIlNwaGVyZSIsIkJveDMiLCJCYWNrU2lkZSIsIkRvdWJsZVNpZGUiLCJJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUiLCJQbGFuZUdlb21ldHJ5IiwiQnVmZmVyR2VvbWV0cnkiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwiVmVjdG9yMiIsIlZlY3RvcjQiLCJNYXRyaXgzIiwiTWVzaCIsIkZyb250U2lkZSIsIk1lc2hCYXNpY01hdGVyaWFsIiwiTWF0cml4NCIsIlZlY3RvcjMiLCJ0ZXJtaW5hdGVXb3JrZXIiLCJkZWZpbmVXb3JrZXJNb2R1bGUiLCJjcmVhdGVTREZHZW5lcmF0b3IiLCJiaWRpRmFjdG9yeSIsImNyZWF0ZURlcml2ZWRNYXRlcmlhbCIsInZvaWRNYWluUmVnRXhwIiwiY3JlYXRlVHlwZXNldHRlciIsImZvbnRQYXJzZXIiLCJiaWRpIiwiY29uZmlnIiwiZGVmYXVsdEZvbnRVUkwiLCJmb250cyIsIk9iamVjdCIsImNyZWF0ZSIsIklORiIsIkluZmluaXR5IiwiREVGQVVMVF9JR05PUkFCTEVfQ0hBUlMiLCJsaW5lQnJlYWtpbmdXaGl0ZVNwYWNlIiwiQlJFQUtfQUZURVJfQ0hBUlMiLCJSZWdFeHAiLCJkb0xvYWRGb250IiwidXJsIiwiY2FsbGJhY2siLCJ0cnlMb2FkIiwib25FcnJvciIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbmxvYWQiLCJzdGF0dXMiLCJFcnJvciIsInN0YXR1c1RleHQiLCJmb250T2JqIiwicmVzcG9uc2UiLCJlIiwib25lcnJvciIsInNlbmQiLCJsb2FkRm9udCIsImZvbnRVcmwiLCJmb250IiwicGVuZGluZyIsInB1c2giLCJjYWxsYmFja3MiLCJmb3JFYWNoIiwiY2IiLCJ0eXBlc2V0IiwidGV4dCIsInNkZkdseXBoU2l6ZSIsImZvbnRTaXplIiwibGV0dGVyU3BhY2luZyIsImxpbmVIZWlnaHQiLCJtYXhXaWR0aCIsImRpcmVjdGlvbiIsInRleHRBbGlnbiIsInRleHRJbmRlbnQiLCJ3aGl0ZVNwYWNlIiwib3ZlcmZsb3dXcmFwIiwiYW5jaG9yWCIsImFuY2hvclkiLCJpbmNsdWRlQ2FyZXRQb3NpdGlvbnMiLCJjaHVua2VkQm91bmRzU2l6ZSIsImNvbG9yUmFuZ2VzIiwibWV0cmljc09ubHkiLCJtYWluU3RhcnQiLCJub3ciLCJ0aW1pbmdzIiwiZm9udExvYWQiLCJ0eXBlc2V0dGluZyIsImluZGV4T2YiLCJpbmZvIiwicmVwbGFjZSIsImhhc01heFdpZHRoIiwiaXNGaW5pdGUiLCJnbHlwaElkcyIsImdseXBoUG9zaXRpb25zIiwiZ2x5cGhEYXRhIiwiZ2x5cGhDb2xvcnMiLCJjYXJldFBvc2l0aW9ucyIsInZpc2libGVCb3VuZHMiLCJjaHVua2VkQm91bmRzIiwibWF4TGluZVdpZHRoIiwicmVuZGVyYWJsZUdseXBoQ291bnQiLCJjYW5XcmFwIiwiYXNjZW5kZXIiLCJkZXNjZW5kZXIiLCJ1bml0c1BlckVtIiwibGluZUdhcCIsImNhcEhlaWdodCIsInhIZWlnaHQiLCJ0eXBlc2V0U3RhcnQiLCJmb250U2l6ZU11bHQiLCJoYWxmTGVhZGluZyIsInRvcEJhc2VsaW5lIiwiY2FyZXRIZWlnaHQiLCJNYXRoIiwibWluIiwiY2FyZXRCb3R0b21PZmZzZXQiLCJsaW5lWE9mZnNldCIsImN1cnJlbnRMaW5lIiwiVGV4dExpbmUiLCJsaW5lcyIsImZvckVhY2hHbHlwaCIsImdseXBoT2JqIiwiZ2x5cGhYIiwiY2hhckluZGV4IiwiY2hhciIsImNoYXJBdCIsImdseXBoV2lkdGgiLCJhZHZhbmNlV2lkdGgiLCJjdXJMaW5lQ291bnQiLCJjb3VudCIsIm5leHRMaW5lIiwiaXNXaGl0ZXNwYWNlIiwidGVzdCIsImNhbkJyZWFrQWZ0ZXIiLCJpc0VtcHR5IiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsImdseXBoQXQiLCJpIiwic3BsaXRBdCIsImFkanVzdFgiLCJ4IiwiaiIsImlzU29mdFdyYXBwZWQiLCJmbHkiLCJ3aWR0aCIsImxpbmUiLCJhbmNob3JYT2Zmc2V0IiwiYW5jaG9yWU9mZnNldCIsInBhcnNlUGVyY2VudCIsImhlaWdodCIsImxlbmd0aCIsImJpZGlMZXZlbHNSZXN1bHQiLCJnZXRFbWJlZGRpbmdMZXZlbHMiLCJVaW50MTZBcnJheSIsIkZsb2F0MzJBcnJheSIsImxpbmVZT2Zmc2V0IiwiVWludDhBcnJheSIsInJlbmRlcmFibGVHbHlwaEluZGV4IiwicHJldkNoYXJJbmRleCIsImNvbG9yQ2hhckluZGV4IiwiY2h1bmsiLCJjdXJyZW50Q29sb3IiLCJsaW5lSW5kZXgiLCJsaW5lR2x5cGhDb3VudCIsImxpbmVXaWR0aCIsInRyYWlsaW5nV2hpdGVzcGFjZUNvdW50IiwianVzdGlmeUFkanVzdCIsIndoaXRlc3BhY2VDb3VudCIsImp1c3RpZnlPZmZzZXQiLCJnbHlwaEluZm8iLCJmbGlwcyIsImdldFJlb3JkZXJTZWdtZW50cyIsImZpIiwic3RhcnQiLCJlbmQiLCJsZWZ0IiwicmlnaHQiLCJzdGFydEluTGluZSIsImVuZEluTGluZSIsIm1heCIsInNldEdseXBoT2JqIiwiZyIsImdseXBoSWQiLCJpbmRleCIsInJ0bCIsImxldmVscyIsIm1pcnJvcmVkIiwiZ2V0TWlycm9yZWRDaGFyYWN0ZXIiLCJjYXJldExlZnQiLCJjYXJldFJpZ2h0IiwibGlnQ291bnQiLCJmaWxsTGlnYXR1cmVDYXJldFBvc2l0aW9ucyIsImhhc093blByb3BlcnR5IiwiaWR4IiwicGF0aCIsInBhdGhCb3VuZHMiLCJnbHlwaFkiLCJ2aXNYMCIsInZpc1kwIiwidmlzWDEiLCJ2aXNZMSIsInJlY3QiLCJjaHVua1JlY3QiLCJibG9ja0JvdW5kcyIsIm1lYXN1cmUiLCJhcmdzIiwicmVzdWx0IiwieDAiLCJ5MCIsIngxIiwieTEiLCJzdHIiLCJtYXRjaCIsInBjdCIsInBhcnNlRmxvYXQiLCJOYU4iLCJpc05hTiIsImxpZ1N0YXJ0SW5kZXgiLCJsaWdTdGFydFgiLCJsaWdFbmRYIiwibGlnWSIsImd1ZXNzZWRBZHZhbmNlWCIsInN0YXJ0SW5kZXgiLCJzZWxmIiwicGVyZm9ybWFuY2UiLCJEYXRlIiwiZGF0YSIsInRleHRMaW5lUHJvcHMiLCJwcm90b3R5cGUiLCJjZWlsIiwiZmx5d2VpZ2h0IiwibmV3TGluZSIsInNwbGljZSIsInJlZHVjZSIsIm9iaiIsInByb3AiLCJhbGwiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInNldCIsInZhbCIsIm1haW5UaHJlYWRHZW5lcmF0b3IiLCJ3YXJuZWQiLCJnZW5lcmF0ZVNERiIsInZpZXdCb3giLCJkaXN0YW5jZSIsImV4cG9uZW50IiwiY2FudmFzIiwieSIsImNoYW5uZWwiLCJ1c2VXZWJHTCIsImdlbmVyYXRlU0RGX0pTX1dvcmtlciIsImdlbmVyYXRlU0RGX0dMIiwidGhlbiIsIndhcm4iLCJxdWV1ZSIsImNodW5rVGltZUJ1ZGdldCIsInRpbWVyIiwibmV4dENodW5rIiwic2hpZnQiLCJzZXRUaW1lb3V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ3ZWJnbCIsImdlbmVyYXRlSW50b0NhbnZhcyIsInRpbWluZyIsInRocmVhZENvdW50IiwiaWRsZVRpbWVvdXQiLCJ0aHJlYWRzIiwiY2FsbE51bSIsIndvcmtlcklkIiwidGhyZWFkIiwid29ya2VyTW9kdWxlIiwibmFtZSIsImRlcGVuZGVuY2llcyIsImluaXQiLCJfY3JlYXRlU0RGR2VuZXJhdG9yIiwiZ2VuZXJhdGUiLCJqYXZhc2NyaXB0IiwidGV4dHVyZURhdGEiLCJnZXRUcmFuc2ZlcmFibGVzIiwiYnVmZmVyIiwicmVxdWVzdHMiLCJpZGxlVGltZXIiLCJjbGVhclRpbWVvdXQiLCJpbWFnZURhdGEiLCJ3ZWJnbFV0aWxzIiwicmVuZGVySW1hZ2VEYXRhIiwid2FybVVwU0RGQ2FudmFzIiwiX3dhcm0iLCJpc1N1cHBvcnRlZCIsInJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nIiwidHlwckZhY3RvcnkiLCJ3aW5kb3ciLCJyIiwicGFyc2UiLCJ0IiwiX2JpbiIsImEiLCJyZWFkQVNDSUkiLCJuIiwicmVhZFVzaG9ydCIsIm8iLCJyZWFkVWludCIsInMiLCJoIiwiX3JlYWRGb250IiwicmVhZEZpeGVkIiwiX2RhdGEiLCJfb2Zmc2V0IiwiZiIsImQiLCJ1IiwibCIsIm9mZnNldCIsInYiLCJ0cmltIiwiX3RhYk9mZnNldCIsInJlYWRGMmRvdDE0IiwicmVhZFNob3J0IiwicmVhZEludCIsIl92aWV3IiwiZ2V0SW50MzIiLCJyZWFkSW50OCIsImdldEludDgiLCJnZXRJbnQxNiIsImdldFVpbnQxNiIsInJlYWRVc2hvcnRzIiwiZ2V0VWludDMyIiwicmVhZFVpbnQ2NCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJlYWRVbmljb2RlIiwiX3RkZWMiLCJUZXh0RGVjb2RlciIsInJlYWRVVEY4IiwiZGVjb2RlIiwicmVhZEJ5dGVzIiwicmVhZEFTQ0lJQXJyYXkiLCJfZGF0YVZpZXciLCJEYXRhVmlldyIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiX2xjdGYiLCJzY3JpcHRMaXN0IiwicmVhZFNjcmlwdExpc3QiLCJmZWF0dXJlTGlzdCIsInJlYWRGZWF0dXJlTGlzdCIsImxvb2t1cExpc3QiLCJyZWFkTG9va3VwTGlzdCIsInJlYWRMb29rdXBUYWJsZSIsInRhYnMiLCJsdHlwZSIsImZsYWciLCJudW1PZk9uZXMiLCJyZWFkQ2xhc3NEZWYiLCJnZXRJbnRlcnZhbCIsInJlYWRDb3ZlcmFnZSIsImZtdCIsInRhYiIsImNvdmVyYWdlSW5kZXgiLCJyZWFkRmVhdHVyZVRhYmxlIiwidGFnIiwiZmVhdHVyZVBhcmFtcyIsInJlYWRTY3JpcHRUYWJsZSIsImRlZmF1bHQiLCJyZWFkTGFuZ1N5c1RhYmxlIiwicmVxRmVhdHVyZSIsImZlYXR1cmVzIiwiQ0ZGIiwicmVhZEluZGV4IiwicmVhZERpY3QiLCJyZWFkU3VicnMiLCJDaGFyU3RyaW5ncyIsIlJPUyIsIkZEQXJyYXkiLCJjIiwicCIsIl9yZWFkRkRpY3QiLCJGRFNlbGVjdCIsIlUiLCJFbmNvZGluZyIsInJlYWRFbmNvZGluZyIsImNoYXJzZXQiLCJyZWFkQ2hhcnNldCIsIlByaXZhdGUiLCJTdWJycyIsIkJpYXMiLCJ0YWJsZVNFIiwiZ2x5cGhCeVVuaWNvZGUiLCJnbHlwaEJ5U0UiLCJnZXRDaGFyU3RyaW5nIiwic2l6ZSIsInJlYWRDaGFyU3RyaW5nIiwiUyIsImNtYXAiLCJ0YWJsZXMiLCJwYXJzZTAiLCJwYXJzZTQiLCJwYXJzZTYiLCJwYXJzZTEyIiwiZGVidWciLCJmb3JtYXQiLCJtYXAiLCJzZWFyY2hSYW5nZSIsImVudHJ5U2VsZWN0b3IiLCJyYW5nZVNoaWZ0IiwiZW5kQ291bnQiLCJzdGFydENvdW50IiwiaWREZWx0YSIsImlkUmFuZ2VPZmZzZXQiLCJnbHlwaElkQXJyYXkiLCJmaXJzdENvZGUiLCJncm91cHMiLCJnbHlmIiwibWF4cCIsIm51bUdseXBocyIsIl9wYXJzZUdseWYiLCJsb2NhIiwibm9jIiwiZW5kUHRzIiwiaW5zdHJ1Y3Rpb25zIiwiZmxhZ3MiLCJ4cyIsInlzIiwicGFydHMiLCJtIiwiYiIsInR4IiwidHkiLCJwMSIsInAyIiwiZ2x5cGhJbmRleCIsImluc3RyIiwiR1BPUyIsInN1YnQiLCJjb3ZlcmFnZSIsInBvcyIsInJlYWRWYWx1ZVJlY29yZCIsInBhaXJzZXRzIiwiUCIsImdpZDIiLCJ2YWwxIiwidmFsMiIsIkYiLCJfIiwiY2xhc3NEZWYxIiwiY2xhc3NEZWYyIiwibWF0cml4IiwiQyIsIkkiLCJ3IiwiR1NVQiIsImRlbHRhIiwibmV3ZyIsInZhbHMiLCJyZWFkTGlnYXR1cmVTZXQiLCJjRGVmIiwic2NzZXQiLCJyZWFkU3ViQ2xhc3NTZXQiLCJiYWNrQ3ZnIiwiaW5wdEN2ZyIsImFoZWRDdmciLCJsb29rdXBSZWMiLCJyZWFkU3Vic3RMb29rdXBSZWNvcmRzIiwicmVhZFN1YkNsYXNzUnVsZSIsImlucHV0Iiwic3Vic3RMb29rdXBSZWNvcmRzIiwicmVhZENoYWluU3ViQ2xhc3NTZXQiLCJyZWFkQ2hhaW5TdWJDbGFzc1J1bGUiLCJzdWJzdCIsInJlYWRMaWdhdHVyZSIsImNoYWluIiwibmdseXBoIiwiaGVhZCIsImZvbnRSZXZpc2lvbiIsImNyZWF0ZWQiLCJtb2RpZmllZCIsIm1hY1N0eWxlIiwibG93ZXN0UmVjUFBFTSIsImZvbnREaXJlY3Rpb25IaW50IiwiaW5kZXhUb0xvY0Zvcm1hdCIsImdseXBoRGF0YUZvcm1hdCIsImhoZWEiLCJhZHZhbmNlV2lkdGhNYXgiLCJtaW5MZWZ0U2lkZUJlYXJpbmciLCJtaW5SaWdodFNpZGVCZWFyaW5nIiwieE1heEV4dGVudCIsImNhcmV0U2xvcGVSaXNlIiwiY2FyZXRTbG9wZVJ1biIsImNhcmV0T2Zmc2V0IiwibWV0cmljRGF0YUZvcm1hdCIsIm51bWJlck9mSE1ldHJpY3MiLCJobXR4IiwiYVdpZHRoIiwibHNCZWFyaW5nIiwia2VybiIsInBhcnNlVjEiLCJnbHlwaDEiLCJydmFsIiwicmVhZEZvcm1hdDAiLCJnbHlwaDIiLCJtYXhQb2ludHMiLCJtYXhDb250b3VycyIsIm1heENvbXBvc2l0ZVBvaW50cyIsIm1heENvbXBvc2l0ZUNvbnRvdXJzIiwibWF4Wm9uZXMiLCJtYXhUd2lsaWdodFBvaW50cyIsIm1heFN0b3JhZ2UiLCJtYXhGdW5jdGlvbkRlZnMiLCJtYXhJbnN0cnVjdGlvbkRlZnMiLCJtYXhTdGFja0VsZW1lbnRzIiwibWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zIiwibWF4Q29tcG9uZW50RWxlbWVudHMiLCJtYXhDb21wb25lbnREZXB0aCIsInRvU3RyaW5nIiwiX2xhbmciLCJwb3N0U2NyaXB0TmFtZSIsInZlcnNpb24wIiwidmVyc2lvbjEiLCJ2ZXJzaW9uMiIsInZlcnNpb241IiwieEF2Z0NoYXJXaWR0aCIsInVzV2VpZ2h0Q2xhc3MiLCJ1c1dpZHRoQ2xhc3MiLCJmc1R5cGUiLCJ5U3Vic2NyaXB0WFNpemUiLCJ5U3Vic2NyaXB0WVNpemUiLCJ5U3Vic2NyaXB0WE9mZnNldCIsInlTdWJzY3JpcHRZT2Zmc2V0IiwieVN1cGVyc2NyaXB0WFNpemUiLCJ5U3VwZXJzY3JpcHRZU2l6ZSIsInlTdXBlcnNjcmlwdFhPZmZzZXQiLCJ5U3VwZXJzY3JpcHRZT2Zmc2V0IiwieVN0cmlrZW91dFNpemUiLCJ5U3RyaWtlb3V0UG9zaXRpb24iLCJzRmFtaWx5Q2xhc3MiLCJwYW5vc2UiLCJ1bFVuaWNvZGVSYW5nZTEiLCJ1bFVuaWNvZGVSYW5nZTIiLCJ1bFVuaWNvZGVSYW5nZTMiLCJ1bFVuaWNvZGVSYW5nZTQiLCJhY2hWZW5kSUQiLCJmc1NlbGVjdGlvbiIsInVzRmlyc3RDaGFySW5kZXgiLCJ1c0xhc3RDaGFySW5kZXgiLCJzVHlwb0FzY2VuZGVyIiwic1R5cG9EZXNjZW5kZXIiLCJzVHlwb0xpbmVHYXAiLCJ1c1dpbkFzY2VudCIsInVzV2luRGVzY2VudCIsInVsQ29kZVBhZ2VSYW5nZTEiLCJ1bENvZGVQYWdlUmFuZ2UyIiwic3hIZWlnaHQiLCJzQ2FwSGVpZ2h0IiwidXNEZWZhdWx0IiwidXNCcmVhayIsInVzTWF4Q29udGV4dCIsInVzTG93ZXJPcHRpY2FsUG9pbnRTaXplIiwidXNVcHBlck9wdGljYWxQb2ludFNpemUiLCJwb3N0IiwidmVyc2lvbiIsIml0YWxpY0FuZ2xlIiwidW5kZXJsaW5lUG9zaXRpb24iLCJ1bmRlcmxpbmVUaGlja25lc3MiLCJjb2RlVG9HbHlwaCIsInAwZTQiLCJwM2UxIiwicDFlMCIsInAwZTMiLCJnbHlwaFRvUGF0aCIsImNtZHMiLCJjcmRzIiwiU1ZHIiwiZW50cmllcyIsInRvUGF0aCIsInN0YWNrIiwiblN0ZW1zIiwiaGF2ZVdpZHRoIiwiZGVmYXVsdFdpZHRoWCIsIl9kcmF3Q0ZGIiwiX2RyYXdHbHlmIiwiX3NpbXBsZUdseXBoIiwiX2NvbXBvR2x5cGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJxY3VydmVUbyIsImNsb3NlUGF0aCIsIl9nZXRHbHlwaENsYXNzIiwiZ2V0UGFpckFkanVzdG1lbnQiLCJfYXBwbHlTdWJzIiwiX2dsc0NvdmVyZWQiLCJnbHlwaHNUb1BhdGgiLCJjdXJ2ZVRvIiwibm9taW5hbFdpZHRoWCIsInBvcCIsIk8iLCJUIiwiYWJzIiwiayIsIkciLCJEIiwiQiIsIkwiLCJSIiwiQSIsIlciLCJNIiwiViIsIk4iLCJUeXByIiwidmFsdWUiLCJ3b2ZmMm90ZkZhY3RvcnkiLCJVaW50MzJBcnJheSIsImNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIkUiLCJzdWJhcnJheSIsInoiLCJxIiwiSCIsIkoiLCJLIiwiUSIsIlgiLCJZIiwiWiIsIiQiLCJyciIsImVyIiwibnIiLCJ0ciIsInN0cmVhbSIsImNvbnZlcnRfc3RyZWFtcyIsInNldFVpbnQxNiIsInNldFVpbnQzMiIsInNpZ25hdHVyZSIsImZsYXZvciIsIm51bVRhYmxlcyIsInJlc2VydmVkIiwidG90YWxTZm50U2l6ZSIsIm1ham9yVmVyc2lvbiIsIm1pbm9yVmVyc2lvbiIsIm1ldGFPZmZzZXQiLCJtZXRhTGVuZ3RoIiwibWV0YU9yaWdMZW5ndGgiLCJwcml2T2Zmc2V0IiwicHJpdkxlbmd0aCIsInBvdyIsImNvbXBMZW5ndGgiLCJvcmlnTGVuZ3RoIiwib3JpZ0NoZWNrc3VtIiwib3V0T2Zmc2V0Iiwic2xpY2UiLCJwYXJzZXJGYWN0b3J5Iiwid29mZjJvdGYiLCJjbWRBcmdMZW5ndGhzIiwiam9pbmluZ1R5cGVSYXdEYXRhIiwiSlRfTEVGVCIsIkpUX1JJR0hUIiwiSlRfRFVBTCIsIkpUX1RSQU5TUEFSRU5UIiwiSlRfSk9JTl9DQVVTSU5HIiwiSlRfTk9OX0pPSU5JTkciLCJqb2luaW5nVHlwZU1hcCIsImdldENoYXJKb2luaW5nVHlwZSIsImNoIiwiTWFwIiwidHlwZSIsImxhc3RDb2RlIiwic3BsaXQiLCJyYW5nZSIsInNraXAiLCJzdGVwIiwicGFyc2VJbnQiLCJJU09MIiwiSU5JVCIsIkZJTkEiLCJNRURJIiwiZm9ybXNUb0ZlYXR1cmVzIiwiZGV0ZWN0Sm9pbmluZ0Zvcm1zIiwiam9pbmluZ0Zvcm1zIiwicHJldkpvaW5pbmdUeXBlIiwicHJldkZvcm0iLCJwcmV2SW5kZXgiLCJjb2RlUG9pbnRBdCIsImpvaW5pbmdUeXBlIiwiZm9ybSIsInN0cmluZ1RvR2x5cGhzIiwiY2MiLCJnc3ViIiwic3VwcG9ydGVkRmVhdHVyZXMiLCJ1c2VkTG9va3VwcyIsImZlYXR1cmUiLCJ0aSIsImlzSm9pbmluZ0ZlYXR1cmUiLCJjaSIsImZpcnN0TnVtIiwid3JhcEZvbnRPYmoiLCJ0eXByRm9udCIsImdseXBoTWFwIiwib3MyIiwiZm9udFNjYWxlIiwiZ2x5cGhJbmRpY2VzIiwicHJldkdseXBoSW5kZXgiLCJjcmRzSWR4IiwibGVuIiwibnVtQXJncyIsInBhdGhDb21tYW5kQ291bnQiLCJjYWxsIiwicGVlayIsIkNPTkZJRyIsInNkZk1hcmdpbiIsInNkZkV4cG9uZW50IiwidGV4dHVyZVdpZHRoIiwidGVtcENvbG9yIiwiaGFzUmVxdWVzdGVkIiwibm93JDEiLCJjb25maWd1cmVUZXh0QnVpbGRlciIsImFzc2lnbiIsImF0bGFzZXMiLCJnZXRUZXh0UmVuZGVySW5mbyIsInRvdGFsU3RhcnQiLCJ0b0Fic29sdXRlVVJMIiwiY29sb3JzIiwia2V5IiwiZ2V0SGV4IiwiZnJlZXplIiwiZ2x5cGhzUGVyUm93IiwiYXRsYXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJnbHlwaENvdW50Iiwic2RmQ2FudmFzIiwic2RmVGV4dHVyZSIsInVuZGVmaW5lZCIsImNvbnRleHRMb3N0IiwiZ2x5cGhzQnlGb250IiwiZ2VuZXJhdGVNaXBtYXBzIiwiaW5pdENvbnRleHRMb3NzSGFuZGxpbmciLCJmb250R2x5cGhzIiwidHlwZXNldEluV29ya2VyIiwibmVlZGVkU0RGcyIsImdseXBoQm91bmRzIiwiYm91bmRzSWR4IiwicG9zaXRpb25zSWR4IiwicXVhZHNTdGFydCIsImZvbnRVbml0c01hcmdpbiIsImF0bGFzSW5kZXgiLCJzZGZWaWV3Qm94IiwicG9zWCIsInBvc1kiLCJxdWFkcyIsInNkZlN0YXJ0Iiwic2RmIiwiY3VycmVudEhlaWdodCIsIm5lZWRlZFJvd3MiLCJuZWVkZWRIZWlnaHQiLCJsb2cyIiwiZGlzcG9zZSIsImdlbmVyYXRlR2x5cGhTREYiLCJncHVBY2NlbGVyYXRlU0RGIiwic2FmYXJpUHJlMTVXb3JrYXJvdW5kIiwibmVlZHNVcGRhdGUiLCJzZGZUb3RhbCIsInRvdGFsIiwicGFyYW1ldGVycyIsImdseXBoQXRsYXNJbmRpY2VzIiwidXNlR1BVIiwibWF4RGlzdCIsInNxdWFyZUluZGV4IiwiZmxvb3IiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJsb2ciLCJwcmV2ZW50RGVmYXVsdCIsInByb21pc2VzIiwiZ2x5cGgiLCJwcmVsb2FkRm9udCIsImNoYXJhY3RlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwidG9PYmoiLCJmcm9tT2JqIiwibGlua0VsIiwiaHJlZiIsImNyZWF0ZUltYWdlQml0bWFwIiwiZ2wiLCJnZXRDb250ZXh0IiwicGl4ZWxzIiwiaW1hZ2UiLCJmbGlwWSIsImlzRGF0YVRleHR1cmUiLCJyZWFkUGl4ZWxzIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJ0eXBlc2V0dGVyV29ya2VyTW9kdWxlIiwidHlwZXNldHRlciIsInRyYW5zZmVyYWJsZXMiLCJkdW1wU0RGVGV4dHVyZXMiLCJrZXlzIiwidG9EYXRhVVJMIiwidGVtcGxhdGVHZW9tZXRyaWVzIiwiZ2V0VGVtcGxhdGVHZW9tZXRyeSIsImRldGFpbCIsImdlb20iLCJmcm9udCIsImJhY2siLCJjbG9uZSIsImZyb250QXR0cnMiLCJhdHRyaWJ1dGVzIiwiYmFja0F0dHJzIiwiY29tYmluZWQiLCJ2ZXJ0Q291bnQiLCJ1diIsInBvc2l0aW9uIiwiYXJyYXkiLCJub3JtYWwiLCJzZXRBdHRyaWJ1dGUiLCJpdGVtU2l6ZSIsInNldEluZGV4IiwidHJhbnNsYXRlIiwiZ2x5cGhCb3VuZHNBdHRyTmFtZSIsImdseXBoSW5kZXhBdHRyTmFtZSIsImdseXBoQ29sb3JBdHRyTmFtZSIsIkdseXBoc0dlb21ldHJ5IiwiY29uc3RydWN0b3IiLCJjdXJ2ZVJhZGl1cyIsIm1hdGVyaWFsSW5kZXgiLCJib3VuZGluZ1NwaGVyZSIsImJvdW5kaW5nQm94IiwiY29tcHV0ZUJvdW5kaW5nU3BoZXJlIiwiY29tcHV0ZUJvdW5kaW5nQm94Iiwic2V0U2lkZSIsInNpZGUiLCJ2ZXJ0cyIsImdldEluZGV4Iiwic2V0RHJhd1JhbmdlIiwiX2RldGFpbCIsInRwbCIsImF0dHIiLCJfY3VydmVSYWRpdXMiLCJfdXBkYXRlQm91bmRzIiwidXBkYXRlR2x5cGhzIiwidXBkYXRlQnVmZmVyQXR0ciIsIl9ibG9ja0JvdW5kcyIsIl9jaHVua2VkQm91bmRzIiwiaW5zdGFuY2VDb3VudCIsImJvdW5kcyIsImJib3giLCJQSSIsInNpbiIsImNvcyIsImhhbGZQaSIsInR3b1BpIiwiYWJzUiIsImxlZnRBbmdsZSIsInJpZ2h0QW5nbGUiLCJtaW5YIiwibWF4WCIsIm1heFoiLCJnZXRCb3VuZGluZ1NwaGVyZSIsImFwcGx5Q2xpcFJlY3QiLCJjbGlwUmVjdCIsImdldEF0dHJpYnV0ZSIsImNodW5rcyIsImF0dHJOYW1lIiwibmV3QXJyYXkiLCJfbWF4SW5zdGFuY2VDb3VudCIsImRlbGV0ZUF0dHJpYnV0ZSIsIlZFUlRFWF9ERUZTIiwiVkVSVEVYX1RSQU5TRk9STSIsIkZSQUdNRU5UX0RFRlMiLCJGUkFHTUVOVF9UUkFOU0ZPUk0iLCJjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsIiwiYmFzZU1hdGVyaWFsIiwidGV4dE1hdGVyaWFsIiwiY2hhaW5lZCIsImV4dGVuc2lvbnMiLCJkZXJpdmF0aXZlcyIsInVuaWZvcm1zIiwidVRyb2lrYVNERlRleHR1cmUiLCJ1VHJvaWthU0RGVGV4dHVyZVNpemUiLCJ1VHJvaWthU0RGR2x5cGhTaXplIiwidVRyb2lrYVNERkV4cG9uZW50IiwidVRyb2lrYVRvdGFsQm91bmRzIiwidVRyb2lrYUNsaXBSZWN0IiwidVRyb2lrYURpc3RhbmNlT2Zmc2V0IiwidVRyb2lrYU91dGxpbmVPcGFjaXR5IiwidVRyb2lrYUZpbGxPcGFjaXR5IiwidVRyb2lrYVBvc2l0aW9uT2Zmc2V0IiwidVRyb2lrYUN1cnZlUmFkaXVzIiwidVRyb2lrYUJsdXJSYWRpdXMiLCJ1VHJvaWthU3Ryb2tlV2lkdGgiLCJ1VHJvaWthU3Ryb2tlQ29sb3IiLCJ1VHJvaWthU3Ryb2tlT3BhY2l0eSIsInVUcm9pa2FPcmllbnQiLCJ1VHJvaWthVXNlR2x5cGhDb2xvcnMiLCJ1VHJvaWthU0RGRGVidWciLCJ2ZXJ0ZXhEZWZzIiwidmVydGV4VHJhbnNmb3JtIiwiZnJhZ21lbnREZWZzIiwiZnJhZ21lbnRDb2xvclRyYW5zZm9ybSIsImN1c3RvbVJld3JpdGVyIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJ1RGlmZnVzZVJFIiwidHJhbnNwYXJlbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiaXNUcm9pa2FUZXh0TWF0ZXJpYWwiLCJzaGFkb3dTaWRlIiwiZGVmYXVsdE1hdGVyaWFsIiwiY29sb3IiLCJkZWZhdWx0U3Ryb2tlQ29sb3IiLCJ0ZW1wTWF0NCIsInRlbXBWZWMzYSIsInRlbXBWZWMzYiIsInRlbXBBcnJheSIsIm9yaWdpbiIsImRlZmF1bHRPcmllbnQiLCJmaXJzdCIsImdldEZsYXRSYXljYXN0TWVzaCIsIm1lc2giLCJnZXRDdXJ2ZWRSYXljYXN0TWVzaCIsInN5bmNTdGFydEV2ZW50Iiwic3luY0NvbXBsZXRlRXZlbnQiLCJTWU5DQUJMRV9QUk9QUyIsIkNPUFlBQkxFX1BST1BTIiwiY29uY2F0IiwiVGV4dCIsImdlb21ldHJ5IiwibWF0ZXJpYWwiLCJvdXRsaW5lV2lkdGgiLCJvdXRsaW5lQ29sb3IiLCJvdXRsaW5lT3BhY2l0eSIsIm91dGxpbmVCbHVyIiwib3V0bGluZU9mZnNldFgiLCJvdXRsaW5lT2Zmc2V0WSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VPcGFjaXR5IiwiZmlsbE9wYWNpdHkiLCJkZXB0aE9mZnNldCIsIm9yaWVudGF0aW9uIiwiZ2x5cGhHZW9tZXRyeURldGFpbCIsImRlYnVnU0RGIiwic3luYyIsIl9uZWVkc1N5bmMiLCJfaXNTeW5jaW5nIiwiX3F1ZXVlZFN5bmNzIiwiZGlzcGF0Y2hFdmVudCIsInRleHRSZW5kZXJJbmZvIiwiX3RleHRSZW5kZXJJbmZvIiwicXVldWVkIiwiZm4iLCJvbkJlZm9yZVJlbmRlciIsInJlbmRlcmVyIiwic2NlbmUiLCJjYW1lcmEiLCJncm91cCIsIl9wcmVwYXJlRm9yUmVuZGVyIiwiX2hhZE93blNpZGUiLCJfYWN0dWFsU2lkZSIsIm9uQWZ0ZXJSZW5kZXIiLCJkZXJpdmVkTWF0ZXJpYWwiLCJfZGVyaXZlZE1hdGVyaWFsIiwiX2Jhc2VNYXRlcmlhbCIsIl9kZWZhdWx0TWF0ZXJpYWwiLCJvbkRpc3Bvc2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib3V0bGluZU1hdGVyaWFsIiwiX291dGxpbmVNdGwiLCJpZCIsImlzVGV4dE91dGxpbmVNYXRlcmlhbCIsImRlcHRoV3JpdGUiLCJjdXN0b21EZXB0aE1hdGVyaWFsIiwiZ2V0RGVwdGhNYXRlcmlhbCIsImN1c3RvbURpc3RhbmNlTWF0ZXJpYWwiLCJnZXREaXN0YW5jZU1hdGVyaWFsIiwiaXNPdXRsaW5lIiwidGV4dEluZm8iLCJmcm9tQXJyYXkiLCJkaXN0YW5jZU9mZnNldCIsImJsdXJSYWRpdXMiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIl9wYXJzZVBlcmNlbnQiLCJwYWQiLCJwb2x5Z29uT2Zmc2V0IiwicG9seWdvbk9mZnNldEZhY3RvciIsInBvbHlnb25PZmZzZXRVbml0cyIsImNvbG9yT2JqIiwiX2lucHV0Iiwib3JpZW50IiwiX29yaWVudGF0aW9uIiwicm90TWF0IiwiaFNpZ24iLCJoQXhpcyIsInZTaWduIiwidkF4aXMiLCJsb29rQXQiLCJjcm9zcyIsInNldEZyb21NYXRyaXg0IiwiaWRlbnRpdHkiLCJsb2NhbFBvc2l0aW9uVG9UZXh0Q29vcmRzIiwidGFyZ2V0IiwiY29weSIsImF0YW4yIiwid29ybGRQb3NpdGlvblRvVGV4dENvb3JkcyIsIndvcmxkVG9Mb2NhbCIsInJheWNhc3QiLCJyYXljYXN0ZXIiLCJpbnRlcnNlY3RzIiwicmF5Y2FzdE1lc2giLCJnZXRYIiwiZ2V0WSIsInNldFhZWiIsIm1hdHJpeFdvcmxkIiwib2JqZWN0Iiwic291cmNlIiwicHJpdmF0ZUtleSIsImdldENhcmV0QXRQb2ludCIsImNsb3Nlc3RDYXJldCIsImNhcmV0c0J5Um93IiwiZ3JvdXBDYXJldHNCeVJvdyIsImNsb3Nlc3RSb3dZIiwiY2FyZXRzIiwicm93WSIsImNhcmV0IiwiX3JlY3RzQ2FjaGUiLCJXZWFrTWFwIiwiZ2V0U2VsZWN0aW9uUmVjdHMiLCJyZWN0cyIsInByZXZSZXN1bHQiLCJjdXJyZW50UmVjdCIsIngyIiwiYm90dG9tIiwidG9wIiwic29ydCIsInJlY3RBIiwicmVjdEIiLCJfY2FyZXRzQnlSb3dDYWNoZSIsInJvd0NhcmV0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-text/dist/troika-three-text.esm.js\n");

/***/ })

};
;