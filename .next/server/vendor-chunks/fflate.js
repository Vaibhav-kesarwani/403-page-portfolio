"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fflate";
exports.ids = ["vendor-chunks/fflate"];
exports.modules = {

/***/ "(ssr)/./node_modules/fflate/esm/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/fflate/esm/index.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCompress: () => (/* binding */ AsyncGzip),\n/* harmony export */   AsyncDecompress: () => (/* binding */ AsyncDecompress),\n/* harmony export */   AsyncDeflate: () => (/* binding */ AsyncDeflate),\n/* harmony export */   AsyncGunzip: () => (/* binding */ AsyncGunzip),\n/* harmony export */   AsyncGzip: () => (/* binding */ AsyncGzip),\n/* harmony export */   AsyncInflate: () => (/* binding */ AsyncInflate),\n/* harmony export */   AsyncUnzipInflate: () => (/* binding */ AsyncUnzipInflate),\n/* harmony export */   AsyncUnzlib: () => (/* binding */ AsyncUnzlib),\n/* harmony export */   AsyncZipDeflate: () => (/* binding */ AsyncZipDeflate),\n/* harmony export */   AsyncZlib: () => (/* binding */ AsyncZlib),\n/* harmony export */   Compress: () => (/* binding */ Gzip),\n/* harmony export */   DecodeUTF8: () => (/* binding */ DecodeUTF8),\n/* harmony export */   Decompress: () => (/* binding */ Decompress),\n/* harmony export */   Deflate: () => (/* binding */ Deflate),\n/* harmony export */   EncodeUTF8: () => (/* binding */ EncodeUTF8),\n/* harmony export */   Gunzip: () => (/* binding */ Gunzip),\n/* harmony export */   Gzip: () => (/* binding */ Gzip),\n/* harmony export */   Inflate: () => (/* binding */ Inflate),\n/* harmony export */   Unzip: () => (/* binding */ Unzip),\n/* harmony export */   UnzipInflate: () => (/* binding */ UnzipInflate),\n/* harmony export */   UnzipPassThrough: () => (/* binding */ UnzipPassThrough),\n/* harmony export */   Unzlib: () => (/* binding */ Unzlib),\n/* harmony export */   Zip: () => (/* binding */ Zip),\n/* harmony export */   ZipDeflate: () => (/* binding */ ZipDeflate),\n/* harmony export */   ZipPassThrough: () => (/* binding */ ZipPassThrough),\n/* harmony export */   Zlib: () => (/* binding */ Zlib),\n/* harmony export */   compress: () => (/* binding */ gzip),\n/* harmony export */   compressSync: () => (/* binding */ gzipSync),\n/* harmony export */   decompress: () => (/* binding */ decompress),\n/* harmony export */   decompressSync: () => (/* binding */ decompressSync),\n/* harmony export */   deflate: () => (/* binding */ deflate),\n/* harmony export */   deflateSync: () => (/* binding */ deflateSync),\n/* harmony export */   gunzip: () => (/* binding */ gunzip),\n/* harmony export */   gunzipSync: () => (/* binding */ gunzipSync),\n/* harmony export */   gzip: () => (/* binding */ gzip),\n/* harmony export */   gzipSync: () => (/* binding */ gzipSync),\n/* harmony export */   inflate: () => (/* binding */ inflate),\n/* harmony export */   inflateSync: () => (/* binding */ inflateSync),\n/* harmony export */   strFromU8: () => (/* binding */ strFromU8),\n/* harmony export */   strToU8: () => (/* binding */ strToU8),\n/* harmony export */   unzip: () => (/* binding */ unzip),\n/* harmony export */   unzipSync: () => (/* binding */ unzipSync),\n/* harmony export */   unzlib: () => (/* binding */ unzlib),\n/* harmony export */   unzlibSync: () => (/* binding */ unzlibSync),\n/* harmony export */   zip: () => (/* binding */ zip),\n/* harmony export */   zipSync: () => (/* binding */ zipSync),\n/* harmony export */   zlib: () => (/* binding */ zlib),\n/* harmony export */   zlibSync: () => (/* binding */ zlibSync)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n\nvar require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"/\");\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\n// Mediocre shim\nvar Worker;\nvar workerAdd = \";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global\";\ntry {\n    Worker = require(\"worker_threads\").Worker;\n} catch (e) {}\nvar wk = Worker ? function(c, _, msg, transfer, cb) {\n    var done = false;\n    var w = new Worker(c + workerAdd, {\n        eval: true\n    }).on(\"error\", function(e) {\n        return cb(e, null);\n    }).on(\"message\", function(m) {\n        return cb(null, m);\n    }).on(\"exit\", function(c) {\n        if (c && !done) cb(new Error(\"exited with code \" + c), null);\n    });\n    w.postMessage(msg, transfer);\n    w.terminate = function() {\n        done = true;\n        return Worker.prototype.terminate.call(w);\n    };\n    return w;\n} : function(_, __, ___, ____, cb) {\n    setImmediate(function() {\n        return cb(new Error(\"async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)\"), null);\n    });\n    var NOP = function() {};\n    return {\n        terminate: NOP,\n        postMessage: NOP\n    };\n};\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */ 0,\n    0,\n    /* impossible */ 0\n]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */ 0,\n    0\n]);\n// code length index map\nvar clim = new u8([\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n]);\n// get base, reverse index map from extra bits\nvar freb = function(eb, start) {\n    var b = new u16(31);\n    for(var i = 0; i < 31; ++i){\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for(var i = 1; i < 30; ++i){\n        for(var j = b[i]; j < b[i + 1]; ++j){\n            r[j] = j - b[i] << 5 | i;\n        }\n    }\n    return [\n        b,\n        r\n    ];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor(var i = 0; i < 32768; ++i){\n    // reverse table algorithm from SO\n    var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n    rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = function(cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for(; i < s; ++i)++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for(i = 0; i < mb; ++i){\n        le[i] = le[i - 1] + l[i - 1] << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for(i = 0; i < s; ++i){\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = i << 4 | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for(var m = v | (1 << r_1) - 1; v <= m; ++v){\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    } else {\n        co = new u16(s);\n        for(i = 0; i < s; ++i){\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n            }\n        }\n    }\n    return co;\n};\n// fixed length tree\nvar flt = new u8(288);\nfor(var i = 0; i < 144; ++i)flt[i] = 8;\nfor(var i = 144; i < 256; ++i)flt[i] = 9;\nfor(var i = 256; i < 280; ++i)flt[i] = 7;\nfor(var i = 280; i < 288; ++i)flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor(var i = 0; i < 32; ++i)fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function(a) {\n    var m = a[0];\n    for(var i = 1; i < a.length; ++i){\n        if (a[i] > m) m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\n// get end of byte\nvar shft = function(p) {\n    return (p / 8 | 0) + (p & 7 && 1);\n};\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function(v, s, e) {\n    if (s == null || s < 0) s = 0;\n    if (e == null || e > v.length) e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function(dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || st && !st.l && sl < 5) return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st) st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf) buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function(l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n                if (t > sl) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                // ensure size\n                if (noBuf) cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for(var i = 0; i < hcLen; ++i){\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for(var i = 0; i < tl;){\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    } else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n                        while(n--)ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            } else throw \"invalid block type\";\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf) cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for(;; lpos = pos){\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n            if (!c) throw \"invalid length/literal\";\n            if (sym < 256) buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            } else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d) throw \"invalid distance\";\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                if (noBuf) cbuf(bt + 131072);\n                var end = bt + add;\n                for(; bt < end; bt += 4){\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    }while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function(d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for(var i = 0; i < d.length; ++i){\n        if (d[i]) t.push({\n            s: i,\n            f: d[i]\n        });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s) return [\n        et,\n        0\n    ];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [\n            v,\n            1\n        ];\n    }\n    t.sort(function(a, b) {\n        return a.f - b.f;\n    });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({\n        s: -1,\n        f: 25001\n    });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = {\n        s: -1,\n        f: l.f + r.f,\n        l: l,\n        r: r\n    };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while(i1 != s - 1){\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = {\n            s: -1,\n            f: l.f + r.f,\n            l: l,\n            r: r\n        };\n    }\n    var maxSym = t2[0].s;\n    for(var i = 1; i < s; ++i){\n        if (t2[i].s > maxSym) maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function(a, b) {\n            return tr[b.s] - tr[a.s] || a.f - b.f;\n        });\n        for(; i < s; ++i){\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << mbt - tr[i2_1]);\n                tr[i2_1] = mb;\n            } else break;\n        }\n        dt >>>= lft;\n        while(dt > 0){\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;\n            else ++i;\n        }\n        for(; i >= 0 && dt; --i){\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [\n        new u8(tr),\n        mbt\n    ];\n};\n// get the max length and assign length codes\nvar ln = function(n, l, d) {\n    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;\n};\n// length codes generation\nvar lc = function(c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while(s && !c[--s]);\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function(v) {\n        cl[cli++] = v;\n    };\n    for(var i = 1; i <= s; ++i){\n        if (c[i] == cln && i != s) ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for(; cls > 138; cls -= 138)w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n                    cls = 0;\n                }\n            } else if (cls > 3) {\n                w(cln), --cls;\n                for(; cls > 6; cls -= 6)w(8304);\n                if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n            }\n            while(cls--)w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [\n        cl.subarray(0, cli),\n        s\n    ];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function(cf, cl) {\n    var l = 0;\n    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function(out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for(var i = 0; i < lclt.length; ++i)lcfreq[lclt[i] & 31]++;\n    for(var i = 0; i < lcdt.length; ++i)lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n    var flen = bl + 5 << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [\n            lclt,\n            lcdt\n        ];\n        for(var it = 0; it < 2; ++it){\n            var clct = lcts[it];\n            for(var i = 0; i < clct.length; ++i){\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;\n            }\n        }\n    } else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for(var i = 0; i < li; ++i){\n        if (syms[i] > 255) {\n            var len = syms[i] >>> 18 & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];\n        } else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([\n    65540,\n    131080,\n    131088,\n    131104,\n    262176,\n    1048704,\n    1048832,\n    2114560,\n    2117632\n]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function(dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for(var i = 0; i <= s; i += 65535){\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            } else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    } else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function(i) {\n            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;\n        };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for(; i < s; ++i){\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for(var j = 0; j < 286; ++j)lf[j] = 0;\n                    for(var j = 0; j < 30; ++j)df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while(dif <= maxd && --ch_1 && imod != pimod){\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn) break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for(var j = 0; j < mmd; ++j){\n                                    var ti = i - dif + j + 32768 & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti + 32768 & 32767;\n                                    if (cd > md) md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod + 32768 & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                } else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ function() {\n    var t = new Int32Array(256);\n    for(var i = 0; i < 256; ++i){\n        var c = i, k = 9;\n        while(--k)c = (c & 1 && -306674912) ^ c >>> 1;\n        t[i] = c;\n    }\n    return t;\n}();\n// CRC32\nvar crc = function() {\n    var c = -1;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var cr = c;\n            for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;\n            c = cr;\n        },\n        d: function() {\n            return ~c;\n        }\n    };\n};\n// Alder32\nvar adler = function() {\n    var a = 1, b = 0;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for(var i = 0; i != l;){\n                var e = Math.min(i + 2655, l);\n                for(; i < e; ++i)m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function() {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function(dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function(a, b) {\n    var o = {};\n    for(var k in a)o[k] = a[k];\n    for(var k in b)o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function(fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/ /g, \"\").split(\",\");\n    for(var i = 0; i < dt.length; ++i){\n        var v = dt[i], k = ks[i];\n        if (typeof v == \"function\") {\n            fnStr += \";\" + k + \"=\";\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf(\"[native code]\") != -1) {\n                    var spInd = st_1.indexOf(\" \", 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\n                } else {\n                    fnStr += st_1;\n                    for(var t in v.prototype)fnStr += \";\" + k + \".prototype.\" + t + \"=\" + v.prototype[t].toString();\n                }\n            } else fnStr += st_1;\n        } else td[k] = v;\n    }\n    return [\n        fnStr,\n        td\n    ];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function(v) {\n    var tl = [];\n    for(var k in v){\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32) tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function(fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = \"\", td_1 = {}, m = fns.length - 1;\n        for(var i = 0; i < m; ++i)_a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + \";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function() {\n    return [\n        u8,\n        u16,\n        u32,\n        fleb,\n        fdeb,\n        clim,\n        fl,\n        fd,\n        flrm,\n        fdrm,\n        rev,\n        hMap,\n        max,\n        bits,\n        bits16,\n        shft,\n        slc,\n        inflt,\n        inflateSync,\n        pbf,\n        gu8\n    ];\n};\nvar bDflt = function() {\n    return [\n        u8,\n        u16,\n        u32,\n        fleb,\n        fdeb,\n        clim,\n        revfl,\n        revfd,\n        flm,\n        flt,\n        fdm,\n        fdt,\n        rev,\n        deo,\n        et,\n        hMap,\n        wbits,\n        wbits16,\n        hTree,\n        ln,\n        lc,\n        clen,\n        wfblk,\n        wblk,\n        shft,\n        slc,\n        dflt,\n        dopt,\n        deflateSync,\n        pbf\n    ];\n};\n// gzip extra\nvar gze = function() {\n    return [\n        gzh,\n        gzhl,\n        wbytes,\n        crc,\n        crct\n    ];\n};\n// gunzip extra\nvar guze = function() {\n    return [\n        gzs,\n        gzl\n    ];\n};\n// zlib extra\nvar zle = function() {\n    return [\n        zlh,\n        wbytes,\n        adler\n    ];\n};\n// unzlib extra\nvar zule = function() {\n    return [\n        zlv\n    ];\n};\n// post buf\nvar pbf = function(msg) {\n    return postMessage(msg, [\n        msg.buffer\n    ]);\n};\n// get u8\nvar gu8 = function(o) {\n    return o && o.size && new u8(o.size);\n};\n// async helper\nvar cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([\n        dat,\n        opts\n    ], opts.consume ? [\n        dat.buffer\n    ] : []);\n    return function() {\n        w.terminate();\n    };\n};\n// auto stream\nvar astrm = function(strm) {\n    strm.ondata = function(dat, final) {\n        return postMessage([\n            dat,\n            final\n        ], [\n            dat.buffer\n        ]);\n    };\n    return function(ev) {\n        return strm.push(ev.data[0], ev.data[1]);\n    };\n};\n// async stream attach\nvar astrmify = function(fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function(err, dat) {\n        if (err) w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1]) w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function(d, f) {\n        if (t) throw \"stream finished\";\n        if (!strm.ondata) throw \"no stream handler\";\n        w.postMessage([\n            d,\n            t = f\n        ], [\n            d.buffer\n        ]);\n    };\n    strm.terminate = function() {\n        w.terminate();\n    };\n};\n// read 2 bytes\nvar b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n};\n// read 4 bytes\nvar b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n};\n// write bytes\nvar wbytes = function(d, b, v) {\n    for(; v; ++b)d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function(c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8) throw \"invalid gzip data\";\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4) st += d[10] | (d[11] << 8) + 2;\n    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function(d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function(o) {\n    return 10 + (o.filename && o.filename.length + 1 || 0);\n};\n// zlib header\nvar zlh = function(c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);\n};\n// zlib valid\nvar zlv = function(d) {\n    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw \"invalid zlib data\";\n    if (d[1] & 32) throw \"invalid zlib data: preset dictionaries not supported\";\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */ var Deflate = /*#__PURE__*/ function() {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function(c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Deflate.prototype.push = function(chunk, final) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE compression\n */ var AsyncDeflate = /*#__PURE__*/ function() {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function() {\n                return [\n                    astrm,\n                    Deflate\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}();\n\nfunction deflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt\n    ], function(ev) {\n        return pbf(deflateSync(ev.data[0], ev.data[1]));\n    }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */ function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */ var Inflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function(c) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function(final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */ Inflate.prototype.push = function(chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE decompression\n */ var AsyncInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function() {\n                return [\n                    astrm,\n                    Inflate\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}();\n\nfunction inflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt\n    ], function(ev) {\n        return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));\n    }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */ var Gzip = /*#__PURE__*/ function() {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gzip.prototype.push = function(chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function(c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v) gzh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}();\n\n/**\n * Asynchronous streaming GZIP compression\n */ var AsyncGzip = /*#__PURE__*/ function() {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Gzip\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}();\n\nfunction gzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function() {\n            return [\n                gzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gzipSync(ev.data[0], ev.data[1]));\n    }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */ function gzipSync(data, opts) {\n    if (!opts) opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */ var Gunzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gunzip.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final) return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8) throw \"invalid gzip stream\";\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}();\n\n/**\n * Asynchronous streaming GZIP decompression\n */ var AsyncGunzip = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Gunzip\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}();\n\nfunction gunzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function() {\n            return [\n                gunzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gunzipSync(ev.data[0]));\n    }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */ function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */ var Zlib = /*#__PURE__*/ function() {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Zlib.prototype.push = function(chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function(c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v) zlh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}();\n\n/**\n * Asynchronous streaming Zlib compression\n */ var AsyncZlib = /*#__PURE__*/ function() {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Zlib\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}();\n\nfunction zlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function() {\n            return [\n                zlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(zlibSync(ev.data[0], ev.data[1]));\n    }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */ function zlibSync(data, opts) {\n    if (!opts) opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */ var Unzlib = /*#__PURE__*/ function() {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzlib.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final) return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4) throw \"invalid zlib stream\";\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}();\n\n/**\n * Asynchronous streaming Zlib decompression\n */ var AsyncUnzlib = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Unzlib\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}();\n\nfunction unzlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function() {\n            return [\n                unzlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));\n    }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var Decompress = /*#__PURE__*/ function() {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */ function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Decompress.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no stream handler\";\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            } else this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function() {\n                    _this_1.ondata.apply(_this_1, arguments);\n                };\n                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        } else this.s.push(chunk, final);\n    };\n    return Decompress;\n}();\n\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var AsyncDecompress = /*#__PURE__*/ function() {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */ function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncDecompress.prototype.push = function(chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}();\n\nfunction decompress(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function decompressSync(data, out) {\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function(d, p, t, o) {\n    for(var k in d){\n        var val = d[k], n = p + k;\n        if (val instanceof u8) t[n] = [\n            val,\n            o\n        ];\n        else if (Array.isArray(val)) t[n] = [\n            val[0],\n            mrg(o, val[1])\n        ];\n        else fltn(val, n + \"/\", t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != \"undefined\" && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != \"undefined\" && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, {\n        stream: true\n    });\n    tds = 1;\n} catch (e) {}\n// decode UTF8\nvar dutf8 = function(d) {\n    for(var r = \"\", i = 0;;){\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length) return [\n            r,\n            slc(d, i - 1)\n        ];\n        if (!eb) r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n        } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */ var DecodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */ function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds) this.t = new TextDecoder();\n        else this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ DecodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, {\n                stream: true\n            }), final);\n            if (final) {\n                if (this.t.decode().length) throw \"invalid utf-8 data\";\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p) throw \"stream finished\";\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length) throw \"invalid utf-8 data\";\n            this.p = null;\n        } else this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}();\n\n/**\n * Streaming UTF-8 encoding\n */ var EncodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */ function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */ EncodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        if (this.d) throw \"stream finished\";\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}();\n\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */ function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te) return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function(v) {\n        ar[ai++] = v;\n    };\n    for(var i = 0; i < l; ++i){\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + (l - i << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1) w(c);\n        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);\n        else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);\n        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */ function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = \"\";\n        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    } else if (td) return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length) throw \"invalid utf-8 data\";\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function(l) {\n    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;\n};\n// skip local zip header\nvar slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n};\n// read zip header\nvar zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [\n        bs,\n        b4(d, b + 24),\n        b4(d, b + 42)\n    ], sc = _a[0], su = _a[1], off = _a[2];\n    return [\n        b2(d, b + 10),\n        sc,\n        su,\n        fn,\n        es + b2(d, b + 30) + b2(d, b + 32),\n        off\n    ];\n};\n// read zip64 extra field\nvar z64e = function(d, b) {\n    for(; b2(d, b) != 1; b += 4 + b2(d, b + 2));\n    return [\n        b8(d, b + 12),\n        b8(d, b + 4),\n        b8(d, b + 20)\n    ];\n};\n// extra field length\nvar exfl = function(ex) {\n    var le = 0;\n    if (ex) {\n        for(var k in ex){\n            var l = ex[k].length;\n            if (l > 65535) throw \"extra field too long\";\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function(d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null) d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119) throw \"date not in range 1980-2099\";\n    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for(var k in ex){\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col) d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function(o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */ var ZipPassThrough = /*#__PURE__*/ function() {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */ function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.process = function(chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback - add to ZIP archive before pushing\";\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final) this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}();\n\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */ var ZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function(chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        } catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */ var AsyncZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function(err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function(chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}();\n\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */ var Zip = /*#__PURE__*/ function() {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */ function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */ Zip.prototype.add = function(file) {\n        var _this_1 = this;\n        if (this.d & 2) throw \"stream finished\";\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || o && com.length != o.length;\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535) throw \"filename too long\";\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [\n            header\n        ];\n        var pAll = function() {\n            for(var _i = 0, chks_1 = chks; _i < chks_1.length; _i++){\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function() {\n                if (file.terminate) file.terminate();\n            },\n            r: function() {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt) nxt.r();\n                    else _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function(err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            } else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr) uf.r();\n                    tr = 1;\n                } else if (tr) pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */ Zip.prototype.end = function() {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1) throw \"stream finishing\";\n            throw \"stream finished\";\n        }\n        if (this.d) this.e();\n        else this.u.push({\n            r: function() {\n                if (!(_this_1.d & 1)) return;\n                _this_1.u.splice(-1, 1);\n                _this_1.e();\n            },\n            t: function() {}\n        });\n        this.d = 3;\n    };\n    Zip.prototype.e = function() {\n        var bt = 0, l = 0, tl = 0;\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for(var _b = 0, _c = this.u; _b < _c.length; _b++){\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */ Zip.prototype.terminate = function() {\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}();\n\nfunction zip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    var r = {};\n    fltn(data, \"\", r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var cbf = function() {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for(var i = 0; i < slft; ++i){\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            } catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft) cbf();\n    var _loop_1 = function(i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || m && com.length != ms,\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft) cbf();\n            }\n        };\n        if (s > 65535) cbl(\"filename too long\", null);\n        if (!compression) cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            } catch (e) {\n                cbl(e, null);\n            }\n        } else term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for(var i = 0; i < slft; ++i){\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */ function zipSync(data, opts) {\n    if (!opts) opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, \"\", r, opts);\n    var o = 0;\n    var tot = 0;\n    for(var fn in r){\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535) throw \"filename too long\";\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || m && com.length != ms,\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for(var i = 0; i < files.length; ++i){\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */ var UnzipPassThrough = /*#__PURE__*/ function() {\n    function UnzipPassThrough() {}\n    UnzipPassThrough.prototype.push = function(data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}();\n\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */ var UnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function(data, final) {\n        try {\n            this.i.push(data, final);\n        } catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */ var AsyncUnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function(dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        } else {\n            this.i = new AsyncInflate(function(err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function(data, final) {\n        if (this.i.terminate) data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}();\n\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */ var Unzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */ function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzip.prototype.push = function(chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile) throw \"no callback\";\n        if (!this.p) throw \"stream finished\";\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d) this.d.push(toAdd, !this.c);\n            else this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length) return this.push(chunk, final);\n        } else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length) buf = chunk;\n            else if (!chunk.length) buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function() {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [\n                                -2\n                            ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        } else if (dd) sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function() {\n                                if (!file_1.ondata) throw \"no callback\";\n                                if (!sc_1) file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr) throw \"unknown compression type \" + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function(err, dat, final) {\n                                        file_1.ondata(err, dat, final);\n                                    };\n                                    for(var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++){\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c) _this_1.d = d_1;\n                                    else d_1.push(et, true);\n                                }\n                            },\n                            terminate: function() {\n                                if (d_1 && d_1.terminate) d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                } else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    } else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for(; i < l - 4; ++i){\n                var state_1 = _loop_2();\n                if (state_1 === \"break\") break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add) add.push(dat, !!f);\n                else this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2) return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c) throw \"invalid zip file\";\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */ Unzip.prototype.register = function(decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}();\n\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */ function unzip(data, cb) {\n    if (typeof cb != \"function\") throw \"no callback\";\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft) cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function(i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                files[fn] = d;\n                if (!--lft) cb(null, files);\n            }\n        };\n        if (!c_1) cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                } catch (e) {\n                    cbl(e, null);\n                }\n            } else term.push(inflate(infl, {\n                size: su\n            }, cbl));\n        } else cbl(\"unknown compression type \" + c_1, null);\n    };\n    for(var i = 0; i < c; ++i){\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */ function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) throw \"invalid zip file\";\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c) return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) throw \"invalid zip file\";\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for(var i = 0; i < c; ++i){\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2) files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else throw \"unknown compression type \" + c_2;\n    }\n    return files;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmZsYXRlL2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1QztBQUN2QyxJQUFJQyxVQUFVRCxxREFBYUEsQ0FBQztBQUM1QiwyRkFBMkY7QUFDM0Ysc0NBQXNDO0FBQ3RDLDJFQUEyRTtBQUMzRSxxRUFBcUU7QUFDckUsNERBQTREO0FBQzVELHNDQUFzQztBQUN0Qyx1SEFBdUg7QUFDdkgsMkZBQTJGO0FBQzNGLG9EQUFvRDtBQUNwRCxnQkFBZ0I7QUFDaEIsSUFBSUU7QUFDSixJQUFJQyxZQUFZO0FBQ2hCLElBQUk7SUFDQUQsU0FBU0QsUUFBUSxrQkFBa0JDLE1BQU07QUFDN0MsRUFDQSxPQUFPRSxHQUFHLENBQ1Y7QUFDQSxJQUFJQyxLQUFLSCxTQUFTLFNBQVVJLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsRUFBRTtJQUMvQyxJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsSUFBSSxJQUFJVixPQUFPSSxJQUFJSCxXQUFXO1FBQUVVLE1BQU07SUFBSyxHQUMxQ0MsRUFBRSxDQUFDLFNBQVMsU0FBVVYsQ0FBQztRQUFJLE9BQU9NLEdBQUdOLEdBQUc7SUFBTyxHQUMvQ1UsRUFBRSxDQUFDLFdBQVcsU0FBVUMsQ0FBQztRQUFJLE9BQU9MLEdBQUcsTUFBTUs7SUFBSSxHQUNqREQsRUFBRSxDQUFDLFFBQVEsU0FBVVIsQ0FBQztRQUN2QixJQUFJQSxLQUFLLENBQUNLLE1BQ05ELEdBQUcsSUFBSU0sTUFBTSxzQkFBc0JWLElBQUk7SUFDL0M7SUFDQU0sRUFBRUssV0FBVyxDQUFDVCxLQUFLQztJQUNuQkcsRUFBRU0sU0FBUyxHQUFHO1FBQ1ZQLE9BQU87UUFDUCxPQUFPVCxPQUFPaUIsU0FBUyxDQUFDRCxTQUFTLENBQUNFLElBQUksQ0FBQ1I7SUFDM0M7SUFDQSxPQUFPQTtBQUNYLElBQUksU0FB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TUFBTXZNLEdBQUcwUixJQUFJbUcsTUFBTTVaLEVBQUUsQ0FBQyxFQUFFLEVBQUU2VCxLQUFLN1QsRUFBRSxDQUFDLEVBQUUsRUFBRThULEtBQUs5VCxFQUFFLENBQUMsRUFBRSxFQUFFd0wsS0FBS3hMLEVBQUUsQ0FBQyxFQUFFLEVBQUV5WixLQUFLelosRUFBRSxDQUFDLEVBQUUsRUFBRStULE1BQU0vVCxFQUFFLENBQUMsRUFBRSxFQUFFSixJQUFJMlQsS0FBS2pGLE1BQU15RjtRQUNsSGhTLElBQUkwWDtRQUNKLElBQUksQ0FBQ0csS0FDRDlDLEtBQUssQ0FBQ3RMLEdBQUcsR0FBR3RKLElBQUlvTSxNQUFNMU8sR0FBR0EsSUFBSWlVO2FBQzVCLElBQUkrRixPQUFPLEdBQ1o5QyxLQUFLLENBQUN0TCxHQUFHLEdBQUdxQixZQUFZeUIsS0FBS2pNLFFBQVEsQ0FBQ3pDLEdBQUdBLElBQUlpVSxLQUFLLElBQUk3VSxHQUFHOFU7YUFFekQsTUFBTSw4QkFBOEI4RjtJQUM1QztJQUNBLE9BQU85QztBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JlYXRpdmUtNDA0Ly4vbm9kZV9tb2R1bGVzL2ZmbGF0ZS9lc20vaW5kZXgubWpzPzNjMTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gJ21vZHVsZSc7XG52YXIgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoJy8nKTtcbi8vIERFRkxBVEUgaXMgYSBjb21wbGV4IGZvcm1hdDsgdG8gcmVhZCB0aGlzIGNvZGUsIHlvdSBzaG91bGQgcHJvYmFibHkgY2hlY2sgdGhlIFJGQyBmaXJzdDpcbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxOTUxXG4vLyBZb3UgbWF5IGFsc28gd2lzaCB0byB0YWtlIGEgbG9vayBhdCB0aGUgZ3VpZGUgSSBtYWRlIGFib3V0IHRoaXMgcHJvZ3JhbTpcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwMWFycm93ei8yNTNmMzFlYjVhYmMzZDkyNzVhYjk0MzAwM2ZmZWNhZFxuLy8gU29tZSBvZiB0aGUgZm9sbG93aW5nIGNvZGUgaXMgc2ltaWxhciB0byB0aGF0IG9mIFVaSVAuanM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9wZWEvVVpJUC5qc1xuLy8gSG93ZXZlciwgdGhlIHZhc3QgbWFqb3JpdHkgb2YgdGhlIGNvZGViYXNlIGhhcyBkaXZlcmdlZCBmcm9tIFVaSVAuanMgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UgYW5kIHJlZHVjZSBidW5kbGUgc2l6ZS5cbi8vIFNvbWV0aW1lcyAwIHdpbGwgYXBwZWFyIHdoZXJlIC0xIHdvdWxkIGJlIG1vcmUgYXBwcm9wcmlhdGUuIFRoaXMgaXMgYmVjYXVzZSB1c2luZyBhIHVpbnRcbi8vIGlzIGJldHRlciBmb3IgbWVtb3J5IGluIG1vc3QgZW5naW5lcyAoSSAqdGhpbmsqKS5cbi8vIE1lZGlvY3JlIHNoaW1cbnZhciBXb3JrZXI7XG52YXIgd29ya2VyQWRkID0gXCI7dmFyIF9fdz1yZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpO19fdy5wYXJlbnRQb3J0Lm9uKCdtZXNzYWdlJyxmdW5jdGlvbihtKXtvbm1lc3NhZ2Uoe2RhdGE6bX0pfSkscG9zdE1lc3NhZ2U9ZnVuY3Rpb24obSx0KXtfX3cucGFyZW50UG9ydC5wb3N0TWVzc2FnZShtLHQpfSxjbG9zZT1wcm9jZXNzLmV4aXQ7c2VsZj1nbG9iYWxcIjtcbnRyeSB7XG4gICAgV29ya2VyID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKS5Xb3JrZXI7XG59XG5jYXRjaCAoZSkge1xufVxudmFyIHdrID0gV29ya2VyID8gZnVuY3Rpb24gKGMsIF8sIG1zZywgdHJhbnNmZXIsIGNiKSB7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB2YXIgdyA9IG5ldyBXb3JrZXIoYyArIHdvcmtlckFkZCwgeyBldmFsOiB0cnVlIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gY2IoZSwgbnVsbCk7IH0pXG4gICAgICAgIC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChtKSB7IHJldHVybiBjYihudWxsLCBtKTsgfSlcbiAgICAgICAgLm9uKCdleGl0JywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgJiYgIWRvbmUpXG4gICAgICAgICAgICBjYihuZXcgRXJyb3IoJ2V4aXRlZCB3aXRoIGNvZGUgJyArIGMpLCBudWxsKTtcbiAgICB9KTtcbiAgICB3LnBvc3RNZXNzYWdlKG1zZywgdHJhbnNmZXIpO1xuICAgIHcudGVybWluYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFdvcmtlci5wcm90b3R5cGUudGVybWluYXRlLmNhbGwodyk7XG4gICAgfTtcbiAgICByZXR1cm4gdztcbn0gOiBmdW5jdGlvbiAoXywgX18sIF9fXywgX19fXywgY2IpIHtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2IobmV3IEVycm9yKCdhc3luYyBvcGVyYXRpb25zIHVuc3VwcG9ydGVkIC0gdXBkYXRlIHRvIE5vZGUgMTIrIChvciBOb2RlIDEwLTExIHdpdGggdGhlIC0tZXhwZXJpbWVudGFsLXdvcmtlciBDTEkgZmxhZyknKSwgbnVsbCk7IH0pO1xuICAgIHZhciBOT1AgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGVybWluYXRlOiBOT1AsXG4gICAgICAgIHBvc3RNZXNzYWdlOiBOT1BcbiAgICB9O1xufTtcblxuLy8gYWxpYXNlcyBmb3Igc2hvcnRlciBjb21wcmVzc2VkIGNvZGUgKG1vc3QgbWluaWZlcnMgZG9uJ3QgZG8gdGhpcylcbnZhciB1OCA9IFVpbnQ4QXJyYXksIHUxNiA9IFVpbnQxNkFycmF5LCB1MzIgPSBVaW50MzJBcnJheTtcbi8vIGZpeGVkIGxlbmd0aCBleHRyYSBiaXRzXG52YXIgZmxlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgLyogdW51c2VkICovIDAsIDAsIC8qIGltcG9zc2libGUgKi8gMF0pO1xuLy8gZml4ZWQgZGlzdGFuY2UgZXh0cmEgYml0c1xuLy8gc2VlIGZsZWIgbm90ZVxudmFyIGZkZWIgPSBuZXcgdTgoWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgLyogdW51c2VkICovIDAsIDBdKTtcbi8vIGNvZGUgbGVuZ3RoIGluZGV4IG1hcFxudmFyIGNsaW0gPSBuZXcgdTgoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKTtcbi8vIGdldCBiYXNlLCByZXZlcnNlIGluZGV4IG1hcCBmcm9tIGV4dHJhIGJpdHNcbnZhciBmcmViID0gZnVuY3Rpb24gKGViLCBzdGFydCkge1xuICAgIHZhciBiID0gbmV3IHUxNigzMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMTsgKytpKSB7XG4gICAgICAgIGJbaV0gPSBzdGFydCArPSAxIDw8IGViW2kgLSAxXTtcbiAgICB9XG4gICAgLy8gbnVtYmVycyBoZXJlIGFyZSBhdCBtYXggMTggYml0c1xuICAgIHZhciByID0gbmV3IHUzMihiWzMwXSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAzMDsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBiW2ldOyBqIDwgYltpICsgMV07ICsraikge1xuICAgICAgICAgICAgcltqXSA9ICgoaiAtIGJbaV0pIDw8IDUpIHwgaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2IsIHJdO1xufTtcbnZhciBfYSA9IGZyZWIoZmxlYiwgMiksIGZsID0gX2FbMF0sIHJldmZsID0gX2FbMV07XG4vLyB3ZSBjYW4gaWdub3JlIHRoZSBmYWN0IHRoYXQgdGhlIG90aGVyIG51bWJlcnMgYXJlIHdyb25nOyB0aGV5IG5ldmVyIGhhcHBlbiBhbnl3YXlcbmZsWzI4XSA9IDI1OCwgcmV2ZmxbMjU4XSA9IDI4O1xudmFyIF9iID0gZnJlYihmZGViLCAwKSwgZmQgPSBfYlswXSwgcmV2ZmQgPSBfYlsxXTtcbi8vIG1hcCBvZiB2YWx1ZSB0byByZXZlcnNlIChhc3N1bWluZyAxNiBiaXRzKVxudmFyIHJldiA9IG5ldyB1MTYoMzI3NjgpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjc2ODsgKytpKSB7XG4gICAgLy8gcmV2ZXJzZSB0YWJsZSBhbGdvcml0aG0gZnJvbSBTT1xuICAgIHZhciB4ID0gKChpICYgMHhBQUFBKSA+Pj4gMSkgfCAoKGkgJiAweDU1NTUpIDw8IDEpO1xuICAgIHggPSAoKHggJiAweENDQ0MpID4+PiAyKSB8ICgoeCAmIDB4MzMzMykgPDwgMik7XG4gICAgeCA9ICgoeCAmIDB4RjBGMCkgPj4+IDQpIHwgKCh4ICYgMHgwRjBGKSA8PCA0KTtcbiAgICByZXZbaV0gPSAoKCh4ICYgMHhGRjAwKSA+Pj4gOCkgfCAoKHggJiAweDAwRkYpIDw8IDgpKSA+Pj4gMTtcbn1cbi8vIGNyZWF0ZSBodWZmbWFuIHRyZWUgZnJvbSB1OCBcIm1hcFwiOiBpbmRleCAtPiBjb2RlIGxlbmd0aCBmb3IgY29kZSBpbmRleFxuLy8gbWIgKG1heCBiaXRzKSBtdXN0IGJlIGF0IG1vc3QgMTVcbi8vIFRPRE86IG9wdGltaXplL3NwbGl0IHVwP1xudmFyIGhNYXAgPSAoZnVuY3Rpb24gKGNkLCBtYiwgcikge1xuICAgIHZhciBzID0gY2QubGVuZ3RoO1xuICAgIC8vIGluZGV4XG4gICAgdmFyIGkgPSAwO1xuICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiAjIG9mIGNvZGVzIHdpdGggYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGwgPSBuZXcgdTE2KG1iKTtcbiAgICAvLyBsZW5ndGggb2YgY2QgbXVzdCBiZSAyODggKHRvdGFsICMgb2YgY29kZXMpXG4gICAgZm9yICg7IGkgPCBzOyArK2kpXG4gICAgICAgICsrbFtjZFtpXSAtIDFdO1xuICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiBtaW5pbXVtIGNvZGUgZm9yIGJpdCBsZW5ndGggPSBpbmRleFxuICAgIHZhciBsZSA9IG5ldyB1MTYobWIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtYjsgKytpKSB7XG4gICAgICAgIGxlW2ldID0gKGxlW2kgLSAxXSArIGxbaSAtIDFdKSA8PCAxO1xuICAgIH1cbiAgICB2YXIgY287XG4gICAgaWYgKHIpIHtcbiAgICAgICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG51bWJlciBvZiBhY3R1YWwgYml0cywgc3ltYm9sIGZvciBjb2RlXG4gICAgICAgIGNvID0gbmV3IHUxNigxIDw8IG1iKTtcbiAgICAgICAgLy8gYml0cyB0byByZW1vdmUgZm9yIHJldmVyc2VyXG4gICAgICAgIHZhciBydmIgPSAxNSAtIG1iO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgMCBsZW5ndGhzXG4gICAgICAgICAgICBpZiAoY2RbaV0pIHtcbiAgICAgICAgICAgICAgICAvLyBudW0gZW5jb2RpbmcgYm90aCBzeW1ib2wgYW5kIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgIHZhciBzdiA9IChpIDw8IDQpIHwgY2RbaV07XG4gICAgICAgICAgICAgICAgLy8gZnJlZSBiaXRzXG4gICAgICAgICAgICAgICAgdmFyIHJfMSA9IG1iIC0gY2RbaV07XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGxlW2NkW2ldIC0gMV0rKyA8PCByXzE7XG4gICAgICAgICAgICAgICAgLy8gbSBpcyBlbmQgdmFsdWVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gdiB8ICgoMSA8PCByXzEpIC0gMSk7IHYgPD0gbTsgKyt2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZXJ5IDE2IGJpdCB2YWx1ZSBzdGFydGluZyB3aXRoIHRoZSBjb2RlIHlpZWxkcyB0aGUgc2FtZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgY29bcmV2W3ZdID4+PiBydmJdID0gc3Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjbyA9IG5ldyB1MTYocyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIGNvW2ldID0gcmV2W2xlW2NkW2ldIC0gMV0rK10gPj4+ICgxNSAtIGNkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY287XG59KTtcbi8vIGZpeGVkIGxlbmd0aCB0cmVlXG52YXIgZmx0ID0gbmV3IHU4KDI4OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDE0NDsgKytpKVxuICAgIGZsdFtpXSA9IDg7XG5mb3IgKHZhciBpID0gMTQ0OyBpIDwgMjU2OyArK2kpXG4gICAgZmx0W2ldID0gOTtcbmZvciAodmFyIGkgPSAyNTY7IGkgPCAyODA7ICsraSlcbiAgICBmbHRbaV0gPSA3O1xuZm9yICh2YXIgaSA9IDI4MDsgaSA8IDI4ODsgKytpKVxuICAgIGZsdFtpXSA9IDg7XG4vLyBmaXhlZCBkaXN0YW5jZSB0cmVlXG52YXIgZmR0ID0gbmV3IHU4KDMyKTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMzI7ICsraSlcbiAgICBmZHRbaV0gPSA1O1xuLy8gZml4ZWQgbGVuZ3RoIG1hcFxudmFyIGZsbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmbHQsIDksIDApLCBmbHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBtYXBcbnZhciBmZG0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmR0LCA1LCAwKSwgZmRybSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDEpO1xuLy8gZmluZCBtYXggb2YgYXJyYXlcbnZhciBtYXggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBtID0gYVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gPiBtKVxuICAgICAgICAgICAgbSA9IGFbaV07XG4gICAgfVxuICAgIHJldHVybiBtO1xufTtcbi8vIHJlYWQgZCwgc3RhcnRpbmcgYXQgYml0IHAgYW5kIG1hc2sgd2l0aCBtXG52YXIgYml0cyA9IGZ1bmN0aW9uIChkLCBwLCBtKSB7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICByZXR1cm4gKChkW29dIHwgKGRbbyArIDFdIDw8IDgpKSA+PiAocCAmIDcpKSAmIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBjb250aW51aW5nIGZvciBhdCBsZWFzdCAxNiBiaXRzXG52YXIgYml0czE2ID0gZnVuY3Rpb24gKGQsIHApIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkgfCAoZFtvICsgMl0gPDwgMTYpKSA+PiAocCAmIDcpKTtcbn07XG4vLyBnZXQgZW5kIG9mIGJ5dGVcbnZhciBzaGZ0ID0gZnVuY3Rpb24gKHApIHsgcmV0dXJuICgocCAvIDgpIHwgMCkgKyAocCAmIDcgJiYgMSk7IH07XG4vLyB0eXBlZCBhcnJheSBzbGljZSAtIGFsbG93cyBnYXJiYWdlIGNvbGxlY3RvciB0byBmcmVlIG9yaWdpbmFsIHJlZmVyZW5jZSxcbi8vIHdoaWxlIGJlaW5nIG1vcmUgY29tcGF0aWJsZSB0aGFuIC5zbGljZVxudmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICAvLyBjYW4ndCB1c2UgLmNvbnN0cnVjdG9yIGluIGNhc2UgdXNlci1zdXBwbGllZFxuICAgIHZhciBuID0gbmV3ICh2IGluc3RhbmNlb2YgdTE2ID8gdTE2IDogdiBpbnN0YW5jZW9mIHUzMiA/IHUzMiA6IHU4KShlIC0gcyk7XG4gICAgbi5zZXQodi5zdWJhcnJheShzLCBlKSk7XG4gICAgcmV0dXJuIG47XG59O1xuLy8gZXhwYW5kcyByYXcgREVGTEFURSBkYXRhXG52YXIgaW5mbHQgPSBmdW5jdGlvbiAoZGF0LCBidWYsIHN0KSB7XG4gICAgLy8gc291cmNlIGxlbmd0aFxuICAgIHZhciBzbCA9IGRhdC5sZW5ndGg7XG4gICAgaWYgKCFzbCB8fCAoc3QgJiYgIXN0LmwgJiYgc2wgPCA1KSlcbiAgICAgICAgcmV0dXJuIGJ1ZiB8fCBuZXcgdTgoMCk7XG4gICAgLy8gaGF2ZSB0byBlc3RpbWF0ZSBzaXplXG4gICAgdmFyIG5vQnVmID0gIWJ1ZiB8fCBzdDtcbiAgICAvLyBubyBzdGF0ZVxuICAgIHZhciBub1N0ID0gIXN0IHx8IHN0Lmk7XG4gICAgaWYgKCFzdClcbiAgICAgICAgc3QgPSB7fTtcbiAgICAvLyBBc3N1bWVzIHJvdWdobHkgMzMlIGNvbXByZXNzaW9uIHJhdGlvIGF2ZXJhZ2VcbiAgICBpZiAoIWJ1ZilcbiAgICAgICAgYnVmID0gbmV3IHU4KHNsICogMyk7XG4gICAgLy8gZW5zdXJlIGJ1ZmZlciBjYW4gZml0IGF0IGxlYXN0IGwgZWxlbWVudHNcbiAgICB2YXIgY2J1ZiA9IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHZhciBibCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIC8vIG5lZWQgdG8gaW5jcmVhc2Ugc2l6ZSB0byBmaXRcbiAgICAgICAgaWYgKGwgPiBibCkge1xuICAgICAgICAgICAgLy8gRG91YmxlIG9yIHNldCB0byBuZWNlc3NhcnksIHdoaWNoZXZlciBpcyBncmVhdGVyXG4gICAgICAgICAgICB2YXIgbmJ1ZiA9IG5ldyB1OChNYXRoLm1heChibCAqIDIsIGwpKTtcbiAgICAgICAgICAgIG5idWYuc2V0KGJ1Zik7XG4gICAgICAgICAgICBidWYgPSBuYnVmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAgbGFzdCBjaHVuayAgICAgICAgIGJpdHBvcyAgICAgICAgICAgYnl0ZXNcbiAgICB2YXIgZmluYWwgPSBzdC5mIHx8IDAsIHBvcyA9IHN0LnAgfHwgMCwgYnQgPSBzdC5iIHx8IDAsIGxtID0gc3QubCwgZG0gPSBzdC5kLCBsYnQgPSBzdC5tLCBkYnQgPSBzdC5uO1xuICAgIC8vIHRvdGFsIGJpdHNcbiAgICB2YXIgdGJ0cyA9IHNsICogODtcbiAgICBkbyB7XG4gICAgICAgIGlmICghbG0pIHtcbiAgICAgICAgICAgIC8vIEJGSU5BTCAtIHRoaXMgaXMgb25seSAxIHdoZW4gbGFzdCBjaHVuayBpcyBuZXh0XG4gICAgICAgICAgICBzdC5mID0gZmluYWwgPSBiaXRzKGRhdCwgcG9zLCAxKTtcbiAgICAgICAgICAgIC8vIHR5cGU6IDAgPSBubyBjb21wcmVzc2lvbiwgMSA9IGZpeGVkIGh1ZmZtYW4sIDIgPSBkeW5hbWljIGh1ZmZtYW5cbiAgICAgICAgICAgIHZhciB0eXBlID0gYml0cyhkYXQsIHBvcyArIDEsIDMpO1xuICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBnbyB0byBlbmQgb2YgYnl0ZSBib3VuZGFyeVxuICAgICAgICAgICAgICAgIHZhciBzID0gc2hmdChwb3MpICsgNCwgbCA9IGRhdFtzIC0gNF0gfCAoZGF0W3MgLSAzXSA8PCA4KSwgdCA9IHMgKyBsO1xuICAgICAgICAgICAgICAgIGlmICh0ID4gc2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHNpemVcbiAgICAgICAgICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICAgICAgICAgIGNidWYoYnQgKyBsKTtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgdW5jb21wcmVzc2VkIGRhdGFcbiAgICAgICAgICAgICAgICBidWYuc2V0KGRhdC5zdWJhcnJheShzLCB0KSwgYnQpO1xuICAgICAgICAgICAgICAgIC8vIEdldCBuZXcgYml0cG9zLCB1cGRhdGUgYnl0ZSBjb3VudFxuICAgICAgICAgICAgICAgIHN0LmIgPSBidCArPSBsLCBzdC5wID0gcG9zID0gdCAqIDg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDEpXG4gICAgICAgICAgICAgICAgbG0gPSBmbHJtLCBkbSA9IGZkcm0sIGxidCA9IDksIGRidCA9IDU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyAgbGl0ZXJhbCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzXG4gICAgICAgICAgICAgICAgdmFyIGhMaXQgPSBiaXRzKGRhdCwgcG9zLCAzMSkgKyAyNTcsIGhjTGVuID0gYml0cyhkYXQsIHBvcyArIDEwLCAxNSkgKyA0O1xuICAgICAgICAgICAgICAgIHZhciB0bCA9IGhMaXQgKyBiaXRzKGRhdCwgcG9zICsgNSwgMzEpICsgMTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTQ7XG4gICAgICAgICAgICAgICAgLy8gbGVuZ3RoK2Rpc3RhbmNlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgbGR0ID0gbmV3IHU4KHRsKTtcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGNsdCA9IG5ldyB1OCgxOSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoY0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBpbmRleCBtYXAgdG8gZ2V0IHJlYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICBjbHRbY2xpbVtpXV0gPSBiaXRzKGRhdCwgcG9zICsgaSAqIDMsIDcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gaGNMZW4gKiAzO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBiaXRzXG4gICAgICAgICAgICAgICAgdmFyIGNsYiA9IG1heChjbHQpLCBjbGJtc2sgPSAoMSA8PCBjbGIpIC0gMTtcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aHMgbWFwXG4gICAgICAgICAgICAgICAgdmFyIGNsbSA9IGhNYXAoY2x0LCBjbGIsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGw7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gY2xtW2JpdHMoZGF0LCBwb3MsIGNsYm1zayldO1xuICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIHJlYWRcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IHIgJiAxNTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gciA+Pj4gNDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGggdG8gY29weVxuICAgICAgICAgICAgICAgICAgICBpZiAocyA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZHRbaSsrXSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgY29weSAgIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IDAsIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT0gMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDMgKyBiaXRzKGRhdCwgcG9zLCAzKSwgcG9zICs9IDIsIGMgPSBsZHRbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxNylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDcpLCBwb3MgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMTgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDExICsgYml0cyhkYXQsIHBvcywgMTI3KSwgcG9zICs9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobi0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICBsZW5ndGggdHJlZSAgICAgICAgICAgICAgICAgZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsdCA9IGxkdC5zdWJhcnJheSgwLCBoTGl0KSwgZHQgPSBsZHQuc3ViYXJyYXkoaExpdCk7XG4gICAgICAgICAgICAgICAgLy8gbWF4IGxlbmd0aCBiaXRzXG4gICAgICAgICAgICAgICAgbGJ0ID0gbWF4KGx0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggZGlzdCBiaXRzXG4gICAgICAgICAgICAgICAgZGJ0ID0gbWF4KGR0KTtcbiAgICAgICAgICAgICAgICBsbSA9IGhNYXAobHQsIGxidCwgMSk7XG4gICAgICAgICAgICAgICAgZG0gPSBoTWFwKGR0LCBkYnQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgRU9GJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGJ1ZmZlciBjYW4gaG9sZCB0aGlzICsgdGhlIGxhcmdlc3QgcG9zc2libGUgYWRkaXRpb25cbiAgICAgICAgLy8gTWF4aW11bSBjaHVuayBzaXplIChwcmFjdGljYWxseSwgdGhlb3JldGljYWxseSBpbmZpbml0ZSkgaXMgMl4xNztcbiAgICAgICAgaWYgKG5vQnVmKVxuICAgICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgIHZhciBsbXMgPSAoMSA8PCBsYnQpIC0gMSwgZG1zID0gKDEgPDwgZGJ0KSAtIDE7XG4gICAgICAgIHZhciBscG9zID0gcG9zO1xuICAgICAgICBmb3IgKDs7IGxwb3MgPSBwb3MpIHtcbiAgICAgICAgICAgIC8vIGJpdHMgcmVhZCwgY29kZVxuICAgICAgICAgICAgdmFyIGMgPSBsbVtiaXRzMTYoZGF0LCBwb3MpICYgbG1zXSwgc3ltID0gYyA+Pj4gNDtcbiAgICAgICAgICAgIHBvcyArPSBjICYgMTU7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGxlbmd0aC9saXRlcmFsJztcbiAgICAgICAgICAgIGlmIChzeW0gPCAyNTYpXG4gICAgICAgICAgICAgICAgYnVmW2J0KytdID0gc3ltO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3ltID09IDI1Nikge1xuICAgICAgICAgICAgICAgIGxwb3MgPSBwb3MsIGxtID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhZGQgPSBzeW0gLSAyNTQ7XG4gICAgICAgICAgICAgICAgLy8gbm8gZXh0cmEgYml0cyBuZWVkZWQgaWYgbGVzc1xuICAgICAgICAgICAgICAgIGlmIChzeW0gPiAyNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBzeW0gLSAyNTcsIGIgPSBmbGViW2ldO1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSBiaXRzKGRhdCwgcG9zLCAoMSA8PCBiKSAtIDEpICsgZmxbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXN0XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkbVtiaXRzMTYoZGF0LCBwb3MpICYgZG1zXSwgZHN5bSA9IGQgPj4+IDQ7XG4gICAgICAgICAgICAgICAgaWYgKCFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCBkaXN0YW5jZSc7XG4gICAgICAgICAgICAgICAgcG9zICs9IGQgJiAxNTtcbiAgICAgICAgICAgICAgICB2YXIgZHQgPSBmZFtkc3ltXTtcbiAgICAgICAgICAgICAgICBpZiAoZHN5bSA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBmZGViW2RzeW1dO1xuICAgICAgICAgICAgICAgICAgICBkdCArPSBiaXRzMTYoZGF0LCBwb3MpICYgKCgxIDw8IGIpIC0gMSksIHBvcyArPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICAgICAgICAgIGNidWYoYnQgKyAxMzEwNzIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBidCArIGFkZDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYnQgPCBlbmQ7IGJ0ICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0XSA9IGJ1ZltidCAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgMV0gPSBidWZbYnQgKyAxIC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAyXSA9IGJ1ZltidCArIDIgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDNdID0gYnVmW2J0ICsgMyAtIGR0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3QubCA9IGxtLCBzdC5wID0gbHBvcywgc3QuYiA9IGJ0O1xuICAgICAgICBpZiAobG0pXG4gICAgICAgICAgICBmaW5hbCA9IDEsIHN0Lm0gPSBsYnQsIHN0LmQgPSBkbSwgc3QubiA9IGRidDtcbiAgICB9IHdoaWxlICghZmluYWwpO1xuICAgIHJldHVybiBidCA9PSBidWYubGVuZ3RoID8gYnVmIDogc2xjKGJ1ZiwgMCwgYnQpO1xufTtcbi8vIHN0YXJ0aW5nIGF0IHAsIHdyaXRlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBiaXRzIHRoYXQgY2FuIGhvbGQgdiB0byBkXG52YXIgd2JpdHMgPSBmdW5jdGlvbiAoZCwgcCwgdikge1xuICAgIHYgPDw9IHAgJiA3O1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgZFtvXSB8PSB2O1xuICAgIGRbbyArIDFdIHw9IHYgPj4+IDg7XG59O1xuLy8gc3RhcnRpbmcgYXQgcCwgd3JpdGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJpdHMgKD44KSB0aGF0IGNhbiBob2xkIHYgdG8gZFxudmFyIHdiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCwgdikge1xuICAgIHYgPDw9IHAgJiA3O1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgZFtvXSB8PSB2O1xuICAgIGRbbyArIDFdIHw9IHYgPj4+IDg7XG4gICAgZFtvICsgMl0gfD0gdiA+Pj4gMTY7XG59O1xuLy8gY3JlYXRlcyBjb2RlIGxlbmd0aHMgZnJvbSBhIGZyZXF1ZW5jeSB0YWJsZVxudmFyIGhUcmVlID0gZnVuY3Rpb24gKGQsIG1iKSB7XG4gICAgLy8gTmVlZCBleHRyYSBpbmZvIHRvIG1ha2UgYSB0cmVlXG4gICAgdmFyIHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGRbaV0pXG4gICAgICAgICAgICB0LnB1c2goeyBzOiBpLCBmOiBkW2ldIH0pO1xuICAgIH1cbiAgICB2YXIgcyA9IHQubGVuZ3RoO1xuICAgIHZhciB0MiA9IHQuc2xpY2UoKTtcbiAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiBbZXQsIDBdO1xuICAgIGlmIChzID09IDEpIHtcbiAgICAgICAgdmFyIHYgPSBuZXcgdTgodFswXS5zICsgMSk7XG4gICAgICAgIHZbdFswXS5zXSA9IDE7XG4gICAgICAgIHJldHVybiBbdiwgMV07XG4gICAgfVxuICAgIHQuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5mIC0gYi5mOyB9KTtcbiAgICAvLyBhZnRlciBpMiByZWFjaGVzIGxhc3QgaW5kLCB3aWxsIGJlIHN0b3BwZWRcbiAgICAvLyBmcmVxIG11c3QgYmUgZ3JlYXRlciB0aGFuIGxhcmdlc3QgcG9zc2libGUgbnVtYmVyIG9mIHN5bWJvbHNcbiAgICB0LnB1c2goeyBzOiAtMSwgZjogMjUwMDEgfSk7XG4gICAgdmFyIGwgPSB0WzBdLCByID0gdFsxXSwgaTAgPSAwLCBpMSA9IDEsIGkyID0gMjtcbiAgICB0WzBdID0geyBzOiAtMSwgZjogbC5mICsgci5mLCBsOiBsLCByOiByIH07XG4gICAgLy8gZWZmaWNpZW50IGFsZ29yaXRobSBmcm9tIFVaSVAuanNcbiAgICAvLyBpMCBpcyBsb29rYmVoaW5kLCBpMiBpcyBsb29rYWhlYWQgLSBhZnRlciBwcm9jZXNzaW5nIHR3byBsb3ctZnJlcVxuICAgIC8vIHN5bWJvbHMgdGhhdCBjb21iaW5lZCBoYXZlIGhpZ2ggZnJlcSwgd2lsbCBzdGFydCBwcm9jZXNzaW5nIGkyIChoaWdoLWZyZXEsXG4gICAgLy8gbm9uLWNvbXBvc2l0ZSkgc3ltYm9scyBpbnN0ZWFkXG4gICAgLy8gc2VlIGh0dHBzOi8vcmVkZGl0LmNvbS9yL3Bob3RvcGVhL2NvbW1lbnRzL2lrZWtodC91emlwanNfcXVlc3Rpb25zL1xuICAgIHdoaWxlIChpMSAhPSBzIC0gMSkge1xuICAgICAgICBsID0gdFt0W2kwXS5mIDwgdFtpMl0uZiA/IGkwKysgOiBpMisrXTtcbiAgICAgICAgciA9IHRbaTAgIT0gaTEgJiYgdFtpMF0uZiA8IHRbaTJdLmYgPyBpMCsrIDogaTIrK107XG4gICAgICAgIHRbaTErK10gPSB7IHM6IC0xLCBmOiBsLmYgKyByLmYsIGw6IGwsIHI6IHIgfTtcbiAgICB9XG4gICAgdmFyIG1heFN5bSA9IHQyWzBdLnM7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgaWYgKHQyW2ldLnMgPiBtYXhTeW0pXG4gICAgICAgICAgICBtYXhTeW0gPSB0MltpXS5zO1xuICAgIH1cbiAgICAvLyBjb2RlIGxlbmd0aHNcbiAgICB2YXIgdHIgPSBuZXcgdTE2KG1heFN5bSArIDEpO1xuICAgIC8vIG1heCBiaXRzIGluIHRyZWVcbiAgICB2YXIgbWJ0ID0gbG4odFtpMSAtIDFdLCB0ciwgMCk7XG4gICAgaWYgKG1idCA+IG1iKSB7XG4gICAgICAgIC8vIG1vcmUgYWxnb3JpdGhtcyBmcm9tIFVaSVAuanNcbiAgICAgICAgLy8gVE9ETzogZmluZCBvdXQgaG93IHRoaXMgY29kZSB3b3JrcyAoZGVidClcbiAgICAgICAgLy8gIGluZCAgICBkZWJ0XG4gICAgICAgIHZhciBpID0gMCwgZHQgPSAwO1xuICAgICAgICAvLyAgICBsZWZ0ICAgICAgICAgICAgY29zdFxuICAgICAgICB2YXIgbGZ0ID0gbWJ0IC0gbWIsIGNzdCA9IDEgPDwgbGZ0O1xuICAgICAgICB0Mi5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB0cltiLnNdIC0gdHJbYS5zXSB8fCBhLmYgLSBiLmY7IH0pO1xuICAgICAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgdmFyIGkyXzEgPSB0MltpXS5zO1xuICAgICAgICAgICAgaWYgKHRyW2kyXzFdID4gbWIpIHtcbiAgICAgICAgICAgICAgICBkdCArPSBjc3QgLSAoMSA8PCAobWJ0IC0gdHJbaTJfMV0pKTtcbiAgICAgICAgICAgICAgICB0cltpMl8xXSA9IG1iO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGR0ID4+Pj0gbGZ0O1xuICAgICAgICB3aGlsZSAoZHQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgaTJfMiA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfMl0gPCBtYilcbiAgICAgICAgICAgICAgICBkdCAtPSAxIDw8IChtYiAtIHRyW2kyXzJdKysgLSAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPj0gMCAmJiBkdDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgaTJfMyA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfM10gPT0gbWIpIHtcbiAgICAgICAgICAgICAgICAtLXRyW2kyXzNdO1xuICAgICAgICAgICAgICAgICsrZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWJ0ID0gbWI7XG4gICAgfVxuICAgIHJldHVybiBbbmV3IHU4KHRyKSwgbWJ0XTtcbn07XG4vLyBnZXQgdGhlIG1heCBsZW5ndGggYW5kIGFzc2lnbiBsZW5ndGggY29kZXNcbnZhciBsbiA9IGZ1bmN0aW9uIChuLCBsLCBkKSB7XG4gICAgcmV0dXJuIG4ucyA9PSAtMVxuICAgICAgICA/IE1hdGgubWF4KGxuKG4ubCwgbCwgZCArIDEpLCBsbihuLnIsIGwsIGQgKyAxKSlcbiAgICAgICAgOiAobFtuLnNdID0gZCk7XG59O1xuLy8gbGVuZ3RoIGNvZGVzIGdlbmVyYXRpb25cbnZhciBsYyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHMgPSBjLmxlbmd0aDtcbiAgICAvLyBOb3RlIHRoYXQgdGhlIHNlbWljb2xvbiB3YXMgaW50ZW50aW9uYWxcbiAgICB3aGlsZSAocyAmJiAhY1stLXNdKVxuICAgICAgICA7XG4gICAgdmFyIGNsID0gbmV3IHUxNigrK3MpO1xuICAgIC8vICBpbmQgICAgICBudW0gICAgICAgICBzdHJlYWtcbiAgICB2YXIgY2xpID0gMCwgY2xuID0gY1swXSwgY2xzID0gMTtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGNsW2NsaSsrXSA9IHY7IH07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gczsgKytpKSB7XG4gICAgICAgIGlmIChjW2ldID09IGNsbiAmJiBpICE9IHMpXG4gICAgICAgICAgICArK2NscztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNsbiAmJiBjbHMgPiAyKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGNscyA+IDEzODsgY2xzIC09IDEzOClcbiAgICAgICAgICAgICAgICAgICAgdygzMjc1NCk7XG4gICAgICAgICAgICAgICAgaWYgKGNscyA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdyhjbHMgPiAxMCA/ICgoY2xzIC0gMTEpIDw8IDUpIHwgMjg2OTAgOiAoKGNscyAtIDMpIDw8IDUpIHwgMTIzMDUpO1xuICAgICAgICAgICAgICAgICAgICBjbHMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNscyA+IDMpIHtcbiAgICAgICAgICAgICAgICB3KGNsbiksIC0tY2xzO1xuICAgICAgICAgICAgICAgIGZvciAoOyBjbHMgPiA2OyBjbHMgLT0gNilcbiAgICAgICAgICAgICAgICAgICAgdyg4MzA0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzID4gMilcbiAgICAgICAgICAgICAgICAgICAgdygoKGNscyAtIDMpIDw8IDUpIHwgODIwOCksIGNscyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2xzLS0pXG4gICAgICAgICAgICAgICAgdyhjbG4pO1xuICAgICAgICAgICAgY2xzID0gMTtcbiAgICAgICAgICAgIGNsbiA9IGNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtjbC5zdWJhcnJheSgwLCBjbGkpLCBzXTtcbn07XG4vLyBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiBvdXRwdXQgZnJvbSB0cmVlLCBjb2RlIGxlbmd0aHNcbnZhciBjbGVuID0gZnVuY3Rpb24gKGNmLCBjbCkge1xuICAgIHZhciBsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsLmxlbmd0aDsgKytpKVxuICAgICAgICBsICs9IGNmW2ldICogY2xbaV07XG4gICAgcmV0dXJuIGw7XG59O1xuLy8gd3JpdGVzIGEgZml4ZWQgYmxvY2tcbi8vIHJldHVybnMgdGhlIG5ldyBiaXQgcG9zXG52YXIgd2ZibGsgPSBmdW5jdGlvbiAob3V0LCBwb3MsIGRhdCkge1xuICAgIC8vIG5vIG5lZWQgdG8gd3JpdGUgMDAgYXMgdHlwZTogVHlwZWRBcnJheSBkZWZhdWx0cyB0byAwXG4gICAgdmFyIHMgPSBkYXQubGVuZ3RoO1xuICAgIHZhciBvID0gc2hmdChwb3MgKyAyKTtcbiAgICBvdXRbb10gPSBzICYgMjU1O1xuICAgIG91dFtvICsgMV0gPSBzID4+PiA4O1xuICAgIG91dFtvICsgMl0gPSBvdXRbb10gXiAyNTU7XG4gICAgb3V0W28gKyAzXSA9IG91dFtvICsgMV0gXiAyNTU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyArK2kpXG4gICAgICAgIG91dFtvICsgaSArIDRdID0gZGF0W2ldO1xuICAgIHJldHVybiAobyArIDQgKyBzKSAqIDg7XG59O1xuLy8gd3JpdGVzIGEgYmxvY2tcbnZhciB3YmxrID0gZnVuY3Rpb24gKGRhdCwgb3V0LCBmaW5hbCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBibCwgcCkge1xuICAgIHdiaXRzKG91dCwgcCsrLCBmaW5hbCk7XG4gICAgKytsZlsyNTZdO1xuICAgIHZhciBfYSA9IGhUcmVlKGxmLCAxNSksIGRsdCA9IF9hWzBdLCBtbGIgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSBoVHJlZShkZiwgMTUpLCBkZHQgPSBfYlswXSwgbWRiID0gX2JbMV07XG4gICAgdmFyIF9jID0gbGMoZGx0KSwgbGNsdCA9IF9jWzBdLCBubGMgPSBfY1sxXTtcbiAgICB2YXIgX2QgPSBsYyhkZHQpLCBsY2R0ID0gX2RbMF0sIG5kYyA9IF9kWzFdO1xuICAgIHZhciBsY2ZyZXEgPSBuZXcgdTE2KDE5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxjbHQubGVuZ3RoOyArK2kpXG4gICAgICAgIGxjZnJlcVtsY2x0W2ldICYgMzFdKys7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsY2R0Lmxlbmd0aDsgKytpKVxuICAgICAgICBsY2ZyZXFbbGNkdFtpXSAmIDMxXSsrO1xuICAgIHZhciBfZSA9IGhUcmVlKGxjZnJlcSwgNyksIGxjdCA9IF9lWzBdLCBtbGNiID0gX2VbMV07XG4gICAgdmFyIG5sY2MgPSAxOTtcbiAgICBmb3IgKDsgbmxjYyA+IDQgJiYgIWxjdFtjbGltW25sY2MgLSAxXV07IC0tbmxjYylcbiAgICAgICAgO1xuICAgIHZhciBmbGVuID0gKGJsICsgNSkgPDwgMztcbiAgICB2YXIgZnRsZW4gPSBjbGVuKGxmLCBmbHQpICsgY2xlbihkZiwgZmR0KSArIGViO1xuICAgIHZhciBkdGxlbiA9IGNsZW4obGYsIGRsdCkgKyBjbGVuKGRmLCBkZHQpICsgZWIgKyAxNCArIDMgKiBubGNjICsgY2xlbihsY2ZyZXEsIGxjdCkgKyAoMiAqIGxjZnJlcVsxNl0gKyAzICogbGNmcmVxWzE3XSArIDcgKiBsY2ZyZXFbMThdKTtcbiAgICBpZiAoZmxlbiA8PSBmdGxlbiAmJiBmbGVuIDw9IGR0bGVuKVxuICAgICAgICByZXR1cm4gd2ZibGsob3V0LCBwLCBkYXQuc3ViYXJyYXkoYnMsIGJzICsgYmwpKTtcbiAgICB2YXIgbG0sIGxsLCBkbSwgZGw7XG4gICAgd2JpdHMob3V0LCBwLCAxICsgKGR0bGVuIDwgZnRsZW4pKSwgcCArPSAyO1xuICAgIGlmIChkdGxlbiA8IGZ0bGVuKSB7XG4gICAgICAgIGxtID0gaE1hcChkbHQsIG1sYiwgMCksIGxsID0gZGx0LCBkbSA9IGhNYXAoZGR0LCBtZGIsIDApLCBkbCA9IGRkdDtcbiAgICAgICAgdmFyIGxsbSA9IGhNYXAobGN0LCBtbGNiLCAwKTtcbiAgICAgICAgd2JpdHMob3V0LCBwLCBubGMgLSAyNTcpO1xuICAgICAgICB3Yml0cyhvdXQsIHAgKyA1LCBuZGMgLSAxKTtcbiAgICAgICAgd2JpdHMob3V0LCBwICsgMTAsIG5sY2MgLSA0KTtcbiAgICAgICAgcCArPSAxNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBubGNjOyArK2kpXG4gICAgICAgICAgICB3Yml0cyhvdXQsIHAgKyAzICogaSwgbGN0W2NsaW1baV1dKTtcbiAgICAgICAgcCArPSAzICogbmxjYztcbiAgICAgICAgdmFyIGxjdHMgPSBbbGNsdCwgbGNkdF07XG4gICAgICAgIGZvciAodmFyIGl0ID0gMDsgaXQgPCAyOyArK2l0KSB7XG4gICAgICAgICAgICB2YXIgY2xjdCA9IGxjdHNbaXRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGNsY3RbaV0gJiAzMTtcbiAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIGxsbVtsZW5dKSwgcCArPSBsY3RbbGVuXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMTUpXG4gICAgICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgKGNsY3RbaV0gPj4+IDUpICYgMTI3KSwgcCArPSBjbGN0W2ldID4+PiAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG0gPSBmbG0sIGxsID0gZmx0LCBkbSA9IGZkbSwgZGwgPSBmZHQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGk7ICsraSkge1xuICAgICAgICBpZiAoc3ltc1tpXSA+IDI1NSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IChzeW1zW2ldID4+PiAxOCkgJiAzMTtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBsbVtsZW4gKyAyNTddKSwgcCArPSBsbFtsZW4gKyAyNTddO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDcpXG4gICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCAoc3ltc1tpXSA+Pj4gMjMpICYgMzEpLCBwICs9IGZsZWJbbGVuXTtcbiAgICAgICAgICAgIHZhciBkc3QgPSBzeW1zW2ldICYgMzE7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgZG1bZHN0XSksIHAgKz0gZGxbZHN0XTtcbiAgICAgICAgICAgIGlmIChkc3QgPiAzKVxuICAgICAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCAoc3ltc1tpXSA+Pj4gNSkgJiA4MTkxKSwgcCArPSBmZGViW2RzdF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgbG1bc3ltc1tpXV0pLCBwICs9IGxsW3N5bXNbaV1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdiaXRzMTYob3V0LCBwLCBsbVsyNTZdKTtcbiAgICByZXR1cm4gcCArIGxsWzI1Nl07XG59O1xuLy8gZGVmbGF0ZSBvcHRpb25zIChuaWNlIDw8IDEzKSB8IGNoYWluXG52YXIgZGVvID0gLyojX19QVVJFX18qLyBuZXcgdTMyKFs2NTU0MCwgMTMxMDgwLCAxMzEwODgsIDEzMTEwNCwgMjYyMTc2LCAxMDQ4NzA0LCAxMDQ4ODMyLCAyMTE0NTYwLCAyMTE3NjMyXSk7XG4vLyBlbXB0eVxudmFyIGV0ID0gLyojX19QVVJFX18qLyBuZXcgdTgoMCk7XG4vLyBjb21wcmVzc2VzIGRhdGEgaW50byBhIHJhdyBERUZMQVRFIGJ1ZmZlclxudmFyIGRmbHQgPSBmdW5jdGlvbiAoZGF0LCBsdmwsIHBsdmwsIHByZSwgcG9zdCwgbHN0KSB7XG4gICAgdmFyIHMgPSBkYXQubGVuZ3RoO1xuICAgIHZhciBvID0gbmV3IHU4KHByZSArIHMgKyA1ICogKDEgKyBNYXRoLmNlaWwocyAvIDcwMDApKSArIHBvc3QpO1xuICAgIC8vIHdyaXRpbmcgdG8gdGhpcyB3cml0ZXMgdG8gdGhlIG91dHB1dCBidWZmZXJcbiAgICB2YXIgdyA9IG8uc3ViYXJyYXkocHJlLCBvLmxlbmd0aCAtIHBvc3QpO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIGlmICghbHZsIHx8IHMgPCA4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHM7IGkgKz0gNjU1MzUpIHtcbiAgICAgICAgICAgIC8vIGVuZFxuICAgICAgICAgICAgdmFyIGUgPSBpICsgNjU1MzU7XG4gICAgICAgICAgICBpZiAoZSA8IHMpIHtcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBmdWxsIGJsb2NrXG4gICAgICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zLCBkYXQuc3ViYXJyYXkoaSwgZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd3JpdGUgZmluYWwgYmxvY2tcbiAgICAgICAgICAgICAgICB3W2ldID0gbHN0O1xuICAgICAgICAgICAgICAgIHBvcyA9IHdmYmxrKHcsIHBvcywgZGF0LnN1YmFycmF5KGksIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9wdCA9IGRlb1tsdmwgLSAxXTtcbiAgICAgICAgdmFyIG4gPSBvcHQgPj4+IDEzLCBjID0gb3B0ICYgODE5MTtcbiAgICAgICAgdmFyIG1za18xID0gKDEgPDwgcGx2bCkgLSAxO1xuICAgICAgICAvLyAgICBwcmV2IDItYnl0ZSB2YWwgbWFwICAgIGN1cnIgMi1ieXRlIHZhbCBtYXBcbiAgICAgICAgdmFyIHByZXYgPSBuZXcgdTE2KDMyNzY4KSwgaGVhZCA9IG5ldyB1MTYobXNrXzEgKyAxKTtcbiAgICAgICAgdmFyIGJzMV8xID0gTWF0aC5jZWlsKHBsdmwgLyAzKSwgYnMyXzEgPSAyICogYnMxXzE7XG4gICAgICAgIHZhciBoc2ggPSBmdW5jdGlvbiAoaSkgeyByZXR1cm4gKGRhdFtpXSBeIChkYXRbaSArIDFdIDw8IGJzMV8xKSBeIChkYXRbaSArIDJdIDw8IGJzMl8xKSkgJiBtc2tfMTsgfTtcbiAgICAgICAgLy8gMjQ1NzYgaXMgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBtYXhpbXVtIHN5bWJvbHMgcGVyIGJsb2NrXG4gICAgICAgIC8vIDQyNCBidWZmZXIgZm9yIGxhc3QgYmxvY2tcbiAgICAgICAgdmFyIHN5bXMgPSBuZXcgdTMyKDI1MDAwKTtcbiAgICAgICAgLy8gbGVuZ3RoL2xpdGVyYWwgZnJlcSAgIGRpc3RhbmNlIGZyZXFcbiAgICAgICAgdmFyIGxmID0gbmV3IHUxNigyODgpLCBkZiA9IG5ldyB1MTYoMzIpO1xuICAgICAgICAvLyAgbC9sY250ICBleGJpdHMgIGluZGV4ICBsL2xpbmQgIHdhaXRkeCAgYml0cG9zXG4gICAgICAgIHZhciBsY18xID0gMCwgZWIgPSAwLCBpID0gMCwgbGkgPSAwLCB3aSA9IDAsIGJzID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGhhc2ggdmFsdWVcbiAgICAgICAgICAgIC8vIGRlb3B0IHdoZW4gaSA+IHMgLSAzIC0gYXQgZW5kLCBkZW9wdCBhY2NlcHRhYmxlXG4gICAgICAgICAgICB2YXIgaHYgPSBoc2goaSk7XG4gICAgICAgICAgICAvLyBpbmRleCBtb2QgMzI3NjggICAgcHJldmlvdXMgaW5kZXggbW9kXG4gICAgICAgICAgICB2YXIgaW1vZCA9IGkgJiAzMjc2NywgcGltb2QgPSBoZWFkW2h2XTtcbiAgICAgICAgICAgIHByZXZbaW1vZF0gPSBwaW1vZDtcbiAgICAgICAgICAgIGhlYWRbaHZdID0gaW1vZDtcbiAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBzaG91bGQgbW9kaWZ5IGhlYWQgYW5kIHByZXYsIGJ1dCBvbmx5IGFkZCBzeW1ib2xzIGlmXG4gICAgICAgICAgICAvLyB0aGlzIGRhdGEgaXMgbm90IHlldCBwcm9jZXNzZWQgKFwid2FpdFwiIGZvciB3YWl0IGluZGV4KVxuICAgICAgICAgICAgaWYgKHdpIDw9IGkpIHtcbiAgICAgICAgICAgICAgICAvLyBieXRlcyByZW1haW5pbmdcbiAgICAgICAgICAgICAgICB2YXIgcmVtID0gcyAtIGk7XG4gICAgICAgICAgICAgICAgaWYgKChsY18xID4gNzAwMCB8fCBsaSA+IDI0NTc2KSAmJiByZW0gPiA0MjMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIDAsIHN5bXMsIGxmLCBkZiwgZWIsIGxpLCBicywgaSAtIGJzLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICBsaSA9IGxjXzEgPSBlYiA9IDAsIGJzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyODY7ICsrailcbiAgICAgICAgICAgICAgICAgICAgICAgIGxmW2pdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzMDsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGZbal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgbGVuICAgIGRpc3QgICBjaGFpblxuICAgICAgICAgICAgICAgIHZhciBsID0gMiwgZCA9IDAsIGNoXzEgPSBjLCBkaWYgPSAoaW1vZCAtIHBpbW9kKSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgIGlmIChyZW0gPiAyICYmIGh2ID09IGhzaChpIC0gZGlmKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4biA9IE1hdGgubWluKG4sIHJlbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ZCA9IE1hdGgubWluKDMyNzY3LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF4IHBvc3NpYmxlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgY2FwcGVkIGF0IGRpZiBiZWNhdXNlIGRlY29tcHJlc3NvcnMgaW1wbGVtZW50IFwicm9sbGluZ1wiIGluZGV4IHBvcHVsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1sID0gTWF0aC5taW4oMjU4LCByZW0pO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGlmIDw9IG1heGQgJiYgLS1jaF8xICYmIGltb2QgIT0gcGltb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRbaSArIGxdID09IGRhdFtpICsgbCAtIGRpZl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBubCA8IG1sICYmIGRhdFtpICsgbmxdID09IGRhdFtpICsgbmwgLSBkaWZdOyArK25sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gbmwsIGQgPSBkaWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrIG91dCBlYXJseSB3aGVuIHdlIHJlYWNoIFwibmljZVwiICh3ZSBhcmUgc2F0aXNmaWVkIGVub3VnaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbWF4bilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3csIGZpbmQgdGhlIHJhcmVzdCAyLWJ5dGUgc2VxdWVuY2Ugd2l0aGluIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxpdGVyYWxzIGFuZCBzZWFyY2ggZm9yIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVjaCBmYXN0ZXIgdGhhbiBqdXN0IHVzaW5nIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW1kID0gTWF0aC5taW4oZGlmLCBubCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1tZDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGkgPSAoaSAtIGRpZiArIGogKyAzMjc2OCkgJiAzMjc2NztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdGkgPSBwcmV2W3RpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZCA9ICh0aSAtIHB0aSArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNkID4gbWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWQgPSBjZCwgcGltb2QgPSB0aTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBwcmV2aW91cyBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1vZCA9IHBpbW9kLCBwaW1vZCA9IHByZXZbaW1vZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWYgKz0gKGltb2QgLSBwaW1vZCArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGQgd2lsbCBiZSBub256ZXJvIG9ubHkgd2hlbiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGJvdGggZGlzdCBhbmQgbGVuIGRhdGEgaW4gb25lIFVpbnQzMlxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyBpcyByZWNvZ25pemVkIGFzIGEgbGVuL2Rpc3Qgd2l0aCAyOHRoIGJpdCAoMl4yOClcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IDI2ODQzNTQ1NiB8IChyZXZmbFtsXSA8PCAxOCkgfCByZXZmZFtkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbiA9IHJldmZsW2xdICYgMzEsIGRpbiA9IHJldmZkW2RdICYgMzE7XG4gICAgICAgICAgICAgICAgICAgIGViICs9IGZsZWJbbGluXSArIGZkZWJbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZlsyNTcgKyBsaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2RmW2Rpbl07XG4gICAgICAgICAgICAgICAgICAgIHdpID0gaSArIGw7XG4gICAgICAgICAgICAgICAgICAgICsrbGNfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bXNbbGkrK10gPSBkYXRbaV07XG4gICAgICAgICAgICAgICAgICAgICsrbGZbZGF0W2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIGxzdCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVhc2llc3Qgd2F5IHRvIGF2b2lkIG5lZWRpbmcgdG8gbWFpbnRhaW4gc3RhdGVcbiAgICAgICAgaWYgKCFsc3QgJiYgcG9zICYgNylcbiAgICAgICAgICAgIHBvcyA9IHdmYmxrKHcsIHBvcyArIDEsIGV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhvLCAwLCBwcmUgKyBzaGZ0KHBvcykgKyBwb3N0KTtcbn07XG4vLyBDUkMzMiB0YWJsZVxudmFyIGNyY3QgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHQgPSBuZXcgSW50MzJBcnJheSgyNTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBpLCBrID0gOTtcbiAgICAgICAgd2hpbGUgKC0taylcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxKSAmJiAtMzA2Njc0OTEyKSBeIChjID4+PiAxKTtcbiAgICAgICAgdFtpXSA9IGM7XG4gICAgfVxuICAgIHJldHVybiB0O1xufSkoKTtcbi8vIENSQzMyXG52YXIgY3JjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjID0gLTE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIC8vIGNsb3N1cmVzIGhhdmUgYXdmdWwgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIHZhciBjciA9IGM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY3IgPSBjcmN0WyhjciAmIDI1NSkgXiBkW2ldXSBeIChjciA+Pj4gOCk7XG4gICAgICAgICAgICBjID0gY3I7XG4gICAgICAgIH0sXG4gICAgICAgIGQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIH5jOyB9XG4gICAgfTtcbn07XG4vLyBBbGRlcjMyXG52YXIgYWRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSAxLCBiID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gY2xvc3VyZXMgaGF2ZSBhd2Z1bCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgdmFyIG4gPSBhLCBtID0gYjtcbiAgICAgICAgICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPSBsOykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gTWF0aC5taW4oaSArIDI2NTUsIGwpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZTsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtICs9IG4gKz0gZFtpXTtcbiAgICAgICAgICAgICAgICBuID0gKG4gJiA2NTUzNSkgKyAxNSAqIChuID4+IDE2KSwgbSA9IChtICYgNjU1MzUpICsgMTUgKiAobSA+PiAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gbiwgYiA9IG07XG4gICAgICAgIH0sXG4gICAgICAgIGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGEgJT0gNjU1MjEsIGIgJT0gNjU1MjE7XG4gICAgICAgICAgICByZXR1cm4gKGEgJiAyNTUpIDw8IDI0IHwgKGEgPj4+IDgpIDw8IDE2IHwgKGIgJiAyNTUpIDw8IDggfCAoYiA+Pj4gOCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbjtcbi8vIGRlZmxhdGUgd2l0aCBvcHRzXG52YXIgZG9wdCA9IGZ1bmN0aW9uIChkYXQsIG9wdCwgcHJlLCBwb3N0LCBzdCkge1xuICAgIHJldHVybiBkZmx0KGRhdCwgb3B0LmxldmVsID09IG51bGwgPyA2IDogb3B0LmxldmVsLCBvcHQubWVtID09IG51bGwgPyBNYXRoLmNlaWwoTWF0aC5tYXgoOCwgTWF0aC5taW4oMTMsIE1hdGgubG9nKGRhdC5sZW5ndGgpKSkgKiAxLjUpIDogKDEyICsgb3B0Lm1lbSksIHByZSwgcG9zdCwgIXN0KTtcbn07XG4vLyBXYWxtYXJ0IG9iamVjdCBzcHJlYWRcbnZhciBtcmcgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBvID0ge307XG4gICAgZm9yICh2YXIgayBpbiBhKVxuICAgICAgICBvW2tdID0gYVtrXTtcbiAgICBmb3IgKHZhciBrIGluIGIpXG4gICAgICAgIG9ba10gPSBiW2tdO1xuICAgIHJldHVybiBvO1xufTtcbi8vIHdvcmtlciBjbG9uZVxuLy8gVGhpcyBpcyBwb3NzaWJseSB0aGUgY3Jhemllc3QgcGFydCBvZiB0aGUgZW50aXJlIGNvZGViYXNlLCBkZXNwaXRlIGhvdyBzaW1wbGUgaXQgbWF5IHNlZW0uXG4vLyBUaGUgb25seSBwYXJhbWV0ZXIgdG8gdGhpcyBmdW5jdGlvbiBpcyBhIGNsb3N1cmUgdGhhdCByZXR1cm5zIGFuIGFycmF5IG9mIHZhcmlhYmxlcyBvdXRzaWRlIG9mIHRoZSBmdW5jdGlvbiBzY29wZS5cbi8vIFdlJ3JlIGdvaW5nIHRvIHRyeSB0byBmaWd1cmUgb3V0IHRoZSB2YXJpYWJsZSBuYW1lcyB1c2VkIGluIHRoZSBjbG9zdXJlIGFzIHN0cmluZ3MgYmVjYXVzZSB0aGF0IGlzIGNydWNpYWwgZm9yIHdvcmtlcml6YXRpb24uXG4vLyBXZSB3aWxsIHJldHVybiBhbiBvYmplY3QgbWFwcGluZyBvZiB0cnVlIHZhcmlhYmxlIG5hbWUgdG8gdmFsdWUgKGJhc2ljYWxseSwgdGhlIGN1cnJlbnQgc2NvcGUgYXMgYSBKUyBvYmplY3QpLlxuLy8gVGhlIHJlYXNvbiB3ZSBjYW4ndCBqdXN0IHVzZSB0aGUgb3JpZ2luYWwgdmFyaWFibGUgbmFtZXMgaXMgbWluaWZpZXJzIG1hbmdsaW5nIHRoZSB0b3BsZXZlbCBzY29wZS5cbi8vIFRoaXMgdG9vayBtZSB0aHJlZSB3ZWVrcyB0byBmaWd1cmUgb3V0IGhvdyB0byBkby5cbnZhciB3Y2xuID0gZnVuY3Rpb24gKGZuLCBmblN0ciwgdGQpIHtcbiAgICB2YXIgZHQgPSBmbigpO1xuICAgIHZhciBzdCA9IGZuLnRvU3RyaW5nKCk7XG4gICAgdmFyIGtzID0gc3Quc2xpY2Uoc3QuaW5kZXhPZignWycpICsgMSwgc3QubGFzdEluZGV4T2YoJ10nKSkucmVwbGFjZSgvIC9nLCAnJykuc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB2ID0gZHRbaV0sIGsgPSBrc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGZuU3RyICs9ICc7JyArIGsgKyAnPSc7XG4gICAgICAgICAgICB2YXIgc3RfMSA9IHYudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh2LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGZvciBnbG9iYWwgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGlmIChzdF8xLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BJbmQgPSBzdF8xLmluZGV4T2YoJyAnLCA4KSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzEuc2xpY2Uoc3BJbmQsIHN0XzEuaW5kZXhPZignKCcsIHNwSW5kKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0IGluIHYucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gJzsnICsgayArICcucHJvdG90eXBlLicgKyB0ICsgJz0nICsgdi5wcm90b3R5cGVbdF0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZFtrXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBbZm5TdHIsIHRkXTtcbn07XG52YXIgY2ggPSBbXTtcbi8vIGNsb25lIGJ1ZnNcbnZhciBjYmZzID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgdGwgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIHYpIHtcbiAgICAgICAgaWYgKHZba10gaW5zdGFuY2VvZiB1OCB8fCB2W2tdIGluc3RhbmNlb2YgdTE2IHx8IHZba10gaW5zdGFuY2VvZiB1MzIpXG4gICAgICAgICAgICB0bC5wdXNoKCh2W2tdID0gbmV3IHZba10uY29uc3RydWN0b3IodltrXSkpLmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiB0bDtcbn07XG4vLyB1c2UgYSB3b3JrZXIgdG8gZXhlY3V0ZSBjb2RlXG52YXIgd3JrciA9IGZ1bmN0aW9uIChmbnMsIGluaXQsIGlkLCBjYikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWNoW2lkXSkge1xuICAgICAgICB2YXIgZm5TdHIgPSAnJywgdGRfMSA9IHt9LCBtID0gZm5zLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbTsgKytpKVxuICAgICAgICAgICAgX2EgPSB3Y2xuKGZuc1tpXSwgZm5TdHIsIHRkXzEpLCBmblN0ciA9IF9hWzBdLCB0ZF8xID0gX2FbMV07XG4gICAgICAgIGNoW2lkXSA9IHdjbG4oZm5zW21dLCBmblN0ciwgdGRfMSk7XG4gICAgfVxuICAgIHZhciB0ZCA9IG1yZyh7fSwgY2hbaWRdWzFdKTtcbiAgICByZXR1cm4gd2soY2hbaWRdWzBdICsgJztvbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7Zm9yKHZhciBrIGluIGUuZGF0YSlzZWxmW2tdPWUuZGF0YVtrXTtvbm1lc3NhZ2U9JyArIGluaXQudG9TdHJpbmcoKSArICd9JywgaWQsIHRkLCBjYmZzKHRkKSwgY2IpO1xufTtcbi8vIGJhc2UgYXN5bmMgaW5mbGF0ZSBmblxudmFyIGJJbmZsdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt1OCwgdTE2LCB1MzIsIGZsZWIsIGZkZWIsIGNsaW0sIGZsLCBmZCwgZmxybSwgZmRybSwgcmV2LCBoTWFwLCBtYXgsIGJpdHMsIGJpdHMxNiwgc2hmdCwgc2xjLCBpbmZsdCwgaW5mbGF0ZVN5bmMsIHBiZiwgZ3U4XTsgfTtcbnZhciBiRGZsdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt1OCwgdTE2LCB1MzIsIGZsZWIsIGZkZWIsIGNsaW0sIHJldmZsLCByZXZmZCwgZmxtLCBmbHQsIGZkbSwgZmR0LCByZXYsIGRlbywgZXQsIGhNYXAsIHdiaXRzLCB3Yml0czE2LCBoVHJlZSwgbG4sIGxjLCBjbGVuLCB3ZmJsaywgd2Jsaywgc2hmdCwgc2xjLCBkZmx0LCBkb3B0LCBkZWZsYXRlU3luYywgcGJmXTsgfTtcbi8vIGd6aXAgZXh0cmFcbnZhciBnemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3poLCBnemhsLCB3Ynl0ZXMsIGNyYywgY3JjdF07IH07XG4vLyBndW56aXAgZXh0cmFcbnZhciBndXplID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW2d6cywgZ3psXTsgfTtcbi8vIHpsaWIgZXh0cmFcbnZhciB6bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbemxoLCB3Ynl0ZXMsIGFkbGVyXTsgfTtcbi8vIHVuemxpYiBleHRyYVxudmFyIHp1bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbemx2XTsgfTtcbi8vIHBvc3QgYnVmXG52YXIgcGJmID0gZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gcG9zdE1lc3NhZ2UobXNnLCBbbXNnLmJ1ZmZlcl0pOyB9O1xuLy8gZ2V0IHU4XG52YXIgZ3U4ID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgby5zaXplICYmIG5ldyB1OChvLnNpemUpOyB9O1xuLy8gYXN5bmMgaGVscGVyXG52YXIgY2JpZnkgPSBmdW5jdGlvbiAoZGF0LCBvcHRzLCBmbnMsIGluaXQsIGlkLCBjYikge1xuICAgIHZhciB3ID0gd3JrcihmbnMsIGluaXQsIGlkLCBmdW5jdGlvbiAoZXJyLCBkYXQpIHtcbiAgICAgICAgdy50ZXJtaW5hdGUoKTtcbiAgICAgICAgY2IoZXJyLCBkYXQpO1xuICAgIH0pO1xuICAgIHcucG9zdE1lc3NhZ2UoW2RhdCwgb3B0c10sIG9wdHMuY29uc3VtZSA/IFtkYXQuYnVmZmVyXSA6IFtdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB3LnRlcm1pbmF0ZSgpOyB9O1xufTtcbi8vIGF1dG8gc3RyZWFtXG52YXIgYXN0cm0gPSBmdW5jdGlvbiAoc3RybSkge1xuICAgIHN0cm0ub25kYXRhID0gZnVuY3Rpb24gKGRhdCwgZmluYWwpIHsgcmV0dXJuIHBvc3RNZXNzYWdlKFtkYXQsIGZpbmFsXSwgW2RhdC5idWZmZXJdKTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2KSB7IHJldHVybiBzdHJtLnB1c2goZXYuZGF0YVswXSwgZXYuZGF0YVsxXSk7IH07XG59O1xuLy8gYXN5bmMgc3RyZWFtIGF0dGFjaFxudmFyIGFzdHJtaWZ5ID0gZnVuY3Rpb24gKGZucywgc3RybSwgb3B0cywgaW5pdCwgaWQpIHtcbiAgICB2YXIgdDtcbiAgICB2YXIgdyA9IHdya3IoZm5zLCBpbml0LCBpZCwgZnVuY3Rpb24gKGVyciwgZGF0KSB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICB3LnRlcm1pbmF0ZSgpLCBzdHJtLm9uZGF0YS5jYWxsKHN0cm0sIGVycik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRhdFsxXSlcbiAgICAgICAgICAgICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgc3RybS5vbmRhdGEuY2FsbChzdHJtLCBlcnIsIGRhdFswXSwgZGF0WzFdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHcucG9zdE1lc3NhZ2Uob3B0cyk7XG4gICAgc3RybS5wdXNoID0gZnVuY3Rpb24gKGQsIGYpIHtcbiAgICAgICAgaWYgKHQpXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgaWYgKCFzdHJtLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBzdHJlYW0gaGFuZGxlcic7XG4gICAgICAgIHcucG9zdE1lc3NhZ2UoW2QsIHQgPSBmXSwgW2QuYnVmZmVyXSk7XG4gICAgfTtcbiAgICBzdHJtLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uICgpIHsgdy50ZXJtaW5hdGUoKTsgfTtcbn07XG4vLyByZWFkIDIgYnl0ZXNcbnZhciBiMiA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBkW2JdIHwgKGRbYiArIDFdIDw8IDgpOyB9O1xuLy8gcmVhZCA0IGJ5dGVzXG52YXIgYjQgPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gKGRbYl0gfCAoZFtiICsgMV0gPDwgOCkgfCAoZFtiICsgMl0gPDwgMTYpIHwgKGRbYiArIDNdIDw8IDI0KSkgPj4+IDA7IH07XG52YXIgYjggPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gYjQoZCwgYikgKyAoYjQoZCwgYiArIDQpICogNDI5NDk2NzI5Nik7IH07XG4vLyB3cml0ZSBieXRlc1xudmFyIHdieXRlcyA9IGZ1bmN0aW9uIChkLCBiLCB2KSB7XG4gICAgZm9yICg7IHY7ICsrYilcbiAgICAgICAgZFtiXSA9IHYsIHYgPj4+PSA4O1xufTtcbi8vIGd6aXAgaGVhZGVyXG52YXIgZ3poID0gZnVuY3Rpb24gKGMsIG8pIHtcbiAgICB2YXIgZm4gPSBvLmZpbGVuYW1lO1xuICAgIGNbMF0gPSAzMSwgY1sxXSA9IDEzOSwgY1syXSA9IDgsIGNbOF0gPSBvLmxldmVsIDwgMiA/IDQgOiBvLmxldmVsID09IDkgPyAyIDogMCwgY1s5XSA9IDM7IC8vIGFzc3VtZSBVbml4XG4gICAgaWYgKG8ubXRpbWUgIT0gMClcbiAgICAgICAgd2J5dGVzKGMsIDQsIE1hdGguZmxvb3IobmV3IERhdGUoby5tdGltZSB8fCBEYXRlLm5vdygpKSAvIDEwMDApKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgICAgY1szXSA9IDg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGZuLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgY1tpICsgMTBdID0gZm4uY2hhckNvZGVBdChpKTtcbiAgICB9XG59O1xuLy8gZ3ppcCBmb290ZXI6IC04IHRvIC00ID0gQ1JDLCAtNCB0byAtMCBpcyBsZW5ndGhcbi8vIGd6aXAgc3RhcnRcbnZhciBnenMgPSBmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkWzBdICE9IDMxIHx8IGRbMV0gIT0gMTM5IHx8IGRbMl0gIT0gOClcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgZ3ppcCBkYXRhJztcbiAgICB2YXIgZmxnID0gZFszXTtcbiAgICB2YXIgc3QgPSAxMDtcbiAgICBpZiAoZmxnICYgNClcbiAgICAgICAgc3QgKz0gZFsxMF0gfCAoZFsxMV0gPDwgOCkgKyAyO1xuICAgIGZvciAodmFyIHpzID0gKGZsZyA+PiAzICYgMSkgKyAoZmxnID4+IDQgJiAxKTsgenMgPiAwOyB6cyAtPSAhZFtzdCsrXSlcbiAgICAgICAgO1xuICAgIHJldHVybiBzdCArIChmbGcgJiAyKTtcbn07XG4vLyBnemlwIGxlbmd0aFxudmFyIGd6bCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgdmFyIGwgPSBkLmxlbmd0aDtcbiAgICByZXR1cm4gKChkW2wgLSA0XSB8IGRbbCAtIDNdIDw8IDggfCBkW2wgLSAyXSA8PCAxNikgfCAoZFtsIC0gMV0gPDwgMjQpKSA+Pj4gMDtcbn07XG4vLyBnemlwIGhlYWRlciBsZW5ndGhcbnZhciBnemhsID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIDEwICsgKChvLmZpbGVuYW1lICYmIChvLmZpbGVuYW1lLmxlbmd0aCArIDEpKSB8fCAwKTsgfTtcbi8vIHpsaWIgaGVhZGVyXG52YXIgemxoID0gZnVuY3Rpb24gKGMsIG8pIHtcbiAgICB2YXIgbHYgPSBvLmxldmVsLCBmbCA9IGx2ID09IDAgPyAwIDogbHYgPCA2ID8gMSA6IGx2ID09IDkgPyAzIDogMjtcbiAgICBjWzBdID0gMTIwLCBjWzFdID0gKGZsIDw8IDYpIHwgKGZsID8gKDMyIC0gMiAqIGZsKSA6IDEpO1xufTtcbi8vIHpsaWIgdmFsaWRcbnZhciB6bHYgPSBmdW5jdGlvbiAoZCkge1xuICAgIGlmICgoZFswXSAmIDE1KSAhPSA4IHx8IChkWzBdID4+PiA0KSA+IDcgfHwgKChkWzBdIDw8IDggfCBkWzFdKSAlIDMxKSlcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgemxpYiBkYXRhJztcbiAgICBpZiAoZFsxXSAmIDMyKVxuICAgICAgICB0aHJvdyAnaW52YWxpZCB6bGliIGRhdGE6IHByZXNldCBkaWN0aW9uYXJpZXMgbm90IHN1cHBvcnRlZCc7XG59O1xuZnVuY3Rpb24gQXN5bmNDbXBTdHJtKG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYiAmJiB0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIHJldHVybiBvcHRzO1xufVxuLy8gemxpYiBmb290ZXI6IC00IHRvIC0wIGlzIEFkbGVyMzJcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb25cbiAqL1xudmFyIERlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmbGF0ZShvcHRzLCBjYikge1xuICAgICAgICBpZiAoIWNiICYmIHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgdGhpcy5vID0gb3B0cyB8fCB7fTtcbiAgICB9XG4gICAgRGVmbGF0ZS5wcm90b3R5cGUucCA9IGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgIHRoaXMub25kYXRhKGRvcHQoYywgdGhpcy5vLCAwLCAwLCAhZiksIGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIHN0cmVhbSBoYW5kbGVyJztcbiAgICAgICAgdGhpcy5kID0gZmluYWw7XG4gICAgICAgIHRoaXMucChjaHVuaywgZmluYWwgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgRGVmbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY0RlZmxhdGUob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGVdOyB9XG4gICAgICAgIF0sIHRoaXMsIEFzeW5jQ21wU3RybS5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBEZWZsYXRlKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDYpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jRGVmbGF0ZSB9O1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGUoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkRmbHQsXG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZGVmbGF0ZVN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCAwLCBjYik7XG59XG4vKipcbiAqIENvbXByZXNzZXMgZGF0YSB3aXRoIERFRkxBVEUgd2l0aG91dCBhbnkgd3JhcHBlclxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZGVmbGF0ZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZVN5bmMoZGF0YSwgb3B0cykge1xuICAgIHJldHVybiBkb3B0KGRhdGEsIG9wdHMgfHwge30sIDAsIDApO1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5mbGF0aW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGluZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5mbGF0ZShjYikge1xuICAgICAgICB0aGlzLnMgPSB7fTtcbiAgICAgICAgdGhpcy5wID0gbmV3IHU4KDApO1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICBJbmZsYXRlLnByb3RvdHlwZS5lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIHN0cmVhbSBoYW5kbGVyJztcbiAgICAgICAgdmFyIGwgPSB0aGlzLnAubGVuZ3RoO1xuICAgICAgICB2YXIgbiA9IG5ldyB1OChsICsgYy5sZW5ndGgpO1xuICAgICAgICBuLnNldCh0aGlzLnApLCBuLnNldChjLCBsKSwgdGhpcy5wID0gbjtcbiAgICB9O1xuICAgIEluZmxhdGUucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoZmluYWwpIHtcbiAgICAgICAgdGhpcy5kID0gdGhpcy5zLmkgPSBmaW5hbCB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGJ0cyA9IHRoaXMucy5iO1xuICAgICAgICB2YXIgZHQgPSBpbmZsdCh0aGlzLnAsIHRoaXMubywgdGhpcy5zKTtcbiAgICAgICAgdGhpcy5vbmRhdGEoc2xjKGR0LCBidHMsIHRoaXMucy5iKSwgdGhpcy5kKTtcbiAgICAgICAgdGhpcy5vID0gc2xjKGR0LCB0aGlzLnMuYiAtIDMyNzY4KSwgdGhpcy5zLmIgPSB0aGlzLm8ubGVuZ3RoO1xuICAgICAgICB0aGlzLnAgPSBzbGModGhpcy5wLCAodGhpcy5zLnAgLyA4KSB8IDApLCB0aGlzLnMucCAmPSA3O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgaW5mbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBmaW5hbCBjaHVua1xuICAgICAqL1xuICAgIEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMuZShjaHVuayksIHRoaXMuYyhmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBJbmZsYXRlIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0luZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgaW5mbGF0aW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGRlZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNJbmZsYXRlKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgSW5mbGF0ZV07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgSW5mbGF0ZSgpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDcpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jSW5mbGF0ZSB9O1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGUoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoaW5mbGF0ZVN5bmMoZXYuZGF0YVswXSwgZ3U4KGV2LmRhdGFbMV0pKSk7IH0sIDEsIGNiKTtcbn1cbi8qKlxuICogRXhwYW5kcyBERUZMQVRFIGRhdGEgd2l0aCBubyB3cmFwcGVyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBTYXZlcyBtZW1vcnkgaWYgeW91IGtub3cgdGhlIGRlY29tcHJlc3NlZCBzaXplIGFuZCBwcm92aWRlIGFuIG91dHB1dCBidWZmZXIgb2YgdGhhdCBsZW5ndGguXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiBpbmZsdChkYXRhLCBvdXQpO1xufVxuLy8gYmVmb3JlIHlvdSB5ZWxsIGF0IG1lIGZvciBub3QganVzdCB1c2luZyBleHRlbmRzLCBteSByZWFzb24gaXMgdGhhdCBUUyBpbmhlcml0YW5jZSBpcyBoYXJkIHRvIHdvcmtlcml6ZS5cbi8qKlxuICogU3RyZWFtaW5nIEdaSVAgY29tcHJlc3Npb25cbiAqL1xudmFyIEd6aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3ppcChvcHRzLCBjYikge1xuICAgICAgICB0aGlzLmMgPSBjcmMoKTtcbiAgICAgICAgdGhpcy5sID0gMDtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgRGVmbGF0ZS5jYWxsKHRoaXMsIG9wdHMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgR1pJUHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBHemlwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIEd6aXAucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB0aGlzLmMucChjKTtcbiAgICAgICAgdGhpcy5sICs9IGMubGVuZ3RoO1xuICAgICAgICB2YXIgcmF3ID0gZG9wdChjLCB0aGlzLm8sIHRoaXMudiAmJiBnemhsKHRoaXMubyksIGYgJiYgOCwgIWYpO1xuICAgICAgICBpZiAodGhpcy52KVxuICAgICAgICAgICAgZ3poKHJhdywgdGhpcy5vKSwgdGhpcy52ID0gMDtcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICB3Ynl0ZXMocmF3LCByYXcubGVuZ3RoIC0gOCwgdGhpcy5jLmQoKSksIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA0LCB0aGlzLmwpO1xuICAgICAgICB0aGlzLm9uZGF0YShyYXcsIGYpO1xuICAgIH07XG4gICAgcmV0dXJuIEd6aXA7XG59KCkpO1xuZXhwb3J0IHsgR3ppcCB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIEdaSVAgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jR3ppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY0d6aXAob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICBnemUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGUsIEd6aXBdOyB9XG4gICAgICAgIF0sIHRoaXMsIEFzeW5jQ21wU3RybS5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBHemlwKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDgpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNHemlwO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jR3ppcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIGd6aXAoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkRmbHQsXG4gICAgICAgIGd6ZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2d6aXBTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGd6aXBTeW5jKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pKTsgfSwgMiwgY2IpO1xufVxuLyoqXG4gKiBDb21wcmVzc2VzIGRhdGEgd2l0aCBHWklQXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBnemlwcGVkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGd6aXBTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgYyA9IGNyYygpLCBsID0gZGF0YS5sZW5ndGg7XG4gICAgYy5wKGRhdGEpO1xuICAgIHZhciBkID0gZG9wdChkYXRhLCBvcHRzLCBnemhsKG9wdHMpLCA4KSwgcyA9IGQubGVuZ3RoO1xuICAgIHJldHVybiBnemgoZCwgb3B0cyksIHdieXRlcyhkLCBzIC0gOCwgYy5kKCkpLCB3Ynl0ZXMoZCwgcyAtIDQsIGwpLCBkO1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBHdW56aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEdVTlpJUCBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBpbmZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEd1bnppcChjYikge1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICBJbmZsYXRlLmNhbGwodGhpcywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBHVU5aSVBwZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgR3VuemlwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5lLmNhbGwodGhpcywgY2h1bmspO1xuICAgICAgICBpZiAodGhpcy52KSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMucC5sZW5ndGggPiAzID8gZ3pzKHRoaXMucCkgOiA0O1xuICAgICAgICAgICAgaWYgKHMgPj0gdGhpcy5wLmxlbmd0aCAmJiAhZmluYWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KHMpLCB0aGlzLnYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPCA4KVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGd6aXAgc3RyZWFtJztcbiAgICAgICAgICAgIHRoaXMucCA9IHRoaXMucC5zdWJhcnJheSgwLCAtOCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVjZXNzYXJ5IHRvIHByZXZlbnQgVFMgZnJvbSB1c2luZyB0aGUgY2xvc3VyZSB2YWx1ZVxuICAgICAgICAvLyBUaGlzIGFsbG93cyBmb3Igd29ya2VyaXphdGlvbiB0byBmdW5jdGlvbiBjb3JyZWN0bHlcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuYy5jYWxsKHRoaXMsIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBHdW56aXA7XG59KCkpO1xuZXhwb3J0IHsgR3VuemlwIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0d1bnppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBHVU5aSVAgc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVmbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY0d1bnppcChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiSW5mbHQsXG4gICAgICAgICAgICBndXplLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBJbmZsYXRlLCBHdW56aXBdOyB9XG4gICAgICAgIF0sIHRoaXMsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IEd1bnppcCgpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDkpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNHdW56aXA7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNHdW56aXAgfTtcbmV4cG9ydCBmdW5jdGlvbiBndW56aXAoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0LFxuICAgICAgICBndXplLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3VuemlwU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihndW56aXBTeW5jKGV2LmRhdGFbMF0pKTsgfSwgMywgY2IpO1xufVxuLyoqXG4gKiBFeHBhbmRzIEdaSVAgZGF0YVxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG91dCBXaGVyZSB0byB3cml0ZSB0aGUgZGF0YS4gR1pJUCBhbHJlYWR5IGVuY29kZXMgdGhlIG91dHB1dCBzaXplLCBzbyBwcm92aWRpbmcgdGhpcyBkb2Vzbid0IHNhdmUgbWVtb3J5LlxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBndW56aXBTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiBpbmZsdChkYXRhLnN1YmFycmF5KGd6cyhkYXRhKSwgLTgpLCBvdXQgfHwgbmV3IHU4KGd6bChkYXRhKSkpO1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgWmxpYiBjb21wcmVzc2lvblxuICovXG52YXIgWmxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBabGliKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMuYyA9IGFkbGVyKCk7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIERlZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHpsaWJiZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmxpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICBabGliLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdGhpcy5jLnAoYyk7XG4gICAgICAgIHZhciByYXcgPSBkb3B0KGMsIHRoaXMubywgdGhpcy52ICYmIDIsIGYgJiYgNCwgIWYpO1xuICAgICAgICBpZiAodGhpcy52KVxuICAgICAgICAgICAgemxoKHJhdywgdGhpcy5vKSwgdGhpcy52ID0gMDtcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICB3Ynl0ZXMocmF3LCByYXcubGVuZ3RoIC0gNCwgdGhpcy5jLmQoKSk7XG4gICAgICAgIHRoaXMub25kYXRhKHJhdywgZik7XG4gICAgfTtcbiAgICByZXR1cm4gWmxpYjtcbn0oKSk7XG5leHBvcnQgeyBabGliIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgWmxpYiBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNabGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jWmxpYihvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIHpsZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZSwgWmxpYl07IH1cbiAgICAgICAgXSwgdGhpcywgQXN5bmNDbXBTdHJtLmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IFpsaWIoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNabGliO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jWmxpYiB9O1xuZXhwb3J0IGZ1bmN0aW9uIHpsaWIoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkRmbHQsXG4gICAgICAgIHpsZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW3psaWJTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKHpsaWJTeW5jKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pKTsgfSwgNCwgY2IpO1xufVxuLyoqXG4gKiBDb21wcmVzcyBkYXRhIHdpdGggWmxpYlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgemxpYi1jb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHpsaWJTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgYSA9IGFkbGVyKCk7XG4gICAgYS5wKGRhdGEpO1xuICAgIHZhciBkID0gZG9wdChkYXRhLCBvcHRzLCAyLCA0KTtcbiAgICByZXR1cm4gemxoKGQsIG9wdHMpLCB3Ynl0ZXMoZCwgZC5sZW5ndGggLSA0LCBhLmQoKSksIGQ7XG59XG4vKipcbiAqIFN0cmVhbWluZyBabGliIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIFVuemxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgWmxpYiBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGluZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gVW56bGliKGNiKSB7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIEluZmxhdGUuY2FsbCh0aGlzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHVuemxpYmJlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBVbnpsaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmUuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIGlmICh0aGlzLnYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoIDwgMiAmJiAhZmluYWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDIpLCB0aGlzLnYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPCA0KVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHpsaWIgc3RyZWFtJztcbiAgICAgICAgICAgIHRoaXMucCA9IHRoaXMucC5zdWJhcnJheSgwLCAtNCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVjZXNzYXJ5IHRvIHByZXZlbnQgVFMgZnJvbSB1c2luZyB0aGUgY2xvc3VyZSB2YWx1ZVxuICAgICAgICAvLyBUaGlzIGFsbG93cyBmb3Igd29ya2VyaXphdGlvbiB0byBmdW5jdGlvbiBjb3JyZWN0bHlcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuYy5jYWxsKHRoaXMsIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBVbnpsaWI7XG59KCkpO1xuZXhwb3J0IHsgVW56bGliIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgWmxpYiBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY1VuemxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBabGliIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVmbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY1VuemxpYihjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiSW5mbHQsXG4gICAgICAgICAgICB6dWxlLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBJbmZsYXRlLCBVbnpsaWJdOyB9XG4gICAgICAgIF0sIHRoaXMsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IFVuemxpYigpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDExKTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jVW56bGliO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jVW56bGliIH07XG5leHBvcnQgZnVuY3Rpb24gdW56bGliKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJJbmZsdCxcbiAgICAgICAgenVsZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW3VuemxpYlN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYodW56bGliU3luYyhldi5kYXRhWzBdLCBndTgoZXYuZGF0YVsxXSkpKTsgfSwgNSwgY2IpO1xufVxuLyoqXG4gKiBFeHBhbmRzIFpsaWIgZGF0YVxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG91dCBXaGVyZSB0byB3cml0ZSB0aGUgZGF0YS4gU2F2ZXMgbWVtb3J5IGlmIHlvdSBrbm93IHRoZSBkZWNvbXByZXNzZWQgc2l6ZSBhbmQgcHJvdmlkZSBhbiBvdXRwdXQgYnVmZmVyIG9mIHRoYXQgbGVuZ3RoLlxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnpsaWJTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiBpbmZsdCgoemx2KGRhdGEpLCBkYXRhLnN1YmFycmF5KDIsIC00KSksIG91dCk7XG59XG4vLyBEZWZhdWx0IGFsZ29yaXRobSBmb3IgY29tcHJlc3Npb24gKHVzZWQgYmVjYXVzZSBoYXZpbmcgYSBrbm93biBvdXRwdXQgc2l6ZSBhbGxvd3MgZmFzdGVyIGRlY29tcHJlc3Npb24pXG5leHBvcnQgeyBnemlwIGFzIGNvbXByZXNzLCBBc3luY0d6aXAgYXMgQXN5bmNDb21wcmVzcyB9O1xuLy8gRGVmYXVsdCBhbGdvcml0aG0gZm9yIGNvbXByZXNzaW9uICh1c2VkIGJlY2F1c2UgaGF2aW5nIGEga25vd24gb3V0cHV0IHNpemUgYWxsb3dzIGZhc3RlciBkZWNvbXByZXNzaW9uKVxuZXhwb3J0IHsgZ3ppcFN5bmMgYXMgY29tcHJlc3NTeW5jLCBHemlwIGFzIENvbXByZXNzIH07XG4vKipcbiAqIFN0cmVhbWluZyBHWklQLCBabGliLCBvciByYXcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBEZWNvbXByZXNzID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGRlY29tcHJlc3NlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY29tcHJlc3MoY2IpIHtcbiAgICAgICAgdGhpcy5HID0gR3VuemlwO1xuICAgICAgICB0aGlzLkkgPSBJbmZsYXRlO1xuICAgICAgICB0aGlzLlogPSBVbnpsaWI7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlY29tcHJlc3NlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIHN0cmVhbSBoYW5kbGVyJztcbiAgICAgICAgaWYgKCF0aGlzLnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAgJiYgdGhpcy5wLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG4uc2V0KHRoaXMucCksIG4uc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBjaHVuaztcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7IF90aGlzXzEub25kYXRhLmFwcGx5KF90aGlzXzEsIGFyZ3VtZW50cyk7IH07XG4gICAgICAgICAgICAgICAgdGhpcy5zID0gKHRoaXMucFswXSA9PSAzMSAmJiB0aGlzLnBbMV0gPT0gMTM5ICYmIHRoaXMucFsyXSA9PSA4KVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyB0aGlzLkcoY2IpXG4gICAgICAgICAgICAgICAgICAgIDogKCh0aGlzLnBbMF0gJiAxNSkgIT0gOCB8fCAodGhpcy5wWzBdID4+IDQpID4gNyB8fCAoKHRoaXMucFswXSA8PCA4IHwgdGhpcy5wWzFdKSAlIDMxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IHRoaXMuSShjYilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IHRoaXMuWihjYik7XG4gICAgICAgICAgICAgICAgdGhpcy5zLnB1c2godGhpcy5wLCBmaW5hbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnMucHVzaChjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29tcHJlc3M7XG59KCkpO1xuZXhwb3J0IHsgRGVjb21wcmVzcyB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jRGVjb21wcmVzcyA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVjb21wcmVzc2VkXG4gICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jRGVjb21wcmVzcyhjYikge1xuICAgICAgICB0aGlzLkcgPSBBc3luY0d1bnppcDtcbiAgICAgICAgdGhpcy5JID0gQXN5bmNJbmZsYXRlO1xuICAgICAgICB0aGlzLlogPSBBc3luY1VuemxpYjtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVjb21wcmVzc2VkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEFzeW5jRGVjb21wcmVzcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgRGVjb21wcmVzcy5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNEZWNvbXByZXNzO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jRGVjb21wcmVzcyB9O1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcHJlc3MoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIChkYXRhWzBdID09IDMxICYmIGRhdGFbMV0gPT0gMTM5ICYmIGRhdGFbMl0gPT0gOClcbiAgICAgICAgPyBndW56aXAoZGF0YSwgb3B0cywgY2IpXG4gICAgICAgIDogKChkYXRhWzBdICYgMTUpICE9IDggfHwgKGRhdGFbMF0gPj4gNCkgPiA3IHx8ICgoZGF0YVswXSA8PCA4IHwgZGF0YVsxXSkgJSAzMSkpXG4gICAgICAgICAgICA/IGluZmxhdGUoZGF0YSwgb3B0cywgY2IpXG4gICAgICAgICAgICA6IHVuemxpYihkYXRhLCBvcHRzLCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgY29tcHJlc3NlZCBHWklQLCBabGliLCBvciByYXcgREVGTEFURSBkYXRhLCBhdXRvbWF0aWNhbGx5IGRldGVjdGluZyB0aGUgZm9ybWF0XG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBTYXZlcyBtZW1vcnkgaWYgeW91IGtub3cgdGhlIGRlY29tcHJlc3NlZCBzaXplIGFuZCBwcm92aWRlIGFuIG91dHB1dCBidWZmZXIgb2YgdGhhdCBsZW5ndGguXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcHJlc3NTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiAoZGF0YVswXSA9PSAzMSAmJiBkYXRhWzFdID09IDEzOSAmJiBkYXRhWzJdID09IDgpXG4gICAgICAgID8gZ3VuemlwU3luYyhkYXRhLCBvdXQpXG4gICAgICAgIDogKChkYXRhWzBdICYgMTUpICE9IDggfHwgKGRhdGFbMF0gPj4gNCkgPiA3IHx8ICgoZGF0YVswXSA8PCA4IHwgZGF0YVsxXSkgJSAzMSkpXG4gICAgICAgICAgICA/IGluZmxhdGVTeW5jKGRhdGEsIG91dClcbiAgICAgICAgICAgIDogdW56bGliU3luYyhkYXRhLCBvdXQpO1xufVxuLy8gZmxhdHRlbiBhIGRpcmVjdG9yeSBzdHJ1Y3R1cmVcbnZhciBmbHRuID0gZnVuY3Rpb24gKGQsIHAsIHQsIG8pIHtcbiAgICBmb3IgKHZhciBrIGluIGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRba10sIG4gPSBwICsgaztcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIHU4KVxuICAgICAgICAgICAgdFtuXSA9IFt2YWwsIG9dO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICAgICAgICB0W25dID0gW3ZhbFswXSwgbXJnKG8sIHZhbFsxXSldO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmbHRuKHZhbCwgbiArICcvJywgdCwgbyk7XG4gICAgfVxufTtcbi8vIHRleHQgZW5jb2RlclxudmFyIHRlID0gdHlwZW9mIFRleHRFbmNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG4vLyB0ZXh0IGRlY29kZXJcbnZhciB0ZCA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPSAndW5kZWZpbmVkJyAmJiAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RGVjb2RlcigpO1xuLy8gdGV4dCBkZWNvZGVyIHN0cmVhbVxudmFyIHRkcyA9IDA7XG50cnkge1xuICAgIHRkLmRlY29kZShldCwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgdGRzID0gMTtcbn1cbmNhdGNoIChlKSB7IH1cbi8vIGRlY29kZSBVVEY4XG52YXIgZHV0ZjggPSBmdW5jdGlvbiAoZCkge1xuICAgIGZvciAodmFyIHIgPSAnJywgaSA9IDA7Oykge1xuICAgICAgICB2YXIgYyA9IGRbaSsrXTtcbiAgICAgICAgdmFyIGViID0gKGMgPiAxMjcpICsgKGMgPiAyMjMpICsgKGMgPiAyMzkpO1xuICAgICAgICBpZiAoaSArIGViID4gZC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gW3IsIHNsYyhkLCBpIC0gMSldO1xuICAgICAgICBpZiAoIWViKVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICBlbHNlIGlmIChlYiA9PSAzKSB7XG4gICAgICAgICAgICBjID0gKChjICYgMTUpIDw8IDE4IHwgKGRbaSsrXSAmIDYzKSA8PCAxMiB8IChkW2krK10gJiA2MykgPDwgNiB8IChkW2krK10gJiA2MykpIC0gNjU1MzYsXG4gICAgICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgKGMgPj4gMTApLCA1NjMyMCB8IChjICYgMTAyMykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGViICYgMSlcbiAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDMxKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChkW2krK10gJiA2MykgPDwgNiB8IChkW2krK10gJiA2MykpO1xuICAgIH1cbn07XG4vKipcbiAqIFN0cmVhbWluZyBVVEYtOCBkZWNvZGluZ1xuICovXG52YXIgRGVjb2RlVVRGOCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVVRGLTggZGVjb2Rpbmcgc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVjb2RlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY29kZVVURjgoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgaWYgKHRkcylcbiAgICAgICAgICAgIHRoaXMudCA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnAgPSBldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVjb2RlZCBmcm9tIFVURi04IGJpbmFyeVxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWNvZGVVVEY4LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICAgICAgZmluYWwgPSAhIWZpbmFsO1xuICAgICAgICBpZiAodGhpcy50KSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YSh0aGlzLnQuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KSwgZmluYWwpO1xuICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudC5kZWNvZGUoKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHV0Zi04IGRhdGEnO1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnApXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgdmFyIGRhdCA9IG5ldyB1OCh0aGlzLnAubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgZGF0LnNldCh0aGlzLnApO1xuICAgICAgICBkYXQuc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgY2ggPSBfYVswXSwgbnAgPSBfYVsxXTtcbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAobnAubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHV0Zi04IGRhdGEnO1xuICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnAgPSBucDtcbiAgICAgICAgdGhpcy5vbmRhdGEoY2gsIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNvZGVVVEY4O1xufSgpKTtcbmV4cG9ydCB7IERlY29kZVVURjggfTtcbi8qKlxuICogU3RyZWFtaW5nIFVURi04IGVuY29kaW5nXG4gKi9cbnZhciBFbmNvZGVVVEY4ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVEYtOCBkZWNvZGluZyBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBlbmNvZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRW5jb2RlVVRGOChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBlbmNvZGVkIHRvIFVURi04XG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBzdHJpbmcgZGF0YSB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEVuY29kZVVURjgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIHRoaXMub25kYXRhKHN0clRvVTgoY2h1bmspLCB0aGlzLmQgPSBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRW5jb2RlVVRGODtcbn0oKSk7XG5leHBvcnQgeyBFbmNvZGVVVEY4IH07XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBVaW50OEFycmF5IGZvciB1c2Ugd2l0aCBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIG1ldGhvZHNcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGRlY29kaW5nIGEgYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcgZW5jb2RlZCBpbiBVVEYtOC9MYXRpbi0xIGJpbmFyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyVG9VOChzdHIsIGxhdGluMSkge1xuICAgIGlmIChsYXRpbjEpIHtcbiAgICAgICAgdmFyIGFyXzEgPSBuZXcgdTgoc3RyLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYXJfMVtpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICByZXR1cm4gYXJfMTtcbiAgICB9XG4gICAgaWYgKHRlKVxuICAgICAgICByZXR1cm4gdGUuZW5jb2RlKHN0cik7XG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuICAgIHZhciBhciA9IG5ldyB1OChzdHIubGVuZ3RoICsgKHN0ci5sZW5ndGggPj4gMSkpO1xuICAgIHZhciBhaSA9IDA7XG4gICAgdmFyIHcgPSBmdW5jdGlvbiAodikgeyBhclthaSsrXSA9IHY7IH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgaWYgKGFpICsgNSA+IGFyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG4gPSBuZXcgdTgoYWkgKyA4ICsgKChsIC0gaSkgPDwgMSkpO1xuICAgICAgICAgICAgbi5zZXQoYXIpO1xuICAgICAgICAgICAgYXIgPSBuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4IHx8IGxhdGluMSlcbiAgICAgICAgICAgIHcoYyk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxuICAgICAgICAgICAgdygxOTIgfCAoYyA+PiA2KSksIHcoMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICBlbHNlIGlmIChjID4gNTUyOTUgJiYgYyA8IDU3MzQ0KVxuICAgICAgICAgICAgYyA9IDY1NTM2ICsgKGMgJiAxMDIzIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMTAyMyksXG4gICAgICAgICAgICAgICAgdygyNDAgfCAoYyA+PiAxOCkpLCB3KDEyOCB8ICgoYyA+PiAxMikgJiA2MykpLCB3KDEyOCB8ICgoYyA+PiA2KSAmIDYzKSksIHcoMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3KDIyNCB8IChjID4+IDEyKSksIHcoMTI4IHwgKChjID4+IDYpICYgNjMpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgfVxuICAgIHJldHVybiBzbGMoYXIsIDAsIGFpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0gZGF0IFRoZSBkYXRhIHRvIGRlY29kZSB0byBzdHJpbmdcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGVuY29kaW5nIHRvIGJpbmFyeSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgb3JpZ2luYWwgVVRGLTgvTGF0aW4tMSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0ckZyb21VOChkYXQsIGxhdGluMSkge1xuICAgIGlmIChsYXRpbjEpIHtcbiAgICAgICAgdmFyIHIgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXQubGVuZ3RoOyBpICs9IDE2Mzg0KVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdC5zdWJhcnJheShpLCBpICsgMTYzODQpKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRkKVxuICAgICAgICByZXR1cm4gdGQuZGVjb2RlKGRhdCk7XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBfYSA9IGR1dGY4KGRhdCksIG91dCA9IF9hWzBdLCBleHQgPSBfYVsxXTtcbiAgICAgICAgaWYgKGV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB1dGYtOCBkYXRhJztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59XG47XG4vLyBkZWZsYXRlIGJpdCBmbGFnXG52YXIgZGJmID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwgPT0gMSA/IDMgOiBsIDwgNiA/IDIgOiBsID09IDkgPyAxIDogMDsgfTtcbi8vIHNraXAgbG9jYWwgemlwIGhlYWRlclxudmFyIHNsemggPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gYiArIDMwICsgYjIoZCwgYiArIDI2KSArIGIyKGQsIGIgKyAyOCk7IH07XG4vLyByZWFkIHppcCBoZWFkZXJcbnZhciB6aCA9IGZ1bmN0aW9uIChkLCBiLCB6KSB7XG4gICAgdmFyIGZubCA9IGIyKGQsIGIgKyAyOCksIGZuID0gc3RyRnJvbVU4KGQuc3ViYXJyYXkoYiArIDQ2LCBiICsgNDYgKyBmbmwpLCAhKGIyKGQsIGIgKyA4KSAmIDIwNDgpKSwgZXMgPSBiICsgNDYgKyBmbmwsIGJzID0gYjQoZCwgYiArIDIwKTtcbiAgICB2YXIgX2EgPSB6ICYmIGJzID09IDQyOTQ5NjcyOTUgPyB6NjRlKGQsIGVzKSA6IFticywgYjQoZCwgYiArIDI0KSwgYjQoZCwgYiArIDQyKV0sIHNjID0gX2FbMF0sIHN1ID0gX2FbMV0sIG9mZiA9IF9hWzJdO1xuICAgIHJldHVybiBbYjIoZCwgYiArIDEwKSwgc2MsIHN1LCBmbiwgZXMgKyBiMihkLCBiICsgMzApICsgYjIoZCwgYiArIDMyKSwgb2ZmXTtcbn07XG4vLyByZWFkIHppcDY0IGV4dHJhIGZpZWxkXG52YXIgejY0ZSA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICg7IGIyKGQsIGIpICE9IDE7IGIgKz0gNCArIGIyKGQsIGIgKyAyKSlcbiAgICAgICAgO1xuICAgIHJldHVybiBbYjgoZCwgYiArIDEyKSwgYjgoZCwgYiArIDQpLCBiOChkLCBiICsgMjApXTtcbn07XG4vLyBleHRyYSBmaWVsZCBsZW5ndGhcbnZhciBleGZsID0gZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIGxlID0gMDtcbiAgICBpZiAoZXgpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBleCkge1xuICAgICAgICAgICAgdmFyIGwgPSBleFtrXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobCA+IDY1NTM1KVxuICAgICAgICAgICAgICAgIHRocm93ICdleHRyYSBmaWVsZCB0b28gbG9uZyc7XG4gICAgICAgICAgICBsZSArPSBsICsgNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGU7XG59O1xuLy8gd3JpdGUgemlwIGhlYWRlclxudmFyIHd6aCA9IGZ1bmN0aW9uIChkLCBiLCBmLCBmbiwgdSwgYywgY2UsIGNvKSB7XG4gICAgdmFyIGZsID0gZm4ubGVuZ3RoLCBleCA9IGYuZXh0cmEsIGNvbCA9IGNvICYmIGNvLmxlbmd0aDtcbiAgICB2YXIgZXhsID0gZXhmbChleCk7XG4gICAgd2J5dGVzKGQsIGIsIGNlICE9IG51bGwgPyAweDIwMTRCNTAgOiAweDQwMzRCNTApLCBiICs9IDQ7XG4gICAgaWYgKGNlICE9IG51bGwpXG4gICAgICAgIGRbYisrXSA9IDIwLCBkW2IrK10gPSBmLm9zO1xuICAgIGRbYl0gPSAyMCwgYiArPSAyOyAvLyBzcGVjIGNvbXBsaWFuY2U/IHdoYXQncyB0aGF0P1xuICAgIGRbYisrXSA9IChmLmZsYWcgPDwgMSkgfCAoYyA9PSBudWxsICYmIDgpLCBkW2IrK10gPSB1ICYmIDg7XG4gICAgZFtiKytdID0gZi5jb21wcmVzc2lvbiAmIDI1NSwgZFtiKytdID0gZi5jb21wcmVzc2lvbiA+PiA4O1xuICAgIHZhciBkdCA9IG5ldyBEYXRlKGYubXRpbWUgPT0gbnVsbCA/IERhdGUubm93KCkgOiBmLm10aW1lKSwgeSA9IGR0LmdldEZ1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGlmICh5IDwgMCB8fCB5ID4gMTE5KVxuICAgICAgICB0aHJvdyAnZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5JztcbiAgICB3Ynl0ZXMoZCwgYiwgKHkgPDwgMjUpIHwgKChkdC5nZXRNb250aCgpICsgMSkgPDwgMjEpIHwgKGR0LmdldERhdGUoKSA8PCAxNikgfCAoZHQuZ2V0SG91cnMoKSA8PCAxMSkgfCAoZHQuZ2V0TWludXRlcygpIDw8IDUpIHwgKGR0LmdldFNlY29uZHMoKSA+Pj4gMSkpLCBiICs9IDQ7XG4gICAgaWYgKGMgIT0gbnVsbCkge1xuICAgICAgICB3Ynl0ZXMoZCwgYiwgZi5jcmMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDQsIGMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDgsIGYuc2l6ZSk7XG4gICAgfVxuICAgIHdieXRlcyhkLCBiICsgMTIsIGZsKTtcbiAgICB3Ynl0ZXMoZCwgYiArIDE0LCBleGwpLCBiICs9IDE2O1xuICAgIGlmIChjZSAhPSBudWxsKSB7XG4gICAgICAgIHdieXRlcyhkLCBiLCBjb2wpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDYsIGYuYXR0cnMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDEwLCBjZSksIGIgKz0gMTQ7XG4gICAgfVxuICAgIGQuc2V0KGZuLCBiKTtcbiAgICBiICs9IGZsO1xuICAgIGlmIChleGwpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBleCkge1xuICAgICAgICAgICAgdmFyIGV4ZiA9IGV4W2tdLCBsID0gZXhmLmxlbmd0aDtcbiAgICAgICAgICAgIHdieXRlcyhkLCBiLCArayk7XG4gICAgICAgICAgICB3Ynl0ZXMoZCwgYiArIDIsIGwpO1xuICAgICAgICAgICAgZC5zZXQoZXhmLCBiICsgNCksIGIgKz0gNCArIGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbClcbiAgICAgICAgZC5zZXQoY28sIGIpLCBiICs9IGNvbDtcbiAgICByZXR1cm4gYjtcbn07XG4vLyB3cml0ZSB6aXAgZm9vdGVyIChlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkpXG52YXIgd3pmID0gZnVuY3Rpb24gKG8sIGIsIGMsIGQsIGUpIHtcbiAgICB3Ynl0ZXMobywgYiwgMHg2MDU0QjUwKTsgLy8gc2tpcCBkaXNrXG4gICAgd2J5dGVzKG8sIGIgKyA4LCBjKTtcbiAgICB3Ynl0ZXMobywgYiArIDEwLCBjKTtcbiAgICB3Ynl0ZXMobywgYiArIDEyLCBkKTtcbiAgICB3Ynl0ZXMobywgYiArIDE2LCBlKTtcbn07XG4vKipcbiAqIEEgcGFzcy10aHJvdWdoIHN0cmVhbSB0byBrZWVwIGRhdGEgdW5jb21wcmVzc2VkIGluIGEgWklQIGFyY2hpdmUuXG4gKi9cbnZhciBaaXBQYXNzVGhyb3VnaCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFzcy10aHJvdWdoIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaaXBQYXNzVGhyb3VnaChmaWxlbmFtZSkge1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMuYyA9IGNyYygpO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGEgY2h1bmsgYW5kIHB1c2hlcyB0byB0aGUgb3V0cHV0IHN0cmVhbS4gWW91IGNhbiBvdmVycmlkZSB0aGlzXG4gICAgICogbWV0aG9kIGluIGEgc3ViY2xhc3MgZm9yIGN1c3RvbSBiZWhhdmlvciwgYnV0IGJ5IGRlZmF1bHQgdGhpcyBwYXNzZXNcbiAgICAgKiB0aGUgZGF0YSB0aHJvdWdoLiBZb3UgbXVzdCBjYWxsIHRoaXMub25kYXRhKGVyciwgY2h1bmssIGZpbmFsKSBhdCBzb21lXG4gICAgICogcG9pbnQgaW4gdGhpcyBtZXRob2QuXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwcm9jZXNzXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgYWRkZWQuIElmIHlvdSBhcmUgc3ViY2xhc3NpbmcgdGhpcyB3aXRoIGEgY3VzdG9tXG4gICAgICogY29tcHJlc3Npb24gYWxnb3JpdGhtLCBub3RlIHRoYXQgeW91IG11c3QgcHVzaCBkYXRhIGZyb20gdGhlIHNvdXJjZVxuICAgICAqIGZpbGUgb25seSwgcHJlLWNvbXByZXNzaW9uLlxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBaaXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayAtIGFkZCB0byBaSVAgYXJjaGl2ZSBiZWZvcmUgcHVzaGluZyc7XG4gICAgICAgIHRoaXMuYy5wKGNodW5rKTtcbiAgICAgICAgdGhpcy5zaXplICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGZpbmFsKVxuICAgICAgICAgICAgdGhpcy5jcmMgPSB0aGlzLmMuZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3MoY2h1bmssIGZpbmFsIHx8IGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBQYXNzVGhyb3VnaDtcbn0oKSk7XG5leHBvcnQgeyBaaXBQYXNzVGhyb3VnaCB9O1xuLy8gSSBkb24ndCBleHRlbmQgYmVjYXVzZSBUeXBlU2NyaXB0IGV4dGVuc2lvbiBhZGRzIDFrQiBvZiBydW50aW1lIGJsb2F0XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXMuIFByZWZlciB1c2luZyBBc3luY1ppcERlZmxhdGVcbiAqIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAqL1xudmFyIFppcERlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gWmlwRGVmbGF0ZShmaWxlbmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0cylcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2guY2FsbCh0aGlzLCBmaWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZCA9IG5ldyBEZWZsYXRlKG9wdHMsIGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpc18xLm9uZGF0YShudWxsLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSA4O1xuICAgICAgICB0aGlzLmZsYWcgPSBkYmYob3B0cy5sZXZlbCk7XG4gICAgfVxuICAgIFppcERlZmxhdGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmQucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlLCBudWxsLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IFppcERlZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXNcbiAqL1xudmFyIEFzeW5jWmlwRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBzdHJlYW0gdGhhdCBjYW4gYmUgYWRkZWQgdG8gWklQIGFyY2hpdmVzXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIFRoZSBmaWxlbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRhdGEgc3RyZWFtXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY1ppcERlZmxhdGUoZmlsZW5hbWUsIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdHMpXG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLmNhbGwodGhpcywgZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmQgPSBuZXcgQXN5bmNEZWZsYXRlKG9wdHMsIGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzXzEub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uID0gODtcbiAgICAgICAgdGhpcy5mbGFnID0gZGJmKG9wdHMubGV2ZWwpO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZSA9IHRoaXMuZC50ZXJtaW5hdGU7XG4gICAgfVxuICAgIEFzeW5jWmlwRGVmbGF0ZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5kLnB1c2goY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEFzeW5jWmlwRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jWmlwRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBBc3luY1ppcERlZmxhdGUgfTtcbi8vIFRPRE86IEJldHRlciB0cmVlIHNoYWtpbmdcbi8qKlxuICogQSB6aXBwYWJsZSBhcmNoaXZlIHRvIHdoaWNoIGZpbGVzIGNhbiBpbmNyZW1lbnRhbGx5IGJlIGFkZGVkXG4gKi9cbnZhciBaaXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlbXB0eSBaSVAgYXJjaGl2ZSB0byB3aGljaCBmaWxlcyBjYW4gYmUgYWRkZWRcbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBmb3IgdGhlIGdlbmVyYXRlZCBaSVAgYXJjaGl2ZVxuICAgICAqICAgICAgICAgICBpcyBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaaXAoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgdGhpcy51ID0gW107XG4gICAgICAgIHRoaXMuZCA9IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmaWxlIHRvIHRoZSBaSVAgYXJjaGl2ZVxuICAgICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHN0cmVhbSB0byBhZGRcbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZCAmIDIpXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZpbGUuZmlsZW5hbWUpLCBmbCA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gZmlsZS5jb21tZW50LCBvID0gY29tICYmIHN0clRvVTgoY29tKTtcbiAgICAgICAgdmFyIHUgPSBmbCAhPSBmaWxlLmZpbGVuYW1lLmxlbmd0aCB8fCAobyAmJiAoY29tLmxlbmd0aCAhPSBvLmxlbmd0aCkpO1xuICAgICAgICB2YXIgaGwgPSBmbCArIGV4ZmwoZmlsZS5leHRyYSkgKyAzMDtcbiAgICAgICAgaWYgKGZsID4gNjU1MzUpXG4gICAgICAgICAgICB0aHJvdyAnZmlsZW5hbWUgdG9vIGxvbmcnO1xuICAgICAgICB2YXIgaGVhZGVyID0gbmV3IHU4KGhsKTtcbiAgICAgICAgd3poKGhlYWRlciwgMCwgZmlsZSwgZiwgdSk7XG4gICAgICAgIHZhciBjaGtzID0gW2hlYWRlcl07XG4gICAgICAgIHZhciBwQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGtzXzEgPSBjaGtzOyBfaSA8IGNoa3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hrID0gY2hrc18xW19pXTtcbiAgICAgICAgICAgICAgICBfdGhpc18xLm9uZGF0YShudWxsLCBjaGssIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoa3MgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRyID0gdGhpcy5kO1xuICAgICAgICB0aGlzLmQgPSAwO1xuICAgICAgICB2YXIgaW5kID0gdGhpcy51Lmxlbmd0aDtcbiAgICAgICAgdmFyIHVmID0gbXJnKGZpbGUsIHtcbiAgICAgICAgICAgIGY6IGYsXG4gICAgICAgICAgICB1OiB1LFxuICAgICAgICAgICAgbzogbyxcbiAgICAgICAgICAgIHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS50ZXJtaW5hdGUpXG4gICAgICAgICAgICAgICAgICAgIGZpbGUudGVybWluYXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBBbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAodHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG54dCA9IF90aGlzXzEudVtpbmQgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG54dClcbiAgICAgICAgICAgICAgICAgICAgICAgIG54dC5yKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzXzEuZCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjbCA9IDA7XG4gICAgICAgIGZpbGUub25kYXRhID0gZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsICs9IGRhdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY2hrcy5wdXNoKGRhdCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZCA9IG5ldyB1OCgxNik7XG4gICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgMCwgMHg4MDc0QjUwKTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCA0LCBmaWxlLmNyYyk7XG4gICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgOCwgY2wpO1xuICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDEyLCBmaWxlLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICBjaGtzLnB1c2goZGQpO1xuICAgICAgICAgICAgICAgICAgICB1Zi5jID0gY2wsIHVmLmIgPSBobCArIGNsICsgMTYsIHVmLmNyYyA9IGZpbGUuY3JjLCB1Zi5zaXplID0gZmlsZS5zaXplO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICAgICAgICAgICAgICB1Zi5yKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHIpXG4gICAgICAgICAgICAgICAgICAgIHBBbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51LnB1c2godWYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5kcyB0aGUgcHJvY2VzcyBvZiBhZGRpbmcgZmlsZXMgYW5kIHByZXBhcmVzIHRvIGVtaXQgdGhlIGZpbmFsIGNodW5rcy5cbiAgICAgKiBUaGlzICptdXN0KiBiZSBjYWxsZWQgYWZ0ZXIgYWRkaW5nIGFsbCBkZXNpcmVkIGZpbGVzIGZvciB0aGUgcmVzdWx0aW5nXG4gICAgICogWklQIGZpbGUgdG8gd29yayBwcm9wZXJseS5cbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kICYgMikge1xuICAgICAgICAgICAgaWYgKHRoaXMuZCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hpbmcnO1xuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIHRoaXMuZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnUucHVzaCh7XG4gICAgICAgICAgICAgICAgcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShfdGhpc18xLmQgJiAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS51LnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzXzEuZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdDogZnVuY3Rpb24gKCkgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kID0gMztcbiAgICB9O1xuICAgIFppcC5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ0ID0gMCwgbCA9IDAsIHRsID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2FbX2ldO1xuICAgICAgICAgICAgdGwgKz0gNDYgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKSArIChmLm8gPyBmLm8ubGVuZ3RoIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IG5ldyB1OCh0bCArIDIyKTtcbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMudTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2NbX2JdO1xuICAgICAgICAgICAgd3poKG91dCwgYnQsIGYsIGYuZiwgZi51LCBmLmMsIGwsIGYubyk7XG4gICAgICAgICAgICBidCArPSA0NiArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpICsgKGYubyA/IGYuby5sZW5ndGggOiAwKSwgbCArPSBmLmI7XG4gICAgICAgIH1cbiAgICAgICAgd3pmKG91dCwgYnQsIHRoaXMudS5sZW5ndGgsIHRsLCBsKTtcbiAgICAgICAgdGhpcy5vbmRhdGEobnVsbCwgb3V0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5kID0gMjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgbWV0aG9kIHRvIHRlcm1pbmF0ZSBhbnkgaW50ZXJuYWwgd29ya2VycyB1c2VkIGJ5IHRoZSBzdHJlYW0uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byBhZGQoKSB3aWxsIGZhaWwuXG4gICAgICovXG4gICAgWmlwLnByb3RvdHlwZS50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnU7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9hW19pXTtcbiAgICAgICAgICAgIGYudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZCA9IDI7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwO1xufSgpKTtcbmV4cG9ydCB7IFppcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIHppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICB2YXIgciA9IHt9O1xuICAgIGZsdG4oZGF0YSwgJycsIHIsIG9wdHMpO1xuICAgIHZhciBrID0gT2JqZWN0LmtleXMocik7XG4gICAgdmFyIGxmdCA9IGsubGVuZ3RoLCBvID0gMCwgdG90ID0gMDtcbiAgICB2YXIgc2xmdCA9IGxmdCwgZmlsZXMgPSBuZXcgQXJyYXkobGZ0KTtcbiAgICB2YXIgdGVybSA9IFtdO1xuICAgIHZhciB0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlcm0ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0ZXJtW2ldKCk7XG4gICAgfTtcbiAgICB2YXIgY2JmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IHU4KHRvdCArIDIyKSwgb2UgPSBvLCBjZGwgPSB0b3QgLSBvO1xuICAgICAgICB0b3QgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsZnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBmLmMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHd6aChvdXQsIHRvdCwgZiwgZi5mLCBmLnUsIGwpO1xuICAgICAgICAgICAgICAgIHZhciBiYWRkID0gMzAgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jID0gdG90ICsgYmFkZDtcbiAgICAgICAgICAgICAgICBvdXQuc2V0KGYuYywgbG9jKTtcbiAgICAgICAgICAgICAgICB3emgob3V0LCBvLCBmLCBmLmYsIGYudSwgbCwgdG90LCBmLm0pLCBvICs9IDE2ICsgYmFkZCArIChmLm0gPyBmLm0ubGVuZ3RoIDogMCksIHRvdCA9IGxvYyArIGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3emYob3V0LCBvLCBmaWxlcy5sZW5ndGgsIGNkbCwgb2UpO1xuICAgICAgICBjYihudWxsLCBvdXQpO1xuICAgIH07XG4gICAgaWYgKCFsZnQpXG4gICAgICAgIGNiZigpO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIGZuID0ga1tpXTtcbiAgICAgICAgdmFyIF9hID0gcltmbl0sIGZpbGUgPSBfYVswXSwgcCA9IF9hWzFdO1xuICAgICAgICB2YXIgYyA9IGNyYygpLCBzaXplID0gZmlsZS5sZW5ndGg7XG4gICAgICAgIGMucChmaWxlKTtcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZuKSwgcyA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gcC5jb21tZW50LCBtID0gY29tICYmIHN0clRvVTgoY29tKSwgbXMgPSBtICYmIG0ubGVuZ3RoO1xuICAgICAgICB2YXIgZXhsID0gZXhmbChwLmV4dHJhKTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gcC5sZXZlbCA9PSAwID8gMCA6IDg7XG4gICAgICAgIHZhciBjYmwgPSBmdW5jdGlvbiAoZSwgZCkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICB0QWxsKCk7XG4gICAgICAgICAgICAgICAgY2IoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZpbGVzW2ldID0gbXJnKHAsIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgY3JjOiBjLmQoKSxcbiAgICAgICAgICAgICAgICAgICAgYzogZCxcbiAgICAgICAgICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgICAgICAgICAgbTogbSxcbiAgICAgICAgICAgICAgICAgICAgdTogcyAhPSBmbi5sZW5ndGggfHwgKG0gJiYgKGNvbS5sZW5ndGggIT0gbXMpKSxcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb246IGNvbXByZXNzaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbyArPSAzMCArIHMgKyBleGwgKyBsO1xuICAgICAgICAgICAgICAgIHRvdCArPSA3NiArIDIgKiAocyArIGV4bCkgKyAobXMgfHwgMCkgKyBsO1xuICAgICAgICAgICAgICAgIGlmICghLS1sZnQpXG4gICAgICAgICAgICAgICAgICAgIGNiZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAocyA+IDY1NTM1KVxuICAgICAgICAgICAgY2JsKCdmaWxlbmFtZSB0b28gbG9uZycsIG51bGwpO1xuICAgICAgICBpZiAoIWNvbXByZXNzaW9uKVxuICAgICAgICAgICAgY2JsKG51bGwsIGZpbGUpO1xuICAgICAgICBlbHNlIGlmIChzaXplIDwgMTYwMDAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNibChudWxsLCBkZWZsYXRlU3luYyhmaWxlLCBwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNibChlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZXJtLnB1c2goZGVmbGF0ZShmaWxlLCBwLCBjYmwpKTtcbiAgICB9O1xuICAgIC8vIENhbm5vdCB1c2UgbGZ0IGJlY2F1c2UgaXQgY2FuIGRlY3JlYXNlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGZ0OyArK2kpIHtcbiAgICAgICAgX2xvb3BfMShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRBbGw7XG59XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgY3JlYXRlcyBhIFpJUCBmaWxlLiBQcmVmZXIgdXNpbmcgYHppcGAgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICogd2l0aCBtb3JlIHRoYW4gb25lIGZpbGUuXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGlyZWN0b3J5IHN0cnVjdHVyZSBmb3IgdGhlIFpJUCBhcmNoaXZlXG4gKiBAcGFyYW0gb3B0cyBUaGUgbWFpbiBvcHRpb25zLCBtZXJnZWQgd2l0aCBwZXItZmlsZSBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIFpJUCBhcmNoaXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6aXBTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgciA9IHt9O1xuICAgIHZhciBmaWxlcyA9IFtdO1xuICAgIGZsdG4oZGF0YSwgJycsIHIsIG9wdHMpO1xuICAgIHZhciBvID0gMDtcbiAgICB2YXIgdG90ID0gMDtcbiAgICBmb3IgKHZhciBmbiBpbiByKSB7XG4gICAgICAgIHZhciBfYSA9IHJbZm5dLCBmaWxlID0gX2FbMF0sIHAgPSBfYVsxXTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gcC5sZXZlbCA9PSAwID8gMCA6IDg7XG4gICAgICAgIHZhciBmID0gc3RyVG9VOChmbiksIHMgPSBmLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbSA9IHAuY29tbWVudCwgbSA9IGNvbSAmJiBzdHJUb1U4KGNvbSksIG1zID0gbSAmJiBtLmxlbmd0aDtcbiAgICAgICAgdmFyIGV4bCA9IGV4ZmwocC5leHRyYSk7XG4gICAgICAgIGlmIChzID4gNjU1MzUpXG4gICAgICAgICAgICB0aHJvdyAnZmlsZW5hbWUgdG9vIGxvbmcnO1xuICAgICAgICB2YXIgZCA9IGNvbXByZXNzaW9uID8gZGVmbGF0ZVN5bmMoZmlsZSwgcCkgOiBmaWxlLCBsID0gZC5sZW5ndGg7XG4gICAgICAgIHZhciBjID0gY3JjKCk7XG4gICAgICAgIGMucChmaWxlKTtcbiAgICAgICAgZmlsZXMucHVzaChtcmcocCwge1xuICAgICAgICAgICAgc2l6ZTogZmlsZS5sZW5ndGgsXG4gICAgICAgICAgICBjcmM6IGMuZCgpLFxuICAgICAgICAgICAgYzogZCxcbiAgICAgICAgICAgIGY6IGYsXG4gICAgICAgICAgICBtOiBtLFxuICAgICAgICAgICAgdTogcyAhPSBmbi5sZW5ndGggfHwgKG0gJiYgKGNvbS5sZW5ndGggIT0gbXMpKSxcbiAgICAgICAgICAgIG86IG8sXG4gICAgICAgICAgICBjb21wcmVzc2lvbjogY29tcHJlc3Npb25cbiAgICAgICAgfSkpO1xuICAgICAgICBvICs9IDMwICsgcyArIGV4bCArIGw7XG4gICAgICAgIHRvdCArPSA3NiArIDIgKiAocyArIGV4bCkgKyAobXMgfHwgMCkgKyBsO1xuICAgIH1cbiAgICB2YXIgb3V0ID0gbmV3IHU4KHRvdCArIDIyKSwgb2UgPSBvLCBjZGwgPSB0b3QgLSBvO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGYgPSBmaWxlc1tpXTtcbiAgICAgICAgd3poKG91dCwgZi5vLCBmLCBmLmYsIGYudSwgZi5jLmxlbmd0aCk7XG4gICAgICAgIHZhciBiYWRkID0gMzAgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKTtcbiAgICAgICAgb3V0LnNldChmLmMsIGYubyArIGJhZGQpO1xuICAgICAgICB3emgob3V0LCBvLCBmLCBmLmYsIGYudSwgZi5jLmxlbmd0aCwgZi5vLCBmLm0pLCBvICs9IDE2ICsgYmFkZCArIChmLm0gPyBmLm0ubGVuZ3RoIDogMCk7XG4gICAgfVxuICAgIHd6ZihvdXQsIG8sIGZpbGVzLmxlbmd0aCwgY2RsLCBvZSk7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3RyZWFtaW5nIHBhc3MtdGhyb3VnaCBkZWNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXNcbiAqL1xudmFyIFVuemlwUGFzc1Rocm91Z2ggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW56aXBQYXNzVGhyb3VnaCgpIHtcbiAgICB9XG4gICAgVW56aXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBkYXRhLCBmaW5hbCk7XG4gICAgfTtcbiAgICBVbnppcFBhc3NUaHJvdWdoLmNvbXByZXNzaW9uID0gMDtcbiAgICByZXR1cm4gVW56aXBQYXNzVGhyb3VnaDtcbn0oKSk7XG5leHBvcnQgeyBVbnppcFBhc3NUaHJvdWdoIH07XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlcy4gUHJlZmVyIEFzeW5jWmlwSW5mbGF0ZSBmb3JcbiAqIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqL1xudmFyIFVuemlwSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBkZWNvbXByZXNzaW9uIHRoYXQgY2FuIGJlIHVzZWQgaW4gWklQIGFyY2hpdmVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVW56aXBJbmZsYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpc18xLm9uZGF0YShudWxsLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFVuemlwSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pLnB1c2goZGF0YSwgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlLCBkYXRhLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVuemlwSW5mbGF0ZS5jb21wcmVzc2lvbiA9IDg7XG4gICAgcmV0dXJuIFVuemlwSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBVbnppcEluZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgQXN5bmNVbnppcEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgZGVjb21wcmVzc2lvbiB0aGF0IGNhbiBiZSB1c2VkIGluIFpJUCBhcmNoaXZlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jVW56aXBJbmZsYXRlKF8sIHN6KSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKHN6IDwgMzIwMDAwKSB7XG4gICAgICAgICAgICB0aGlzLmkgPSBuZXcgSW5mbGF0ZShmdW5jdGlvbiAoZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmkgPSBuZXcgQXN5bmNJbmZsYXRlKGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpc18xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSA9IHRoaXMuaS50ZXJtaW5hdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXN5bmNVbnppcEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmluYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaS50ZXJtaW5hdGUpXG4gICAgICAgICAgICBkYXRhID0gc2xjKGRhdGEsIDApO1xuICAgICAgICB0aGlzLmkucHVzaChkYXRhLCBmaW5hbCk7XG4gICAgfTtcbiAgICBBc3luY1VuemlwSW5mbGF0ZS5jb21wcmVzc2lvbiA9IDg7XG4gICAgcmV0dXJuIEFzeW5jVW56aXBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jVW56aXBJbmZsYXRlIH07XG4vKipcbiAqIEEgWklQIGFyY2hpdmUgZGVjb21wcmVzc2lvbiBzdHJlYW0gdGhhdCBlbWl0cyBmaWxlcyBhcyB0aGV5IGFyZSBkaXNjb3ZlcmVkXG4gKi9cbnZhciBVbnppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgWklQIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGEgZmlsZSBpbiB0aGUgWklQIGFyY2hpdmUgaXMgZm91bmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnppcChjYikge1xuICAgICAgICB0aGlzLm9uZmlsZSA9IGNiO1xuICAgICAgICB0aGlzLmsgPSBbXTtcbiAgICAgICAgdGhpcy5vID0ge1xuICAgICAgICAgICAgMDogVW56aXBQYXNzVGhyb3VnaFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnAgPSBldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgdW56aXBwZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgVW56aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLm9uZmlsZSlcbiAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgIGlmICghdGhpcy5wKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICh0aGlzLmMgPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4odGhpcy5jLCBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHRvQWRkID0gY2h1bmsuc3ViYXJyYXkoMCwgbGVuKTtcbiAgICAgICAgICAgIHRoaXMuYyAtPSBsZW47XG4gICAgICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgICAgIHRoaXMuZC5wdXNoKHRvQWRkLCAhdGhpcy5jKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmtbMF0ucHVzaCh0b0FkZCk7XG4gICAgICAgICAgICBjaHVuayA9IGNodW5rLnN1YmFycmF5KGxlbik7XG4gICAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2goY2h1bmssIGZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmID0gMCwgaSA9IDAsIGlzID0gdm9pZCAwLCBidWYgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoIXRoaXMucC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnVmID0gY2h1bms7XG4gICAgICAgICAgICBlbHNlIGlmICghY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJ1ZiA9IHRoaXMucDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZiA9IG5ldyB1OCh0aGlzLnAubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBidWYuc2V0KHRoaXMucCksIGJ1Zi5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGwgPSBidWYubGVuZ3RoLCBvYyA9IHRoaXMuYywgYWRkID0gb2MgJiYgdGhpcy5kO1xuICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhciBzaWcgPSBiNChidWYsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChzaWcgPT0gMHg0MDM0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSAxLCBpcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmYgPSBiMihidWYsIGkgKyA2KSwgY21wXzEgPSBiMihidWYsIGkgKyA4KSwgdSA9IGJmICYgMjA0OCwgZGQgPSBiZiAmIDgsIGZubCA9IGIyKGJ1ZiwgaSArIDI2KSwgZXMgPSBiMihidWYsIGkgKyAyOCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsID4gaSArIDMwICsgZm5sICsgZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGtzXzIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5rLnVuc2hpZnQoY2hrc18yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjXzEgPSBiNChidWYsIGkgKyAxOCksIHN1XzEgPSBiNChidWYsIGkgKyAyMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5fMSA9IHN0ckZyb21VOChidWYuc3ViYXJyYXkoaSArIDMwLCBpICs9IDMwICsgZm5sKSwgIXUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjXzEgPT0gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gZGQgPyBbLTJdIDogejY0ZShidWYsIGkpLCBzY18xID0gX2FbMF0sIHN1XzEgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjXzEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYyA9IHNjXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVfMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmbl8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjbXBfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVfMS5vbmRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjXzEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlXzEub25kYXRhKG51bGwsIGV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3RyID0gX3RoaXNfMS5vW2NtcF8xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3RyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNtcF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xID0gc2NfMSA8IDAgPyBuZXcgY3RyKGZuXzEpIDogbmV3IGN0cihmbl8xLCBzY18xLCBzdV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5vbmRhdGEgPSBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7IGZpbGVfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY2hrc18zID0gY2hrc18yOyBfaSA8IGNoa3NfMy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0ID0gY2hrc18zW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEucHVzaChkYXQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpc18xLmtbMF0gPT0gY2hrc18yICYmIF90aGlzXzEuYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpc18xLmQgPSBkXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLnB1c2goZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRfMSAmJiBkXzEudGVybWluYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NfMSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfMS5zaXplID0gc2NfMSwgZmlsZV8xLm9yaWdpbmFsU2l6ZSA9IHN1XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEub25maWxlKGZpbGVfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZyA9PSAweDgwNzRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzID0gaSArPSAxMiArIChvYyA9PSAtMiAmJiA4KSwgZiA9IDMsIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lnID09IDB4MjAxNEI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXMgPSBpIC09IDQsIGYgPSAzLCB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsIC0gNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnAgPSBldDtcbiAgICAgICAgICAgIGlmIChvYyA8IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ID0gZiA/IGJ1Zi5zdWJhcnJheSgwLCBpcyAtIDEyIC0gKG9jID09IC0yICYmIDgpIC0gKGI0KGJ1ZiwgaXMgLSAxNikgPT0gMHg4MDc0QjUwICYmIDQpKSA6IGJ1Zi5zdWJhcnJheSgwLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkKVxuICAgICAgICAgICAgICAgICAgICBhZGQucHVzaChkYXQsICEhZik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtbKyhmID09IDIpXS5wdXNoKGRhdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZiAmIDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChidWYuc3ViYXJyYXkoaSksIGZpbmFsKTtcbiAgICAgICAgICAgIHRoaXMucCA9IGJ1Zi5zdWJhcnJheShpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmMpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgemlwIGZpbGUnO1xuICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZGVjb2RlciB3aXRoIHRoZSBzdHJlYW0sIGFsbG93aW5nIGZvciBmaWxlcyBjb21wcmVzc2VkIHdpdGhcbiAgICAgKiB0aGUgY29tcHJlc3Npb24gdHlwZSBwcm92aWRlZCB0byBiZSBleHBhbmRlZCBjb3JyZWN0bHlcbiAgICAgKiBAcGFyYW0gZGVjb2RlciBUaGUgZGVjb2RlciBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIFVuemlwLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChkZWNvZGVyKSB7XG4gICAgICAgIHRoaXMub1tkZWNvZGVyLmNvbXByZXNzaW9uXSA9IGRlY29kZXI7XG4gICAgfTtcbiAgICByZXR1cm4gVW56aXA7XG59KCkpO1xuZXhwb3J0IHsgVW56aXAgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzbHkgZGVjb21wcmVzc2VzIGEgWklQIGFyY2hpdmVcbiAqIEBwYXJhbSBkYXRhIFRoZSByYXcgY29tcHJlc3NlZCBaSVAgZmlsZVxuICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdpdGggdGhlIGRlY29tcHJlc3NlZCBmaWxlc1xuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGltbWVkaWF0ZWx5IHRlcm1pbmF0ZSB0aGUgdW56aXBwaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnppcChkYXRhLCBjYikge1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICB2YXIgdGVybSA9IFtdO1xuICAgIHZhciB0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlcm0ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0ZXJtW2ldKCk7XG4gICAgfTtcbiAgICB2YXIgZmlsZXMgPSB7fTtcbiAgICB2YXIgZSA9IGRhdGEubGVuZ3RoIC0gMjI7XG4gICAgZm9yICg7IGI0KGRhdGEsIGUpICE9IDB4NjA1NEI1MDsgLS1lKSB7XG4gICAgICAgIGlmICghZSB8fCBkYXRhLmxlbmd0aCAtIGUgPiA2NTU1OCkge1xuICAgICAgICAgICAgY2IoJ2ludmFsaWQgemlwIGZpbGUnLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgdmFyIGxmdCA9IGIyKGRhdGEsIGUgKyA4KTtcbiAgICBpZiAoIWxmdClcbiAgICAgICAgY2IobnVsbCwge30pO1xuICAgIHZhciBjID0gbGZ0O1xuICAgIHZhciBvID0gYjQoZGF0YSwgZSArIDE2KTtcbiAgICB2YXIgeiA9IG8gPT0gNDI5NDk2NzI5NTtcbiAgICBpZiAoeikge1xuICAgICAgICBlID0gYjQoZGF0YSwgZSAtIDEyKTtcbiAgICAgICAgaWYgKGI0KGRhdGEsIGUpICE9IDB4NjA2NEI1MCkge1xuICAgICAgICAgICAgY2IoJ2ludmFsaWQgemlwIGZpbGUnLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjID0gbGZ0ID0gYjQoZGF0YSwgZSArIDMyKTtcbiAgICAgICAgbyA9IGI0KGRhdGEsIGUgKyA0OCk7XG4gICAgfVxuICAgIHZhciBfbG9vcF8zID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIF9hID0gemgoZGF0YSwgbywgeiksIGNfMSA9IF9hWzBdLCBzYyA9IF9hWzFdLCBzdSA9IF9hWzJdLCBmbiA9IF9hWzNdLCBubyA9IF9hWzRdLCBvZmYgPSBfYVs1XSwgYiA9IHNsemgoZGF0YSwgb2ZmKTtcbiAgICAgICAgbyA9IG5vO1xuICAgICAgICB2YXIgY2JsID0gZnVuY3Rpb24gKGUsIGQpIHtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgdEFsbCgpO1xuICAgICAgICAgICAgICAgIGNiKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsZXNbZm5dID0gZDtcbiAgICAgICAgICAgICAgICBpZiAoIS0tbGZ0KVxuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBmaWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghY18xKVxuICAgICAgICAgICAgY2JsKG51bGwsIHNsYyhkYXRhLCBiLCBiICsgc2MpKTtcbiAgICAgICAgZWxzZSBpZiAoY18xID09IDgpIHtcbiAgICAgICAgICAgIHZhciBpbmZsID0gZGF0YS5zdWJhcnJheShiLCBiICsgc2MpO1xuICAgICAgICAgICAgaWYgKHNjIDwgMzIwMDAwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2JsKG51bGwsIGluZmxhdGVTeW5jKGluZmwsIG5ldyB1OChzdSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0ZXJtLnB1c2goaW5mbGF0ZShpbmZsLCB7IHNpemU6IHN1IH0sIGNibCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNibCgndW5rbm93biBjb21wcmVzc2lvbiB0eXBlICcgKyBjXzEsIG51bGwpO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyArK2kpIHtcbiAgICAgICAgX2xvb3BfMyhpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRBbGw7XG59XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgZGVjb21wcmVzc2VzIGEgWklQIGFyY2hpdmUuIFByZWZlciB1c2luZyBgdW56aXBgIGZvciBiZXR0ZXJcbiAqIHBlcmZvcm1hbmNlIHdpdGggbW9yZSB0aGFuIG9uZSBmaWxlLlxuICogQHBhcmFtIGRhdGEgVGhlIHJhdyBjb21wcmVzc2VkIFpJUCBmaWxlXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIGZpbGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnppcFN5bmMoZGF0YSkge1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KVxuICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgemlwIGZpbGUnO1xuICAgIH1cbiAgICA7XG4gICAgdmFyIGMgPSBiMihkYXRhLCBlICsgOCk7XG4gICAgaWYgKCFjKVxuICAgICAgICByZXR1cm4ge307XG4gICAgdmFyIG8gPSBiNChkYXRhLCBlICsgMTYpO1xuICAgIHZhciB6ID0gbyA9PSA0Mjk0OTY3Mjk1O1xuICAgIGlmICh6KSB7XG4gICAgICAgIGUgPSBiNChkYXRhLCBlIC0gMTIpO1xuICAgICAgICBpZiAoYjQoZGF0YSwgZSkgIT0gMHg2MDY0QjUwKVxuICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgemlwIGZpbGUnO1xuICAgICAgICBjID0gYjQoZGF0YSwgZSArIDMyKTtcbiAgICAgICAgbyA9IGI0KGRhdGEsIGUgKyA0OCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYzsgKytpKSB7XG4gICAgICAgIHZhciBfYSA9IHpoKGRhdGEsIG8sIHopLCBjXzIgPSBfYVswXSwgc2MgPSBfYVsxXSwgc3UgPSBfYVsyXSwgZm4gPSBfYVszXSwgbm8gPSBfYVs0XSwgb2ZmID0gX2FbNV0sIGIgPSBzbHpoKGRhdGEsIG9mZik7XG4gICAgICAgIG8gPSBubztcbiAgICAgICAgaWYgKCFjXzIpXG4gICAgICAgICAgICBmaWxlc1tmbl0gPSBzbGMoZGF0YSwgYiwgYiArIHNjKTtcbiAgICAgICAgZWxzZSBpZiAoY18yID09IDgpXG4gICAgICAgICAgICBmaWxlc1tmbl0gPSBpbmZsYXRlU3luYyhkYXRhLnN1YmFycmF5KGIsIGIgKyBzYyksIG5ldyB1OChzdSkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyAndW5rbm93biBjb21wcmVzc2lvbiB0eXBlICcgKyBjXzI7XG4gICAgfVxuICAgIHJldHVybiBmaWxlcztcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVSZXF1aXJlIiwicmVxdWlyZSIsIldvcmtlciIsIndvcmtlckFkZCIsImUiLCJ3ayIsImMiLCJfIiwibXNnIiwidHJhbnNmZXIiLCJjYiIsImRvbmUiLCJ3IiwiZXZhbCIsIm9uIiwibSIsIkVycm9yIiwicG9zdE1lc3NhZ2UiLCJ0ZXJtaW5hdGUiLCJwcm90b3R5cGUiLCJjYWxsIiwiX18iLCJfX18iLCJfX19fIiwic2V0SW1tZWRpYXRlIiwiTk9QIiwidTgiLCJVaW50OEFycmF5IiwidTE2IiwiVWludDE2QXJyYXkiLCJ1MzIiLCJVaW50MzJBcnJheSIsImZsZWIiLCJmZGViIiwiY2xpbSIsImZyZWIiLCJlYiIsInN0YXJ0IiwiYiIsImkiLCJyIiwiaiIsIl9hIiwiZmwiLCJyZXZmbCIsIl9iIiwiZmQiLCJyZXZmZCIsInJldiIsIngiLCJoTWFwIiwiY2QiLCJtYiIsInMiLCJsZW5ndGgiLCJsIiwibGUiLCJjbyIsInJ2YiIsInN2Iiwicl8xIiwidiIsImZsdCIsImZkdCIsImZsbSIsImZscm0iLCJmZG0iLCJmZHJtIiwibWF4IiwiYSIsImJpdHMiLCJkIiwicCIsIm8iLCJiaXRzMTYiLCJzaGZ0Iiwic2xjIiwibiIsInNldCIsInN1YmFycmF5IiwiaW5mbHQiLCJkYXQiLCJidWYiLCJzdCIsInNsIiwibm9CdWYiLCJub1N0IiwiY2J1ZiIsImJsIiwibmJ1ZiIsIk1hdGgiLCJmaW5hbCIsImYiLCJwb3MiLCJidCIsImxtIiwiZG0iLCJsYnQiLCJkYnQiLCJ0YnRzIiwidHlwZSIsInQiLCJoTGl0IiwiaGNMZW4iLCJ0bCIsImxkdCIsImNsdCIsImNsYiIsImNsYm1zayIsImNsbSIsImx0IiwiZHQiLCJsbXMiLCJkbXMiLCJscG9zIiwic3ltIiwiYWRkIiwiZHN5bSIsImVuZCIsIndiaXRzIiwid2JpdHMxNiIsImhUcmVlIiwicHVzaCIsInQyIiwic2xpY2UiLCJldCIsInNvcnQiLCJpMCIsImkxIiwiaTIiLCJtYXhTeW0iLCJ0ciIsIm1idCIsImxuIiwibGZ0IiwiY3N0IiwiaTJfMSIsImkyXzIiLCJpMl8zIiwibGMiLCJjbCIsImNsaSIsImNsbiIsImNscyIsImNsZW4iLCJjZiIsIndmYmxrIiwib3V0Iiwid2JsayIsInN5bXMiLCJsZiIsImRmIiwibGkiLCJicyIsImRsdCIsIm1sYiIsImRkdCIsIm1kYiIsIl9jIiwibGNsdCIsIm5sYyIsIl9kIiwibGNkdCIsIm5kYyIsImxjZnJlcSIsIl9lIiwibGN0IiwibWxjYiIsIm5sY2MiLCJmbGVuIiwiZnRsZW4iLCJkdGxlbiIsImxsIiwiZGwiLCJsbG0iLCJsY3RzIiwiaXQiLCJjbGN0IiwibGVuIiwiZHN0IiwiZGVvIiwiZGZsdCIsImx2bCIsInBsdmwiLCJwcmUiLCJwb3N0IiwibHN0IiwiY2VpbCIsIm9wdCIsIm1za18xIiwicHJldiIsImhlYWQiLCJiczFfMSIsImJzMl8xIiwiaHNoIiwibGNfMSIsIndpIiwiaHYiLCJpbW9kIiwicGltb2QiLCJyZW0iLCJjaF8xIiwiZGlmIiwibWF4biIsIm1pbiIsIm1heGQiLCJtbCIsIm5sIiwibW1kIiwibWQiLCJ0aSIsInB0aSIsImxpbiIsImRpbiIsImNyY3QiLCJJbnQzMkFycmF5IiwiayIsImNyYyIsImNyIiwiYWRsZXIiLCJkb3B0IiwibGV2ZWwiLCJtZW0iLCJsb2ciLCJtcmciLCJ3Y2xuIiwiZm4iLCJmblN0ciIsInRkIiwidG9TdHJpbmciLCJrcyIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsInJlcGxhY2UiLCJzcGxpdCIsInN0XzEiLCJzcEluZCIsImNoIiwiY2JmcyIsImNvbnN0cnVjdG9yIiwiYnVmZmVyIiwid3JrciIsImZucyIsImluaXQiLCJpZCIsInRkXzEiLCJiSW5mbHQiLCJpbmZsYXRlU3luYyIsInBiZiIsImd1OCIsImJEZmx0IiwiZGVmbGF0ZVN5bmMiLCJnemUiLCJnemgiLCJnemhsIiwid2J5dGVzIiwiZ3V6ZSIsImd6cyIsImd6bCIsInpsZSIsInpsaCIsInp1bGUiLCJ6bHYiLCJzaXplIiwiY2JpZnkiLCJvcHRzIiwiZXJyIiwiY29uc3VtZSIsImFzdHJtIiwic3RybSIsIm9uZGF0YSIsImV2IiwiZGF0YSIsImFzdHJtaWZ5IiwiYjIiLCJiNCIsImI4IiwiZmlsZW5hbWUiLCJtdGltZSIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImNoYXJDb2RlQXQiLCJmbGciLCJ6cyIsImx2IiwiQXN5bmNDbXBTdHJtIiwiRGVmbGF0ZSIsImNodW5rIiwiQXN5bmNEZWZsYXRlIiwib25tZXNzYWdlIiwiZGVmbGF0ZSIsIkluZmxhdGUiLCJidHMiLCJBc3luY0luZmxhdGUiLCJpbmZsYXRlIiwiR3ppcCIsInJhdyIsIkFzeW5jR3ppcCIsImd6aXAiLCJnemlwU3luYyIsIkd1bnppcCIsIkFzeW5jR3VuemlwIiwiZ3VuemlwIiwiZ3VuemlwU3luYyIsIlpsaWIiLCJBc3luY1psaWIiLCJ6bGliIiwiemxpYlN5bmMiLCJVbnpsaWIiLCJBc3luY1VuemxpYiIsInVuemxpYiIsInVuemxpYlN5bmMiLCJjb21wcmVzcyIsIkFzeW5jQ29tcHJlc3MiLCJjb21wcmVzc1N5bmMiLCJDb21wcmVzcyIsIkRlY29tcHJlc3MiLCJHIiwiSSIsIloiLCJfdGhpc18xIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJBc3luY0RlY29tcHJlc3MiLCJkZWNvbXByZXNzIiwiZGVjb21wcmVzc1N5bmMiLCJmbHRuIiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwidGUiLCJUZXh0RW5jb2RlciIsIlRleHREZWNvZGVyIiwidGRzIiwiZGVjb2RlIiwic3RyZWFtIiwiZHV0ZjgiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJEZWNvZGVVVEY4IiwibnAiLCJFbmNvZGVVVEY4Iiwic3RyVG9VOCIsInN0ciIsImxhdGluMSIsImFyXzEiLCJlbmNvZGUiLCJhciIsImFpIiwic3RyRnJvbVU4IiwiZXh0IiwiZGJmIiwic2x6aCIsInpoIiwieiIsImZubCIsImVzIiwiejY0ZSIsInNjIiwic3UiLCJvZmYiLCJleGZsIiwiZXgiLCJ3emgiLCJ1IiwiY2UiLCJleHRyYSIsImNvbCIsImV4bCIsIm9zIiwiZmxhZyIsImNvbXByZXNzaW9uIiwieSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImF0dHJzIiwiZXhmIiwid3pmIiwiWmlwUGFzc1Rocm91Z2giLCJwcm9jZXNzIiwiWmlwRGVmbGF0ZSIsIkFzeW5jWmlwRGVmbGF0ZSIsIlppcCIsImZpbGUiLCJjb20iLCJjb21tZW50IiwiaGwiLCJoZWFkZXIiLCJjaGtzIiwicEFsbCIsIl9pIiwiY2hrc18xIiwiY2hrIiwiaW5kIiwidWYiLCJueHQiLCJkZCIsInNwbGljZSIsInppcCIsIk9iamVjdCIsImtleXMiLCJ0b3QiLCJzbGZ0IiwiZmlsZXMiLCJ0ZXJtIiwidEFsbCIsImNiZiIsIm9lIiwiY2RsIiwiYmFkZCIsImxvYyIsIl9sb29wXzEiLCJtcyIsImNibCIsInppcFN5bmMiLCJVbnppcFBhc3NUaHJvdWdoIiwiVW56aXBJbmZsYXRlIiwiQXN5bmNVbnppcEluZmxhdGUiLCJzeiIsIlVuemlwIiwib25maWxlIiwidG9BZGQiLCJpcyIsIm9jIiwiX2xvb3BfMiIsInNpZyIsInRoaXNfMSIsImJmIiwiY21wXzEiLCJjaGtzXzIiLCJ1bnNoaWZ0Iiwic2NfMSIsInN1XzEiLCJmbl8xIiwiZF8xIiwiZmlsZV8xIiwibmFtZSIsImN0ciIsImNoa3NfMyIsIm9yaWdpbmFsU2l6ZSIsInN0YXRlXzEiLCJyZWdpc3RlciIsImRlY29kZXIiLCJ1bnppcCIsIl9sb29wXzMiLCJjXzEiLCJubyIsImluZmwiLCJ1bnppcFN5bmMiLCJjXzIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fflate/esm/index.mjs\n");

/***/ })

};
;