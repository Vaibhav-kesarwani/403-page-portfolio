"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-utils";
exports.ids = ["vendor-chunks/troika-three-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezierMesh: () => (/* binding */ BezierMesh),\n/* harmony export */   createDerivedMaterial: () => (/* binding */ createDerivedMaterial),\n/* harmony export */   expandShaderIncludes: () => (/* binding */ expandShaderIncludes),\n/* harmony export */   getShaderUniformTypes: () => (/* binding */ getShaderUniformTypes),\n/* harmony export */   getShadersForMaterial: () => (/* binding */ getShadersForMaterial),\n/* harmony export */   invertMatrix4: () => (/* binding */ invertMatrix4),\n/* harmony export */   voidMainRegExp: () => (/* binding */ voidMainRegExp)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */ const voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */ function expandShaderIncludes(source) {\n    const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function replace(match, include) {\n        let chunk = three__WEBPACK_IMPORTED_MODULE_0__.ShaderChunk[include];\n        return chunk ? expandShaderIncludes(chunk) : match;\n    }\n    return source.replace(pattern, replace);\n}\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */ const _lut = [];\nfor(let i = 0; i < 256; i++){\n    _lut[i] = (i < 16 ? \"0\" : \"\") + i.toString(16);\n}\nfunction generateUUID() {\n    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n    const d0 = Math.random() * 0xffffffff | 0;\n    const d1 = Math.random() * 0xffffffff | 0;\n    const d2 = Math.random() * 0xffffffff | 0;\n    const d3 = Math.random() * 0xffffffff | 0;\n    const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + \"-\" + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + \"-\" + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + \"-\" + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + \"-\" + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n    // .toUpperCase() here flattens concatenated strings to save heap memory space.\n    return uuid.toUpperCase();\n}\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function() {\n    let target = arguments[0];\n    for(let i = 1, len = arguments.length; i < len; i++){\n        let source = arguments[i];\n        if (source) {\n            for(let prop in source){\n                if (Object.prototype.hasOwnProperty.call(source, prop)) {\n                    target[prop] = source[prop];\n                }\n            }\n        }\n    }\n    return target;\n};\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object} options.defines - Custom `defines` for the material\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */ function createDerivedMaterial(baseMaterial, options) {\n    // Generate a key that is unique to the content of these `options`. We'll use this\n    // throughout for caching and for generating the upgraded shader code. This increases\n    // the likelihood that the resulting shaders will line up across multiple calls so\n    // their GL programs can be shared and cached.\n    const optionsKey = getKeyForOptions(options);\n    // First check to see if we've already derived from this baseMaterial using this\n    // unique set of options, and if so reuse the constructor to avoid some allocations.\n    let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n    if (!ctorsByDerivation) {\n        CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));\n    }\n    if (ctorsByDerivation[optionsKey]) {\n        return new ctorsByDerivation[optionsKey]();\n    }\n    const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n    // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material's program\n    const onBeforeCompile = function(shaderInfo, renderer) {\n        baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n        // Upgrade the shaders, caching the result by incoming source code\n        const cacheKey = this.customProgramCacheKey() + \"|\" + shaderInfo.vertexShader + \"|\" + shaderInfo.fragmentShader;\n        let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n        if (!upgradedShaders) {\n            const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n            upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n        }\n        // Inject upgraded shaders and uniforms into the program\n        shaderInfo.vertexShader = upgradedShaders.vertexShader;\n        shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n        assign(shaderInfo.uniforms, this.uniforms);\n        // Inject auto-updating time uniform if requested\n        if (options.timeUniform) {\n            shaderInfo.uniforms[options.timeUniform] = {\n                get value () {\n                    return Date.now() - epoch;\n                }\n            };\n        }\n        // Users can still add their own handlers on top of ours\n        if (this[privateBeforeCompileProp]) {\n            this[privateBeforeCompileProp](shaderInfo);\n        }\n    };\n    const DerivedMaterial = function DerivedMaterial() {\n        return derive(options.chained ? baseMaterial : baseMaterial.clone());\n    };\n    const derive = function(base) {\n        // Prototype chain to the base material\n        const derived = Object.create(base, descriptor);\n        // Store the baseMaterial for reference; this is always the original even when cloning\n        Object.defineProperty(derived, \"baseMaterial\", {\n            value: baseMaterial\n        });\n        // Needs its own ids\n        Object.defineProperty(derived, \"id\", {\n            value: materialInstanceId++\n        });\n        derived.uuid = generateUUID();\n        // Merge uniforms, defines, and extensions\n        derived.uniforms = assign({}, base.uniforms, options.uniforms);\n        derived.defines = assign({}, base.defines, options.defines);\n        derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = \"\"; //force a program change from the base material\n        derived.extensions = assign({}, base.extensions, options.extensions);\n        // Don't inherit EventDispatcher listeners\n        derived._listeners = undefined;\n        return derived;\n    };\n    const descriptor = {\n        constructor: {\n            value: DerivedMaterial\n        },\n        isDerivedMaterial: {\n            value: true\n        },\n        customProgramCacheKey: {\n            writable: true,\n            configurable: true,\n            value: function() {\n                return baseMaterial.customProgramCacheKey() + \"|\" + optionsKey;\n            }\n        },\n        onBeforeCompile: {\n            get () {\n                return onBeforeCompile;\n            },\n            set (fn) {\n                this[privateBeforeCompileProp] = fn;\n            }\n        },\n        copy: {\n            writable: true,\n            configurable: true,\n            value: function(source) {\n                baseMaterial.copy.call(this, source);\n                if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n                    assign(this.extensions, source.extensions);\n                    assign(this.defines, source.defines);\n                    assign(this.uniforms, three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone(source.uniforms));\n                }\n                return this;\n            }\n        },\n        clone: {\n            writable: true,\n            configurable: true,\n            value: function() {\n                const newBase = new baseMaterial.constructor();\n                return derive(newBase).copy(this);\n            }\n        },\n        /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */ getDepthMaterial: {\n            writable: true,\n            configurable: true,\n            value: function() {\n                let depthMaterial = this._depthMaterial;\n                if (!depthMaterial) {\n                    depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial({\n                        depthPacking: three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking\n                    }), options);\n                    depthMaterial.defines.IS_DEPTH_MATERIAL = \"\";\n                    depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n                }\n                return depthMaterial;\n            }\n        },\n        /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */ getDistanceMaterial: {\n            writable: true,\n            configurable: true,\n            value: function() {\n                let distanceMaterial = this._distanceMaterial;\n                if (!distanceMaterial) {\n                    distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDistanceMaterial(), options);\n                    distanceMaterial.defines.IS_DISTANCE_MATERIAL = \"\";\n                    distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n                }\n                return distanceMaterial;\n            }\n        },\n        dispose: {\n            writable: true,\n            configurable: true,\n            value () {\n                const { _depthMaterial, _distanceMaterial } = this;\n                if (_depthMaterial) _depthMaterial.dispose();\n                if (_distanceMaterial) _distanceMaterial.dispose();\n                baseMaterial.dispose.call(this);\n            }\n        }\n    };\n    ctorsByDerivation[optionsKey] = DerivedMaterial;\n    return new DerivedMaterial();\n}\nfunction upgradeShaders(material, { vertexShader, fragmentShader }, options, key) {\n    let { vertexDefs, vertexMainIntro, vertexMainOutro, vertexTransform, fragmentDefs, fragmentMainIntro, fragmentMainOutro, fragmentColorTransform, customRewriter, timeUniform } = options;\n    vertexDefs = vertexDefs || \"\";\n    vertexMainIntro = vertexMainIntro || \"\";\n    vertexMainOutro = vertexMainOutro || \"\";\n    fragmentDefs = fragmentDefs || \"\";\n    fragmentMainIntro = fragmentMainIntro || \"\";\n    fragmentMainOutro = fragmentMainOutro || \"\";\n    // Expand includes if needed\n    if (vertexTransform || customRewriter) {\n        vertexShader = expandShaderIncludes(vertexShader);\n    }\n    if (fragmentColorTransform || customRewriter) {\n        // We need to be able to find postprocessing chunks after include expansion in order to\n        // put them after the fragmentColorTransform, so mark them with comments first. Even if\n        // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n        // so we still mark them.\n        fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, \"\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n\");\n        fragmentShader = expandShaderIncludes(fragmentShader);\n    }\n    // Apply custom rewriter function\n    if (customRewriter) {\n        let res = customRewriter({\n            vertexShader,\n            fragmentShader\n        });\n        vertexShader = res.vertexShader;\n        fragmentShader = res.fragmentShader;\n    }\n    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n    // those and re-insert them into the outro in the correct place:\n    if (fragmentColorTransform) {\n        let postChunks = [];\n        fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, (match)=>{\n            postChunks.push(match);\n            return \"\";\n        });\n        fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join(\"\\n\")}\\n${fragmentMainOutro}`;\n    }\n    // Inject auto-updating time uniform if requested\n    if (timeUniform) {\n        const code = `\\nuniform float ${timeUniform};\\n`;\n        vertexDefs = code + vertexDefs;\n        fragmentDefs = code + fragmentDefs;\n    }\n    // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n    if (vertexTransform) {\n        // Hoist these defs to the very top so they work in other function defs\n        vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n        vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n        vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n        vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr)=>{\n            return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;\n        });\n        // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n        // Perhaps the other textures too going forward?\n        if (!(material.map && material.map.channel > 0)) {\n            vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n        }\n    }\n    // Inject defs and intro/outro snippets\n    vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n    fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n    return {\n        vertexShader,\n        fragmentShader\n    };\n}\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n    if (intro || outro || defs) {\n        shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`);\n        shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n    }\n    return shaderCode;\n}\nfunction optionsJsonReplacer(key, value) {\n    return key === \"uniforms\" ? undefined : typeof value === \"function\" ? value.toString() : value;\n}\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n    const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n    let id = optionsHashesToIds.get(optionsHash);\n    if (id == null) {\n        optionsHashesToIds.set(optionsHash, id = ++_idCtr);\n    }\n    return id;\n}\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: \"depth\",\n    MeshDistanceMaterial: \"distanceRGBA\",\n    MeshNormalMaterial: \"normal\",\n    MeshBasicMaterial: \"basic\",\n    MeshLambertMaterial: \"lambert\",\n    MeshPhongMaterial: \"phong\",\n    MeshToonMaterial: \"toon\",\n    MeshStandardMaterial: \"physical\",\n    MeshPhysicalMaterial: \"physical\",\n    MeshMatcapMaterial: \"matcap\",\n    LineBasicMaterial: \"basic\",\n    LineDashedMaterial: \"dashed\",\n    PointsMaterial: \"points\",\n    ShadowMaterial: \"shadow\",\n    SpriteMaterial: \"sprite\"\n};\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */ function getShadersForMaterial(material) {\n    let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n    ;\n}\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */ function getShaderUniformTypes(shader) {\n    let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n    let uniforms = Object.create(null);\n    let match;\n    while((match = uniformRE.exec(shader)) !== null){\n        uniforms[match[2]] = match[1];\n    }\n    return uniforms;\n}\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */ function invertMatrix4(srcMatrix, tgtMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()) {\n    if (typeof tgtMatrix.invert === \"function\") {\n        tgtMatrix.copy(srcMatrix).invert();\n    } else {\n        tgtMatrix.getInverse(srcMatrix);\n    }\n    return tgtMatrix;\n}\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/ const vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\nfunction createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(baseMaterial, {\n        chained: true,\n        uniforms: {\n            pointA: {\n                value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n            },\n            controlA: {\n                value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n            },\n            controlB: {\n                value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n            },\n            pointB: {\n                value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n            },\n            radius: {\n                value: 0.01\n            },\n            dashing: {\n                value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n            } //on, off, offset\n        },\n        vertexDefs,\n        vertexTransform,\n        fragmentDefs,\n        fragmentMainIntro\n    });\n}\nlet geometry = null;\nconst defaultBaseMaterial = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n    color: 0xffffff,\n    side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n});\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */ class BezierMesh extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n    static getGeometry() {\n        return geometry || (geometry = new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n    }\n    constructor(){\n        super(BezierMesh.getGeometry(), defaultBaseMaterial);\n        this.pointA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.controlA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.controlB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.pointB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.radius = 0.01;\n        this.dashArray = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        this.dashOffset = 0;\n        // TODO - disabling frustum culling until I figure out how to customize the\n        //  geometry's bounding sphere that gets used\n        this.frustumCulled = false;\n    }\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    get material() {\n        let derivedMaterial = this._derivedMaterial;\n        const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n        if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n            derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n            // dispose the derived material when its base material is disposed:\n            baseMaterial.addEventListener(\"dispose\", function onDispose() {\n                baseMaterial.removeEventListener(\"dispose\", onDispose);\n                derivedMaterial.dispose();\n            });\n        }\n        return derivedMaterial;\n    }\n    set material(baseMaterial) {\n        this._baseMaterial = baseMaterial;\n    }\n    // Create and update material for shadows upon request:\n    get customDepthMaterial() {\n        return this.material.getDepthMaterial();\n    }\n    get customDistanceMaterial() {\n        return this.material.getDistanceMaterial();\n    }\n    onBeforeRender() {\n        const { uniforms } = this.material;\n        const { pointA, controlA, controlB, pointB, radius, dashArray, dashOffset } = this;\n        uniforms.pointA.value.copy(pointA);\n        uniforms.controlA.value.copy(controlA);\n        uniforms.controlB.value.copy(controlB);\n        uniforms.pointB.value.copy(pointB);\n        uniforms.radius.value = radius;\n        uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    }\n    raycast() {\n    // TODO - just fail for now\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4TTtBQUU5TTs7O0NBR0MsR0FDRCxNQUFNYSxpQkFBaUI7QUFFdkI7Ozs7OztDQU1DLEdBQ0QsU0FBU0MscUJBQXNCQyxNQUFNO0lBQ25DLE1BQU1DLFVBQVU7SUFDaEIsU0FBU0MsUUFBUUMsS0FBSyxFQUFFQyxPQUFPO1FBQzdCLElBQUlDLFFBQVFwQiw4Q0FBVyxDQUFDbUIsUUFBUTtRQUNoQyxPQUFPQyxRQUFRTixxQkFBcUJNLFNBQVNGO0lBQy9DO0lBQ0EsT0FBT0gsT0FBT0UsT0FBTyxDQUFFRCxTQUFTQztBQUNsQztBQUVBOzs7O0NBSUMsR0FFRCxNQUFNSSxPQUFPLEVBQUU7QUFFZixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxLQUFLQSxJQUFLO0lBQzVCRCxJQUFJLENBQUNDLEVBQUUsR0FBRyxDQUFDQSxJQUFJLEtBQUssTUFBTSxFQUFDLElBQUssRUFBSUMsUUFBUSxDQUFDO0FBQy9DO0FBRUEsU0FBU0M7SUFFUCxzR0FBc0c7SUFFdEcsTUFBTUMsS0FBS0MsS0FBS0MsTUFBTSxLQUFLLGFBQWE7SUFDeEMsTUFBTUMsS0FBS0YsS0FBS0MsTUFBTSxLQUFLLGFBQWE7SUFDeEMsTUFBTUUsS0FBS0gsS0FBS0MsTUFBTSxLQUFLLGFBQWE7SUFDeEMsTUFBTUcsS0FBS0osS0FBS0MsTUFBTSxLQUFLLGFBQWE7SUFDeEMsTUFBTUksT0FBT1YsSUFBSSxDQUFDSSxLQUFLLEtBQUssR0FBR0osSUFBSSxDQUFDSSxNQUFNLElBQUksS0FBSyxHQUFHSixJQUFJLENBQUNJLE1BQU0sS0FBSyxLQUFLLEdBQUdKLElBQUksQ0FBQ0ksTUFBTSxLQUFLLEtBQUssR0FBRyxNQUNwR0osSUFBSSxDQUFDTyxLQUFLLEtBQUssR0FBR1AsSUFBSSxDQUFDTyxNQUFNLElBQUksS0FBSyxHQUFH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dURBQXVEO0lBQ3ZELElBQUl3SSxzQkFBc0I7UUFDeEIsT0FBTyxJQUFJLENBQUNwRixRQUFRLENBQUNWLGdCQUFnQjtJQUN2QztJQUNBLElBQUkrRix5QkFBeUI7UUFDM0IsT0FBTyxJQUFJLENBQUNyRixRQUFRLENBQUNMLG1CQUFtQjtJQUMxQztJQUVBMkYsaUJBQWlCO1FBQ2YsTUFBTSxFQUFDdkgsUUFBUSxFQUFDLEdBQUcsSUFBSSxDQUFDaUMsUUFBUTtRQUNoQyxNQUFNLEVBQUM2RCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRVMsU0FBUyxFQUFFQyxVQUFVLEVBQUMsR0FBRyxJQUFJO1FBQ2hGNUcsU0FBUzhGLE1BQU0sQ0FBQzVGLEtBQUssQ0FBQ2tCLElBQUksQ0FBQzBFO1FBQzNCOUYsU0FBUytGLFFBQVEsQ0FBQzdGLEtBQUssQ0FBQ2tCLElBQUksQ0FBQzJFO1FBQzdCL0YsU0FBU2dHLFFBQVEsQ0FBQzlGLEtBQUssQ0FBQ2tCLElBQUksQ0FBQzRFO1FBQzdCaEcsU0FBU2lHLE1BQU0sQ0FBQy9GLEtBQUssQ0FBQ2tCLElBQUksQ0FBQzZFO1FBQzNCakcsU0FBU2tHLE1BQU0sQ0FBQ2hHLEtBQUssR0FBR2dHO1FBQ3hCbEcsU0FBU21HLE9BQU8sQ0FBQ2pHLEtBQUssQ0FBQ2YsR0FBRyxDQUFDd0gsVUFBVWEsQ0FBQyxFQUFFYixVQUFVYyxDQUFDLEVBQUViLGNBQWM7SUFDckU7SUFFQWMsVUFBbUM7SUFDakMsMkJBQTJCO0lBQzdCO0FBQ0Y7QUFFZ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmVhdGl2ZS00MDQvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLmVzbS5qcz81NzVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoYWRlckNodW5rLCBVbmlmb3Jtc1V0aWxzLCBNZXNoRGVwdGhNYXRlcmlhbCwgUkdCQURlcHRoUGFja2luZywgTWVzaERpc3RhbmNlTWF0ZXJpYWwsIFNoYWRlckxpYiwgTWF0cml4NCwgVmVjdG9yMywgTWVzaCwgQ3lsaW5kZXJHZW9tZXRyeSwgVmVjdG9yMiwgTWVzaFN0YW5kYXJkTWF0ZXJpYWwsIERvdWJsZVNpZGUgfSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyB0aGUgYHZvaWQgbWFpbigpIHtgIG9wZW5lciBsaW5lIGluIEdMU0wuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCB2b2lkTWFpblJlZ0V4cCA9IC9cXGJ2b2lkXFxzK21haW5cXHMqXFwoXFxzKlxcKVxccyp7L2c7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZXhwYW5kcyBhbGwgYCNpbmNsdWRlIDx4eXo+YCBzdGF0ZW1lbnRzIHdpdGhpbiBzdHJpbmcgb2Ygc2hhZGVyIGNvZGUuXG4gKiBDb3BpZWQgZnJvbSB0aHJlZSdzIFdlYkdMUHJvZ3JhbSNwYXJzZUluY2x1ZGVzIGZvciBleHRlcm5hbCB1c2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBHTFNMIHNvdXJjZSBjb2RlIHRvIGV2YWx1YXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBHTFNMIGNvZGUgd2l0aCBhbGwgaW5jbHVkZXMgZXhwYW5kZWRcbiAqL1xuZnVuY3Rpb24gZXhwYW5kU2hhZGVySW5jbHVkZXMoIHNvdXJjZSApIHtcbiAgY29uc3QgcGF0dGVybiA9IC9eWyBcXHRdKiNpbmNsdWRlICs8KFtcXHdcXGQuL10rKT4vZ207XG4gIGZ1bmN0aW9uIHJlcGxhY2UobWF0Y2gsIGluY2x1ZGUpIHtcbiAgICBsZXQgY2h1bmsgPSBTaGFkZXJDaHVua1tpbmNsdWRlXTtcbiAgICByZXR1cm4gY2h1bmsgPyBleHBhbmRTaGFkZXJJbmNsdWRlcyhjaHVuaykgOiBtYXRjaFxuICB9XG4gIHJldHVybiBzb3VyY2UucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApXG59XG5cbi8qXG4gKiBUaGlzIGlzIGEgZGlyZWN0IGNvcHkgb2YgTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCBmcm9tIFRocmVlLmpzLCB0byBwcmVzZXJ2ZSBjb21wYXRpYmlsaXR5IHdpdGggdGhyZWVcbiAqIHZlcnNpb25zIGJlZm9yZSAwLjExMy4wIGFzIGl0IHdhcyBjaGFuZ2VkIGZyb20gTWF0aCB0byBNYXRoVXRpbHMgaW4gdGhhdCB2ZXJzaW9uLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL2RkOGI1YWEzYjI3MGMxNzA5NmI5MDk0NWNkMmQ2ZDFiMTNhYWVjNTMvc3JjL21hdGgvTWF0aFV0aWxzLmpzI0wxNlxuICovXG5cbmNvbnN0IF9sdXQgPSBbXTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBfbHV0W2ldID0gKGkgPCAxNiA/ICcwJyA6ICcnKSArIChpKS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcblxuICBjb25zdCBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgdXVpZCA9IF9sdXRbZDAgJiAweGZmXSArIF9sdXRbZDAgPj4gOCAmIDB4ZmZdICsgX2x1dFtkMCA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMCA+PiAyNCAmIDB4ZmZdICsgJy0nICtcbiAgICBfbHV0W2QxICYgMHhmZl0gKyBfbHV0W2QxID4+IDggJiAweGZmXSArICctJyArIF9sdXRbZDEgPj4gMTYgJiAweDBmIHwgMHg0MF0gKyBfbHV0W2QxID4+IDI0ICYgMHhmZl0gKyAnLScgK1xuICAgIF9sdXRbZDIgJiAweDNmIHwgMHg4MF0gKyBfbHV0W2QyID4+IDggJiAweGZmXSArICctJyArIF9sdXRbZDIgPj4gMTYgJiAweGZmXSArIF9sdXRbZDIgPj4gMjQgJiAweGZmXSArXG4gICAgX2x1dFtkMyAmIDB4ZmZdICsgX2x1dFtkMyA+PiA4ICYgMHhmZl0gKyBfbHV0W2QzID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QzID4+IDI0ICYgMHhmZl07XG5cbiAgLy8gLnRvVXBwZXJDYXNlKCkgaGVyZSBmbGF0dGVucyBjb25jYXRlbmF0ZWQgc3RyaW5ncyB0byBzYXZlIGhlYXAgbWVtb3J5IHNwYWNlLlxuICByZXR1cm4gdXVpZC50b1VwcGVyQ2FzZSgpXG5cbn1cblxuLy8gTG9jYWwgYXNzaWduIHBvbHlmaWxsIHRvIGF2b2lkIGltcG9ydGluZyB0cm9pa2EtY29yZVxuY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbigvKnRhcmdldCwgLi4uc291cmNlcyovKSB7XG4gIGxldCB0YXJnZXQgPSBhcmd1bWVudHNbMF07XG4gIGZvciAobGV0IGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIGZvciAobGV0IHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0XG59O1xuXG5cbmNvbnN0IGVwb2NoID0gRGF0ZS5ub3coKTtcbmNvbnN0IENPTlNUUlVDVE9SX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IFNIQURFUl9VUEdSQURFX0NBQ0hFID0gbmV3IE1hcCgpO1xuXG4vLyBNYXRlcmlhbCBpZHMgbXVzdCBiZSBpbnRlZ2VycywgYnV0IHdlIGNhbid0IGFjY2VzcyB0aGUgaW5jcmVtZW50IGZyb20gVGhyZWUncyBgTWF0ZXJpYWxgIG1vZHVsZSxcbi8vIHNvIGxldCdzIGNob29zZSBhIHN1ZmZpY2llbnRseSBsYXJnZSBzdGFydGluZyB2YWx1ZSB0aGF0IHNob3VsZCB0aGVvcmV0aWNhbGx5IG5ldmVyIGNvbGxpZGUuXG5sZXQgbWF0ZXJpYWxJbnN0YW5jZUlkID0gMWUxMDtcblxuLyoqXG4gKiBBIHV0aWxpdHkgZm9yIGNyZWF0aW5nIGEgY3VzdG9tIHNoYWRlciBtYXRlcmlhbCBkZXJpdmVkIGZyb20gYW5vdGhlciBtYXRlcmlhbCdzXG4gKiBzaGFkZXJzLiBUaGlzIGFsbG93cyB5b3UgdG8gaW5qZWN0IGN1c3RvbSBzaGFkZXIgbG9naWMgYW5kIHRyYW5zZm9ybXMgaW50byB0aGVcbiAqIGJ1aWx0aW4gVGhyZWVKUyBtYXRlcmlhbHMgd2l0aG91dCBoYXZpbmcgdG8gcmVjcmVhdGUgdGhlbSBmcm9tIHNjcmF0Y2guXG4gKlxuICogQHBhcmFtIHtUSFJFRS5NYXRlcmlhbH0gYmFzZU1hdGVyaWFsIC0gdGhlIG9yaWdpbmFsIG1hdGVyaWFsIHRvIGRlcml2ZSBmcm9tXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBIb3cgdGhlIGJhc2UgbWF0ZXJpYWwgc2hvdWxkIGJlIG1vZGlmaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGVmaW5lcyAtIEN1c3RvbSBgZGVmaW5lc2AgZm9yIHRoZSBtYXRlcmlhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZXh0ZW5zaW9ucyAtIEN1c3RvbSBgZXh0ZW5zaW9uc2AgZm9yIHRoZSBtYXRlcmlhbCwgZS5nLiBge2Rlcml2YXRpdmVzOiB0cnVlfWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnVuaWZvcm1zIC0gQ3VzdG9tIGB1bmlmb3Jtc2AgZm9yIHVzZSBpbiB0aGUgbW9kaWZpZWQgc2hhZGVyLiBUaGVzZSBjYW5cbiAqICAgICAgICBiZSBhY2Nlc3NlZCBhbmQgbWFuaXB1bGF0ZWQgdmlhIHRoZSByZXN1bHRpbmcgbWF0ZXJpYWwncyBgdW5pZm9ybXNgIHByb3BlcnR5LCBqdXN0IGxpa2VcbiAqICAgICAgICBpbiBhIFNoYWRlck1hdGVyaWFsLiBZb3UgZG8gbm90IG5lZWQgdG8gcmVwZWF0IHRoZSBiYXNlIG1hdGVyaWFsJ3Mgb3duIHVuaWZvcm1zIGhlcmUuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1lVW5pZm9ybSAtIElmIHNwZWNpZmllZCwgYSB1bmlmb3JtIG9mIHRoaXMgbmFtZSB3aWxsIGJlIGluamVjdGVkIGludG9cbiAqICAgICAgICBib3RoIHNoYWRlcnMsIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgdXBkYXRlZCBvbiBlYWNoIHJlbmRlciBmcmFtZSB3aXRoIGEgbnVtYmVyIG9mXG4gKiAgICAgICAgZWxhcHNlZCBtaWxsaXNlY29uZHMuIFRoZSBcInplcm9cIiBlcG9jaCB0aW1lIGlzIG5vdCBzaWduaWZpY2FudCBzbyBkb24ndCByZWx5IG9uIHRoaXMgYXMgYVxuICogICAgICAgIHRydWUgY2FsZW5kYXIgdGltZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleERlZnMgLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBpbnRvIHRoZSB2ZXJ0ZXggc2hhZGVyJ3MgdG9wLWxldmVsXG4gKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudmVydGV4TWFpbkludHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIHRvcCBvZiB0aGUgdmVydGV4XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhNYWluT3V0cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgZW5kIG9mIHRoZSB2ZXJ0ZXhcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleFRyYW5zZm9ybSAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gbWFuaXB1bGF0ZSB0aGUgYHBvc2l0aW9uYCwgYG5vcm1hbGAsXG4gKiAgICAgICAgYW5kL29yIGB1dmAgdmVydGV4IGF0dHJpYnV0ZXMuIFRoaXMgY29kZSB3aWxsIGJlIHdyYXBwZWQgd2l0aGluIGEgc3RhbmRhbG9uZSBmdW5jdGlvbiB3aXRoXG4gKiAgICAgICAgdGhvc2UgYXR0cmlidXRlcyBleHBvc2VkIGJ5IHRoZWlyIG5vcm1hbCBuYW1lcyBhcyByZWFkL3dyaXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50RGVmcyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGludG8gdGhlIGZyYWdtZW50IHNoYWRlcidzIHRvcC1sZXZlbFxuICogICAgICAgIGRlZmluaXRpb25zLCBhYm92ZSB0aGUgYHZvaWQgbWFpbigpYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50TWFpbkludHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIHRvcCBvZiB0aGUgZnJhZ21lbnRcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50TWFpbk91dHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnRcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi4gWW91IGNhbiBtYW5pcHVsYXRlIGBnbF9GcmFnQ29sb3JgIGhlcmUgYnV0IGtlZXAgaW4gbWluZCBpdCBnb2VzXG4gKiAgICAgICAgYWZ0ZXIgYW55IG9mIFRocmVlSlMncyBjb2xvciBwb3N0cHJvY2Vzc2luZyBzaGFkZXIgY2h1bmtzICh0b25lbWFwcGluZywgZm9nLCBldGMuKSwgc28gaWYgeW91XG4gKiAgICAgICAgd2FudCB0aG9zZSB0byBhcHBseSB0byB5b3VyIGNoYW5nZXMgdXNlIGBmcmFnbWVudENvbG9yVHJhbnNmb3JtYCBpbnN0ZWFkLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnRDb2xvclRyYW5zZm9ybSAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gbWFuaXB1bGF0ZSB0aGUgYGdsX0ZyYWdDb2xvcmBcbiAqICAgICAgICBvdXRwdXQgdmFsdWUuIFdpbGwgYmUgaW5qZWN0ZWQgbmVhciB0aGUgZW5kIG9mIHRoZSBgdm9pZCBtYWluYCBmdW5jdGlvbiwgYnV0IGJlZm9yZSBhbnlcbiAqICAgICAgICBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIGFuZCBiZWZvcmUgdGhlXG4gKiAgICAgICAgYGZyYWdtZW50TWFpbk91dHJvYC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb248e3ZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcn0+Ont2ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXJ9fSBvcHRpb25zLmN1c3RvbVJld3JpdGVyIC0gQSBmdW5jdGlvblxuICogICAgICAgIGZvciBwZXJmb3JtaW5nIGN1c3RvbSByZXdyaXRlcyBvZiB0aGUgZnVsbCBzaGFkZXIgY29kZS4gVXNlZnVsIGlmIHlvdSBuZWVkIHRvIGRvIHNvbWV0aGluZ1xuICogICAgICAgIHNwZWNpYWwgdGhhdCdzIG5vdCBjb3ZlcmVkIGJ5IHRoZSBvdGhlciBidWlsdGluIG9wdGlvbnMuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZCBiZWZvcmVcbiAqICAgICAgICBhbnkgb3RoZXIgdHJhbnNmb3JtcyBhcmUgYXBwbGllZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jaGFpbmVkIC0gU2V0IHRvIGB0cnVlYCB0byBwcm90b3R5cGUtY2hhaW4gdGhlIGRlcml2ZWQgbWF0ZXJpYWwgdG8gdGhlIGJhc2VcbiAqICAgICAgICBtYXRlcmlhbCwgcmF0aGVyIHRoYW4gdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgY29weWluZyBpdC4gVGhpcyBhbGxvd3MgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgdG9cbiAqICAgICAgICBhdXRvbWF0aWNhbGx5IHBpY2sgdXAgY2hhbmdlcyBtYWRlIHRvIHRoZSBiYXNlIG1hdGVyaWFsIGFuZCBpdHMgcHJvcGVydGllcy4gVGhpcyBjYW4gYmUgdXNlZnVsXG4gKiAgICAgICAgd2hlcmUgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgaXMgaGlkZGVuIGZyb20gdGhlIHVzZXIgYXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLCBhbGxvd2luZyB0aGVtXG4gKiAgICAgICAgdG8gd29yayB3aXRoIHRoZSBvcmlnaW5hbCBtYXRlcmlhbCBsaWtlIG5vcm1hbC4gQnV0IGl0IGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvciBpZiBub3RcbiAqICAgICAgICBoYW5kbGVkIGNhcmVmdWxseS5cbiAqXG4gKiBAcmV0dXJuIHtUSFJFRS5NYXRlcmlhbH1cbiAqXG4gKiBUaGUgcmV0dXJuZWQgbWF0ZXJpYWwgd2lsbCBhbHNvIGhhdmUgdHdvIG5ldyBtZXRob2RzLCBgZ2V0RGVwdGhNYXRlcmlhbCgpYCBhbmQgYGdldERpc3RhbmNlTWF0ZXJpYWwoKWAsXG4gKiB3aGljaCBjYW4gYmUgY2FsbGVkIHRvIGdldCBhIHZhcmlhbnQgb2YgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgZm9yIHVzZSBpbiBzaGFkb3cgY2FzdGluZy4gSWYgdGhlXG4gKiB0YXJnZXQgbWVzaCBpcyBleHBlY3RlZCB0byBjYXN0IHNoYWRvd3MsIHRoZW4geW91IGNhbiBhc3NpZ24gdGhlc2UgdG8gdGhlIG1lc2gncyBgY3VzdG9tRGVwdGhNYXRlcmlhbGBcbiAqIChmb3IgZGlyZWN0aW9uYWwgYW5kIHNwb3QgbGlnaHRzKSBhbmQvb3IgYGN1c3RvbURpc3RhbmNlTWF0ZXJpYWxgIChmb3IgcG9pbnQgbGlnaHRzKSBwcm9wZXJ0aWVzIHRvXG4gKiBhbGxvdyB0aGUgY2FzdCBzaGFkb3cgdG8gaG9ub3IgeW91ciBkZXJpdmVkIHNoYWRlcidzIHZlcnRleCB0cmFuc2Zvcm1zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLiBUaGVzZVxuICogd2lsbCBhbHNvIHNldCBhIGN1c3RvbSBgI2RlZmluZSBJU19ERVBUSF9NQVRFUklBTGAgb3IgYCNkZWZpbmUgSVNfRElTVEFOQ0VfTUFURVJJQUxgIHRoYXQgeW91IGNhbiBsb29rXG4gKiBmb3IgaW4geW91ciBkZXJpdmVkIHNoYWRlcnMgd2l0aCBgI2lmZGVmYCB0byBjdXN0b21pemUgdGhlaXIgYmVoYXZpb3IgZm9yIHRoZSBkZXB0aCBvciBkaXN0YW5jZVxuICogc2NlbmFyaW9zLCBlLmcuIHNraXBwaW5nIGFudGlhbGlhc2luZyBvciBleHBlbnNpdmUgc2hhZGVyIGxvZ2ljLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsLCBvcHRpb25zKSB7XG4gIC8vIEdlbmVyYXRlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSBjb250ZW50IG9mIHRoZXNlIGBvcHRpb25zYC4gV2UnbGwgdXNlIHRoaXNcbiAgLy8gdGhyb3VnaG91dCBmb3IgY2FjaGluZyBhbmQgZm9yIGdlbmVyYXRpbmcgdGhlIHVwZ3JhZGVkIHNoYWRlciBjb2RlLiBUaGlzIGluY3JlYXNlc1xuICAvLyB0aGUgbGlrZWxpaG9vZCB0aGF0IHRoZSByZXN1bHRpbmcgc2hhZGVycyB3aWxsIGxpbmUgdXAgYWNyb3NzIG11bHRpcGxlIGNhbGxzIHNvXG4gIC8vIHRoZWlyIEdMIHByb2dyYW1zIGNhbiBiZSBzaGFyZWQgYW5kIGNhY2hlZC5cbiAgY29uc3Qgb3B0aW9uc0tleSA9IGdldEtleUZvck9wdGlvbnMob3B0aW9ucyk7XG5cbiAgLy8gRmlyc3QgY2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGFscmVhZHkgZGVyaXZlZCBmcm9tIHRoaXMgYmFzZU1hdGVyaWFsIHVzaW5nIHRoaXNcbiAgLy8gdW5pcXVlIHNldCBvZiBvcHRpb25zLCBhbmQgaWYgc28gcmV1c2UgdGhlIGNvbnN0cnVjdG9yIHRvIGF2b2lkIHNvbWUgYWxsb2NhdGlvbnMuXG4gIGxldCBjdG9yc0J5RGVyaXZhdGlvbiA9IENPTlNUUlVDVE9SX0NBQ0hFLmdldChiYXNlTWF0ZXJpYWwpO1xuICBpZiAoIWN0b3JzQnlEZXJpdmF0aW9uKSB7XG4gICAgQ09OU1RSVUNUT1JfQ0FDSEUuc2V0KGJhc2VNYXRlcmlhbCwgKGN0b3JzQnlEZXJpdmF0aW9uID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpO1xuICB9XG4gIGlmIChjdG9yc0J5RGVyaXZhdGlvbltvcHRpb25zS2V5XSkge1xuICAgIHJldHVybiBuZXcgY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0oKVxuICB9XG5cbiAgY29uc3QgcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wID0gYF9vbkJlZm9yZUNvbXBpbGUke29wdGlvbnNLZXl9YDtcblxuICAvLyBQcml2YXRlIG9uQmVmb3JlQ29tcGlsZSBoYW5kbGVyIHRoYXQgaW5qZWN0cyB0aGUgbW9kaWZpZWQgc2hhZGVycyBhbmQgdW5pZm9ybXMgd2hlblxuICAvLyB0aGUgcmVuZGVyZXIgc3dpdGNoZXMgdG8gdGhpcyBtYXRlcmlhbCdzIHByb2dyYW1cbiAgY29uc3Qgb25CZWZvcmVDb21waWxlID0gZnVuY3Rpb24gKHNoYWRlckluZm8sIHJlbmRlcmVyKSB7XG4gICAgYmFzZU1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZS5jYWxsKHRoaXMsIHNoYWRlckluZm8sIHJlbmRlcmVyKTtcblxuICAgIC8vIFVwZ3JhZGUgdGhlIHNoYWRlcnMsIGNhY2hpbmcgdGhlIHJlc3VsdCBieSBpbmNvbWluZyBzb3VyY2UgY29kZVxuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKSArICd8JyArIHNoYWRlckluZm8udmVydGV4U2hhZGVyICsgJ3wnICsgc2hhZGVySW5mby5mcmFnbWVudFNoYWRlcjtcbiAgICBsZXQgdXBncmFkZWRTaGFkZXJzID0gU0hBREVSX1VQR1JBREVfQ0FDSEVbY2FjaGVLZXldO1xuICAgIGlmICghdXBncmFkZWRTaGFkZXJzKSB7XG4gICAgICBjb25zdCB1cGdyYWRlZCA9IHVwZ3JhZGVTaGFkZXJzKHRoaXMsIHNoYWRlckluZm8sIG9wdGlvbnMsIG9wdGlvbnNLZXkpO1xuICAgICAgdXBncmFkZWRTaGFkZXJzID0gU0hBREVSX1VQR1JBREVfQ0FDSEVbY2FjaGVLZXldID0gdXBncmFkZWQ7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IHVwZ3JhZGVkIHNoYWRlcnMgYW5kIHVuaWZvcm1zIGludG8gdGhlIHByb2dyYW1cbiAgICBzaGFkZXJJbmZvLnZlcnRleFNoYWRlciA9IHVwZ3JhZGVkU2hhZGVycy52ZXJ0ZXhTaGFkZXI7XG4gICAgc2hhZGVySW5mby5mcmFnbWVudFNoYWRlciA9IHVwZ3JhZGVkU2hhZGVycy5mcmFnbWVudFNoYWRlcjtcbiAgICBhc3NpZ24oc2hhZGVySW5mby51bmlmb3JtcywgdGhpcy51bmlmb3Jtcyk7XG5cbiAgICAvLyBJbmplY3QgYXV0by11cGRhdGluZyB0aW1lIHVuaWZvcm0gaWYgcmVxdWVzdGVkXG4gICAgaWYgKG9wdGlvbnMudGltZVVuaWZvcm0pIHtcbiAgICAgIHNoYWRlckluZm8udW5pZm9ybXNbb3B0aW9ucy50aW1lVW5pZm9ybV0gPSB7XG4gICAgICAgIGdldCB2YWx1ZSgpIHtyZXR1cm4gRGF0ZS5ub3coKSAtIGVwb2NofVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBVc2VycyBjYW4gc3RpbGwgYWRkIHRoZWlyIG93biBoYW5kbGVycyBvbiB0b3Agb2Ygb3Vyc1xuICAgIGlmICh0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0pIHtcbiAgICAgIHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXShzaGFkZXJJbmZvKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgRGVyaXZlZE1hdGVyaWFsID0gZnVuY3Rpb24gRGVyaXZlZE1hdGVyaWFsKCkge1xuICAgIHJldHVybiBkZXJpdmUob3B0aW9ucy5jaGFpbmVkID8gYmFzZU1hdGVyaWFsIDogYmFzZU1hdGVyaWFsLmNsb25lKCkpXG4gIH07XG5cbiAgY29uc3QgZGVyaXZlID0gZnVuY3Rpb24oYmFzZSkge1xuICAgIC8vIFByb3RvdHlwZSBjaGFpbiB0byB0aGUgYmFzZSBtYXRlcmlhbFxuICAgIGNvbnN0IGRlcml2ZWQgPSBPYmplY3QuY3JlYXRlKGJhc2UsIGRlc2NyaXB0b3IpO1xuXG4gICAgLy8gU3RvcmUgdGhlIGJhc2VNYXRlcmlhbCBmb3IgcmVmZXJlbmNlOyB0aGlzIGlzIGFsd2F5cyB0aGUgb3JpZ2luYWwgZXZlbiB3aGVuIGNsb25pbmdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVyaXZlZCwgJ2Jhc2VNYXRlcmlhbCcsIHsgdmFsdWU6IGJhc2VNYXRlcmlhbCB9KTtcblxuICAgIC8vIE5lZWRzIGl0cyBvd24gaWRzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWQsICdpZCcsIHsgdmFsdWU6IG1hdGVyaWFsSW5zdGFuY2VJZCsrIH0pO1xuICAgIGRlcml2ZWQudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG4gICAgLy8gTWVyZ2UgdW5pZm9ybXMsIGRlZmluZXMsIGFuZCBleHRlbnNpb25zXG4gICAgZGVyaXZlZC51bmlmb3JtcyA9IGFzc2lnbih7fSwgYmFzZS51bmlmb3Jtcywgb3B0aW9ucy51bmlmb3Jtcyk7XG4gICAgZGVyaXZlZC5kZWZpbmVzID0gYXNzaWduKHt9LCBiYXNlLmRlZmluZXMsIG9wdGlvbnMuZGVmaW5lcyk7XG4gICAgZGVyaXZlZC5kZWZpbmVzW2BUUk9JS0FfREVSSVZFRF9NQVRFUklBTF8ke29wdGlvbnNLZXl9YF0gPSAnJzsgLy9mb3JjZSBhIHByb2dyYW0gY2hhbmdlIGZyb20gdGhlIGJhc2UgbWF0ZXJpYWxcbiAgICBkZXJpdmVkLmV4dGVuc2lvbnMgPSBhc3NpZ24oe30sIGJhc2UuZXh0ZW5zaW9ucywgb3B0aW9ucy5leHRlbnNpb25zKTtcblxuICAgIC8vIERvbid0IGluaGVyaXQgRXZlbnREaXNwYXRjaGVyIGxpc3RlbmVyc1xuICAgIGRlcml2ZWQuX2xpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBkZXJpdmVkXG4gIH07XG5cbiAgY29uc3QgZGVzY3JpcHRvciA9IHtcbiAgICBjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBEZXJpdmVkTWF0ZXJpYWx9LFxuICAgIGlzRGVyaXZlZE1hdGVyaWFsOiB7dmFsdWU6IHRydWV9LFxuXG4gICAgY3VzdG9tUHJvZ3JhbUNhY2hlS2V5OiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBiYXNlTWF0ZXJpYWwuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkgKyAnfCcgKyBvcHRpb25zS2V5XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uQmVmb3JlQ29tcGlsZToge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gb25CZWZvcmVDb21waWxlXG4gICAgICB9LFxuICAgICAgc2V0KGZuKSB7XG4gICAgICAgIHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXSA9IGZuO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb3B5OiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5jb3B5LmNhbGwodGhpcywgc291cmNlKTtcbiAgICAgICAgaWYgKCFiYXNlTWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiAhYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsKSB7XG4gICAgICAgICAgYXNzaWduKHRoaXMuZXh0ZW5zaW9ucywgc291cmNlLmV4dGVuc2lvbnMpO1xuICAgICAgICAgIGFzc2lnbih0aGlzLmRlZmluZXMsIHNvdXJjZS5kZWZpbmVzKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy51bmlmb3JtcywgVW5pZm9ybXNVdGlscy5jbG9uZShzb3VyY2UudW5pZm9ybXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjbG9uZToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBuZXdCYXNlID0gbmV3IGJhc2VNYXRlcmlhbC5jb25zdHJ1Y3RvcigpO1xuICAgICAgICByZXR1cm4gZGVyaXZlKG5ld0Jhc2UpLmNvcHkodGhpcylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBnZXQgYSBNZXNoRGVwdGhNYXRlcmlhbCB0aGF0IHdpbGwgaG9ub3IgdGhpcyBkZXJpdmVkIG1hdGVyaWFsJ3MgdmVydGV4XG4gICAgICogdHJhbnNmb3JtYXRpb25zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLlxuICAgICAqL1xuICAgIGdldERlcHRoTWF0ZXJpYWw6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgZGVwdGhNYXRlcmlhbCA9IHRoaXMuX2RlcHRoTWF0ZXJpYWw7XG4gICAgICAgIGlmICghZGVwdGhNYXRlcmlhbCkge1xuICAgICAgICAgIGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgICAgICAgYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsXG4gICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICA6IG5ldyBNZXNoRGVwdGhNYXRlcmlhbCh7IGRlcHRoUGFja2luZzogUkdCQURlcHRoUGFja2luZyB9KSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGRlcHRoTWF0ZXJpYWwuZGVmaW5lcy5JU19ERVBUSF9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgIGRlcHRoTWF0ZXJpYWwudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zOyAvL2F1dG9tYXRpY2FsbHkgcmVjaWV2ZSBzYW1lIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcHRoTWF0ZXJpYWxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBnZXQgYSBNZXNoRGlzdGFuY2VNYXRlcmlhbCB0aGF0IHdpbGwgaG9ub3IgdGhpcyBkZXJpdmVkIG1hdGVyaWFsJ3MgdmVydGV4XG4gICAgICogdHJhbnNmb3JtYXRpb25zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLlxuICAgICAqL1xuICAgIGdldERpc3RhbmNlTWF0ZXJpYWw6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgZGlzdGFuY2VNYXRlcmlhbCA9IHRoaXMuX2Rpc3RhbmNlTWF0ZXJpYWw7XG4gICAgICAgIGlmICghZGlzdGFuY2VNYXRlcmlhbCkge1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgICAgICAgYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsXG4gICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICA6IG5ldyBNZXNoRGlzdGFuY2VNYXRlcmlhbCgpLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbC5kZWZpbmVzLklTX0RJU1RBTkNFX01BVEVSSUFMID0gJyc7XG4gICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbC51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7IC8vYXV0b21hdGljYWxseSByZWNpZXZlIHNhbWUgdW5pZm9ybSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdGFuY2VNYXRlcmlhbFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlKCkge1xuICAgICAgICBjb25zdCB7X2RlcHRoTWF0ZXJpYWwsIF9kaXN0YW5jZU1hdGVyaWFsfSA9IHRoaXM7XG4gICAgICAgIGlmIChfZGVwdGhNYXRlcmlhbCkgX2RlcHRoTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICBpZiAoX2Rpc3RhbmNlTWF0ZXJpYWwpIF9kaXN0YW5jZU1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgYmFzZU1hdGVyaWFsLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0gPSBEZXJpdmVkTWF0ZXJpYWw7XG4gIHJldHVybiBuZXcgRGVyaXZlZE1hdGVyaWFsKClcbn1cblxuXG5mdW5jdGlvbiB1cGdyYWRlU2hhZGVycyhtYXRlcmlhbCwge3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9LCBvcHRpb25zLCBrZXkpIHtcbiAgbGV0IHtcbiAgICB2ZXJ0ZXhEZWZzLFxuICAgIHZlcnRleE1haW5JbnRybyxcbiAgICB2ZXJ0ZXhNYWluT3V0cm8sXG4gICAgdmVydGV4VHJhbnNmb3JtLFxuICAgIGZyYWdtZW50RGVmcyxcbiAgICBmcmFnbWVudE1haW5JbnRybyxcbiAgICBmcmFnbWVudE1haW5PdXRybyxcbiAgICBmcmFnbWVudENvbG9yVHJhbnNmb3JtLFxuICAgIGN1c3RvbVJld3JpdGVyLFxuICAgIHRpbWVVbmlmb3JtXG4gIH0gPSBvcHRpb25zO1xuXG4gIHZlcnRleERlZnMgPSB2ZXJ0ZXhEZWZzIHx8ICcnO1xuICB2ZXJ0ZXhNYWluSW50cm8gPSB2ZXJ0ZXhNYWluSW50cm8gfHwgJyc7XG4gIHZlcnRleE1haW5PdXRybyA9IHZlcnRleE1haW5PdXRybyB8fCAnJztcbiAgZnJhZ21lbnREZWZzID0gZnJhZ21lbnREZWZzIHx8ICcnO1xuICBmcmFnbWVudE1haW5JbnRybyA9IGZyYWdtZW50TWFpbkludHJvIHx8ICcnO1xuICBmcmFnbWVudE1haW5PdXRybyA9IGZyYWdtZW50TWFpbk91dHJvIHx8ICcnO1xuXG4gIC8vIEV4cGFuZCBpbmNsdWRlcyBpZiBuZWVkZWRcbiAgaWYgKHZlcnRleFRyYW5zZm9ybSB8fCBjdXN0b21SZXdyaXRlcikge1xuICAgIHZlcnRleFNoYWRlciA9IGV4cGFuZFNoYWRlckluY2x1ZGVzKHZlcnRleFNoYWRlcik7XG4gIH1cbiAgaWYgKGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGJlIGFibGUgdG8gZmluZCBwb3N0cHJvY2Vzc2luZyBjaHVua3MgYWZ0ZXIgaW5jbHVkZSBleHBhbnNpb24gaW4gb3JkZXIgdG9cbiAgICAvLyBwdXQgdGhlbSBhZnRlciB0aGUgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgc28gbWFyayB0aGVtIHdpdGggY29tbWVudHMgZmlyc3QuIEV2ZW4gaWZcbiAgICAvLyB0aGlzIHBhcnRpY3VsYXIgZGVyaXZhdGlvbiBkb2Vzbid0IGhhdmUgYSBmcmFnbWVudENvbG9yVHJhbnNmb3JtLCBvdGhlciBkZXJpdmF0aW9ucyBtYXksXG4gICAgLy8gc28gd2Ugc3RpbGwgbWFyayB0aGVtLlxuICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcbiAgICAgIC9eWyBcXHRdKiNpbmNsdWRlIDwoKD86dG9uZW1hcHBpbmd8ZW5jb2RpbmdzfGZvZ3xwcmVtdWx0aXBsaWVkX2FscGhhfGRpdGhlcmluZylfZnJhZ21lbnQpPi9nbSxcbiAgICAgICdcXG4vLyFCRUdJTl9QT1NUX0NIVU5LICQxXFxuJCZcXG4vLyFFTkRfUE9TVF9DSFVOS1xcbidcbiAgICApO1xuICAgIGZyYWdtZW50U2hhZGVyID0gZXhwYW5kU2hhZGVySW5jbHVkZXMoZnJhZ21lbnRTaGFkZXIpO1xuICB9XG5cbiAgLy8gQXBwbHkgY3VzdG9tIHJld3JpdGVyIGZ1bmN0aW9uXG4gIGlmIChjdXN0b21SZXdyaXRlcikge1xuICAgIGxldCByZXMgPSBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0pO1xuICAgIHZlcnRleFNoYWRlciA9IHJlcy52ZXJ0ZXhTaGFkZXI7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSByZXMuZnJhZ21lbnRTaGFkZXI7XG4gIH1cblxuICAvLyBUaGUgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSBuZWVkcyB0byBnbyBiZWZvcmUgYW55IHBvc3Rwcm9jZXNzaW5nIGNodW5rcywgc28gZXh0cmFjdFxuICAvLyB0aG9zZSBhbmQgcmUtaW5zZXJ0IHRoZW0gaW50byB0aGUgb3V0cm8gaW4gdGhlIGNvcnJlY3QgcGxhY2U6XG4gIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtKSB7XG4gICAgbGV0IHBvc3RDaHVua3MgPSBbXTtcbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAvXlxcL1xcLyFCRUdJTl9QT1NUX0NIVU5LW15dKz9eXFwvXFwvIUVORF9QT1NUX0NIVU5LL2dtLCAvLyBbXl0rPyA9IG5vbi1ncmVlZHkgbWF0Y2ggb2YgYW55IGNoYXJzIGluY2x1ZGluZyBuZXdsaW5lc1xuICAgICAgbWF0Y2ggPT4ge1xuICAgICAgICBwb3N0Q2h1bmtzLnB1c2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cbiAgICApO1xuICAgIGZyYWdtZW50TWFpbk91dHJvID0gYCR7ZnJhZ21lbnRDb2xvclRyYW5zZm9ybX1cXG4ke3Bvc3RDaHVua3Muam9pbignXFxuJyl9XFxuJHtmcmFnbWVudE1haW5PdXRyb31gO1xuICB9XG5cbiAgLy8gSW5qZWN0IGF1dG8tdXBkYXRpbmcgdGltZSB1bmlmb3JtIGlmIHJlcXVlc3RlZFxuICBpZiAodGltZVVuaWZvcm0pIHtcbiAgICBjb25zdCBjb2RlID0gYFxcbnVuaWZvcm0gZmxvYXQgJHt0aW1lVW5pZm9ybX07XFxuYDtcbiAgICB2ZXJ0ZXhEZWZzID0gY29kZSArIHZlcnRleERlZnM7XG4gICAgZnJhZ21lbnREZWZzID0gY29kZSArIGZyYWdtZW50RGVmcztcbiAgfVxuXG4gIC8vIEluamVjdCBhIGZ1bmN0aW9uIGZvciB0aGUgdmVydGV4VHJhbnNmb3JtIGFuZCByZW5hbWUgYWxsIHVzYWdlcyBvZiBwb3NpdGlvbi9ub3JtYWwvdXZcbiAgaWYgKHZlcnRleFRyYW5zZm9ybSkge1xuICAgIC8vIEhvaXN0IHRoZXNlIGRlZnMgdG8gdGhlIHZlcnkgdG9wIHNvIHRoZXkgd29yayBpbiBvdGhlciBmdW5jdGlvbiBkZWZzXG4gICAgdmVydGV4U2hhZGVyID0gYHZlYzMgdHJvaWthX3Bvc2l0aW9uXyR7a2V5fTtcbnZlYzMgdHJvaWthX25vcm1hbF8ke2tleX07XG52ZWMyIHRyb2lrYV91dl8ke2tleX07XG4ke3ZlcnRleFNoYWRlcn1cbmA7XG4gICAgdmVydGV4RGVmcyA9IGAke3ZlcnRleERlZnN9XG52b2lkIHRyb2lrYVZlcnRleFRyYW5zZm9ybSR7a2V5fShpbm91dCB2ZWMzIHBvc2l0aW9uLCBpbm91dCB2ZWMzIG5vcm1hbCwgaW5vdXQgdmVjMiB1dikge1xuICAke3ZlcnRleFRyYW5zZm9ybX1cbn1cbmA7XG4gICAgdmVydGV4TWFpbkludHJvID0gYFxudHJvaWthX3Bvc2l0aW9uXyR7a2V5fSA9IHZlYzMocG9zaXRpb24pO1xudHJvaWthX25vcm1hbF8ke2tleX0gPSB2ZWMzKG5vcm1hbCk7XG50cm9pa2FfdXZfJHtrZXl9ID0gdmVjMih1dik7XG50cm9pa2FWZXJ0ZXhUcmFuc2Zvcm0ke2tleX0odHJvaWthX3Bvc2l0aW9uXyR7a2V5fSwgdHJvaWthX25vcm1hbF8ke2tleX0sIHRyb2lrYV91dl8ke2tleX0pO1xuJHt2ZXJ0ZXhNYWluSW50cm99XG5gO1xuICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKC9cXGIocG9zaXRpb258bm9ybWFsfHV2KVxcYi9nLCAobWF0Y2gsIG1hdGNoMSwgaW5kZXgsIGZ1bGxTdHIpID0+IHtcbiAgICAgIHJldHVybiAvXFxiYXR0cmlidXRlXFxzK3ZlY1syM11cXHMrJC8udGVzdChmdWxsU3RyLnN1YnN0cigwLCBpbmRleCkpID8gbWF0Y2gxIDogYHRyb2lrYV8ke21hdGNoMX1fJHtrZXl9YFxuICAgIH0pO1xuXG4gICAgLy8gVGhyZWUgcjE1MiBpbnRyb2R1Y2VkIHRoZSBNQVBfVVYgdG9rZW4sIHJlcGxhY2UgaXQgdG9vIGlmIGl0J3MgcG9pbnRpbmcgdG8gdGhlIG1haW4gJ3V2J1xuICAgIC8vIFBlcmhhcHMgdGhlIG90aGVyIHRleHR1cmVzIHRvbyBnb2luZyBmb3J3YXJkP1xuICAgIGlmICghKG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuY2hhbm5lbCA+IDApKSB7XG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxiTUFQX1VWXFxiL2csIGB0cm9pa2FfdXZfJHtrZXl9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5qZWN0IGRlZnMgYW5kIGludHJvL291dHJvIHNuaXBwZXRzXG4gIHZlcnRleFNoYWRlciA9IGluamVjdEludG9TaGFkZXJDb2RlKHZlcnRleFNoYWRlciwga2V5LCB2ZXJ0ZXhEZWZzLCB2ZXJ0ZXhNYWluSW50cm8sIHZlcnRleE1haW5PdXRybyk7XG4gIGZyYWdtZW50U2hhZGVyID0gaW5qZWN0SW50b1NoYWRlckNvZGUoZnJhZ21lbnRTaGFkZXIsIGtleSwgZnJhZ21lbnREZWZzLCBmcmFnbWVudE1haW5JbnRybywgZnJhZ21lbnRNYWluT3V0cm8pO1xuXG4gIHJldHVybiB7XG4gICAgdmVydGV4U2hhZGVyLFxuICAgIGZyYWdtZW50U2hhZGVyXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b1NoYWRlckNvZGUoc2hhZGVyQ29kZSwgaWQsIGRlZnMsIGludHJvLCBvdXRybykge1xuICBpZiAoaW50cm8gfHwgb3V0cm8gfHwgZGVmcykge1xuICAgIHNoYWRlckNvZGUgPSBzaGFkZXJDb2RlLnJlcGxhY2Uodm9pZE1haW5SZWdFeHAsIGBcbiR7ZGVmc31cbnZvaWQgdHJvaWthT3JpZ01haW4ke2lkfSgpIHtgXG4gICAgKTtcbiAgICBzaGFkZXJDb2RlICs9IGBcbnZvaWQgbWFpbigpIHtcbiAgJHtpbnRyb31cbiAgdHJvaWthT3JpZ01haW4ke2lkfSgpO1xuICAke291dHJvfVxufWA7XG4gIH1cbiAgcmV0dXJuIHNoYWRlckNvZGVcbn1cblxuXG5mdW5jdGlvbiBvcHRpb25zSnNvblJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ3VuaWZvcm1zJyA/IHVuZGVmaW5lZCA6IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZVxufVxuXG5sZXQgX2lkQ3RyID0gMDtcbmNvbnN0IG9wdGlvbnNIYXNoZXNUb0lkcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEtleUZvck9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zSGFzaCA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG9wdGlvbnNKc29uUmVwbGFjZXIpO1xuICBsZXQgaWQgPSBvcHRpb25zSGFzaGVzVG9JZHMuZ2V0KG9wdGlvbnNIYXNoKTtcbiAgaWYgKGlkID09IG51bGwpIHtcbiAgICBvcHRpb25zSGFzaGVzVG9JZHMuc2V0KG9wdGlvbnNIYXNoLCAoaWQgPSArK19pZEN0cikpO1xuICB9XG4gIHJldHVybiBpZFxufVxuXG4vLyBDb3BpZWQgZnJvbSB0aHJlZWpzIFdlYkdMUHJvZ3JhbXMuanMgc28gd2UgY2FuIHJlc29sdmUgYnVpbHRpbiBtYXRlcmlhbHMgdG8gdGhlaXIgc2hhZGVyc1xuLy8gVE9ETyBob3cgY2FuIHdlIGtlZXAgdGhpcyBmcm9tIGdldHRpbmcgc3RhbGU/XG5jb25zdCBNQVRFUklBTF9UWVBFU19UT19TSEFERVJTID0ge1xuICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgTWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxuICBNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgTWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuICBNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcbiAgTWVzaFRvb25NYXRlcmlhbDogJ3Rvb24nLFxuICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgTWVzaFBoeXNpY2FsTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG4gIE1lc2hNYXRjYXBNYXRlcmlhbDogJ21hdGNhcCcsXG4gIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICBMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuICBQb2ludHNNYXRlcmlhbDogJ3BvaW50cycsXG4gIFNoYWRvd01hdGVyaWFsOiAnc2hhZG93JyxcbiAgU3ByaXRlTWF0ZXJpYWw6ICdzcHJpdGUnXG59O1xuXG4vKipcbiAqIEdpdmVuIGEgVGhyZWUuanMgYE1hdGVyaWFsYCBpbnN0YW5jZSwgZmluZCB0aGUgc2hhZGVycy91bmlmb3JtcyB0aGF0IHdpbGwgYmVcbiAqIHVzZWQgdG8gcmVuZGVyIHRoYXQgbWF0ZXJpYWwuXG4gKlxuICogQHBhcmFtIG1hdGVyaWFsIC0gdGhlIE1hdGVyaWFsIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gdGhlIG1hdGVyaWFsJ3Mgc2hhZGVyIGluZm86IGB7dW5pZm9ybXM6e30sIGZyYWdtZW50U2hhZGVyOicnLCB2ZXJ0ZXhTaGFkZXI6Jyd9YFxuICovXG5mdW5jdGlvbiBnZXRTaGFkZXJzRm9yTWF0ZXJpYWwobWF0ZXJpYWwpIHtcbiAgbGV0IGJ1aWx0aW5UeXBlID0gTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSU1ttYXRlcmlhbC50eXBlXTtcbiAgcmV0dXJuIGJ1aWx0aW5UeXBlID8gU2hhZGVyTGliW2J1aWx0aW5UeXBlXSA6IG1hdGVyaWFsIC8vVE9ETyBmYWxsYmFjayBmb3IgdW5rbm93biB0eXBlP1xufVxuXG4vKipcbiAqIEZpbmQgYWxsIHVuaWZvcm1zIGFuZCB0aGVpciB0eXBlcyB3aXRoaW4gYSBzaGFkZXIgY29kZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlciAtIFRoZSBzaGFkZXIgY29kZSB0byBwYXJzZVxuICogQHJldHVybiB7b2JqZWN0fSBtYXBwaW5nIG9mIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgZ2xzbCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldFNoYWRlclVuaWZvcm1UeXBlcyhzaGFkZXIpIHtcbiAgbGV0IHVuaWZvcm1SRSA9IC9cXGJ1bmlmb3JtXFxzKyhpbnR8ZmxvYXR8dmVjWzIzNF18bWF0WzM0XSlcXHMrKFtBLVphLXpfXVtcXHddKikvZztcbiAgbGV0IHVuaWZvcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gdW5pZm9ybVJFLmV4ZWMoc2hhZGVyKSkgIT09IG51bGwpIHtcbiAgICB1bmlmb3Jtc1ttYXRjaFsyXV0gPSBtYXRjaFsxXTtcbiAgfVxuICByZXR1cm4gdW5pZm9ybXNcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHNtb290aGluZyBvdXQgdGhlIGBtLmdldEludmVyc2UoeClgIC0tPiBgbS5jb3B5KHgpLmludmVydCgpYCBjb252ZXJzaW9uXG4gKiB0aGF0IGhhcHBlbmVkIGluIFRocmVlSlMgcjEyMy5cbiAqIEBwYXJhbSB7TWF0cml4NH0gc3JjTWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDR9IFt0Z3RNYXRyaXhdXG4gKi9cbmZ1bmN0aW9uIGludmVydE1hdHJpeDQoc3JjTWF0cml4LCB0Z3RNYXRyaXggPSBuZXcgTWF0cml4NCgpKSB7XG4gIGlmICh0eXBlb2YgdGd0TWF0cml4LmludmVydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRndE1hdHJpeC5jb3B5KHNyY01hdHJpeCkuaW52ZXJ0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGd0TWF0cml4LmdldEludmVyc2Uoc3JjTWF0cml4KTtcbiAgfVxuICByZXR1cm4gdGd0TWF0cml4XG59XG5cbi8qXG5JbnB1dCBnZW9tZXRyeSBpcyBhIGN5bGluZGVyIHdpdGggcj0xLCBoZWlnaHQgaW4geSBkaW1lbnNpb24gZnJvbSAwIHRvIDEsXG5kaXZpZGVkIGludG8gYSByZWFzb25hYmxlIG51bWJlciBvZiBoZWlnaHQgc2VnbWVudHMuXG4qL1xuXG5jb25zdCB2ZXJ0ZXhEZWZzID0gYFxudW5pZm9ybSB2ZWMzIHBvaW50QTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQjtcbnVuaWZvcm0gdmVjMyBwb2ludEI7XG51bmlmb3JtIGZsb2F0IHJhZGl1cztcbnZhcnlpbmcgZmxvYXQgYmV6aWVyVDtcblxudmVjMyBjdWJpY0Jlemllcih2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgZmxvYXQgYjAgPSB0MiAqIHQyICogdDI7XG4gIGZsb2F0IGIxID0gMy4wICogdCAqIHQyICogdDI7XG4gIGZsb2F0IGIyID0gMy4wICogdCAqIHQgKiB0MjtcbiAgZmxvYXQgYjMgPSB0ICogdCAqIHQ7XG4gIHJldHVybiBiMCAqIHAxICsgYjEgKiBjMSArIGIyICogYzIgKyBiMyAqIHAyO1xufVxuXG52ZWMzIGN1YmljQmV6aWVyRGVyaXZhdGl2ZSh2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgcmV0dXJuIC0zLjAgKiBwMSAqIHQyICogdDIgK1xuICAgIGMxICogKDMuMCAqIHQyICogdDIgLSA2LjAgKiB0MiAqIHQpICtcbiAgICBjMiAqICg2LjAgKiB0MiAqIHQgLSAzLjAgKiB0ICogdCkgK1xuICAgIDMuMCAqIHAyICogdCAqIHQ7XG59XG5gO1xuXG5jb25zdCB2ZXJ0ZXhUcmFuc2Zvcm0gPSBgXG5mbG9hdCB0ID0gcG9zaXRpb24ueTtcbmJlemllclQgPSB0O1xudmVjMyBiZXppZXJDZW50ZXJQb3MgPSBjdWJpY0Jlemllcihwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KTtcbnZlYzMgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KSk7XG5cbi8vIE1ha2UgXCJzaWRld2F5c1wiIGFsd2F5cyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBjYW1lcmEgcmF5OyB0aGlzIGVuc3VyZXMgdGhhdCBhbnkgdHdpc3RzXG4vLyBpbiB0aGUgY3lsaW5kZXIgb2NjdXIgd2hlcmUgeW91IHdvbid0IHNlZSB0aGVtOiBcbnZlYzMgdmlld0RpcmVjdGlvbiA9IG5vcm1hbE1hdHJpeCAqIHZlYzMoMC4wLCAwLjAsIDEuMCk7XG5pZiAoYmV6aWVyRGlyID09IHZpZXdEaXJlY3Rpb24pIHtcbiAgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0ID09IDEuMCA/IHQgLSAwLjAwMDEgOiB0ICsgMC4wMDAxKSk7XG59XG52ZWMzIHNpZGV3YXlzID0gbm9ybWFsaXplKGNyb3NzKGJlemllckRpciwgdmlld0RpcmVjdGlvbikpO1xudmVjMyB1cGlzaCA9IG5vcm1hbGl6ZShjcm9zcyhzaWRld2F5cywgYmV6aWVyRGlyKSk7XG5cbi8vIEJ1aWxkIGEgbWF0cml4IGZvciB0cmFuc2Zvcm1pbmcgdGhpcyBkaXNjIGluIHRoZSBjeWxpbmRlcjpcbm1hdDQgZGlzY1R4O1xuZGlzY1R4WzBdLnh5eiA9IHNpZGV3YXlzICogcmFkaXVzO1xuZGlzY1R4WzFdLnh5eiA9IGJlemllckRpciAqIHJhZGl1cztcbmRpc2NUeFsyXS54eXogPSB1cGlzaCAqIHJhZGl1cztcbmRpc2NUeFszXS54eXogPSBiZXppZXJDZW50ZXJQb3M7XG5kaXNjVHhbM11bM10gPSAxLjA7XG5cbi8vIEFwcGx5IHRyYW5zZm9ybSwgaWdub3Jpbmcgb3JpZ2luYWwgeVxucG9zaXRpb24gPSAoZGlzY1R4ICogdmVjNChwb3NpdGlvbi54LCAwLjAsIHBvc2l0aW9uLnosIDEuMCkpLnh5ejtcbm5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKGRpc2NUeCkgKiBub3JtYWwpO1xuYDtcblxuY29uc3QgZnJhZ21lbnREZWZzID0gYFxudW5pZm9ybSB2ZWMzIGRhc2hpbmc7XG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XG5gO1xuXG5jb25zdCBmcmFnbWVudE1haW5JbnRybyA9IGBcbmlmIChkYXNoaW5nLnggKyBkYXNoaW5nLnkgPiAwLjApIHtcbiAgZmxvYXQgZGFzaEZyYWMgPSBtb2QoYmV6aWVyVCAtIGRhc2hpbmcueiwgZGFzaGluZy54ICsgZGFzaGluZy55KTtcbiAgaWYgKGRhc2hGcmFjID4gZGFzaGluZy54KSB7XG4gICAgZGlzY2FyZDtcbiAgfVxufVxuYDtcblxuLy8gRGVidWdnaW5nOiBzZXBhcmF0ZSBjb2xvciBmb3IgZWFjaCBvZiB0aGUgNiBzaWRlczpcbi8vIGNvbnN0IGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gPSBgXG4vLyBmbG9hdCBzaWRlTnVtID0gZmxvb3IodlVWLnggKiA2LjApO1xuLy8gdmVjMyBtaXhDb2xvciA9IHNpZGVOdW0gPCAxLjAgPyB2ZWMzKDEuMCwgMC4wLCAwLjApIDpcbi8vICAgc2lkZU51bSA8IDIuMCA/IHZlYzMoMC4wLCAxLjAsIDEuMCkgOlxuLy8gICBzaWRlTnVtIDwgMy4wID8gdmVjMygxLjAsIDEuMCwgMC4wKSA6XG4vLyAgIHNpZGVOdW0gPCA0LjAgPyB2ZWMzKDAuMCwgMC4wLCAxLjApIDpcbi8vICAgc2lkZU51bSA8IDUuMCA/IHZlYzMoMC4wLCAxLjAsIDAuMCkgOlxuLy8gICB2ZWMzKDEuMCwgMC4wLCAxLjApO1xuLy8gZ2xfRnJhZ0NvbG9yLnh5eiA9IG1peChnbF9GcmFnQ29sb3IueHl6LCBtaXhDb2xvciwgMC41KTtcbi8vIGBcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgcmV0dXJuIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICBiYXNlTWF0ZXJpYWwsXG4gICAge1xuICAgICAgY2hhaW5lZDogdHJ1ZSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHBvaW50QToge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgY29udHJvbEE6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIGNvbnRyb2xCOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICBwb2ludEI6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIHJhZGl1czoge3ZhbHVlOiAwLjAxfSxcbiAgICAgICAgZGFzaGluZzoge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSAvL29uLCBvZmYsIG9mZnNldFxuICAgICAgfSxcbiAgICAgIHZlcnRleERlZnMsXG4gICAgICB2ZXJ0ZXhUcmFuc2Zvcm0sXG4gICAgICBmcmFnbWVudERlZnMsXG4gICAgICBmcmFnbWVudE1haW5JbnRyb1xuICAgIH1cbiAgKVxufVxuXG5sZXQgZ2VvbWV0cnkgPSBudWxsO1xuXG5jb25zdCBkZWZhdWx0QmFzZU1hdGVyaWFsID0gLyojX19QVVJFX18qL25ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7Y29sb3I6IDB4ZmZmZmZmLCBzaWRlOiBEb3VibGVTaWRlfSk7XG5cblxuLyoqXG4gKiBBIFRocmVlSlMgYE1lc2hgIHRoYXQgYmVuZHMgYSB0dWJlIHNoYXBlIGFsb25nIGEgM0QgY3ViaWMgYmV6aWVyIHBhdGguIFRoZSBiZW5kaW5nIGlzIGRvbmVcbiAqIGJ5IGRlZm9ybWluZyBhIHN0cmFpZ2h0IGN5bGluZHJpY2FsIGdlb21ldHJ5IGluIHRoZSB2ZXJ0ZXggc2hhZGVyIGJhc2VkIG9uIGEgc2V0IG9mIGZvdXJcbiAqIGNvbnRyb2wgcG9pbnQgdW5pZm9ybXMuIEl0IHBhdGNoZXMgdGhlIG5lY2Vzc2FyeSBHTFNMIGludG8gdGhlIG1lc2gncyBhc3NpZ25lZCBgbWF0ZXJpYWxgXG4gKiBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIFRoZSBjdWJpeiBiZXppZXIgcGF0aCBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBmb3VyIGBWZWN0b3IzYCBwcm9wZXJ0aWVzOlxuICogLSBgcG9pbnRBYFxuICogLSBgY29udHJvbEFgXG4gKiAtIGBjb250cm9sQmBcbiAqIC0gYHBvaW50QmBcbiAqXG4gKiBUaGUgdHViZSdzIHJhZGl1cyBpcyBjb250cm9sbGVkIGJ5IGl0cyBgcmFkaXVzYCBwcm9wZXJ0eSwgd2hpY2ggZGVmYXVsdHMgdG8gYDAuMDFgLlxuICpcbiAqIFlvdSBjYW4gYWxzbyBnaXZlIHRoZSB0dWJlIGEgZGFzaGVkIGFwcGVhcmFuY2Ugd2l0aCB0d28gcHJvcGVydGllczpcbiAqXG4gKiAtIGBkYXNoQXJyYXlgIC0gYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMsIGRlZmluaW5nIHRoZSBsZW5ndGggb2YgXCJvblwiIGFuZCBcIm9mZlwiIHBhcnRzIG9mXG4gKiAgIHRoZSBkYXNoLiBFYWNoIGlzIGEgMC0xIHJhdGlvIG9mIHRoZSBlbnRpcmUgcGF0aCdzIGxlbmd0aC4gKEFjdHVhbGx5IHRoaXMgaXMgdGhlIGB0YCBsZW5ndGhcbiAqICAgdXNlZCBhcyBpbnB1dCB0byB0aGUgY3ViaWMgYmV6aWVyIGZ1bmN0aW9uLCBub3QgaXRzIHZpc2libGUgbGVuZ3RoLilcbiAqIC0gYGRhc2hPZmZzZXRgIC0gb2Zmc2V0IG9mIHdoZXJlIHRoZSBkYXNoIHN0YXJ0cy4gWW91IGNhbiBhbmltYXRlIHRoaXMgdG8gbWFrZSB0aGUgZGFzaGVzIG1vdmUuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBkYXNoZXMgd2lsbCBhcHBlYXIgbGlrZSBhIGhvbGxvdyB0dWJlLCBub3Qgc29saWQuIFRoaXMgd2lsbCBiZSBtb3JlIGFwcGFyZW50IG9uXG4gKiB0aGlja2VyIHR1YmVzLlxuICpcbiAqIFRPRE86IHByb3BlciBnZW9tZXRyeSBib3VuZGluZyBzcGhlcmUgYW5kIHJheWNhc3RpbmdcbiAqIFRPRE86IGFsbG93IGNvbnRyb2wgb2YgdGhlIGdlb21ldHJ5J3Mgc2VnbWVudCBjb3VudHNcbiAqL1xuY2xhc3MgQmV6aWVyTWVzaCBleHRlbmRzIE1lc2gge1xuICBzdGF0aWMgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIGdlb21ldHJ5IHx8IChnZW9tZXRyeSA9XG4gICAgICBuZXcgQ3lsaW5kZXJHZW9tZXRyeSgxLCAxLCAxLCA2LCA2NCkudHJhbnNsYXRlKDAsIDAuNSwgMClcbiAgICApXG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcbiAgICAgIEJlemllck1lc2guZ2V0R2VvbWV0cnkoKSxcbiAgICAgIGRlZmF1bHRCYXNlTWF0ZXJpYWxcbiAgICApO1xuXG4gICAgdGhpcy5wb2ludEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY29udHJvbEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY29udHJvbEIgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMucG9pbnRCID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLnJhZGl1cyA9IDAuMDE7XG4gICAgdGhpcy5kYXNoQXJyYXkgPSBuZXcgVmVjdG9yMigpO1xuICAgIHRoaXMuZGFzaE9mZnNldCA9IDA7XG5cbiAgICAvLyBUT0RPIC0gZGlzYWJsaW5nIGZydXN0dW0gY3VsbGluZyB1bnRpbCBJIGZpZ3VyZSBvdXQgaG93IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICAvLyAgZ2VvbWV0cnkncyBib3VuZGluZyBzcGhlcmUgdGhhdCBnZXRzIHVzZWRcbiAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEhhbmRsZXIgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgdGhlIGJhc2UgbWF0ZXJpYWwgd2l0aCBvdXIgdXBncmFkZXMuIFdlIGRvIHRoZSB3cmFwcGluZ1xuICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gIGdldCBtYXRlcmlhbCgpIHtcbiAgICBsZXQgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsO1xuICAgIGNvbnN0IGJhc2VNYXRlcmlhbCA9IHRoaXMuX2Jhc2VNYXRlcmlhbCB8fCB0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgfHwgKHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRCYXNlTWF0ZXJpYWwuY2xvbmUoKSk7XG4gICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgZGVyaXZlZE1hdGVyaWFsLmJhc2VNYXRlcmlhbCAhPT0gYmFzZU1hdGVyaWFsKSB7XG4gICAgICBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVCZXppZXJNZXNoTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKTtcbiAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgIGJhc2VNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICB9XG4gIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gIH1cblxuICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gIGdldCBjdXN0b21EZXB0aE1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICB9XG4gIGdldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICB9XG5cbiAgb25CZWZvcmVSZW5kZXIoKSB7XG4gICAgY29uc3Qge3VuaWZvcm1zfSA9IHRoaXMubWF0ZXJpYWw7XG4gICAgY29uc3Qge3BvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHJhZGl1cywgZGFzaEFycmF5LCBkYXNoT2Zmc2V0fSA9IHRoaXM7XG4gICAgdW5pZm9ybXMucG9pbnRBLnZhbHVlLmNvcHkocG9pbnRBKTtcbiAgICB1bmlmb3Jtcy5jb250cm9sQS52YWx1ZS5jb3B5KGNvbnRyb2xBKTtcbiAgICB1bmlmb3Jtcy5jb250cm9sQi52YWx1ZS5jb3B5KGNvbnRyb2xCKTtcbiAgICB1bmlmb3Jtcy5wb2ludEIudmFsdWUuY29weShwb2ludEIpO1xuICAgIHVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHJhZGl1cztcbiAgICB1bmlmb3Jtcy5kYXNoaW5nLnZhbHVlLnNldChkYXNoQXJyYXkueCwgZGFzaEFycmF5LnksIGRhc2hPZmZzZXQgfHwgMCk7XG4gIH1cblxuICByYXljYXN0KC8qcmF5Y2FzdGVyLCBpbnRlcnNlY3RzKi8pIHtcbiAgICAvLyBUT0RPIC0ganVzdCBmYWlsIGZvciBub3dcbiAgfVxufVxuXG5leHBvcnQgeyBCZXppZXJNZXNoLCBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwsIGV4cGFuZFNoYWRlckluY2x1ZGVzLCBnZXRTaGFkZXJVbmlmb3JtVHlwZXMsIGdldFNoYWRlcnNGb3JNYXRlcmlhbCwgaW52ZXJ0TWF0cml4NCwgdm9pZE1haW5SZWdFeHAgfTtcbiJdLCJuYW1lcyI6WyJTaGFkZXJDaHVuayIsIlVuaWZvcm1zVXRpbHMiLCJNZXNoRGVwdGhNYXRlcmlhbCIsIlJHQkFEZXB0aFBhY2tpbmciLCJNZXNoRGlzdGFuY2VNYXRlcmlhbCIsIlNoYWRlckxpYiIsIk1hdHJpeDQiLCJWZWN0b3IzIiwiTWVzaCIsIkN5bGluZGVyR2VvbWV0cnkiLCJWZWN0b3IyIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJEb3VibGVTaWRlIiwidm9pZE1haW5SZWdFeHAiLCJleHBhbmRTaGFkZXJJbmNsdWRlcyIsInNvdXJjZSIsInBhdHRlcm4iLCJyZXBsYWNlIiwibWF0Y2giLCJpbmNsdWRlIiwiY2h1bmsiLCJfbHV0IiwiaSIsInRvU3RyaW5nIiwiZ2VuZXJhdGVVVUlEIiwiZDAiLCJNYXRoIiwicmFuZG9tIiwiZDEiLCJkMiIsImQzIiwidXVpZCIsInRvVXBwZXJDYXNlIiwiYXNzaWduIiwiT2JqZWN0IiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuIiwibGVuZ3RoIiwicHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImVwb2NoIiwiRGF0ZSIsIm5vdyIsIkNPTlNUUlVDVE9SX0NBQ0hFIiwiV2Vha01hcCIsIlNIQURFUl9VUEdSQURFX0NBQ0hFIiwiTWFwIiwibWF0ZXJpYWxJbnN0YW5jZUlkIiwiY3JlYXRlRGVyaXZlZE1hdGVyaWFsIiwiYmFzZU1hdGVyaWFsIiwib3B0aW9ucyIsIm9wdGlvbnNLZXkiLCJnZXRLZXlGb3JPcHRpb25zIiwiY3RvcnNCeURlcml2YXRpb24iLCJnZXQiLCJzZXQiLCJjcmVhdGUiLCJwcml2YXRlQmVmb3JlQ29tcGlsZVByb3AiLCJvbkJlZm9yZUNvbXBpbGUiLCJzaGFkZXJJbmZvIiwicmVuZGVyZXIiLCJjYWNoZUtleSIsImN1c3RvbVByb2dyYW1DYWNoZUtleSIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwidXBncmFkZWRTaGFkZXJzIiwidXBncmFkZWQiLCJ1cGdyYWRlU2hhZGVycyIsInVuaWZvcm1zIiwidGltZVVuaWZvcm0iLCJ2YWx1ZSIsIkRlcml2ZWRNYXRlcmlhbCIsImRlcml2ZSIsImNoYWluZWQiLCJjbG9uZSIsImJhc2UiLCJkZXJpdmVkIiwiZGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiZGVmaW5lcyIsImV4dGVuc2lvbnMiLCJfbGlzdGVuZXJzIiwidW5kZWZpbmVkIiwiY29uc3RydWN0b3IiLCJpc0Rlcml2ZWRNYXRlcmlhbCIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZm4iLCJjb3B5IiwiaXNTaGFkZXJNYXRlcmlhbCIsIm5ld0Jhc2UiLCJnZXREZXB0aE1hdGVyaWFsIiwiZGVwdGhNYXRlcmlhbCIsIl9kZXB0aE1hdGVyaWFsIiwiZGVwdGhQYWNraW5nIiwiSVNfREVQVEhfTUFURVJJQUwiLCJnZXREaXN0YW5jZU1hdGVyaWFsIiwiZGlzdGFuY2VNYXRlcmlhbCIsIl9kaXN0YW5jZU1hdGVyaWFsIiwiSVNfRElTVEFOQ0VfTUFURVJJQUwiLCJkaXNwb3NlIiwibWF0ZXJpYWwiLCJrZXkiLCJ2ZXJ0ZXhEZWZzIiwidmVydGV4TWFpbkludHJvIiwidmVydGV4TWFpbk91dHJvIiwidmVydGV4VHJhbnNmb3JtIiwiZnJhZ21lbnREZWZzIiwiZnJhZ21lbnRNYWluSW50cm8iLCJmcmFnbWVudE1haW5PdXRybyIsImZyYWdtZW50Q29sb3JUcmFuc2Zvcm0iLCJjdXN0b21SZXdyaXRlciIsInJlcyIsInBvc3RDaHVua3MiLCJwdXNoIiwiam9pbiIsImNvZGUiLCJtYXRjaDEiLCJpbmRleCIsImZ1bGxTdHIiLCJ0ZXN0Iiwic3Vic3RyIiwibWFwIiwiY2hhbm5lbCIsImluamVjdEludG9TaGFkZXJDb2RlIiwic2hhZGVyQ29kZSIsImlkIiwiZGVmcyIsImludHJvIiwib3V0cm8iLCJvcHRpb25zSnNvblJlcGxhY2VyIiwiX2lkQ3RyIiwib3B0aW9uc0hhc2hlc1RvSWRzIiwib3B0aW9uc0hhc2giLCJKU09OIiwic3RyaW5naWZ5IiwiTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSUyIsIk1lc2hOb3JtYWxNYXRlcmlhbCIsIk1lc2hCYXNpY01hdGVyaWFsIiwiTWVzaExhbWJlcnRNYXRlcmlhbCIsIk1lc2hQaG9uZ01hdGVyaWFsIiwiTWVzaFRvb25NYXRlcmlhbCIsIk1lc2hQaHlzaWNhbE1hdGVyaWFsIiwiTWVzaE1hdGNhcE1hdGVyaWFsIiwiTGluZUJhc2ljTWF0ZXJpYWwiLCJMaW5lRGFzaGVkTWF0ZXJpYWwiLCJQb2ludHNNYXRlcmlhbCIsIlNoYWRvd01hdGVyaWFsIiwiU3ByaXRlTWF0ZXJpYWwiLCJnZXRTaGFkZXJzRm9yTWF0ZXJpYWwiLCJidWlsdGluVHlwZSIsInR5cGUiLCJnZXRTaGFkZXJVbmlmb3JtVHlwZXMiLCJzaGFkZXIiLCJ1bmlmb3JtUkUiLCJleGVjIiwiaW52ZXJ0TWF0cml4NCIsInNyY01hdHJpeCIsInRndE1hdHJpeCIsImludmVydCIsImdldEludmVyc2UiLCJjcmVhdGVCZXppZXJNZXNoTWF0ZXJpYWwiLCJwb2ludEEiLCJjb250cm9sQSIsImNvbnRyb2xCIiwicG9pbnRCIiwicmFkaXVzIiwiZGFzaGluZyIsImdlb21ldHJ5IiwiZGVmYXVsdEJhc2VNYXRlcmlhbCIsImNvbG9yIiwic2lkZSIsIkJlemllck1lc2giLCJnZXRHZW9tZXRyeSIsInRyYW5zbGF0ZSIsImRhc2hBcnJheSIsImRhc2hPZmZzZXQiLCJmcnVzdHVtQ3VsbGVkIiwiZGVyaXZlZE1hdGVyaWFsIiwiX2Rlcml2ZWRNYXRlcmlhbCIsIl9iYXNlTWF0ZXJpYWwiLCJfZGVmYXVsdE1hdGVyaWFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uRGlzcG9zZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjdXN0b21EZXB0aE1hdGVyaWFsIiwiY3VzdG9tRGlzdGFuY2VNYXRlcmlhbCIsIm9uQmVmb3JlUmVuZGVyIiwieCIsInkiLCJyYXljYXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\n");

/***/ })

};
;